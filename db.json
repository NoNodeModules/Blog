{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/loading.gif","path":"img/loading.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"source/img/01.png","path":"img/01.png","modified":1,"renderable":0},{"_id":"source/img/02.png","path":"img/02.png","modified":1,"renderable":0},{"_id":"source/img/CPPrimer.png","path":"img/CPPrimer.png","modified":1,"renderable":0},{"_id":"source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":0},{"_id":"source/img/coffee.png","path":"img/coffee.png","modified":1,"renderable":0},{"_id":"source/img/fish.png","path":"img/fish.png","modified":1,"renderable":0},{"_id":"source/img/friends.png","path":"img/friends.png","modified":1,"renderable":0},{"_id":"source/img/game.png","path":"img/game.png","modified":1,"renderable":0},{"_id":"source/img/biang.png","path":"img/biang.png","modified":1,"renderable":0},{"_id":"source/img/index_head.png","path":"img/index_head.png","modified":1,"renderable":0},{"_id":"source/img/index_head.jpg","path":"img/index_head.jpg","modified":1,"renderable":0},{"_id":"source/img/line.png","path":"img/line.png","modified":1,"renderable":0},{"_id":"source/img/python.png","path":"img/python.png","modified":1,"renderable":0},{"_id":"source/img/radian.png","path":"img/radian.png","modified":1,"renderable":0},{"_id":"source/img/shark.png","path":"img/shark.png","modified":1,"renderable":0},{"_id":"source/img/cpp.png","path":"img/cpp.png","modified":1,"renderable":0},{"_id":"source/img/thumb.jpg","path":"img/thumb.jpg","modified":1,"renderable":0},{"_id":"source/img/thumb.png","path":"img/thumb.png","modified":1,"renderable":0},{"_id":"source/img/wolf.png","path":"img/wolf.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/artitalk/index.md","hash":"3747dac15602c73ca059743e0b625d7a1a76758e","modified":1609638430000},{"_id":"source/.DS_Store","hash":"94d53dc852f46f53a99f2a804d3cc2c99e426e44","modified":1619009439898},{"_id":"source/link/index.md","hash":"465352e1ca5bd4d890eab4a3c047b7e4b0e107d5","modified":1618931982447},{"_id":"source/message/index.md","hash":"70ebfc7bb23b2a538a308c7e7ca8b64cc1f7b753","modified":1619047941530},{"_id":"source/_posts/.DS_Store","hash":"5ca50d12b068e54fee156ad85504c0bdbd39d02a","modified":1619009396044},{"_id":"source/photos/index.md","hash":"9737c0bedf861649e0e3a50e8b41fa44447bca5f","modified":1609639082000},{"_id":"source/about/index.md","hash":"a48c0b0438445b2ab13c4da4c2c35ff85d5e97f0","modified":1617764872000},{"_id":"source/categories/index.md","hash":"98c96d49e73ae0b4b3a0e188abee702e33941ca0","modified":1618931959400},{"_id":"source/_data/link.yml","hash":"dfff7337c5f4502db6cc916b931333406d91975b","modified":1609333982000},{"_id":"source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1619013306885},{"_id":"source/tags/index.md","hash":"efee6cbdf9e35f74ba86d91ab4244086bf02c2a1","modified":1618931973974},{"_id":"source/img/thumb.jpg","hash":"2e04e72f911cb1a115e5e0026966693edd6aaec4","modified":1609657592000},{"_id":"source/_posts/algorithm_md/23种设计模式的通俗解释.md","hash":"d47be9ed9c001481d0f921df57b9c9d2b290059a","modified":1617891228000},{"_id":"source/_posts/cloud_md/Helm Introduction.md","hash":"7b8e9c706313fe2e98da1fd910f2cadf10aa5f8f","modified":1617972730000},{"_id":"source/_posts/go_md/Golang flag包简介.md","hash":"5afce54106bb0491536343bf88f46932ef366108","modified":1617972544000},{"_id":"source/_posts/cloud_md/Jenkinsfile introduce.md","hash":"326a2f7c370ef87a9dc58d79ca89d24952de2618","modified":1617973266000},{"_id":"source/_posts/go_md/Golang net包简介.md","hash":"369c73974fc8a754b8b11a8337e5e13b9230e0f0","modified":1617972538000},{"_id":"source/_posts/algorithm_md/图解霍夫曼编码.md","hash":"5963fb05c36532d163fe0f755835bd53120bc76a","modified":1617891244000},{"_id":"source/_posts/go_md/[译] Go 项目结构规范.md","hash":"17a796c42b5e67c67eaa3de7548d33feb7633760","modified":1617972554000},{"_id":"source/_posts/go_md/Go关键字和Channel.md","hash":"db46802eb3647c719dd581ce28a2b3d0584760e6","modified":1617972532000},{"_id":"source/_posts/linux_md/.DS_Store","hash":"4b48cbafee70e15dad1733c269a267077556a296","modified":1618323771070},{"_id":"source/_posts/cplus_md/.DS_Store","hash":"2280c12ba37a82584e95fc02b17cc8c0ad4c08a1","modified":1618876856470},{"_id":"source/_posts/go_md/Go Handler和HandlerFunc.md","hash":"090ff8995d20172196caceed13d9a68c02e9e3d1","modified":1617972548000},{"_id":"source/_posts/python_md/Python内置方法和属性应用.md","hash":"60721cae0e8420d5765ee8ec117d334a73e9f750","modified":1617890954000},{"_id":"source/_posts/python_md/Python中的star总结.md","hash":"659fb2f8914d2d93143a7c791a94884041712f32","modified":1617890956000},{"_id":"source/_posts/go_md/用Go编写HTTP服务器.md","hash":"a779f41500badbf92ba6c1e519e5f693c4015630","modified":1617971790000},{"_id":"source/_posts/python_md/Python模块学习.md","hash":"1a01c391e566b662b921dd0a274569ee787dc75b","modified":1617976422000},{"_id":"source/_posts/python_md/Python学习之整数比较.md","hash":"1d41ef0daac956eb2cb3f920682de024dce68202","modified":1617890952000},{"_id":"source/_posts/python_md/Jupyter notebooks单元测试.md","hash":"ee0e2aef5af7a13be60e3b468af4861e120b7ca0","modified":1617890958000},{"_id":"source/_posts/tips_md/怎么修改Logic K580的快捷键.md","hash":"69bae8261989648feeed15b0f4cd5c2b7aa3dc5b","modified":1617974088000},{"_id":"source/_posts/tips_md/.DS_Store","hash":"5fc8eac9a2f894830caa9b6f1707e1d7d8c8574f","modified":1617973898000},{"_id":"source/_posts/python_md/Python面向对象编程.md","hash":"c0fe479669586c8e85b1c23f4d0d93e515b13990","modified":1617890948000},{"_id":"source/_posts/python_md/Test with Coverage.md","hash":"a96120d75f03a5cbe3149d4263dc1dc7a1fdb8ca","modified":1617973302000},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130535776-1276148478.png","hash":"1b6cae5c84a6832537180afb8c1f9bf3f68c4eb9","modified":1617073236000},{"_id":"source/_posts/cloud_md/Jenkinsfile introduce/image-20200729094356824.png","hash":"eea9d7fbe100116c6722d982cad1d129db776159","modified":1595987038000},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130619082-1720959137.png","hash":"8cfc127d9683a941613fc6a1b8517b1b32486dc8","modified":1617073236000},{"_id":"source/_posts/cloud_md/Jenkinsfile introduce/image2018-3-19_16-58-55.png","hash":"f1832164c4cd9e6fda3ad69a907bf4478ef3386f","modified":1595987010000},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130707783-39205152.png","hash":"b3e1123eebc21e8e8638004419f720050b818d14","modified":1617073236000},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130753330-702637440.png","hash":"79b6db55d83fab390e364fe08c15f9e7fac70576","modified":1617073236000},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130449855-404730543.png","hash":"62b2e95d2def3876d1f4262dd19016daf17a2b42","modified":1617073236000},{"_id":"source/_posts/go_md/Golang flag包简介/copycode.gif","hash":"7e9c17336e21497cc5b8871097e3e5c0332aa47d","modified":1617073234000},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTuK","hash":"cf4dcd45da3dd26c9dc15d28c8058bff98971474","modified":1617091544000},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTto","hash":"d890ddc435168b7d1aa4799bc8fc0d085c9e4a64","modified":1617091574000},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTuM","hash":"cf4dcd45da3dd26c9dc15d28c8058bff98971474","modified":1617091544000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL.md","hash":"7c3c1320f0cb6a95d999f377f54bb2650bf7b298","modified":1617891008000},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTux","hash":"cf4dcd45da3dd26c9dc15d28c8058bff98971474","modified":1617091544000},{"_id":"source/_posts/linux_md/Linux Shell/Linux中的pushd和popd.md","hash":"3080dd9238a42a56c286ab63d343ea3dddc9ec28","modified":1617890976000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存.md","hash":"da981173b81c650f3003ca1b04d1d60f78b945c6","modified":1618302888000},{"_id":"source/_posts/linux_md/Makefile/Makefile.am的例子.md","hash":"5fd39ae2664d5b97c5abdea76f92d8b583816306","modified":1617891088000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode.md","hash":"abcf388377acb09c6661081de03787aee3e946bf","modified":1617890992000},{"_id":"source/_posts/linux_md/Makefile/automake基础.md","hash":"bbbeae6bfed74a00c61929d5f84f8d51d0f38fcf","modified":1618314002510},{"_id":"source/_posts/linux_md/Makefile/pkg-config基础.md","hash":"e6560dbe3000ea999c198cfb43a106257d24c2ff","modified":1617891076000},{"_id":"source/_posts/linux_md/Makefile/How to write SPEC file.md","hash":"b037143daf3ceb5ff6ce99417f870ea8cb57c310","modified":1618323341810},{"_id":"source/_posts/linux_md/Makefile/SPEC file writing - Best Practices.md","hash":"54bb8997b55e1297d1555c9d6765a8819dedf4bb","modified":1618323351190},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.md","hash":"d0a9b2c709cd0ecd980328053591ae7731bb4b9c","modified":1618924054653},{"_id":"source/_posts/cplus_md/C Baisc/计算导论与C语言基础.md","hash":"8bc69f46e4e243d78ab0bfcf803630058635a126","modified":1618924054653},{"_id":"source/_posts/linux_md/Makefile/SPEC 基础知识.md","hash":"162bb9c45bb7de1d7301f2aa9d5953b63d6204d9","modified":1617891068000},{"_id":"source/_posts/linux_md/Makefile/configure.ac介绍.md","hash":"27a33c331ba11100241e28ff7b86329d05060c11","modified":1618305668000},{"_id":"source/_posts/cplus_md/C Baisc/《明解C语言》读书笔记.md","hash":"2943cb7ef3e9292757278cfca1e9e79c32a4904a","modified":1618924062254},{"_id":"source/_posts/cplus_md/C Baisc/C语言宏的特殊用法和几个坑.md","hash":"2706bc6395aa583df8d662647e5b35b73f014de1","modified":1617972702000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ Struct的使用.md","hash":"79e528a400c0f221675749e1ea5b225bd02cb652","modified":1617977190000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ Primer Plus笔记.md","hash":"8e888edfd0f81b5d064e924c586e3cf8e6af98c8","modified":1618831813920},{"_id":"source/_posts/cplus_md/CPlus Basic/学习C++ - 不常见概念解释.md","hash":"1f4c6d400f692cb600150f9ef9f1ac3be1ad5918","modified":1617977184000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ stdbind的使用.md","hash":"780ea2fd73f5fca2da4b74d21f8a921750c9110e","modified":1617977192000},{"_id":"source/_posts/cplus_md/CPlus Basic/学习C++ - 艰难的熟悉过程.md","hash":"41bfa951adac8823c3ffaa7d2e65f851df8d0331","modified":1617977182000},{"_id":"source/photos/Gallery/my_photos/add_photos.md","hash":"e89e3b23a6abd9f9f7538b7e436ca9a24a6199cf","modified":1609639116000},{"_id":"source/_posts/cplus_md/CPlus Basic/智能指针引用.md","hash":"07849dc17953ff0d4108ae42f9716d836c1fc85d","modified":1617977180000},{"_id":"source/_posts/python_md/Python学习之整数比较/int.png","hash":"794f13d2ec1ce190de422db1ba70d0b031b944a6","modified":1611644472000},{"_id":"source/_posts/cplus_md/CPlus Basic/深入理解C++11.md","hash":"c5dd91f8cdb1aba712cec2298ca4bad1aad49360","modified":1617977176000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/29b980e2bc932adf7464c8f17c5302cd.png","hash":"f2398a535db87582cd8de6a3e76ed0cf930b642a","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/1cb5ae3625df65f6dd793016bd6ba1b8.png","hash":"9836fe0d532b9ae6e703512f0f13648eac4d9654","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/5ab2c7d479df91a760c9d4a5a3c910a8.png","hash":"d78ba507ef9cd0f6d9abfddda543c3c4b157d77f","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/67b8b0eb1f1a2653847f192d3419f03d.png","hash":"21bfd149335857a6a51a36f462d084aab3447078","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/6bac3d6ecb4de4fb911fdea52ac3b685.png","hash":"03e36a16d41323168cbfade8e2e134bc41b84c20","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/36bf84b3afa4158dd7d0aff0ee6e7a85.png","hash":"35202057879f74eb8d9d4b60f40a4b1b05834cd3","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/795f16a399b397a69fe06e8feaea5cbd.png","hash":"31fd52c19346b32fe84feca80ae68bd0cb5e5a30","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bf51de614427cbe876e34154c0d163ed.png","hash":"e130cbc611428fb46c265ffd3d8c1c311f473d2b","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bcf035cdda2f9ec3b303a4246f873571.png","hash":"02926bc4dbfacdd58c3d2804e2dded07b59ed884","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/8d12750add3c38f5500d3df3ce376fd3.png","hash":"5a91ac81a5f47e1a961bc6af01618b2a24c21bd7","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/c64bae7e63e732efcd28ab9f5698094a.png","hash":"be753f251e2f1c093d20d3db3be6ebe73c720b5d","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/f20c49b0c9978b8ef05c5f21b3086abb.png","hash":"a09c98af2b94cc6f7a67f743e41f426fcc4f8255","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/af59ab58bba48a1b8eb5365af15a3713.png","hash":"d03a2acf8f1ceb5986ba7aaa80f8012ae9a3a9bd","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/277dafd9086b4d148de8b617f9252b62.png","hash":"c12ac3f5f8b938fba68877b16aede72f82173a35","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/fff4bc0460b6a42964f0707e37e2fdfc.png","hash":"44fce82c59e815d0eefa85b7cab1c120fa4889a1","modified":1617889642000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/539b3cebc6034a6187bb941433906a9a.png","hash":"0fdefba2992199ca99603948f4207f76621bc5e2","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/1fce6c5c621b4fd09919e87f52c59801.png","hash":"1aa97427b8167af382d14a2a0eedddb7be32401e","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5a7596802fc1411bbbca9f481cc42913.png","hash":"1e63953171b35e33fc74534fd75133330e65c596","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0af65e9d09c34b96890eba35cecb648b.png","hash":"f76bfcdb51bf72dd017b625fae7d9124ea421c23","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0e672cd9bd994dc285f89e617c06305b.png","hash":"fe76562a0ad451813065605f39538ed29b8ce514","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/7e632a0669e34ab69bac30c3f5e4dd60.png","hash":"87e4c411a4398958ade7c0518796b88cf4715e1d","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/675fef6379254f7fb5c7b3a934c32255.png","hash":"3b15b3f0cf2529f586c26ae5bd0a6a06f2c8136e","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/a0d3b15c19454faabb33b6fab3704d6f.png","hash":"9a5f34c4f8f11d0831d72ae4287e6281642c5b99","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/36e34f1760bb4ac6a3192f57d58264ca.png","hash":"c59ce08f53254c4bafc1991da2bf0b60cea1629e","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/cb54f7e833a743b1962c47dcd996e921.png","hash":"79e2b35d44b7a185fe693263472759e47f1a163d","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/9a7eb6b3c35d45a1a4eaf1b76cc1398c.png","hash":"b356168a3d19669860d49ac196e54bb626e29fef","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/e0230f143c434814ba2cdc39c2faaa68.png","hash":"e8c661b40656284ae4461e6b703977157f9b6016","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215025345.png","hash":"2671d4d6eede088803ac5a5d4b06f09e47e44262","modified":1617889824000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/d48bc627be544288b73fe774962b1010.png","hash":"82fbcbab8f26721ad32fb9543c5d1bc817aaf095","modified":1617890296000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215049945.png","hash":"1e0b2bad6579e0a220dcf6f8eae9109161d325eb","modified":1617889848000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215041892.png","hash":"d845bccfdceefdf7a84596e6a59eefbc8e59bd9b","modified":1617889840000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215112625.png","hash":"77c5d430d6c0c4b0350fe7db4182659f0a3a5691","modified":1617889872000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215056849.png","hash":"5c7d3c2d116ef070b514ea81d930d88d8268b520","modified":1617889856000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215011301.png","hash":"e62d09d816b1704e35161539367f961cfe88a5ef","modified":1617889810000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215150439.png","hash":"4d1db67344e681c927769a9ae3894b905fdd8ab3","modified":1617889910000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215142219.png","hash":"553117b7385c314076745e879006ca194fd010ac","modified":1617889902000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215211094.png","hash":"b8832d415361a791b189e945fc3899f2675653c9","modified":1617889930000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215157588.png","hash":"398a4874cb123bc404cac37cec5ed7f7cbe8e913","modified":1617889916000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215306929.png","hash":"78fe2c1015b8701f2281d15c7f4006ed715e03be","modified":1617889986000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215225519.jpeg","hash":"4f0451c27abefc1316ecf91c7aa38118c45a3c03","modified":1617889944000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215257440.png","hash":"b8483fc258223be6e50eedd9afa584a9afd1b8b3","modified":1617889976000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215504370.gif","hash":"d6b36d026c1eb86e71a21eec9007721a24b9869f","modified":1617890104000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215512581.jpeg","hash":"5c612a59a451f82db27015c47ffd6dddcd9a869f","modified":1617890112000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215535838.png","hash":"1740df4ce7a62106b7ec084b01aa714890a9107a","modified":1617890134000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215545396.png","hash":"e5ac4df063818e24c63a0c043c92a9684803bdf2","modified":1617890144000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215552177.png","hash":"eab99d583598df960da13319b2c12b4e70f3ce2a","modified":1617890152000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215521174.gif","hash":"d6b36d026c1eb86e71a21eec9007721a24b9869f","modified":1617890120000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215600171.png","hash":"f01d908a0fe29e93dec7dfca4fe980cd66cdbb9b","modified":1617890160000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215607387.png","hash":"cb5dd99b51e6ff4e3f293549609f6e0cc9f3ddcc","modified":1617890166000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215645563.png","hash":"e9101214463b6417ba39a073df85c22351d27321","modified":1617890204000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215615006.png","hash":"ea0f18f514a38a0bfa8ddd50ffea90614187e488","modified":1617890174000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215637250.png","hash":"483683bd204d66286aee6dba017db6d3b59380ef","modified":1617890196000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215624632.png","hash":"eb8eab11d521815a8866011105b9aea07d71f9b6","modified":1617890184000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215631492.png","hash":"3e6561e4ac914ed4eb55ad0123cb2a1c60eedde7","modified":1617890190000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.png","hash":"6834e727b4e6ea231cd7bd26fc6b60afff600208","modified":1617889802000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.gif","hash":"d6b36d026c1eb86e71a21eec9007721a24b9869f","modified":1617890006000},{"_id":"source/_posts/linux_md/Makefile/SPEC 基础知识/image2019-12-5_16-10-23.png","hash":"07e89d2d0a5b11a55b97cb401378f23fbde8f5f7","modified":1615796444000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ Primer Plus/image-20210417152825695.png","hash":"ddd7839de69efbc284981bcb1ab34a076e6eee23","modified":1618644505690},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ Primer Plus/编程步骤.png","hash":"d8e0f8fde8e4e56c88cb22b893e31b7d4dc67558","modified":1618644442240},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ Primer Plus/编程步骤-8644713.png","hash":"e8366467c81913bc7e084c5d7480c0038745cb36","modified":1618644569870},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/con_and_par.jpg","hash":"da3450f0e5b3ae7a2ba528864977dd165a802002","modified":1614923968000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/cpp_timeline.png","hash":"59db7c0cc849576d5dd0d52d1bbb02ea94d03dc6","modified":1614923968000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/cpu.png","hash":"fd6a3ee1688a45ad278544883d474f6f313a9b28","modified":1614924012000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/Thread_pool.svg","hash":"026f167313e8843456965bd58477a490e70e762b","modified":1614924012000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/image-20210305140102303.png","hash":"5cfdb42554983b810f1046634bdf3a6ae09a9b1c","modified":1614924064000},{"_id":"source/img/fish.png","hash":"c80a42860aed0a1b1c4a529c2674a6168b2102dc","modified":1618885382000},{"_id":"source/img/02.png","hash":"0263cbbb9456d1fddf30129c1f9cebee6673ecf2","modified":1609676258000},{"_id":"source/img/radian.png","hash":"0263cbbb9456d1fddf30129c1f9cebee6673ecf2","modified":1609676258000},{"_id":"source/img/shark.png","hash":"9ca254e2487d5a4f0fba1cdaabe689c48a787ef2","modified":1618885442000},{"_id":"source/img/wolf.png","hash":"792dcacb11d6c715fe08c8340fb08322c634aa40","modified":1618885466000},{"_id":"source/_posts/go_md/用Go编写HTTP服务器/image-20210331100841458.png","hash":"a7243a02b1e40f3b6c405c222ae8e6281ba00651","modified":1617156522000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程.md","hash":"69c4661fa338fd53b76a64025279c3662f229cdc","modified":1617977186000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215103876.png","hash":"5e28281b08a04cfdc9527f20726916d690b69be0","modified":1617889862000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215118480.png","hash":"65acd2658c12ae6e008abc42ba89ab29c7be3036","modified":1617889878000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215135031.jpeg","hash":"eed1a221a65bd2b58e8e7ca592b8b731cc123389","modified":1617889894000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215203155.png","hash":"ec19c6dff17047b682202ee57ab7df7d869a7ee6","modified":1617889922000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215127651.png","hash":"ede8fcd51c523d6919ede81df96310d72764f858","modified":1617889886000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215243422.png","hash":"b91fb9bbec56760570dc5353782a55ab8c5c788e","modified":1617889962000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215219100.png","hash":"7a4879ef86b27918d0b1782fa0febcc8aa91f4ba","modified":1617889938000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215235412.png","hash":"fb896de38a4e4d2a498e74f0484d15db6f5cd783","modified":1617889954000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215249606.png","hash":"4ecb656773cb89919c46507a2589e3ee68ab7dd8","modified":1617889968000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215333648.jpeg","hash":"2ee222c9f1474b353e2a53c26b585f58cf9cb7fb","modified":1617890012000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215340645.jpeg","hash":"8afa14e517b60b5da923a1c80a8ae6eb832c2351","modified":1617890020000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215351143.jpeg","hash":"97a6e0ebb342fc4df53efdbc4442a9f5050797c5","modified":1617890030000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215527335.png","hash":"59d1b476b140a29cbad138713d7d46d9933f99cb","modified":1617890126000},{"_id":"source/_posts/linux_md/Makefile/SPEC 基础知识/image-20210315162108826.png","hash":"f980b0e25828cf14a480d72e12ba92a0b9864263","modified":1615796470000},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.jpeg","hash":"1ef1048bb4ead24c7deeae234bcb660eea6d4380","modified":1617889834000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201103210746239.png","hash":"91cccdb9654fa2e5b1651cc6071e7fef611584dc","modified":1604408866000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201104215246865.png","hash":"1f050e2988d7462a867fad97411b92ab4773d6cb","modified":1604497966000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201103211138499.png","hash":"1d808d58fd30839532322d09955dfa79bcd6ce50","modified":1604409098000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201103194803509.png","hash":"c892792af5199427f9935dec9b2c05d76e18ccdc","modified":1604404083000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201103211648452.png","hash":"c6e7c320b5777c36efed2215a75e0760cb92a670","modified":1604409408000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201104215312619.png","hash":"4177d49d45659b1bff74d70505d2164fd43dbdae","modified":1604497992000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/deadlock.png","hash":"d6f0fe0eab79926b40be55c0beff02cc3a3c483d","modified":1614924012000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/multithread.png","hash":"df1614eb566fbebb2006cb6311bed5bad77a64fe","modified":1614924012000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/single_core.png","hash":"1153e8b0e7e47bd05f9a6f2f3bb2ad4d3823c93f","modified":1614923968000},{"_id":"themes/butterfly/README.md","hash":"32ada08cfe64b38f8d5ac5de31cfb92956ff407c","modified":1617712920000},{"_id":"themes/butterfly/README_CN.md","hash":"dc38de6a558b66e05188fc62c5047ec982a74ff3","modified":1617712920000},{"_id":"themes/butterfly/package.json","hash":"9811c9076a191872f93442d86b7d5c505765e15f","modified":1617712920000},{"_id":"themes/butterfly/_config.yml","hash":"f94af3be4a1fdd401dde66a462c53b071c8fe39a","modified":1617712920000},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1609329154000},{"_id":"themes/butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1617712920000},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1617712920000},{"_id":"themes/butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1617712920000},{"_id":"themes/butterfly/.DS_Store","hash":"f09a86bb4ce7d04901ec1bb4cb55bee99909840c","modified":1618928261906},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1609329154000},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1609329154000},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1609329154000},{"_id":"themes/butterfly/layout/404.pug","hash":"58cfa5985e58e10c97a9f8a9dc354f1c766154b3","modified":1617712920000},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1617712920000},{"_id":"themes/butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1617712920000},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1617712920000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1609329154000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1609329154000},{"_id":"themes/butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1617712920000},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1609329154000},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1609329154000},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"aa105ea4eaecc951f7474b549b6ac0095a5fab1f","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"76d672c91f6bb6f20c6936e05067c42f7917ac61","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"ec7ba875aaa2b95ab9d8256bd21c1e006bbe2820","modified":1617712920000},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"2b34e587030516afe2faf1a8cb20aebaead012f1","modified":1617712920000},{"_id":"themes/butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":1617712920000},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1609329154000},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1609329154000},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1609329154000},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1609329154000},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1609329154000},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1617712920000},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1617712920000},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1609329154000},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1617712920000},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"81459adf885a15c6e9784bc2275c07efe67ab0b4","modified":1617712920000},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"1da73cd47b78c6dbc3f04ce500d6cc5711c94412","modified":1617712920000},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"e75283267f3a4773e6d803593d557e218396f260","modified":1609329154000},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"0d8ba6120dce617a2a1fbc9167572db2ee9f22ef","modified":1609329154000},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"e9cf275c362d8634f093e63068da7ed1e53c7600","modified":1609329154000},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1609329154000},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1609329154000},{"_id":"themes/butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1609329154000},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1609329154000},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1617712920000},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1609329154000},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1609329154000},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1609329154000},{"_id":"themes/butterfly/source/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1609329154000},{"_id":"themes/butterfly/scripts/events/init.js","hash":"43b245c308797c2d62cb70429a85f1a05d3395ab","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1609472918000},{"_id":"themes/butterfly/source/js/main.js","hash":"8b670bed658cf879e37a12d9fda064cf4b55cc3f","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"62cf37e28795d8b68a0e850ec8c94987b9e08db5","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"798dbbe9146e8e2379b39a49acf8c8a1eeabb8fb","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"44d231314d4bfffdb93096c1fa18d05de7293267","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"6058de23612ab1ed17d2ad93f5866d5f745135f0","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"68dfd3c6a0f00b3ffc0333c81e165b4626f7425f","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"edebe930a2e3c4a4de5a35b9c1b1409cdd401372","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"45f0d36b1ac686b5984909dae55d3c522f549c3a","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"5e3c9d25298ae3025b59dd4cb080259c0f8fab78","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"36b368516b5a746be84a6aa08767ee24d220d509","modified":1609472918000},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1609472918000},{"_id":"themes/butterfly/layout/includes/widget/card_self.pug","hash":"a1b2f5575b6804c5c4b9288db143b5164cbbd289","modified":1609472918000},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e356f916ceb28702812d8f66c1fea0ae75eece47","modified":1609472918000},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1609472918000},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"3e4e83a41a444f7454ff682620369a8af1f960c9","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1609472918000},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"9e91f2543ab39815309268d07ae248a78887acf9","modified":1617712920000},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"ce3d0c8984c8a46e3c8e1727806bb4d37ff3e2d4","modified":1617712920000},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"6ba9dcda7ff1ceda4e07c8c08517259e8b7dbcd5","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1609329154000},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1609329154000},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"6317bc18152e474b8faa7994fc5fbc3c9e455a84","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1609329154000},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1609329154000},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"d6548e332e6e57e2a7ba2eb53cdd838c3cd1846d","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"e639219e12069f9a71c8f325364a8f656454b999","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7a6e1f21173022a3a1f18a62785cdd657a1af0a1","modified":1609329154000},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"b09e3a834ab8389f731bee5703b86e8aea27cda8","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1609329154000},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1617712920000},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a6f8637e90e44e23338209d4a3438e3e67766971","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"788a28f68e29fad5328dc03be2f3268324281652","modified":1617712920000},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1617712920000},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1609329154000},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"6b05ca4409d2dc09e123af4e0af9f9d0f7142b73","modified":1609329154000},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1617712920000},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"89e744abc5e41f4855e7b87b13b854f4ec4ffc0e","modified":1609329154000},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1609329154000},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"d60b7a94a7adeac489b8c1afdf7e679994829742","modified":1617712920000},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"51f2bd03a2d0787911d0c090fb555a664b3fac8b","modified":1609329154000},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1609329154000},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1609329154000},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"a7fc7624a8d893bdf9444f14154484c29c790e99","modified":1609329154000},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1609329154000},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1609329154000},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1617712920000},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1609329154000},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1609329154000},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c2d35443807a121e20c7ac3c1caa50f848bacd59","modified":1617712920000},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1609329154000},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1609329154000},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"d7717ce0c061b2471bf1a366c1a81158af266417","modified":1617712920000},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"76c061a16d7e5935f02acd27c6cdb4933c642b97","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"fd68563e649bd95529d4b3a828e430a9997f66ee","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1609472918000},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"353ebd0bdecdfde6dee32c3aa208cc87c72b15c0","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"4afc12ce42d067fa4012039aa444343a36f73599","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"21b7ec96c606823d3d72e72775495ef77502b4cb","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"a91df377d8ac227ff210cc5d0295648ba9daf6ed","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"87b097f791f56ca17319657de7901853b798555d","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"9820d731bb66a1d9c2e0083361d0c99c68c93fdf","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"18dcf05ab58107bbff426376aef2577f59583fc2","modified":1609472918000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"9657b1b08ff3f98e49ca250ed47a81b8b202ac7a","modified":1617712920000},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1609329154000},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1617712920000},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1617712920000},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1617712920000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1617712920000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1617712920000},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1609329154000},{"_id":"source/img/CPPrimer.png","hash":"cdfba0cd6eef7fcb0f4e98519900ba409a8a642c","modified":1618884626000},{"_id":"source/img/coffee.png","hash":"bc295b4f2f8534da210480a7290d7c0245d39db4","modified":1618884904000},{"_id":"source/img/avatar.png","hash":"0d88a35123819e9ab28c650ba76684b0d5e87a7f","modified":1617972222000},{"_id":"source/img/thumb.png","hash":"58a8e76397475e7539337020bc56dbc92d2d05d5","modified":1618884946000},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160649541.png","hash":"09f71c9f0339976fcc79faf6eee81055e955e63c","modified":1617091610000},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160629256.png","hash":"6a53da07ef89bbaa11074c354431a2643b8f8c03","modified":1617091590000},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160725275.png","hash":"4f37c73c855428c96f886e0a80bf558e1bf74d99","modified":1617091646000},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160708936.png","hash":"cdcccfe8e7b1e6a2f1bf131870304ddd6e3ff20d","modified":1617091630000},{"_id":"source/_posts/linux_md/Makefile/Makefile基础.md","hash":"d4dce39e3356496d23012d8262d9e16a72dd2f66","modified":1617891084000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201103204628715.png","hash":"6b3e87fcd296a2cfcb5d940ed84182f2c96d8826","modified":1604407588000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201103210051065.png","hash":"35008c6d52235de0a5b0a4cdc2ba000d0c9154dd","modified":1604408451000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201103211526043.png","hash":"35c890966b0282dda6ec1aa9b5798a150cd78072","modified":1604409326000},{"_id":"source/_posts/cplus_md/CPlus Basic/深入理解C++11/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png","hash":"e5dbb97a0ea677e8be512f2ab3b7b0cb299a665d","modified":1616458928000},{"_id":"source/img/game.png","hash":"c5abd8ea470c3983d595f9a8025c7d8d1dfe0835","modified":1618886400000},{"_id":"source/img/index_head.jpg","hash":"fc8095586a26b5e2cc51a9cf98f8587cf9f85ea6","modified":1609657246000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201104214940683.png","hash":"b9386b30de67a3fdd116c6cb31a0420d3d21b068","modified":1604497780000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201104213741370.png","hash":"b9386b30de67a3fdd116c6cb31a0420d3d21b068","modified":1604497061000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/deadlock.gif","hash":"e0264c05af962bb4ae9cd2e0cb06338bb1d0653a","modified":1614924012000},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/four_core.png","hash":"6c32ab424b858fedfae5bdd488531a1367c8e775","modified":1614923968000},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5013388ec46043c59f4fb4b3e373e955.png","hash":"a1812286937653861e74c4a098f05eda0ba5294f","modified":1617890296000},{"_id":"source/_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.assets/image-20201104215858679.png","hash":"708b59f5f81e7b47ef4c016837ec36edde3aa425","modified":1604498338000},{"_id":"source/img/friends.png","hash":"62526f808b500220c01bf37bc50c2b7c82e42807","modified":1618885410000},{"_id":"source/_posts/tips_md/怎么修改Logic K580的快捷键/k580.png","hash":"1b4b0f35564f32312e874699147c42a1e3a188d3","modified":1614074200000},{"_id":"source/img/biang.png","hash":"0c51605e949a81588616b3f8da90f302db18fa52","modified":1618886356000},{"_id":"source/img/01.png","hash":"24d247c5c0cb2ccf1e45c2752245b437a128d084","modified":1609676760000},{"_id":"source/img/line.png","hash":"24d247c5c0cb2ccf1e45c2752245b437a128d084","modified":1609676760000},{"_id":"source/img/python.png","hash":"5b4b0cf09fab4054503c5f8ab9959f6105efa8c0","modified":1618226736000},{"_id":"source/img/cpp.png","hash":"9c3417b202027397d174753bc798466033116fa8","modified":1618226712000},{"_id":"source/_posts/linux_md/Makefile/automake基础/Makefile基础.png","hash":"12fd0ce2e11f9ee69f1ab1b9d87afdcb2840ecd4","modified":1618305764000},{"_id":"source/img/index_head.png","hash":"83da739b6f1f19e40823490a3ece126c25e00aa8","modified":1618886302000},{"_id":"public/search.xml","hash":"4b14211737be10a502c82f603139855131fc9196","modified":1619047960305},{"_id":"public/link/index.html","hash":"34b85d78e9addc93e4d84598db90a1025a20e7bc","modified":1619047960305},{"_id":"public/tags/index.html","hash":"194570f76d44b75447032726c9c9b6ea4a3d3072","modified":1619047960305},{"_id":"public/categories/index.html","hash":"68ab54bb8b092f5b56afb77f9ce3d5d61a32c1f1","modified":1619047960305},{"_id":"public/message/index.html","hash":"12aa72984890b6b1d3ce729fc3fa2d6c14bb7956","modified":1619047960305},{"_id":"public/artitalk/index.html","hash":"4d7d4a69997b64039b91aeb8cb849c4f8c03aff3","modified":1619047960305},{"_id":"public/photos/index.html","hash":"52934aa5e7bb3adfee371925e9a7b0b6999d03af","modified":1619047960305},{"_id":"public/photos/Gallery/my_photos/add_photos.html","hash":"dd13f1a9879e2e17aca135f5bbc21575078bb04e","modified":1619047960305},{"_id":"public/about/index.html","hash":"3e4e03e3091f28f5cefe5688d75f3cc7cbb8f2bb","modified":1619047960305},{"_id":"public/posts/16108/index.html","hash":"baa6599239cdd281770125fa6a7e6e7a509810f7","modified":1619047960305},{"_id":"public/posts/13020/index.html","hash":"53dcff159193823872d0aeed0145dd593ca1b5db","modified":1619047960305},{"_id":"public/posts/11000/index.html","hash":"879a8c100910ef1489981ee9811412f469e47ba5","modified":1619047960305},{"_id":"public/posts/12007/index.html","hash":"2686264e92ed4376ff628e0bebc60ebca550b186","modified":1619047960305},{"_id":"public/posts/12008/index.html","hash":"165fca04676f1753c4ac50c7f5ea82f1eb1815c1","modified":1619047960305},{"_id":"public/posts/14002/index.html","hash":"8144e79b2bc459ce255dedf20dc7b23e3e9226ac","modified":1619047960305},{"_id":"public/posts/14001/index.html","hash":"44517976568f80f3550787d37619d14b2d613d7c","modified":1619047960305},{"_id":"public/posts/14000/index.html","hash":"de469224da31b99cd7a63e3c129910c852ace276","modified":1619047960305},{"_id":"public/posts/14004/index.html","hash":"e5e3d773e95d4e1b64529342eba5849ef53e18a5","modified":1619047960305},{"_id":"public/posts/16002/index.html","hash":"529190367a80a6b146bd2da2573585d67e10cf43","modified":1619047960305},{"_id":"public/posts/16001/index.html","hash":"d2bafc1ef0554c79e0bdee0a0b75f66c7ed9264e","modified":1619047960305},{"_id":"public/posts/14003/index.html","hash":"18a6adc91f31b9b15d244029430ca34210edf3a0","modified":1619047960305},{"_id":"public/posts/16005/index.html","hash":"d7d6c884f53f5a35ac1bc754b5a5d8769a5c256c","modified":1619047960305},{"_id":"public/posts/16000/index.html","hash":"2c95f6570f8118cd632b990987ee08a6355e85f4","modified":1619047960305},{"_id":"public/posts/15000/index.html","hash":"2b07a40e9d8f312bfbca77b2732c1f9f3331e421","modified":1619047960305},{"_id":"public/posts/16003/index.html","hash":"384a253590d0fc56e0277ba390ac2dd4c7c4db04","modified":1619047960305},{"_id":"public/posts/15001/index.html","hash":"6b264b9cfa94b422db88789f056feff9967562ab","modified":1619047960305},{"_id":"public/posts/16004/index.html","hash":"cba220f622c0c509791dfe23c7122273cf15cb81","modified":1619047960305},{"_id":"public/posts/15500/index.html","hash":"7cd03c903ae2bb9fa3ddc62f3ae9f8884d9aba9f","modified":1619047960305},{"_id":"public/posts/13009/index.html","hash":"8bd9ba83413b3c4d830da4c7aa009bfd0a455261","modified":1619047960305},{"_id":"public/posts/18003/index.html","hash":"7051f8ad661c178413a1e3f74e3c3f1c9f5050c5","modified":1619047960305},{"_id":"public/posts/13011/index.html","hash":"c3f6fc02a03734b76cb7f5a6021039e5f070438e","modified":1619047960305},{"_id":"public/posts/15002/index.html","hash":"10082fd31962b6d316f4a525a1c46d31b73d43c2","modified":1619047960305},{"_id":"public/posts/13014/index.html","hash":"b7e13ea74e27f78785270adc29af7e4072a5b7e1","modified":1619047960305},{"_id":"public/posts/13008/index.html","hash":"a14596d840f38abdf614a15314f0ad4cce7f012d","modified":1619047960305},{"_id":"public/posts/13012/index.html","hash":"69aba9e72e55ff432212277c33d966a5e5aa9d08","modified":1619047960305},{"_id":"public/posts/13013/index.html","hash":"1f0e9f3fdd09e3cf91cb52060ad5d7bdb84f4c56","modified":1619047960305},{"_id":"public/posts/13000/index.html","hash":"c4ed6958765faf2b1ccc3d99250cb0258db00771","modified":1619047960305},{"_id":"public/posts/13001/index.html","hash":"935d6a972302cd63547fc73e15b3a08d38e86c68","modified":1619047960305},{"_id":"public/posts/13010/index.html","hash":"8d09849d24967f0d8761f0baf0584df49b850871","modified":1619047960305},{"_id":"public/posts/13004/index.html","hash":"c4708c2441bb0feb5cfa74953c4617118e844377","modified":1619047960305},{"_id":"public/posts/13002/index.html","hash":"1ec49718e13e0a6afb74e71a6946302985e04f57","modified":1619047960305},{"_id":"public/posts/13005/index.html","hash":"4541712e15a7ec387b2a2093fb52e88d48a91771","modified":1619047960305},{"_id":"public/posts/13003/index.html","hash":"4b2cbdd4a2ab07bbde0dd4ba72e8447069382dbc","modified":1619047960305},{"_id":"public/posts/13007/index.html","hash":"6ed812b022c37645f9e0b79df5bb7156a8b773b0","modified":1619047960305},{"_id":"public/posts/13006/index.html","hash":"5f7a3531873c10068af05d42d9d4a9a5805e29b6","modified":1619047960305},{"_id":"public/posts/2/index.html","hash":"b14cabbeaa620059f25bc2401d54c256035a4741","modified":1619047960305},{"_id":"public/posts/3/index.html","hash":"39d439c5e447125f40ffde9685f7940161005e2b","modified":1619047960305},{"_id":"public/posts/1/index.html","hash":"87405db80a76f229df1c911150456e2c3d12a152","modified":1619047960305},{"_id":"public/categories/学习笔记/index.html","hash":"a13142cd6fe140d0e173d06c343055e77c44a69c","modified":1619047960305},{"_id":"public/categories/学习笔记/page/2/index.html","hash":"606e081dbd5c95eccf2de88faa40afb64f48f49c","modified":1619047960305},{"_id":"public/categories/学习笔记/page/3/index.html","hash":"dda17d72aa1eb6db58c0a5f6da1e80a397fc492e","modified":1619047960305},{"_id":"public/categories/使用教程/index.html","hash":"2d2e1a95975961f79268bb48a8d98699bc4299b4","modified":1619047960305},{"_id":"public/categories/博客搭建/index.html","hash":"3054a8f8584795c239c666b79650934968c84ff5","modified":1619047960305},{"_id":"public/categories/个人项目/index.html","hash":"4eec46108442dfce5643a0cc2e74c966c796f997","modified":1619047960305},{"_id":"public/index.html","hash":"09506a11992a8c05fbbc90b226b846a77e1ecde0","modified":1619047960305},{"_id":"public/page/2/index.html","hash":"10db3d4814fda499e7a18bbcf219186f7810c3eb","modified":1619047960305},{"_id":"public/page/3/index.html","hash":"4aa8e0257bd930a44c8055a227bdcade13d0ba2e","modified":1619047960305},{"_id":"public/page/4/index.html","hash":"b7cde6ebaa984449f07bd64afef58a6d838e4534","modified":1619047960305},{"_id":"public/page/5/index.html","hash":"4f286bc11222eaf6c5011ba903b325e40bd6e18d","modified":1619047960305},{"_id":"public/tags/algorithm/index.html","hash":"e76cc9581d923508ab3d75052a2ff5b50a77f128","modified":1619047960305},{"_id":"public/tags/jenkins/index.html","hash":"947d97db7a7ebc068941909f670d4370de7de47c","modified":1619047960305},{"_id":"public/tags/helm/index.html","hash":"2fb43ac24bc0d5d578d0aee9a29ddd7ea09a7469","modified":1619047960305},{"_id":"public/tags/coverage/index.html","hash":"4ff3fc7f0fd4ed28582cd41ab3f43a4ab17ddeb9","modified":1619047960305},{"_id":"public/tags/baisc/index.html","hash":"586311aeb91b4588f1e7ae66348506c5b2a0b9e6","modified":1619047960305},{"_id":"public/tags/baisc/page/2/index.html","hash":"d22c2ecdde025f33f6e9d9e7e01ca6c950d04ed4","modified":1619047960305},{"_id":"public/tags/go/index.html","hash":"06d943dbc596fb59d1351cfcbeed16abab7fa7e4","modified":1619047960305},{"_id":"public/tags/python/index.html","hash":"4792d169abc3dcb8cff61c3b678080997f93cab8","modified":1619047960305},{"_id":"public/tags/linux/index.html","hash":"2a407e654626caa1b4f53a02ce86a212bab4d5d8","modified":1619047960305},{"_id":"public/tags/Encrypted/index.html","hash":"7343bf90783fec5ee55087516fcb8a3b7f19f36f","modified":1619047960305},{"_id":"public/tags/tips/index.html","hash":"071b15e38eb7e3267dc7da4a00e20cf3d5fa0e41","modified":1619047960305},{"_id":"public/tags/automake/index.html","hash":"a28174537b590e8eb99b523f610702f38dc3e434","modified":1619047960305},{"_id":"public/tags/cpp/index.html","hash":"5869277aac8e8fc775a64fd5f347c219311e4e46","modified":1619047960305},{"_id":"public/archives/index.html","hash":"8ff216f34d4b76225f8520714485d23df0005461","modified":1619047960305},{"_id":"public/archives/page/2/index.html","hash":"145bf2e0f7baa5a92837123c963004b8b29ebe4c","modified":1619047960305},{"_id":"public/archives/page/3/index.html","hash":"89a4caa21b548f3a689f8b9668c9cf6ccaf3124b","modified":1619047960305},{"_id":"public/archives/page/5/index.html","hash":"c335756945faea76ea91dbbd315ddd521c6d86ac","modified":1619047960305},{"_id":"public/archives/2020/index.html","hash":"a8fb75553ea4314d2254848d7f98e121d9f84196","modified":1619047960305},{"_id":"public/archives/2020/page/2/index.html","hash":"70a83b40fb1c0ed87b41f23b61d0fc9a67fe797a","modified":1619047960305},{"_id":"public/archives/page/4/index.html","hash":"55613130fc5bd6102f7c626934f31cf50a25bd38","modified":1619047960305},{"_id":"public/archives/2020/page/3/index.html","hash":"cfd72f2c593f031d37b6abc159fde0d2f782bb43","modified":1619047960305},{"_id":"public/archives/2020/02/index.html","hash":"fbd9d60ddf41a81978101544ebfc758e7b76c465","modified":1619047960305},{"_id":"public/archives/2020/11/index.html","hash":"25846d021e943c236bad87cce36f0f04cec90838","modified":1619047960305},{"_id":"public/archives/2020/12/index.html","hash":"83209d65cf652b3962f74ba84202558084f00a57","modified":1619047960305},{"_id":"public/archives/2020/page/4/index.html","hash":"d17cf9819f6868284cd0b88fa455d2918e54d06a","modified":1619047960305},{"_id":"public/archives/2020/12/page/2/index.html","hash":"e0d1f5d9895f941e8f2195504a3ccab9991a7cac","modified":1619047960305},{"_id":"public/archives/2020/12/page/3/index.html","hash":"787abaecee9e48fb6e9c534bf87781332d61bb4c","modified":1619047960305},{"_id":"public/archives/2020/12/page/4/index.html","hash":"da2d52744c0941b351a1858b9035d9d3fbc57a0e","modified":1619047960305},{"_id":"public/archives/2021/index.html","hash":"0336b5adc1f84b5e16cdd80e10aadfeaca18256b","modified":1619047960305},{"_id":"public/archives/2021/04/index.html","hash":"d22adf4a3c75e3cd69e92f25932d3caf8178e551","modified":1619047960305},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1619047960305},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1619047960305},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1619047960305},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1619047960305},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1619047960305},{"_id":"public/img/thumb.jpg","hash":"2e04e72f911cb1a115e5e0026966693edd6aaec4","modified":1619047960305},{"_id":"public/posts/12007/image2018-3-19_16-58-55.png","hash":"f1832164c4cd9e6fda3ad69a907bf4478ef3386f","modified":1619047960305},{"_id":"public/posts/12007/image-20200729094356824.png","hash":"eea9d7fbe100116c6722d982cad1d129db776159","modified":1619047960305},{"_id":"public/posts/14002/952033-20190505130619082-1720959137.png","hash":"8cfc127d9683a941613fc6a1b8517b1b32486dc8","modified":1619047960305},{"_id":"public/posts/14002/952033-20190505130707783-39205152.png","hash":"b3e1123eebc21e8e8638004419f720050b818d14","modified":1619047960305},{"_id":"public/posts/14002/copycode.gif","hash":"7e9c17336e21497cc5b8871097e3e5c0332aa47d","modified":1619047960305},{"_id":"public/posts/14002/952033-20190505130753330-702637440.png","hash":"79b6db55d83fab390e364fe08c15f9e7fac70576","modified":1619047960305},{"_id":"public/posts/14002/952033-20190505130449855-404730543.png","hash":"62b2e95d2def3876d1f4262dd19016daf17a2b42","modified":1619047960305},{"_id":"public/posts/14003/bVbGTuK","hash":"cf4dcd45da3dd26c9dc15d28c8058bff98971474","modified":1619047960305},{"_id":"public/posts/14003/bVbGTuM","hash":"cf4dcd45da3dd26c9dc15d28c8058bff98971474","modified":1619047960305},{"_id":"public/posts/14002/952033-20190505130535776-1276148478.png","hash":"1b6cae5c84a6832537180afb8c1f9bf3f68c4eb9","modified":1619047960305},{"_id":"public/posts/14003/bVbGTto","hash":"d890ddc435168b7d1aa4799bc8fc0d085c9e4a64","modified":1619047960305},{"_id":"public/posts/14003/bVbGTux","hash":"cf4dcd45da3dd26c9dc15d28c8058bff98971474","modified":1619047960305},{"_id":"public/posts/16003/int.png","hash":"794f13d2ec1ce190de422db1ba70d0b031b944a6","modified":1619047960305},{"_id":"public/posts/15000/29b980e2bc932adf7464c8f17c5302cd.png","hash":"f2398a535db87582cd8de6a3e76ed0cf930b642a","modified":1619047960305},{"_id":"public/posts/15000/1cb5ae3625df65f6dd793016bd6ba1b8.png","hash":"9836fe0d532b9ae6e703512f0f13648eac4d9654","modified":1619047960305},{"_id":"public/posts/15000/5ab2c7d479df91a760c9d4a5a3c910a8.png","hash":"d78ba507ef9cd0f6d9abfddda543c3c4b157d77f","modified":1619047960305},{"_id":"public/posts/15000/36bf84b3afa4158dd7d0aff0ee6e7a85.png","hash":"35202057879f74eb8d9d4b60f40a4b1b05834cd3","modified":1619047960305},{"_id":"public/posts/15000/67b8b0eb1f1a2653847f192d3419f03d.png","hash":"21bfd149335857a6a51a36f462d084aab3447078","modified":1619047960305},{"_id":"public/posts/15000/6bac3d6ecb4de4fb911fdea52ac3b685.png","hash":"03e36a16d41323168cbfade8e2e134bc41b84c20","modified":1619047960305},{"_id":"public/posts/15000/af59ab58bba48a1b8eb5365af15a3713.png","hash":"d03a2acf8f1ceb5986ba7aaa80f8012ae9a3a9bd","modified":1619047960305},{"_id":"public/posts/15000/8d12750add3c38f5500d3df3ce376fd3.png","hash":"5a91ac81a5f47e1a961bc6af01618b2a24c21bd7","modified":1619047960305},{"_id":"public/posts/15000/f20c49b0c9978b8ef05c5f21b3086abb.png","hash":"a09c98af2b94cc6f7a67f743e41f426fcc4f8255","modified":1619047960305},{"_id":"public/posts/15000/bcf035cdda2f9ec3b303a4246f873571.png","hash":"02926bc4dbfacdd58c3d2804e2dded07b59ed884","modified":1619047960305},{"_id":"public/posts/15000/795f16a399b397a69fe06e8feaea5cbd.png","hash":"31fd52c19346b32fe84feca80ae68bd0cb5e5a30","modified":1619047960305},{"_id":"public/posts/15000/c64bae7e63e732efcd28ab9f5698094a.png","hash":"be753f251e2f1c093d20d3db3be6ebe73c720b5d","modified":1619047960305},{"_id":"public/posts/15000/bf51de614427cbe876e34154c0d163ed.png","hash":"e130cbc611428fb46c265ffd3d8c1c311f473d2b","modified":1619047960305},{"_id":"public/posts/15000/fff4bc0460b6a42964f0707e37e2fdfc.png","hash":"44fce82c59e815d0eefa85b7cab1c120fa4889a1","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215011301.png","hash":"e62d09d816b1704e35161539367f961cfe88a5ef","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215025345.png","hash":"2671d4d6eede088803ac5a5d4b06f09e47e44262","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215041892.png","hash":"d845bccfdceefdf7a84596e6a59eefbc8e59bd9b","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215112625.png","hash":"77c5d430d6c0c4b0350fe7db4182659f0a3a5691","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215142219.png","hash":"553117b7385c314076745e879006ca194fd010ac","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215150439.png","hash":"4d1db67344e681c927769a9ae3894b905fdd8ab3","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215056849.png","hash":"5c7d3c2d116ef070b514ea81d930d88d8268b520","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215049945.png","hash":"1e0b2bad6579e0a220dcf6f8eae9109161d325eb","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215157588.png","hash":"398a4874cb123bc404cac37cec5ed7f7cbe8e913","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215211094.png","hash":"b8832d415361a791b189e945fc3899f2675653c9","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215225519.jpeg","hash":"4f0451c27abefc1316ecf91c7aa38118c45a3c03","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215257440.png","hash":"b8483fc258223be6e50eedd9afa584a9afd1b8b3","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215306929.png","hash":"78fe2c1015b8701f2281d15c7f4006ed715e03be","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215504370.gif","hash":"d6b36d026c1eb86e71a21eec9007721a24b9869f","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215512581.jpeg","hash":"5c612a59a451f82db27015c47ffd6dddcd9a869f","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215535838.png","hash":"1740df4ce7a62106b7ec084b01aa714890a9107a","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215600171.png","hash":"f01d908a0fe29e93dec7dfca4fe980cd66cdbb9b","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215607387.png","hash":"cb5dd99b51e6ff4e3f293549609f6e0cc9f3ddcc","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215552177.png","hash":"eab99d583598df960da13319b2c12b4e70f3ce2a","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215521174.gif","hash":"d6b36d026c1eb86e71a21eec9007721a24b9869f","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215545396.png","hash":"e5ac4df063818e24c63a0c043c92a9684803bdf2","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215631492.png","hash":"3e6561e4ac914ed4eb55ad0123cb2a1c60eedde7","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215624632.png","hash":"eb8eab11d521815a8866011105b9aea07d71f9b6","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215637250.png","hash":"483683bd204d66286aee6dba017db6d3b59380ef","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215645563.png","hash":"e9101214463b6417ba39a073df85c22351d27321","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215615006.png","hash":"ea0f18f514a38a0bfa8ddd50ffea90614187e488","modified":1619047960305},{"_id":"public/posts/15001/format,png.gif","hash":"d6b36d026c1eb86e71a21eec9007721a24b9869f","modified":1619047960305},{"_id":"public/posts/15001/format,png.png","hash":"6834e727b4e6ea231cd7bd26fc6b60afff600208","modified":1619047960305},{"_id":"public/posts/15002/0af65e9d09c34b96890eba35cecb648b.png","hash":"f76bfcdb51bf72dd017b625fae7d9124ea421c23","modified":1619047960305},{"_id":"public/posts/15002/0e672cd9bd994dc285f89e617c06305b.png","hash":"fe76562a0ad451813065605f39538ed29b8ce514","modified":1619047960305},{"_id":"public/posts/15002/1fce6c5c621b4fd09919e87f52c59801.png","hash":"1aa97427b8167af382d14a2a0eedddb7be32401e","modified":1619047960305},{"_id":"public/posts/15002/277dafd9086b4d148de8b617f9252b62.png","hash":"c12ac3f5f8b938fba68877b16aede72f82173a35","modified":1619047960305},{"_id":"public/posts/15002/36e34f1760bb4ac6a3192f57d58264ca.png","hash":"c59ce08f53254c4bafc1991da2bf0b60cea1629e","modified":1619047960305},{"_id":"public/posts/15002/539b3cebc6034a6187bb941433906a9a.png","hash":"0fdefba2992199ca99603948f4207f76621bc5e2","modified":1619047960305},{"_id":"public/posts/15002/675fef6379254f7fb5c7b3a934c32255.png","hash":"3b15b3f0cf2529f586c26ae5bd0a6a06f2c8136e","modified":1619047960305},{"_id":"public/posts/15002/9a7eb6b3c35d45a1a4eaf1b76cc1398c.png","hash":"b356168a3d19669860d49ac196e54bb626e29fef","modified":1619047960305},{"_id":"public/posts/15002/d48bc627be544288b73fe774962b1010.png","hash":"82fbcbab8f26721ad32fb9543c5d1bc817aaf095","modified":1619047960305},{"_id":"public/posts/15002/e0230f143c434814ba2cdc39c2faaa68.png","hash":"e8c661b40656284ae4461e6b703977157f9b6016","modified":1619047960305},{"_id":"public/posts/15002/a0d3b15c19454faabb33b6fab3704d6f.png","hash":"9a5f34c4f8f11d0831d72ae4287e6281642c5b99","modified":1619047960305},{"_id":"public/posts/15002/5a7596802fc1411bbbca9f481cc42913.png","hash":"1e63953171b35e33fc74534fd75133330e65c596","modified":1619047960305},{"_id":"public/posts/15002/7e632a0669e34ab69bac30c3f5e4dd60.png","hash":"87e4c411a4398958ade7c0518796b88cf4715e1d","modified":1619047960305},{"_id":"public/posts/15002/cb54f7e833a743b1962c47dcd996e921.png","hash":"79e2b35d44b7a185fe693263472759e47f1a163d","modified":1619047960305},{"_id":"public/posts/13003/cpp_timeline.png","hash":"59db7c0cc849576d5dd0d52d1bbb02ea94d03dc6","modified":1619047960305},{"_id":"public/posts/13014/image2019-12-5_16-10-23.png","hash":"07e89d2d0a5b11a55b97cb401378f23fbde8f5f7","modified":1619047960305},{"_id":"public/posts/13003/cpu.png","hash":"fd6a3ee1688a45ad278544883d474f6f313a9b28","modified":1619047960305},{"_id":"public/posts/13003/con_and_par.jpg","hash":"da3450f0e5b3ae7a2ba528864977dd165a802002","modified":1619047960305},{"_id":"public/posts/13003/Thread_pool.svg","hash":"026f167313e8843456965bd58477a490e70e762b","modified":1619047960305},{"_id":"public/posts/13003/image-20210305140102303.png","hash":"5cfdb42554983b810f1046634bdf3a6ae09a9b1c","modified":1619047960305},{"_id":"public/lib/hbe.js","hash":"785f2f93e63a7302df623febc143d9630918a222","modified":1619047960305},{"_id":"public/css/hbe.style.css","hash":"b0a0077cb588c0941823905fcc383aa7509ade73","modified":1619047960305},{"_id":"public/assets/js/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1619047960305},{"_id":"public/img/02.png","hash":"0263cbbb9456d1fddf30129c1f9cebee6673ecf2","modified":1619047960305},{"_id":"public/img/fish.png","hash":"c80a42860aed0a1b1c4a529c2674a6168b2102dc","modified":1619047960305},{"_id":"public/img/radian.png","hash":"0263cbbb9456d1fddf30129c1f9cebee6673ecf2","modified":1619047960305},{"_id":"public/img/shark.png","hash":"9ca254e2487d5a4f0fba1cdaabe689c48a787ef2","modified":1619047960305},{"_id":"public/img/wolf.png","hash":"792dcacb11d6c715fe08c8340fb08322c634aa40","modified":1619047960305},{"_id":"public/posts/14004/image-20210331100841458.png","hash":"a7243a02b1e40f3b6c405c222ae8e6281ba00651","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215103876.png","hash":"5e28281b08a04cfdc9527f20726916d690b69be0","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215118480.png","hash":"65acd2658c12ae6e008abc42ba89ab29c7be3036","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215127651.png","hash":"ede8fcd51c523d6919ede81df96310d72764f858","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215135031.jpeg","hash":"eed1a221a65bd2b58e8e7ca592b8b731cc123389","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215219100.png","hash":"7a4879ef86b27918d0b1782fa0febcc8aa91f4ba","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215203155.png","hash":"ec19c6dff17047b682202ee57ab7df7d869a7ee6","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215243422.png","hash":"b91fb9bbec56760570dc5353782a55ab8c5c788e","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215249606.png","hash":"4ecb656773cb89919c46507a2589e3ee68ab7dd8","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215235412.png","hash":"fb896de38a4e4d2a498e74f0484d15db6f5cd783","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215333648.jpeg","hash":"2ee222c9f1474b353e2a53c26b585f58cf9cb7fb","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215351143.jpeg","hash":"97a6e0ebb342fc4df53efdbc4442a9f5050797c5","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215340645.jpeg","hash":"8afa14e517b60b5da923a1c80a8ae6eb832c2351","modified":1619047960305},{"_id":"public/posts/15001/format,png-20210408215527335.png","hash":"59d1b476b140a29cbad138713d7d46d9933f99cb","modified":1619047960305},{"_id":"public/posts/15001/format,png.jpeg","hash":"1ef1048bb4ead24c7deeae234bcb660eea6d4380","modified":1619047960305},{"_id":"public/posts/13014/image-20210315162108826.png","hash":"f980b0e25828cf14a480d72e12ba92a0b9864263","modified":1619047960305},{"_id":"public/posts/13003/deadlock.png","hash":"d6f0fe0eab79926b40be55c0beff02cc3a3c483d","modified":1619047960305},{"_id":"public/posts/13003/multithread.png","hash":"df1614eb566fbebb2006cb6311bed5bad77a64fe","modified":1619047960305},{"_id":"public/posts/13003/single_core.png","hash":"1153e8b0e7e47bd05f9a6f2f3bb2ad4d3823c93f","modified":1619047960305},{"_id":"public/img/avatar.png","hash":"0d88a35123819e9ab28c650ba76684b0d5e87a7f","modified":1619047960305},{"_id":"public/img/coffee.png","hash":"bc295b4f2f8534da210480a7290d7c0245d39db4","modified":1619047960305},{"_id":"public/img/CPPrimer.png","hash":"cdfba0cd6eef7fcb0f4e98519900ba409a8a642c","modified":1619047960305},{"_id":"public/img/thumb.png","hash":"58a8e76397475e7539337020bc56dbc92d2d05d5","modified":1619047960305},{"_id":"public/posts/14003/image-20210330160629256.png","hash":"6a53da07ef89bbaa11074c354431a2643b8f8c03","modified":1619047960305},{"_id":"public/posts/14003/image-20210330160708936.png","hash":"cdcccfe8e7b1e6a2f1bf131870304ddd6e3ff20d","modified":1619047960305},{"_id":"public/posts/14003/image-20210330160725275.png","hash":"4f37c73c855428c96f886e0a80bf558e1bf74d99","modified":1619047960305},{"_id":"public/posts/14003/image-20210330160649541.png","hash":"09f71c9f0339976fcc79faf6eee81055e955e63c","modified":1619047960305},{"_id":"public/posts/13007/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png","hash":"e5dbb97a0ea677e8be512f2ab3b7b0cb299a665d","modified":1619047960305},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1619047960305},{"_id":"public/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1619047960305},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1619047960305},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1619047960305},{"_id":"public/css/index.css","hash":"67e813df8cc4fd3a35f31ccc756eb9734deca1cf","modified":1619047960305},{"_id":"public/js/main.js","hash":"8b670bed658cf879e37a12d9fda064cf4b55cc3f","modified":1619047960305},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1619047960305},{"_id":"public/img/index_head.jpg","hash":"fc8095586a26b5e2cc51a9cf98f8587cf9f85ea6","modified":1619047960305},{"_id":"public/img/game.png","hash":"c5abd8ea470c3983d595f9a8025c7d8d1dfe0835","modified":1619047960305},{"_id":"public/posts/13003/deadlock.gif","hash":"e0264c05af962bb4ae9cd2e0cb06338bb1d0653a","modified":1619047960305},{"_id":"public/posts/13003/four_core.png","hash":"6c32ab424b858fedfae5bdd488531a1367c8e775","modified":1619047960305},{"_id":"public/posts/15002/5013388ec46043c59f4fb4b3e373e955.png","hash":"a1812286937653861e74c4a098f05eda0ba5294f","modified":1619047960305},{"_id":"public/img/friends.png","hash":"62526f808b500220c01bf37bc50c2b7c82e42807","modified":1619047960305},{"_id":"public/posts/18003/k580.png","hash":"1b4b0f35564f32312e874699147c42a1e3a188d3","modified":1619047960305},{"_id":"public/img/biang.png","hash":"0c51605e949a81588616b3f8da90f302db18fa52","modified":1619047960305},{"_id":"public/img/01.png","hash":"24d247c5c0cb2ccf1e45c2752245b437a128d084","modified":1619047960305},{"_id":"public/img/line.png","hash":"24d247c5c0cb2ccf1e45c2752245b437a128d084","modified":1619047960305},{"_id":"public/img/python.png","hash":"5b4b0cf09fab4054503c5f8ab9959f6105efa8c0","modified":1619047960305},{"_id":"public/img/cpp.png","hash":"9c3417b202027397d174753bc798466033116fa8","modified":1619047960305},{"_id":"public/posts/13020/Makefile基础.png","hash":"12fd0ce2e11f9ee69f1ab1b9d87afdcb2840ecd4","modified":1619047960305},{"_id":"public/img/index_head.png","hash":"83da739b6f1f19e40823490a3ece126c25e00aa8","modified":1619047960305}],"Category":[{"name":"学习笔记","_id":"ckns3cr5o0004w9q9a67qhck3"},{"name":"个人项目","_id":"ckns3cr5t000jw9q9bnsm32ue"},{"name":"使用教程","_id":"ckns3cr620020w9q9gp6q9whv"},{"name":"博客搭建","_id":"ckns3cr6b003vw9q9cjmib0y9"}],"Data":[{"_id":"link","data":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}],"Page":[{"title":"留言","date":"2021-04-21T13:57:35.000Z","type":"message","aside":false,"_content":"<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/zjwo/CDN/css/messagebar.css\"/>\n\n<div id=\"computer\"><div id=\"maincontent\"><br><div id=\"form-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/before.webp\"id=\"beforeimg\"><div id=\"envelope\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 calss=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img class=\"bottomimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"/></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div><img id=\"afterimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/after.webp\"></div></div></div><div id=\"mobile\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 class=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"class=\"bottomhr\"></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div>\n\n------\n\n","source":"message/index.md","raw":"---\ntitle: 留言\ndate: 2021-04-21 21:57:35\ntype: message\naside: false\n---\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/zjwo/CDN/css/messagebar.css\"/>\n\n<div id=\"computer\"><div id=\"maincontent\"><br><div id=\"form-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/before.webp\"id=\"beforeimg\"><div id=\"envelope\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 calss=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img class=\"bottomimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"/></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div><img id=\"afterimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/after.webp\"></div></div></div><div id=\"mobile\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 class=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"class=\"bottomhr\"></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div>\n\n------\n\n","updated":"2021-04-21T23:32:21.530Z","path":"message/index.html","comments":1,"layout":"page","_id":"ckns3cr5l0000w9q9ecewh4lc","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/zjwo/CDN/css/messagebar.css\"/>\n\n<div id=\"computer\"><div id=\"maincontent\"><br><div id=\"form-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/before.webp\"id=\"beforeimg\"><div id=\"envelope\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 calss=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img class=\"bottomimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"/></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div><img id=\"afterimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/after.webp\"></div></div></div><div id=\"mobile\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 class=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"class=\"bottomhr\"></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div>\n\n<hr>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/gh/zjwo/CDN/css/messagebar.css\"/>\n\n<div id=\"computer\"><div id=\"maincontent\"><br><div id=\"form-wrap\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/before.webp\"id=\"beforeimg\"><div id=\"envelope\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 calss=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img class=\"bottomimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"/></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div><img id=\"afterimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/after.webp\"></div></div></div><div id=\"mobile\"><form><div class=\"formmain\"><img class=\"headerimg\"src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/t011bf35a6af9498421.6whv4f8z5v00.webp\"/><div style=\"padding: 5px 20px;\"><center><h3 class=\"title3\">来自Evan的留言</h3></center><center class=\"comments\">有什么想問的？<br>有什么想說的？<br>有什么想吐槽的？<br>都可以在這裏留言哦 💋💋<br></center><div class=\"bottomcontent\"><img src=\"https://cdn.jsdelivr.net/gh/cpddo/blend@master/20210216/U0968ee80fd5c4f05a02bdda9709b041eE.webp\"class=\"bottomhr\"></div><p class=\"bottomhr\">自动书记人偶竭诚为您服务！</p></div></div></form></div>\n\n<hr>\n"},{"title":"link","date":"2020-12-30T13:10:27.000Z","type":"link","aside":false,"_content":"","source":"link/index.md","raw":"---\ntitle: link\ndate: 2020-12-30 21:10:27\ntype: link\naside: false\n---\n","updated":"2021-04-20T15:19:42.447Z","path":"link/index.html","comments":1,"layout":"page","_id":"ckns3cr5n0002w9q9612pb2pf","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"artitalk","date":"2021-01-02T14:26:24.000Z","type":"artitalk","_content":"","source":"artitalk/index.md","raw":"---\ntitle: artitalk\ndate: 2021-01-02 22:26:24\ntype: artitalk\n---\n","updated":"2021-01-03T01:47:10.000Z","path":"artitalk/index.html","comments":1,"layout":"page","_id":"ckns3cr5p0006w9q93b4c51dy","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"title":"photos","date":"2021-01-03T01:54:11.000Z","type":"photos","_content":"\n<div class=\"gallery-group-main\">\n{% galleryGroup 'Gallery' '我的相册 - 个人的一些图片集' '/photos/Gallery/my_photos' /photos/Gallery/my_photos/10.jpg %}\n{% galleryGroup 'Gallery' '我的相册 - 个人的一些图片集' '/photos/Gallery/my_photos' /photos/Gallery/my_photos/01.jpg %}\n{% galleryGroup 'Gallery' '我的相册 - 个人的一些图片集' '/photos/Gallery/my_photos' /photos/Gallery/my_photos/02.jpg %}\n</div>\n","source":"photos/index.md","raw":"---\ntitle: photos\ndate: 2021-01-03 09:54:11\ntype: photos\n---\n\n<div class=\"gallery-group-main\">\n{% galleryGroup 'Gallery' '我的相册 - 个人的一些图片集' '/photos/Gallery/my_photos' /photos/Gallery/my_photos/10.jpg %}\n{% galleryGroup 'Gallery' '我的相册 - 个人的一些图片集' '/photos/Gallery/my_photos' /photos/Gallery/my_photos/01.jpg %}\n{% galleryGroup 'Gallery' '我的相册 - 个人的一些图片集' '/photos/Gallery/my_photos' /photos/Gallery/my_photos/02.jpg %}\n</div>\n","updated":"2021-01-03T01:58:02.000Z","path":"photos/index.html","comments":1,"layout":"page","_id":"ckns3cr5q0008w9q9dqgygyfk","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='/Blog/photos/Gallery/my_photos/10.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">Gallery</div>\n  <p>我的相册 - 个人的一些图片集</p>\n  <a href='/Blog/photos/Gallery/my_photos'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='/Blog/photos/Gallery/my_photos/01.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">Gallery</div>\n  <p>我的相册 - 个人的一些图片集</p>\n  <a href='/Blog/photos/Gallery/my_photos'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='/Blog/photos/Gallery/my_photos/02.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">Gallery</div>\n  <p>我的相册 - 个人的一些图片集</p>\n  <a href='/Blog/photos/Gallery/my_photos'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<div class=\"gallery-group-main\">\n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='/Blog/photos/Gallery/my_photos/10.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">Gallery</div>\n  <p>我的相册 - 个人的一些图片集</p>\n  <a href='/Blog/photos/Gallery/my_photos'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='/Blog/photos/Gallery/my_photos/01.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">Gallery</div>\n  <p>我的相册 - 个人的一些图片集</p>\n  <a href='/Blog/photos/Gallery/my_photos'></a>\n  </figcaption>\n  </figure>\n  \n\n  <figure class=\"gallery-group\">\n  <img class=\"gallery-group-img\" src='/Blog/photos/Gallery/my_photos/02.jpg' alt=\"Group Image Gallery\">\n  <figcaption>\n  <div class=\"gallery-group-name\">Gallery</div>\n  <p>我的相册 - 个人的一些图片集</p>\n  <a href='/Blog/photos/Gallery/my_photos'></a>\n  </figcaption>\n  </figure>\n  \n</div>\n"},{"title":"tags","date":"2020-12-30T13:07:55.000Z","type":"tags","aside":false,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2020-12-30 21:07:55\ntype: \"tags\"\naside: false\n---\n","updated":"2021-04-20T15:19:33.974Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckns3cr5q000aw9q91fmhdlda","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""},{"_content":"{% gallery %}\n![](01.jpg)\n![](02.jpg)\n![](03.jpg)\n![](04.jpg)\n![](05.jpg)\n![](06.jpg)\n![](07.jpg)\n![](08.jpg)\n![](09.jpg)\n![](10.jpg)\n{% endgallery %}\n","source":"photos/Gallery/my_photos/add_photos.md","raw":"{% gallery %}\n![](01.jpg)\n![](02.jpg)\n![](03.jpg)\n![](04.jpg)\n![](05.jpg)\n![](06.jpg)\n![](07.jpg)\n![](08.jpg)\n![](09.jpg)\n![](10.jpg)\n{% endgallery %}\n","date":"2021-04-20T13:02:47.073Z","updated":"2021-01-03T01:58:36.000Z","path":"photos/Gallery/my_photos/add_photos.html","title":"","comments":1,"layout":"page","_id":"ckns3cr5s000fw9q9hlq506rz","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><div class=\"justified-gallery\"><p><img src=\"01.jpg\"><br><img src=\"02.jpg\"><br><img src=\"03.jpg\"><br><img src=\"04.jpg\"><br><img src=\"05.jpg\"><br><img src=\"06.jpg\"><br><img src=\"07.jpg\"><br><img src=\"08.jpg\"><br><img src=\"09.jpg\"><br><img src=\"10.jpg\"></p>\n          </div>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<div class=\"justified-gallery\"><p><img src=\"01.jpg\"><br><img src=\"02.jpg\"><br><img src=\"03.jpg\"><br><img src=\"04.jpg\"><br><img src=\"05.jpg\"><br><img src=\"06.jpg\"><br><img src=\"07.jpg\"><br><img src=\"08.jpg\"><br><img src=\"09.jpg\"><br><img src=\"10.jpg\"></p>\n          </div>\n"},{"title":"About Me","date":"2020-12-30T10:38:35.000Z","type":"about","top_img":"https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/banner/about.jpg","_content":"\n### This is about Me\n<div style=\"border:1px soli #333;border-left:4px solid #fa0; padding-left:15px;\">\n<p> Never put off till tomorrow what you can do today.</p>\n<p style=\"font-weight:bold; margin-top:-15px;\"> —— Thomas Jefferson</p>\n</div>","source":"about/index.md","raw":"---\ntitle: About Me\ndate: 2020-12-30 18:38:35\ntype: about\ntop_img: https://cdn.jsdelivr.net/gh/cungudafa/cdn/img/banner/about.jpg\n---\n\n### This is about Me\n<div style=\"border:1px soli #333;border-left:4px solid #fa0; padding-left:15px;\">\n<p> Never put off till tomorrow what you can do today.</p>\n<p style=\"font-weight:bold; margin-top:-15px;\"> —— Thomas Jefferson</p>\n</div>","updated":"2021-04-07T03:07:52.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckns3cr5t000hw9q9efen3kmk","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h3 id=\"This-is-about-Me\"><a href=\"#This-is-about-Me\" class=\"headerlink\" title=\"This is about Me\"></a>This is about Me</h3><div style=\"border:1px soli #333;border-left:4px solid #fa0; padding-left:15px;\">\n<p> Never put off till tomorrow what you can do today.</p>\n<p style=\"font-weight:bold; margin-top:-15px;\"> —— Thomas Jefferson</p>\n</div>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h3 id=\"This-is-about-Me\"><a href=\"#This-is-about-Me\" class=\"headerlink\" title=\"This is about Me\"></a>This is about Me</h3><div style=\"border:1px soli #333;border-left:4px solid #fa0; padding-left:15px;\">\n<p> Never put off till tomorrow what you can do today.</p>\n<p style=\"font-weight:bold; margin-top:-15px;\"> —— Thomas Jefferson</p>\n</div>"},{"title":"categories","date":"2020-12-30T13:09:14.000Z","type":"categories","aside":false,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2020-12-30 21:09:14\ntype: \"categories\"\naside: false\n---\n","updated":"2021-04-20T15:19:19.400Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckns3cr5u000nw9q997ef2fs2","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":""}],"Post":[{"title":"23 种设计模式的通俗解释","date":"2020-12-31T15:59:00.000Z","abbrlink":11000,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"## 23 种设计模式的通俗解释\n\n### 01 工厂方法\n\n追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory\n\n工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。\n\n缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。\n\n### 02 建造者模式\n\nMM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。\n\n建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。\n\n### 03 抽象工厂\n\n请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。\n\n工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。\n\n### 04 原型模式\n\n跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）\n\n原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。\n\n### 05 单态模式\n\n俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)\n\n单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。\n\n### 06 适配器模式\n\n在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)\n\n适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。\n\n### 07 桥梁模式\n\n早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了\n\n桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。\n\n### 08 合成模式\n\nMary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？\n\n合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。\n\n### 09 装饰模式\n\nMary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？\n\n装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。\n\n### 10 门面模式\n\n我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。\n\n门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。\n\n### 11 享元模式\n\n每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。\n\n享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。\n\n### 12 代理模式\n\n跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。\n\n代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。\n\n### 13 责任链模式\n\n晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！\n\n责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。\n\n### 14 命令模式\n\n俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”\n\n命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。\n\n### 15 解释器模式\n\n俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。\n\n解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。\n\n### 16 迭代模式\n\n我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”\n\n迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。\n\n### 17 调停者模式\n\n四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。\n\n调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。\n\n### 18 备忘录模式\n\n同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。\n\n备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。\n\n### 19 观察者模式\n\n想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。\n\n观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。\n\n### 20 状态模式\n\n跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。\n\n状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。\n\n### 21 策略模式\n\n跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。\n\n策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。\n\n### 22 模板方法模式\n\n看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；\n\n模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。\n\n### 23 访问者模式\n\n情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；\n\n\n访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。\n\n访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。","source":"_posts/algorithm_md/23种设计模式的通俗解释.md","raw":"---\ntitle: 23 种设计模式的通俗解释\ndate: '2020/12/31 23:59'\ntags:\n - algorithm\ncategories:\n - 学习笔记\nabbrlink: 11000\ncover: \n---\n## 23 种设计模式的通俗解释\n\n### 01 工厂方法\n\n追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory\n\n工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。\n\n缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。\n\n### 02 建造者模式\n\nMM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。\n\n建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。\n\n### 03 抽象工厂\n\n请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。\n\n工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。\n\n### 04 原型模式\n\n跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）\n\n原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。\n\n### 05 单态模式\n\n俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)\n\n单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。\n\n### 06 适配器模式\n\n在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)\n\n适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。\n\n### 07 桥梁模式\n\n早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了\n\n桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。\n\n### 08 合成模式\n\nMary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？\n\n合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。\n\n### 09 装饰模式\n\nMary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？\n\n装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。\n\n### 10 门面模式\n\n我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。\n\n门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。\n\n### 11 享元模式\n\n每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。\n\n享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。\n\n### 12 代理模式\n\n跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。\n\n代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。\n\n### 13 责任链模式\n\n晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！\n\n责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。\n\n### 14 命令模式\n\n俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”\n\n命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。\n\n### 15 解释器模式\n\n俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。\n\n解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。\n\n### 16 迭代模式\n\n我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”\n\n迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。\n\n### 17 调停者模式\n\n四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。\n\n调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。\n\n### 18 备忘录模式\n\n同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。\n\n备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。\n\n### 19 观察者模式\n\n想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。\n\n观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。\n\n### 20 状态模式\n\n跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。\n\n状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。\n\n### 21 策略模式\n\n跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。\n\n策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。\n\n### 22 模板方法模式\n\n看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；\n\n模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。\n\n### 23 访问者模式\n\n情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；\n\n\n访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。\n\n访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。","slug":"algorithm_md/23种设计模式的通俗解释","published":1,"updated":"2021-04-08T14:13:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5m0001w9q94h8r8nq9","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h2 id=\"23-种设计模式的通俗解释\"><a href=\"#23-种设计模式的通俗解释\" class=\"headerlink\" title=\"23 种设计模式的通俗解释\"></a>23 种设计模式的通俗解释</h2><h3 id=\"01-工厂方法\"><a href=\"#01-工厂方法\" class=\"headerlink\" title=\"01 工厂方法\"></a>01 工厂方法</h3><p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory</p>\n<p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。</p>\n<p>缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>\n<h3 id=\"02-建造者模式\"><a href=\"#02-建造者模式\" class=\"headerlink\" title=\"02 建造者模式\"></a>02 建造者模式</h3><p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>\n<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>\n<h3 id=\"03-抽象工厂\"><a href=\"#03-抽象工厂\" class=\"headerlink\" title=\"03 抽象工厂\"></a>03 抽象工厂</h3><p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>\n<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>\n<h3 id=\"04-原型模式\"><a href=\"#04-原型模式\" class=\"headerlink\" title=\"04 原型模式\"></a>04 原型模式</h3><p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>\n<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>\n<h3 id=\"05-单态模式\"><a href=\"#05-单态模式\" class=\"headerlink\" title=\"05 单态模式\"></a>05 单态模式</h3><p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>\n<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。</p>\n<h3 id=\"06-适配器模式\"><a href=\"#06-适配器模式\" class=\"headerlink\" title=\"06 适配器模式\"></a>06 适配器模式</h3><p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>\n<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>\n<h3 id=\"07-桥梁模式\"><a href=\"#07-桥梁模式\" class=\"headerlink\" title=\"07 桥梁模式\"></a>07 桥梁模式</h3><p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>\n<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>\n<h3 id=\"08-合成模式\"><a href=\"#08-合成模式\" class=\"headerlink\" title=\"08 合成模式\"></a>08 合成模式</h3><p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>\n<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>\n<h3 id=\"09-装饰模式\"><a href=\"#09-装饰模式\" class=\"headerlink\" title=\"09 装饰模式\"></a>09 装饰模式</h3><p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>\n<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>\n<h3 id=\"10-门面模式\"><a href=\"#10-门面模式\" class=\"headerlink\" title=\"10 门面模式\"></a>10 门面模式</h3><p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。</p>\n<p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>\n<h3 id=\"11-享元模式\"><a href=\"#11-享元模式\" class=\"headerlink\" title=\"11 享元模式\"></a>11 享元模式</h3><p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。</p>\n<p>享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>\n<h3 id=\"12-代理模式\"><a href=\"#12-代理模式\" class=\"headerlink\" title=\"12 代理模式\"></a>12 代理模式</h3><p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>\n<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>\n<h3 id=\"13-责任链模式\"><a href=\"#13-责任链模式\" class=\"headerlink\" title=\"13 责任链模式\"></a>13 责任链模式</h3><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>\n<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>\n<h3 id=\"14-命令模式\"><a href=\"#14-命令模式\" class=\"headerlink\" title=\"14 命令模式\"></a>14 命令模式</h3><p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>\n<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>\n<h3 id=\"15-解释器模式\"><a href=\"#15-解释器模式\" class=\"headerlink\" title=\"15 解释器模式\"></a>15 解释器模式</h3><p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>\n<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>\n<h3 id=\"16-迭代模式\"><a href=\"#16-迭代模式\" class=\"headerlink\" title=\"16 迭代模式\"></a>16 迭代模式</h3><p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>\n<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>\n<h3 id=\"17-调停者模式\"><a href=\"#17-调停者模式\" class=\"headerlink\" title=\"17 调停者模式\"></a>17 调停者模式</h3><p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。</p>\n<p>调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>\n<h3 id=\"18-备忘录模式\"><a href=\"#18-备忘录模式\" class=\"headerlink\" title=\"18 备忘录模式\"></a>18 备忘录模式</h3><p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>\n<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>\n<h3 id=\"19-观察者模式\"><a href=\"#19-观察者模式\" class=\"headerlink\" title=\"19 观察者模式\"></a>19 观察者模式</h3><p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>\n<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>\n<h3 id=\"20-状态模式\"><a href=\"#20-状态模式\" class=\"headerlink\" title=\"20 状态模式\"></a>20 状态模式</h3><p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>\n<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>\n<h3 id=\"21-策略模式\"><a href=\"#21-策略模式\" class=\"headerlink\" title=\"21 策略模式\"></a>21 策略模式</h3><p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。</p>\n<p>策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>\n<h3 id=\"22-模板方法模式\"><a href=\"#22-模板方法模式\" class=\"headerlink\" title=\"22 模板方法模式\"></a>22 模板方法模式</h3><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>\n<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>\n<h3 id=\"23-访问者模式\"><a href=\"#23-访问者模式\" class=\"headerlink\" title=\"23 访问者模式\"></a>23 访问者模式</h3><p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>\n<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>\n<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"23-种设计模式的通俗解释\"><a href=\"#23-种设计模式的通俗解释\" class=\"headerlink\" title=\"23 种设计模式的通俗解释\"></a>23 种设计模式的通俗解释</h2><h3 id=\"01-工厂方法\"><a href=\"#01-工厂方法\" class=\"headerlink\" title=\"01 工厂方法\"></a>01 工厂方法</h3><p>追 MM 少不了请吃饭了，麦当劳的鸡翅和肯德基的鸡翅都是 MM 爱吃的东西，虽然口味有所不同，但不管你带 MM 去麦当劳或肯德基，只管向服务员说「来四个鸡翅」就行了。麦当劳和肯德基就是生产鸡翅的 Factory</p>\n<p>工厂模式：客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。</p>\n<p>缺点是当产品修改时，工厂类也要做相应的修改。如：如何创建及如何向客户端提供。</p>\n<h3 id=\"02-建造者模式\"><a href=\"#02-建造者模式\" class=\"headerlink\" title=\"02 建造者模式\"></a>02 建造者模式</h3><p>MM 最爱听的就是「我爱你」这句话了，见到不同地方的 MM，要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到 MM 我只要按对应的键，它就能够用相应的语言说出「我爱你」这句话了，国外的 MM 也可以轻松搞掂，这就是我的「我爱你」builder。</p>\n<p>建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。</p>\n<h3 id=\"03-抽象工厂\"><a href=\"#03-抽象工厂\" class=\"headerlink\" title=\"03 抽象工厂\"></a>03 抽象工厂</h3><p>请 MM 去麦当劳吃汉堡，不同的 MM 有不同的口味，要每个都记住是一件烦人的事情，我一般采用 Factory Method 模式，带着 MM 到服务员那儿，说「要一个汉堡」，具体要什么样的汉堡呢，让 MM 直接跟服务员说就行了。</p>\n<p>工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p>\n<h3 id=\"04-原型模式\"><a href=\"#04-原型模式\" class=\"headerlink\" title=\"04 原型模式\"></a>04 原型模式</h3><p>跟 MM 用 QQ 聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要 copy 出来放到 QQ 里面就行了，这就是我的情话 prototype 了。（100 块钱一份，你要不要）</p>\n<p>原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。</p>\n<h3 id=\"05-单态模式\"><a href=\"#05-单态模式\" class=\"headerlink\" title=\"05 单态模式\"></a>05 单态模式</h3><p>俺有 6 个漂亮的老婆，她们的老公都是我，我就是我们家里的老公 Sigleton，她们只要说道「老公」，都是指的同一个人，那就是我 (刚才做了个梦啦，哪有这么好的事)</p>\n<p>单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的 “单一实例” 的需求时才可使用。</p>\n<h3 id=\"06-适配器模式\"><a href=\"#06-适配器模式\" class=\"headerlink\" title=\"06 适配器模式\"></a>06 适配器模式</h3><p>在朋友聚会上碰到了一个美女 Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友 kent 了，他作为我和 Sarah 之间的 Adapter，让我和 Sarah 可以相互交谈了 (也不知道他会不会耍我)</p>\n<p>适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。</p>\n<h3 id=\"07-桥梁模式\"><a href=\"#07-桥梁模式\" class=\"headerlink\" title=\"07 桥梁模式\"></a>07 桥梁模式</h3><p>早上碰到 MM，要说早上好，晚上碰到 MM，要说晚上好；碰到 MM 穿了件新衣服，要说你的衣服好漂亮哦，碰到 MM 新做的发型，要说你的头发好漂亮哦。不要问我 “早上碰到 MM 新做了个发型怎么说” 这种问题，自己用 BRIDGE 组合一下不就行了</p>\n<p>桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合 / 聚合关系而不是继承关系，从而使两者可以独立的变化。</p>\n<h3 id=\"08-合成模式\"><a href=\"#08-合成模式\" class=\"headerlink\" title=\"08 合成模式\"></a>08 合成模式</h3><p>Mary 今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件 T 恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T 恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM 都会用 Composite 模式了，你会了没有？</p>\n<p>合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。</p>\n<h3 id=\"09-装饰模式\"><a href=\"#09-装饰模式\" class=\"headerlink\" title=\"09 装饰模式\"></a>09 装饰模式</h3><p>Mary 过完轮到 Sarly 过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上 “最好的的礼物，就是爱你的 Fita”，再到街上礼品店买了个像框（卖礼品的 MM 也很漂亮哦），再找隔壁搞美术设计的 Mike 设计了一个漂亮的盒子装起来……，我们都是 Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？</p>\n<p>装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。</p>\n<h3 id=\"10-门面模式\"><a href=\"#10-门面模式\" class=\"headerlink\" title=\"10 门面模式\"></a>10 门面模式</h3><p>我有一个专业的 Nikon 相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但 MM 可不懂这些，教了半天也不会。幸好相机有 Facade 设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样 MM 也可以用这个相机给我拍张照片了。</p>\n<p>门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。</p>\n<h3 id=\"11-享元模式\"><a href=\"#11-享元模式\" class=\"headerlink\" title=\"11 享元模式\"></a>11 享元模式</h3><p>每天跟 MM 发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上 MM 的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是 Flyweight，MM 的名字就是提取出来的外部特征，根据上下文情况使用。</p>\n<p>享元模式：FLYWEIGHT 在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。</p>\n<h3 id=\"12-代理模式\"><a href=\"#12-代理模式\" class=\"headerlink\" title=\"12 代理模式\"></a>12 代理模式</h3><p>跟 MM 在网上聊天，一开头总是 “hi, 你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？” 这些话，真烦人，写个程序做为我的 Proxy 吧，凡是接收到这些话都设置好了自己的回答，接收到其他的话时再通知我回答，怎么样，酷吧。</p>\n<p>代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。</p>\n<h3 id=\"13-责任链模式\"><a href=\"#13-责任链模式\" class=\"headerlink\" title=\"13 责任链模式\"></a>13 责任链模式</h3><p>晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的 MM 哎，找张纸条，写上 “Hi, 可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的 MM 把纸条传给老师了，听说是个老处女呀，快跑！</p>\n<p>责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。</p>\n<h3 id=\"14-命令模式\"><a href=\"#14-命令模式\" class=\"headerlink\" title=\"14 命令模式\"></a>14 命令模式</h3><p>俺有一个 MM 家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个 COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送 COMMAND，就数你最小气，才请我吃面。”</p>\n<p>命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。</p>\n<h3 id=\"15-解释器模式\"><a href=\"#15-解释器模式\" class=\"headerlink\" title=\"15 解释器模式\"></a>15 解释器模式</h3><p>俺有一个《泡 MM 真经》，上面有各种泡 MM 的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟 MM 约会时，只要做一个 Interpreter，照着上面的脚本执行就可以了。</p>\n<p>解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。</p>\n<h3 id=\"16-迭代模式\"><a href=\"#16-迭代模式\" class=\"headerlink\" title=\"16 迭代模式\"></a>16 迭代模式</h3><p>我爱上了 Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件” 我：“什么条件我都答应，你说吧” Mary：“我看上了那个一克拉的钻石” 我：“我买，我买，还有吗？” Mary：“我看上了湖边的那栋别墅” 我：“我买，我买，还有吗？” Mary：“我看上那辆法拉利跑车” 我脑袋嗡的一声，坐在椅子上，一咬牙：“我买，我买，还有吗？”</p>\n<p>迭代模式：迭代模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。</p>\n<h3 id=\"17-调停者模式\"><a href=\"#17-调停者模式\" class=\"headerlink\" title=\"17 调停者模式\"></a>17 调停者模式</h3><p>四个 MM 打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就 OK 啦，俺得到了四个 MM 的电话。</p>\n<p>调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。</p>\n<h3 id=\"18-备忘录模式\"><a href=\"#18-备忘录模式\" class=\"headerlink\" title=\"18 备忘录模式\"></a>18 备忘录模式</h3><p>同时跟几个 MM 聊天时，一定要记清楚刚才跟 MM 说了些什么话，不然 MM 发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个 MM 说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。</p>\n<p>备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。</p>\n<h3 id=\"19-观察者模式\"><a href=\"#19-观察者模式\" class=\"headerlink\" title=\"19 观察者模式\"></a>19 观察者模式</h3><p>想知道咱们公司最新 MM 情报吗？加入公司的 MM 情报邮件组就行了，tom 负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦。</p>\n<p>观察者模式：观察者模式定义了一种一队多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。</p>\n<h3 id=\"20-状态模式\"><a href=\"#20-状态模式\" class=\"headerlink\" title=\"20 状态模式\"></a>20 状态模式</h3><p>跟 MM 交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的 MM 就会说 “有事情啦”，对你不讨厌但还没喜欢上的 MM 就会说 “好啊，不过可以带上我同事么？”，已经喜欢上你的 MM 就会说 “几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把 MM 的状态从不讨厌不喜欢变成喜欢哦。</p>\n<p>状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。</p>\n<h3 id=\"21-策略模式\"><a href=\"#21-策略模式\" class=\"headerlink\" title=\"21 策略模式\"></a>21 策略模式</h3><p>跟不同类型的 MM 约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到 MM 的芳心，我的追 MM 锦囊中有好多 Strategy 哦。</p>\n<p>策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。</p>\n<h3 id=\"22-模板方法模式\"><a href=\"#22-模板方法模式\" class=\"headerlink\" title=\"22 模板方法模式\"></a>22 模板方法模式</h3><p>看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤 (Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦 (具体实现)；</p>\n<p>模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。</p>\n<h3 id=\"23-访问者模式\"><a href=\"#23-访问者模式\" class=\"headerlink\" title=\"23 访问者模式\"></a>23 访问者模式</h3><p>情人节到了，要给每个 MM 送一束鲜花和一张卡片，可是每个 MM 送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下 Visitor，让花店老板根据 MM 的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；</p>\n<p>访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。</p>\n<p>访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。</p>\n"},{"title":"图解霍夫曼编码","date":"2020-12-31T15:59:00.000Z","abbrlink":11000,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"以下文章来源于沉默王二 ，作者沉默王二\n\n今天来给大家普及一下霍夫曼编码（Huffman Coding），一种用于无损数据压缩的熵编码算法，由美国计算机科学家大卫·霍夫曼在 1952 年提出——这么专业的解释，不用问，来自维基百科了。\n\n说实话，很早之前我就听说过霍夫曼编码，除了知道它通常用于 GZIP、BZIP2、PKZIP 这些常规的压缩格式中，我还知道它通常用于压缩重复率比较高的字符数据。\n\n大家想啊，英文就 26 个字母进行的无限组合，重复率高得一逼啊！常用的汉字也不多，2500 个左右，别问我怎么知道的，我有问过搜索引擎的。\n\n字符重复的频率越高，霍夫曼编码的工作效率就越高！\n\n是时候，和大家一起来了解一下霍夫曼编码的工作原理啦，毕竟一名优秀的程序员要能做到知其然知其所以然——请允许我又用了一次这句快用臭了话。\n\n假设下面的字符串要通过网络发送。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-261c8885057911f2?imageMogr2/auto-orient/strip|imageView2/2/w/1022)\n\n图片\n\n大家应该知道，每个字符占 8 个比特，上面这串字符总共有 15 个字符，所以一共要占用 15*8=120 个比特。没有疑问吧？有疑问的同学请不好意思下。\n\n如果我们使用霍夫曼编码的话，就可以将这串字符压缩到一个更小的尺寸。怎么做到的呢？\n\n霍夫曼编码首先会使用字符的频率创建一棵树，然后通过这个树的结构为每个字符生成一个特定的编码，出现频率高的字符使用较短的编码，出现频率低的则使用较长的编码，这样就会使编码之后的字符串平均长度降低，从而达到数据无损压缩的目的。\n\n拿上面这串初始字符来一步步的说明下霍夫曼编码的工作步骤。\n\n01**计算字符串中每个字符的频率**\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-493db2230ee56ed0?imageMogr2/auto-orient/strip|imageView2/2/w/1028)\n\n图片\n\nB 出现 1 次，C 出现 6 次，A 出现 5 次，D 出现 3 次。\n\n02 **按照字符出现的频率进行排序，组成一个队列 Q**\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-3f78e78f46bc2087?imageMogr2/auto-orient/strip|imageView2/2/w/970)\n\n图片\n\n出现频率最低的在前面，出现频率高的在后面。\n\n03 **把这些字符作为叶子节点开始构建一颗树**\n\n首先创建一个空节点 z，将最小频率的字符分配给 z 的左侧，并将频率排在第二位的分配给 z 的右侧，然后将 z 赋值为两个字符频率的和。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-933d7c629818420a?imageMogr2/auto-orient/strip|imageView2/2/w/976)\n\n图片\n\nB 的频率最小，所以在左侧，然后是频率为 3 的 D，在右侧；然后把它们的父节点的值设为 4，子节点的频率之和。\n\n然后从队列 Q 中删除 B 和 D，并将它们的和添加到队列中，上图中 * 表示的位置。紧接着，重新创建一个空的节点 z，并将 4 作为左侧的节点，频率为 5 的 A 作为右侧的节点，4 与 5 的和作为父节点。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-6e573edfd090db02?imageMogr2/auto-orient/strip|imageView2/2/w/998)\n\n图片\n\n继续按照之前的思路构建树，直到所有的字符都出现在树的节点中。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-5504ad16fc28b126?imageMogr2/auto-orient/strip|imageView2/2/w/980)\n\n图片\n\n04 **非叶子节点**\n\n对于每个非叶子节点，将 0 分配给连接线的左侧，1 分配给连接线的右侧。\n\n此时，霍夫曼树就构建完成了。霍夫曼树又称为最优二叉树，是一种带权路径长度最短的二叉树。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-9de6082055563916?imageMogr2/auto-orient/strip|imageView2/2/w/980)\n\n图片\n\n当树构建完毕后，我们来统计一下要发送的比特数。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-1f1ab86e20f25599?imageMogr2/auto-orient/strip|imageView2/2/w/1030)\n\n图片\n\n1.来看字符这一列。四个字符 A、B、C、D 共计 4*8=32 比特。每个英文字母均占用一个字节，即 8 个比特。\n\n2.来看频率这一列。A 5 次，B 1 次，C 6 次，D 3 次，一共 15 比特。\n\n3.来看编码这一列。A 的编码为 11，对应霍夫曼树上的 15→9→5，也就是说，从根节点走到叶子节点 A，需要经过 11 这条路径；对应的 B 需要走过 100 这条路径；对应的 D 需要走过 101 这条路径；对应的 C 需要走过 0 这条路径。\n\n4.来看长度这一列。A 的编码为 11，出现了 5 次，因此占用 10 个比特，即 1111111111；B 的编码为 100，出现了 1 次，因此占用 3 个比特，即 100；C 的编码为 0，出现了 6 次，因此占用 6 个比特，即 000000；D 的编码为 101，出现了 3 次，因此占用 9 个比特，即 101101101。\n\n哈夫曼编码从本质上讲，是将最宝贵的资源（最短的编码）给出现概率最多的数据。在上面的例子中，C 出现的频率最高，它的编码为 0，就省下了不少空间。\n\n结合生活中的一些情况想一下，也是这样，我们把最常用的放在手边，这样就能提高效率，节约时间。所以，我有一个大胆的猜想，霍夫曼就是这样发现编码的最优解的。\n\n在没有经过霍夫曼编码之前，字符串“BCAADDDCCACACAC”的二进制为：\n\n10000100100001101000001010000010100010001000100010001000100001101000011010000010100001101000001010000110100000101000011\n\n也就是占了 120 比特。\n\n编码之后为：\n\n0000001001011011011111111111\n\n占了 28 比特。\n\n但考虑到解码，需要把霍夫曼树的结构也传递过去，于是字符占用的 32 比特和频率占用的 15 比特也需要传递过去。总体上，编码后比特数为32 + 15 + 28 = 75,比 120 比特少了 45 个，效率还是非常高的。关于霍夫曼编码的 Java 示例，我在这里也贴出来一下，供大家参考。\n\n```java\nclass HuffmanNode {\n    int item;\n    char c;\n    HuffmanNode left;\n    HuffmanNode right;\n}\n\nclass ImplementComparator implements Comparator<HuffmanNode> {\n    public int compare(HuffmanNode x, HuffmanNode y) {\n        return x.item - y.item;\n    }\n}\n\npublic class Huffman {\n    public static void printCode(HuffmanNode root, String s) {\n        if (root.left == null && root.right == null && Character.isLetter(root.c)) {\n\n            System.out.println(root.c + \"   |  \" + s);\n\n            return;\n        }\n        printCode(root.left, s + \"0\");\n        printCode(root.right, s + \"1\");\n    }\n\npublic static void main(String[] args) {\n        int n = 4;\n        char[] charArray = { 'A', 'B', 'C', 'D' };\n        int[] charfreq = { 5, 1, 6, 3 };\n\n        PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new ImplementComparator());\n\n        for (int i = 0; i < n; i++) {\n            HuffmanNode hn = new HuffmanNode();\n\n            hn.c = charArray[i];\n            hn.item = charfreq[i];\n\n            hn.left = null;\n            hn.right = null;\n\n            q.add(hn);\n        }\n\n        HuffmanNode root = null;\n\n        while (q.size() > 1) {\n\n            HuffmanNode x = q.peek();\n            q.poll();\n\n            HuffmanNode y = q.peek();\n            q.poll();\n\n            HuffmanNode f = new HuffmanNode();\n\n            f.item = x.item + y.item;\n            f.c = '-';\n            f.left = x;\n            f.right = y;\n            root = f;\n\n            q.add(f);\n        }\n        System.out.println(\" 字符 | 霍夫曼编码 \");\n        System.out.println(\"--------------------\");\n        printCode(root, \"\");\n    }\n}\n```\n\n本例的输出结果如下所示：\n\n```ruby\n 字符 | 霍夫曼编码 --------------------C   |  0B   |  100D   |  101A   |  11\n```\n\n给大家留个作业题吧，考虑一下霍夫曼编码的时间复杂度，知道的同学可以在留言区给出答案哈。\n\n> 答案也可以看这里 [https://www.includehelp.com/algorithms/huffman-coding-algorithm-example-and-time-complexity.aspx](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.includehelp.com%2Falgorithms%2Fhuffman-coding-algorithm-example-and-time-complexity.aspx)","source":"_posts/algorithm_md/图解霍夫曼编码.md","raw":"---\ntitle: 图解霍夫曼编码\ndate: '2020/12/31 23:59'\ntags:\n - algorithm\ncategories:\n - 学习笔记\nabbrlink: 11000\ncover: \n---\n以下文章来源于沉默王二 ，作者沉默王二\n\n今天来给大家普及一下霍夫曼编码（Huffman Coding），一种用于无损数据压缩的熵编码算法，由美国计算机科学家大卫·霍夫曼在 1952 年提出——这么专业的解释，不用问，来自维基百科了。\n\n说实话，很早之前我就听说过霍夫曼编码，除了知道它通常用于 GZIP、BZIP2、PKZIP 这些常规的压缩格式中，我还知道它通常用于压缩重复率比较高的字符数据。\n\n大家想啊，英文就 26 个字母进行的无限组合，重复率高得一逼啊！常用的汉字也不多，2500 个左右，别问我怎么知道的，我有问过搜索引擎的。\n\n字符重复的频率越高，霍夫曼编码的工作效率就越高！\n\n是时候，和大家一起来了解一下霍夫曼编码的工作原理啦，毕竟一名优秀的程序员要能做到知其然知其所以然——请允许我又用了一次这句快用臭了话。\n\n假设下面的字符串要通过网络发送。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-261c8885057911f2?imageMogr2/auto-orient/strip|imageView2/2/w/1022)\n\n图片\n\n大家应该知道，每个字符占 8 个比特，上面这串字符总共有 15 个字符，所以一共要占用 15*8=120 个比特。没有疑问吧？有疑问的同学请不好意思下。\n\n如果我们使用霍夫曼编码的话，就可以将这串字符压缩到一个更小的尺寸。怎么做到的呢？\n\n霍夫曼编码首先会使用字符的频率创建一棵树，然后通过这个树的结构为每个字符生成一个特定的编码，出现频率高的字符使用较短的编码，出现频率低的则使用较长的编码，这样就会使编码之后的字符串平均长度降低，从而达到数据无损压缩的目的。\n\n拿上面这串初始字符来一步步的说明下霍夫曼编码的工作步骤。\n\n01**计算字符串中每个字符的频率**\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-493db2230ee56ed0?imageMogr2/auto-orient/strip|imageView2/2/w/1028)\n\n图片\n\nB 出现 1 次，C 出现 6 次，A 出现 5 次，D 出现 3 次。\n\n02 **按照字符出现的频率进行排序，组成一个队列 Q**\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-3f78e78f46bc2087?imageMogr2/auto-orient/strip|imageView2/2/w/970)\n\n图片\n\n出现频率最低的在前面，出现频率高的在后面。\n\n03 **把这些字符作为叶子节点开始构建一颗树**\n\n首先创建一个空节点 z，将最小频率的字符分配给 z 的左侧，并将频率排在第二位的分配给 z 的右侧，然后将 z 赋值为两个字符频率的和。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-933d7c629818420a?imageMogr2/auto-orient/strip|imageView2/2/w/976)\n\n图片\n\nB 的频率最小，所以在左侧，然后是频率为 3 的 D，在右侧；然后把它们的父节点的值设为 4，子节点的频率之和。\n\n然后从队列 Q 中删除 B 和 D，并将它们的和添加到队列中，上图中 * 表示的位置。紧接着，重新创建一个空的节点 z，并将 4 作为左侧的节点，频率为 5 的 A 作为右侧的节点，4 与 5 的和作为父节点。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-6e573edfd090db02?imageMogr2/auto-orient/strip|imageView2/2/w/998)\n\n图片\n\n继续按照之前的思路构建树，直到所有的字符都出现在树的节点中。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-5504ad16fc28b126?imageMogr2/auto-orient/strip|imageView2/2/w/980)\n\n图片\n\n04 **非叶子节点**\n\n对于每个非叶子节点，将 0 分配给连接线的左侧，1 分配给连接线的右侧。\n\n此时，霍夫曼树就构建完成了。霍夫曼树又称为最优二叉树，是一种带权路径长度最短的二叉树。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-9de6082055563916?imageMogr2/auto-orient/strip|imageView2/2/w/980)\n\n图片\n\n当树构建完毕后，我们来统计一下要发送的比特数。\n\n![img](https:////upload-images.jianshu.io/upload_images/22668939-1f1ab86e20f25599?imageMogr2/auto-orient/strip|imageView2/2/w/1030)\n\n图片\n\n1.来看字符这一列。四个字符 A、B、C、D 共计 4*8=32 比特。每个英文字母均占用一个字节，即 8 个比特。\n\n2.来看频率这一列。A 5 次，B 1 次，C 6 次，D 3 次，一共 15 比特。\n\n3.来看编码这一列。A 的编码为 11，对应霍夫曼树上的 15→9→5，也就是说，从根节点走到叶子节点 A，需要经过 11 这条路径；对应的 B 需要走过 100 这条路径；对应的 D 需要走过 101 这条路径；对应的 C 需要走过 0 这条路径。\n\n4.来看长度这一列。A 的编码为 11，出现了 5 次，因此占用 10 个比特，即 1111111111；B 的编码为 100，出现了 1 次，因此占用 3 个比特，即 100；C 的编码为 0，出现了 6 次，因此占用 6 个比特，即 000000；D 的编码为 101，出现了 3 次，因此占用 9 个比特，即 101101101。\n\n哈夫曼编码从本质上讲，是将最宝贵的资源（最短的编码）给出现概率最多的数据。在上面的例子中，C 出现的频率最高，它的编码为 0，就省下了不少空间。\n\n结合生活中的一些情况想一下，也是这样，我们把最常用的放在手边，这样就能提高效率，节约时间。所以，我有一个大胆的猜想，霍夫曼就是这样发现编码的最优解的。\n\n在没有经过霍夫曼编码之前，字符串“BCAADDDCCACACAC”的二进制为：\n\n10000100100001101000001010000010100010001000100010001000100001101000011010000010100001101000001010000110100000101000011\n\n也就是占了 120 比特。\n\n编码之后为：\n\n0000001001011011011111111111\n\n占了 28 比特。\n\n但考虑到解码，需要把霍夫曼树的结构也传递过去，于是字符占用的 32 比特和频率占用的 15 比特也需要传递过去。总体上，编码后比特数为32 + 15 + 28 = 75,比 120 比特少了 45 个，效率还是非常高的。关于霍夫曼编码的 Java 示例，我在这里也贴出来一下，供大家参考。\n\n```java\nclass HuffmanNode {\n    int item;\n    char c;\n    HuffmanNode left;\n    HuffmanNode right;\n}\n\nclass ImplementComparator implements Comparator<HuffmanNode> {\n    public int compare(HuffmanNode x, HuffmanNode y) {\n        return x.item - y.item;\n    }\n}\n\npublic class Huffman {\n    public static void printCode(HuffmanNode root, String s) {\n        if (root.left == null && root.right == null && Character.isLetter(root.c)) {\n\n            System.out.println(root.c + \"   |  \" + s);\n\n            return;\n        }\n        printCode(root.left, s + \"0\");\n        printCode(root.right, s + \"1\");\n    }\n\npublic static void main(String[] args) {\n        int n = 4;\n        char[] charArray = { 'A', 'B', 'C', 'D' };\n        int[] charfreq = { 5, 1, 6, 3 };\n\n        PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new ImplementComparator());\n\n        for (int i = 0; i < n; i++) {\n            HuffmanNode hn = new HuffmanNode();\n\n            hn.c = charArray[i];\n            hn.item = charfreq[i];\n\n            hn.left = null;\n            hn.right = null;\n\n            q.add(hn);\n        }\n\n        HuffmanNode root = null;\n\n        while (q.size() > 1) {\n\n            HuffmanNode x = q.peek();\n            q.poll();\n\n            HuffmanNode y = q.peek();\n            q.poll();\n\n            HuffmanNode f = new HuffmanNode();\n\n            f.item = x.item + y.item;\n            f.c = '-';\n            f.left = x;\n            f.right = y;\n            root = f;\n\n            q.add(f);\n        }\n        System.out.println(\" 字符 | 霍夫曼编码 \");\n        System.out.println(\"--------------------\");\n        printCode(root, \"\");\n    }\n}\n```\n\n本例的输出结果如下所示：\n\n```ruby\n 字符 | 霍夫曼编码 --------------------C   |  0B   |  100D   |  101A   |  11\n```\n\n给大家留个作业题吧，考虑一下霍夫曼编码的时间复杂度，知道的同学可以在留言区给出答案哈。\n\n> 答案也可以看这里 [https://www.includehelp.com/algorithms/huffman-coding-algorithm-example-and-time-complexity.aspx](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.includehelp.com%2Falgorithms%2Fhuffman-coding-algorithm-example-and-time-complexity.aspx)","slug":"algorithm_md/图解霍夫曼编码","published":1,"updated":"2021-04-08T14:14:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5o0003w9q96foe0l5y","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><p>以下文章来源于沉默王二 ，作者沉默王二</p>\n<p>今天来给大家普及一下霍夫曼编码（Huffman Coding），一种用于无损数据压缩的熵编码算法，由美国计算机科学家大卫·霍夫曼在 1952 年提出——这么专业的解释，不用问，来自维基百科了。</p>\n<p>说实话，很早之前我就听说过霍夫曼编码，除了知道它通常用于 GZIP、BZIP2、PKZIP 这些常规的压缩格式中，我还知道它通常用于压缩重复率比较高的字符数据。</p>\n<p>大家想啊，英文就 26 个字母进行的无限组合，重复率高得一逼啊！常用的汉字也不多，2500 个左右，别问我怎么知道的，我有问过搜索引擎的。</p>\n<p>字符重复的频率越高，霍夫曼编码的工作效率就越高！</p>\n<p>是时候，和大家一起来了解一下霍夫曼编码的工作原理啦，毕竟一名优秀的程序员要能做到知其然知其所以然——请允许我又用了一次这句快用臭了话。</p>\n<p>假设下面的字符串要通过网络发送。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-261c8885057911f2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1022\" alt=\"img\"></p>\n<p>图片</p>\n<p>大家应该知道，每个字符占 8 个比特，上面这串字符总共有 15 个字符，所以一共要占用 15*8=120 个比特。没有疑问吧？有疑问的同学请不好意思下。</p>\n<p>如果我们使用霍夫曼编码的话，就可以将这串字符压缩到一个更小的尺寸。怎么做到的呢？</p>\n<p>霍夫曼编码首先会使用字符的频率创建一棵树，然后通过这个树的结构为每个字符生成一个特定的编码，出现频率高的字符使用较短的编码，出现频率低的则使用较长的编码，这样就会使编码之后的字符串平均长度降低，从而达到数据无损压缩的目的。</p>\n<p>拿上面这串初始字符来一步步的说明下霍夫曼编码的工作步骤。</p>\n<p>01<strong>计算字符串中每个字符的频率</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-493db2230ee56ed0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1028\" alt=\"img\"></p>\n<p>图片</p>\n<p>B 出现 1 次，C 出现 6 次，A 出现 5 次，D 出现 3 次。</p>\n<p>02 <strong>按照字符出现的频率进行排序，组成一个队列 Q</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-3f78e78f46bc2087?imageMogr2/auto-orient/strip%7CimageView2/2/w/970\" alt=\"img\"></p>\n<p>图片</p>\n<p>出现频率最低的在前面，出现频率高的在后面。</p>\n<p>03 <strong>把这些字符作为叶子节点开始构建一颗树</strong></p>\n<p>首先创建一个空节点 z，将最小频率的字符分配给 z 的左侧，并将频率排在第二位的分配给 z 的右侧，然后将 z 赋值为两个字符频率的和。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-933d7c629818420a?imageMogr2/auto-orient/strip%7CimageView2/2/w/976\" alt=\"img\"></p>\n<p>图片</p>\n<p>B 的频率最小，所以在左侧，然后是频率为 3 的 D，在右侧；然后把它们的父节点的值设为 4，子节点的频率之和。</p>\n<p>然后从队列 Q 中删除 B 和 D，并将它们的和添加到队列中，上图中 * 表示的位置。紧接着，重新创建一个空的节点 z，并将 4 作为左侧的节点，频率为 5 的 A 作为右侧的节点，4 与 5 的和作为父节点。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-6e573edfd090db02?imageMogr2/auto-orient/strip%7CimageView2/2/w/998\" alt=\"img\"></p>\n<p>图片</p>\n<p>继续按照之前的思路构建树，直到所有的字符都出现在树的节点中。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-5504ad16fc28b126?imageMogr2/auto-orient/strip%7CimageView2/2/w/980\" alt=\"img\"></p>\n<p>图片</p>\n<p>04 <strong>非叶子节点</strong></p>\n<p>对于每个非叶子节点，将 0 分配给连接线的左侧，1 分配给连接线的右侧。</p>\n<p>此时，霍夫曼树就构建完成了。霍夫曼树又称为最优二叉树，是一种带权路径长度最短的二叉树。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-9de6082055563916?imageMogr2/auto-orient/strip%7CimageView2/2/w/980\" alt=\"img\"></p>\n<p>图片</p>\n<p>当树构建完毕后，我们来统计一下要发送的比特数。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-1f1ab86e20f25599?imageMogr2/auto-orient/strip%7CimageView2/2/w/1030\" alt=\"img\"></p>\n<p>图片</p>\n<p>1.来看字符这一列。四个字符 A、B、C、D 共计 4*8=32 比特。每个英文字母均占用一个字节，即 8 个比特。</p>\n<p>2.来看频率这一列。A 5 次，B 1 次，C 6 次，D 3 次，一共 15 比特。</p>\n<p>3.来看编码这一列。A 的编码为 11，对应霍夫曼树上的 15→9→5，也就是说，从根节点走到叶子节点 A，需要经过 11 这条路径；对应的 B 需要走过 100 这条路径；对应的 D 需要走过 101 这条路径；对应的 C 需要走过 0 这条路径。</p>\n<p>4.来看长度这一列。A 的编码为 11，出现了 5 次，因此占用 10 个比特，即 1111111111；B 的编码为 100，出现了 1 次，因此占用 3 个比特，即 100；C 的编码为 0，出现了 6 次，因此占用 6 个比特，即 000000；D 的编码为 101，出现了 3 次，因此占用 9 个比特，即 101101101。</p>\n<p>哈夫曼编码从本质上讲，是将最宝贵的资源（最短的编码）给出现概率最多的数据。在上面的例子中，C 出现的频率最高，它的编码为 0，就省下了不少空间。</p>\n<p>结合生活中的一些情况想一下，也是这样，我们把最常用的放在手边，这样就能提高效率，节约时间。所以，我有一个大胆的猜想，霍夫曼就是这样发现编码的最优解的。</p>\n<p>在没有经过霍夫曼编码之前，字符串“BCAADDDCCACACAC”的二进制为：</p>\n<p>10000100100001101000001010000010100010001000100010001000100001101000011010000010100001101000001010000110100000101000011</p>\n<p>也就是占了 120 比特。</p>\n<p>编码之后为：</p>\n<p>0000001001011011011111111111</p>\n<p>占了 28 比特。</p>\n<p>但考虑到解码，需要把霍夫曼树的结构也传递过去，于是字符占用的 32 比特和频率占用的 15 比特也需要传递过去。总体上，编码后比特数为32 + 15 + 28 = 75,比 120 比特少了 45 个，效率还是非常高的。关于霍夫曼编码的 Java 示例，我在这里也贴出来一下，供大家参考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuffmanNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> item;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    HuffmanNode left;</span><br><span class=\"line\">    HuffmanNode right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplementComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">HuffmanNode</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(HuffmanNode x, HuffmanNode y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x.item - y.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Huffman</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printCode</span><span class=\"params\">(HuffmanNode root, String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span> &amp;&amp; Character.isLetter(root.c)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(root.c + <span class=\"string\">&quot;   |  &quot;</span> + s);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printCode(root.left, s + <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">        printCode(root.right, s + <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArray = &#123; <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span> &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] charfreq = &#123; <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        PriorityQueue&lt;HuffmanNode&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;HuffmanNode&gt;(n, <span class=\"keyword\">new</span> ImplementComparator());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            HuffmanNode hn = <span class=\"keyword\">new</span> HuffmanNode();</span><br><span class=\"line\"></span><br><span class=\"line\">            hn.c = charArray[i];</span><br><span class=\"line\">            hn.item = charfreq[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            hn.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            hn.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.add(hn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        HuffmanNode root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (q.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            HuffmanNode x = q.peek();</span><br><span class=\"line\">            q.poll();</span><br><span class=\"line\"></span><br><span class=\"line\">            HuffmanNode y = q.peek();</span><br><span class=\"line\">            q.poll();</span><br><span class=\"line\"></span><br><span class=\"line\">            HuffmanNode f = <span class=\"keyword\">new</span> HuffmanNode();</span><br><span class=\"line\"></span><br><span class=\"line\">            f.item = x.item + y.item;</span><br><span class=\"line\">            f.c = <span class=\"string\">&#x27;-&#x27;</span>;</span><br><span class=\"line\">            f.left = x;</span><br><span class=\"line\">            f.right = y;</span><br><span class=\"line\">            root = f;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.add(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; 字符 | 霍夫曼编码 &quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--------------------&quot;</span>);</span><br><span class=\"line\">        printCode(root, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本例的输出结果如下所示：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符 <span class=\"params\">| 霍夫曼编码 --------------------C   |</span>  0B   <span class=\"params\">|  100D   |</span>  101A   <span class=\"params\">|  11</span></span><br></pre></td></tr></table></figure>\n<p>给大家留个作业题吧，考虑一下霍夫曼编码的时间复杂度，知道的同学可以在留言区给出答案哈。</p>\n<blockquote>\n<p>答案也可以看这里 <a href=\"https://links.jianshu.com/go?to=https://www.includehelp.com/algorithms/huffman-coding-algorithm-example-and-time-complexity.aspx\">https://www.includehelp.com/algorithms/huffman-coding-algorithm-example-and-time-complexity.aspx</a></p>\n</blockquote>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>以下文章来源于沉默王二 ，作者沉默王二</p>\n<p>今天来给大家普及一下霍夫曼编码（Huffman Coding），一种用于无损数据压缩的熵编码算法，由美国计算机科学家大卫·霍夫曼在 1952 年提出——这么专业的解释，不用问，来自维基百科了。</p>\n<p>说实话，很早之前我就听说过霍夫曼编码，除了知道它通常用于 GZIP、BZIP2、PKZIP 这些常规的压缩格式中，我还知道它通常用于压缩重复率比较高的字符数据。</p>\n<p>大家想啊，英文就 26 个字母进行的无限组合，重复率高得一逼啊！常用的汉字也不多，2500 个左右，别问我怎么知道的，我有问过搜索引擎的。</p>\n<p>字符重复的频率越高，霍夫曼编码的工作效率就越高！</p>\n<p>是时候，和大家一起来了解一下霍夫曼编码的工作原理啦，毕竟一名优秀的程序员要能做到知其然知其所以然——请允许我又用了一次这句快用臭了话。</p>\n<p>假设下面的字符串要通过网络发送。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-261c8885057911f2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1022\" alt=\"img\"></p>\n<p>图片</p>\n<p>大家应该知道，每个字符占 8 个比特，上面这串字符总共有 15 个字符，所以一共要占用 15*8=120 个比特。没有疑问吧？有疑问的同学请不好意思下。</p>\n<p>如果我们使用霍夫曼编码的话，就可以将这串字符压缩到一个更小的尺寸。怎么做到的呢？</p>\n<p>霍夫曼编码首先会使用字符的频率创建一棵树，然后通过这个树的结构为每个字符生成一个特定的编码，出现频率高的字符使用较短的编码，出现频率低的则使用较长的编码，这样就会使编码之后的字符串平均长度降低，从而达到数据无损压缩的目的。</p>\n<p>拿上面这串初始字符来一步步的说明下霍夫曼编码的工作步骤。</p>\n<p>01<strong>计算字符串中每个字符的频率</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-493db2230ee56ed0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1028\" alt=\"img\"></p>\n<p>图片</p>\n<p>B 出现 1 次，C 出现 6 次，A 出现 5 次，D 出现 3 次。</p>\n<p>02 <strong>按照字符出现的频率进行排序，组成一个队列 Q</strong></p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-3f78e78f46bc2087?imageMogr2/auto-orient/strip%7CimageView2/2/w/970\" alt=\"img\"></p>\n<p>图片</p>\n<p>出现频率最低的在前面，出现频率高的在后面。</p>\n<p>03 <strong>把这些字符作为叶子节点开始构建一颗树</strong></p>\n<p>首先创建一个空节点 z，将最小频率的字符分配给 z 的左侧，并将频率排在第二位的分配给 z 的右侧，然后将 z 赋值为两个字符频率的和。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-933d7c629818420a?imageMogr2/auto-orient/strip%7CimageView2/2/w/976\" alt=\"img\"></p>\n<p>图片</p>\n<p>B 的频率最小，所以在左侧，然后是频率为 3 的 D，在右侧；然后把它们的父节点的值设为 4，子节点的频率之和。</p>\n<p>然后从队列 Q 中删除 B 和 D，并将它们的和添加到队列中，上图中 * 表示的位置。紧接着，重新创建一个空的节点 z，并将 4 作为左侧的节点，频率为 5 的 A 作为右侧的节点，4 与 5 的和作为父节点。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-6e573edfd090db02?imageMogr2/auto-orient/strip%7CimageView2/2/w/998\" alt=\"img\"></p>\n<p>图片</p>\n<p>继续按照之前的思路构建树，直到所有的字符都出现在树的节点中。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-5504ad16fc28b126?imageMogr2/auto-orient/strip%7CimageView2/2/w/980\" alt=\"img\"></p>\n<p>图片</p>\n<p>04 <strong>非叶子节点</strong></p>\n<p>对于每个非叶子节点，将 0 分配给连接线的左侧，1 分配给连接线的右侧。</p>\n<p>此时，霍夫曼树就构建完成了。霍夫曼树又称为最优二叉树，是一种带权路径长度最短的二叉树。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-9de6082055563916?imageMogr2/auto-orient/strip%7CimageView2/2/w/980\" alt=\"img\"></p>\n<p>图片</p>\n<p>当树构建完毕后，我们来统计一下要发送的比特数。</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/22668939-1f1ab86e20f25599?imageMogr2/auto-orient/strip%7CimageView2/2/w/1030\" alt=\"img\"></p>\n<p>图片</p>\n<p>1.来看字符这一列。四个字符 A、B、C、D 共计 4*8=32 比特。每个英文字母均占用一个字节，即 8 个比特。</p>\n<p>2.来看频率这一列。A 5 次，B 1 次，C 6 次，D 3 次，一共 15 比特。</p>\n<p>3.来看编码这一列。A 的编码为 11，对应霍夫曼树上的 15→9→5，也就是说，从根节点走到叶子节点 A，需要经过 11 这条路径；对应的 B 需要走过 100 这条路径；对应的 D 需要走过 101 这条路径；对应的 C 需要走过 0 这条路径。</p>\n<p>4.来看长度这一列。A 的编码为 11，出现了 5 次，因此占用 10 个比特，即 1111111111；B 的编码为 100，出现了 1 次，因此占用 3 个比特，即 100；C 的编码为 0，出现了 6 次，因此占用 6 个比特，即 000000；D 的编码为 101，出现了 3 次，因此占用 9 个比特，即 101101101。</p>\n<p>哈夫曼编码从本质上讲，是将最宝贵的资源（最短的编码）给出现概率最多的数据。在上面的例子中，C 出现的频率最高，它的编码为 0，就省下了不少空间。</p>\n<p>结合生活中的一些情况想一下，也是这样，我们把最常用的放在手边，这样就能提高效率，节约时间。所以，我有一个大胆的猜想，霍夫曼就是这样发现编码的最优解的。</p>\n<p>在没有经过霍夫曼编码之前，字符串“BCAADDDCCACACAC”的二进制为：</p>\n<p>10000100100001101000001010000010100010001000100010001000100001101000011010000010100001101000001010000110100000101000011</p>\n<p>也就是占了 120 比特。</p>\n<p>编码之后为：</p>\n<p>0000001001011011011111111111</p>\n<p>占了 28 比特。</p>\n<p>但考虑到解码，需要把霍夫曼树的结构也传递过去，于是字符占用的 32 比特和频率占用的 15 比特也需要传递过去。总体上，编码后比特数为32 + 15 + 28 = 75,比 120 比特少了 45 个，效率还是非常高的。关于霍夫曼编码的 Java 示例，我在这里也贴出来一下，供大家参考。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HuffmanNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> item;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">    HuffmanNode left;</span><br><span class=\"line\">    HuffmanNode right;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ImplementComparator</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparator</span>&lt;<span class=\"title\">HuffmanNode</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(HuffmanNode x, HuffmanNode y)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x.item - y.item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Huffman</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">printCode</span><span class=\"params\">(HuffmanNode root, String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span> &amp;&amp; Character.isLetter(root.c)) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(root.c + <span class=\"string\">&quot;   |  &quot;</span> + s);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        printCode(root.left, s + <span class=\"string\">&quot;0&quot;</span>);</span><br><span class=\"line\">        printCode(root.right, s + <span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">4</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span>[] charArray = &#123; <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>, <span class=\"string\">&#x27;D&#x27;</span> &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] charfreq = &#123; <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        PriorityQueue&lt;HuffmanNode&gt; q = <span class=\"keyword\">new</span> PriorityQueue&lt;HuffmanNode&gt;(n, <span class=\"keyword\">new</span> ImplementComparator());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            HuffmanNode hn = <span class=\"keyword\">new</span> HuffmanNode();</span><br><span class=\"line\"></span><br><span class=\"line\">            hn.c = charArray[i];</span><br><span class=\"line\">            hn.item = charfreq[i];</span><br><span class=\"line\"></span><br><span class=\"line\">            hn.left = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            hn.right = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.add(hn);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        HuffmanNode root = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (q.size() &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            HuffmanNode x = q.peek();</span><br><span class=\"line\">            q.poll();</span><br><span class=\"line\"></span><br><span class=\"line\">            HuffmanNode y = q.peek();</span><br><span class=\"line\">            q.poll();</span><br><span class=\"line\"></span><br><span class=\"line\">            HuffmanNode f = <span class=\"keyword\">new</span> HuffmanNode();</span><br><span class=\"line\"></span><br><span class=\"line\">            f.item = x.item + y.item;</span><br><span class=\"line\">            f.c = <span class=\"string\">&#x27;-&#x27;</span>;</span><br><span class=\"line\">            f.left = x;</span><br><span class=\"line\">            f.right = y;</span><br><span class=\"line\">            root = f;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.add(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot; 字符 | 霍夫曼编码 &quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--------------------&quot;</span>);</span><br><span class=\"line\">        printCode(root, <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>本例的输出结果如下所示：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">字符 <span class=\"params\">| 霍夫曼编码 --------------------C   |</span>  0B   <span class=\"params\">|  100D   |</span>  101A   <span class=\"params\">|  11</span></span><br></pre></td></tr></table></figure>\n<p>给大家留个作业题吧，考虑一下霍夫曼编码的时间复杂度，知道的同学可以在留言区给出答案哈。</p>\n<blockquote>\n<p>答案也可以看这里 <a href=\"https://links.jianshu.com/go?to=https://www.includehelp.com/algorithms/huffman-coding-algorithm-example-and-time-complexity.aspx\">https://www.includehelp.com/algorithms/huffman-coding-algorithm-example-and-time-complexity.aspx</a></p>\n</blockquote>\n"},{"title":"Jenkinsfile introduce","date":"2020-12-31T15:59:00.000Z","abbrlink":12007,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"# Jenkinsfile introduce\n\n## Jenkinsfile 基本语法\n\n### Defining a Pipeline\n\nJenkins Pipeline is a suite of plugins that supports implementing and integrating continuous delivery pipelines into Jenkins. \n\nA Pipeline can be created in one of the following ways:\n\n- [Through Blue Ocean](https://jenkins.io/doc/book/pipeline/getting-started/#through-blue-ocean) - after setting up a Pipeline project in Blue Ocean, the Blue Ocean UI helps you write your Pipeline’s `Jenkinsfile` and commit it to source control.\n- [Through the classic UI](https://jenkins.io/doc/book/pipeline/getting-started/#through-the-classic-ui) - you can enter a basic Pipeline directly in Jenkins through the classic UI.\n- [In SCM](https://jenkins.io/doc/book/pipeline/getting-started/#defining-a-pipeline-in-scm) - you can write a `Jenkinsfile` manually, which you can commit to your project’s source control repository.\n\n### Using Environmental Variables\n\nEnvironment variables can be set globally or per stage.\n\nSetting environment variables per stage means they will only apply to the stage in which they’re defined.\n\n```Jenkins\n// setting environment variables globally\npipeline {\n environment {\n BUILD_NUMBER=\"${Calendar.getInstance()format('yyyyMMddHHmmssSSS')}\"\n BUILD_ID = \"${env.BUILD_NUMBER}\"\n }\n}\n```\n\n### Agent\n\nIn declarative pipelines the **agent** directive is used for specifying which agent/slave the job/task is to be executed on. This directive only allows you to specify where the task can be executed (On which agent, slave, label or docker image)\n\n```\nagent { kubernetes { label 'my-defined-label' inheritFrom 'my-defined-build' containerTemplate { name 'build-name' image 'my-docker-image:latest' workingDir 'my/working/dir' } } }\n```\n\n### Parameters\n\nThe parameters directive provides a list of parameters which a user should provide when triggering the Pipeline. The values for these user-specified parameters are made available to Pipeline steps via the '`params'` object.\n\n```Jenkins\nString parameter:\nparameters {\n string(name: 'DEPLOY_ENV', defaultValue: 'staging', description: '')\n}\nBoolean parameter:\nparameters {\n booleanParam(name: 'DEBUG_BUILD', defaultValue: true, description: '')\n}\nChoice parameter:\nparameters {\n choice(name:'OPTIONS', description:'Select an option', choices:'Option1\\nOption2\\nOption3')\n}\n```\n\n### Gerrit Triggers\n\nThis plugin integrates Jenkins to Gerrit code review for triggering builds when a \"patch set\" is created.\n\n<u>**Trigger configuration in pipeline job:**</u>\n\nIn the \"Build Triggers\" section of your Job configuration page; tick \"Gerrit event\"\n\nSpecify what type of event(s) to trigger on:\n\n- **Draft Published:** Sent when a change moves from draft state to new. (only available in version 2.5 or higher of Gerrit).\n- **Patchset Created:** Sent when a new patchset arrives on a change. Before version 2.6.0, this was the only event you could trigger on.\n- **Change Merged:** Sent when a change is merged on the Gerrit server.\n- **Comment Added:** Sent when a comment is added to a change. Which category and value to trigger on can be configured. The available categories can be configured in the server settings for the plugin.\n- **Ref Updated:** Sent when a ref is updated on the Gerrit server, i.e. someone pushes past code review.\n\n{% asset_img image-20200729094356824.png %}\n\n<img src=\"Jenkinsfile%20introduce/image-20200729094356824.png\" alt=\"image-20200729094356824\" style=\"zoom: 67%;\" />\n\n<u>**Trigger configuration in Jenkinsfile:**</u>\n\nJenkinsfile will overwrite the configuration done in pipeline job. \n\n```\ntriggers {\n gerrit(\n   customUrl: '',\n   gerritProjects: [[\n     branches: [[\n      compareType: 'PLAIN',\n      pattern: 'master'\n     ]],\n    compareType: 'PLAIN',\n    disableStrictForbiddenFileVerification: false,\n    pattern: 'repo-name'\n   ]],\n   serverName: 'user-name',\n   triggerOnEvents: [\n     changeMerged(),\n     patchsetCreated(\n       excludeDrafts: true,\n       excludeNoCodeChange: false,\n       excludeTrivialRebase: false\n     ),\n     commentAdded(\n       verdictCategory: 'Code-Review',\n       commentAddedTriggerApprovalValue: '+2'\n     )\n   ]\n  )\n}\n```\n\n## Jenkinsfile simple\n\n### @Library\n\n```Jenkins\n@Library(['scm@<pipeline-utils branch or tag>']) _\n```\n\nExample:\n\n```Jenkins\n@Library(['scm@container-stable-2.x', 'commonLibs@0.0.3']) _\n```\n\n### extraOnboardingImages\n\nList containing the extra images that need to onboard to Open Edge server. \n\n列出包含需要附加到Open Edge服务器的其他图像的列表。\n\nExample:\n\n```Jenkins\nMap containers = [\n    DockerImage: [\n        name: 'fhproxy/docker-fhproxy',\n        buildName: 'fhproxy',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: true,\n        type: 'runtime'\n    ],\n    DockerTestImage: [\n        name: 'fhproxy/docker-fhproxy-test',\n        buildName: 'fhproxy',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: true,\n        type: 'runtime'\n    ],\n    NwInitImage: [\n        name: \"fhproxy/docker-nwinit\",\n        buildName: 'Onboarding',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: false\n    ],\n    NwMgmtImage: [\n        name: \"fhproxy/docker-nwmgmt\",\n        buildName: 'Onboarding',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: false\n    ]\n]\n```\n\n### tersyParams\n\n> platform: <b>Optional arguments</b>\n\nString containing platform type of NESC node.  包含NESC节点的平台类型的字符串\n\nPossible values:\n\n- any\n- TPI3-like\n- NCIR-like\n\nDefault value: NCIR-like\n\nWhen test is executed in real HW [tersyParams](#tersyparams) will define which kind of environment is selected\n\n在实际硬件中执行测试时，tersyParams将定义选择哪种环境\n\nMap containing information that is used for test environment reservation from Tersy. \n\n映射包含用于从Tersy保留测试环境的信息。\n\nDuration and pool or tenant attributes in tersyParams are mandatory if RUN_ON_HW is set to true. \n\n如果将**RUN_ON_HW**设置为true，则tersyParams中的**duration**和**pool**或**tenant**属性是必需的。\n\nOther attributes are optional.\n\nTersy parameters:\n\nFor details on supported parameters see documentation of [tersycli create](https://pypi.dynamic.nsn-net.net/rcp/prod/tersycli/latest/+doc/CLI.html#create) command.\n\n有关支持的参数的详细信息，请参见tersycli create命令的文档。\n\nOnly long format of the named arguments are supported, use for example 'duration' instead of 'd'. \n\nNote that '**reservation_name**' is not needed as it is automatically set to Jenkins job name. \n\nDefault value of **queue_timeout** parameter is 1 hour if priority is given. \n\nDefault value of **env_type** is CAAS. \n\nAdditionally a specific tersycli version can be requested with `tersycliVersion`, 2.3.5 is used by default.\n\n仅支持长格式的命名参数，例如使用“duration”代替“ d”。\n\n```Jenkins\nMap tersyParamsMvp = [    \n    pool: \"CAAS_test\",\n    priority: \"3\",\n    duration: \"1\",\n    queue_timeout: \"6\",\n    tag: \"NIC=Intel-XXV710\",\n    platform: \"NCIR19\"\n]\n\nMap tersyParams = [\n    pool: \"CAAS_Host_VLAN\",\n    priority: \"3\",\n    duration: \"1\",\n    queue_timeout: \"6\",\n    tag: \"NIC=Intel-XXV710\",\n    platform: \"NCIR19\"\n]\n```\n\n### builds\n\n```Jenkins\nList builds = [\n    [\n        name: 'fhproxy',\n        agent: 'docker_helmci',\n        command: 'ci/docker-build'\n    ],\n    [\n        name: 'Onboarding',\n        agent: 'docker_helmci',\n        command: 'ci/get-onboarding-images'\n    ]\n]\n```\n\n### agent\n\n> agent: <b>Optional arguments</b>\n\nJenkins agent where the test is executed. 执行测试的Jenkins代理。\n\nSome possible values are:\n\n- `single-node-container-k8s-dpdk`  for 8 core [cloud-development](https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/) environment with dpdk support\n- `single-node-pod-k8s-dpdk`  for 16 core [cloud-development](https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/) environment with dpdk support\n- `multi-node-pod-k8s-dpdk`  for 1+1 node, 13 core each, [container-infra-system](https://gitlabe2.ext.net.nokia.com/cloud-tools/container-infra-system) environment with dpdk support\n- TODO: IT kubernetes cluster agent\n\nDefault value for the parameter is `single-node-container-k8s-dpdk`\n\n> cleanCommand: <b>Optional arguments</b>\n\nOptional shell command to run before and after test to clean up resources. \n\n在测试之前和之后运行的可选shell命令，以清理资源。\n\n要注意的是，pipeline检测v2和v3的Helm命令，并将它们分别暴露为环境变量$ {HELM2}和$ {HELM3}。因此最好在shell脚本中使用这些变量，以避免在'helm'命令更改为指向helm3而不是旧的helm2时更改脚本。\n\n> helmName:  <b>Mandatory arguments</b>\n\nName of the helm chart to be tested and published. Helm chart will be cloned to a directory with this name regardless what the repository name is. All scripts are executed in this directory.\n\n要测试和发布的helm chart的名称, 无论存储库名称是什么，Helm chart都会被克隆到具有该名称的目录中。所有脚本都在此目录中执行。\n\nTo allow for more than one pipeline to be executed for same helm chart, pipeline appends automatically Jenkins build id and branch name to the helm name defined in the [env_vars file]().\n\n为了允许对同一helm chart执行多个管道，管道会自动将Jenkins构建ID和分支名称附加到env_vars文件中定义的helm名称。\n\n> deployCommand: <b>Optional arguments</b>\n\nOptional shell command to deploy the helm chart. Default value is `ci/deploy.sh`\n\n可选的shell命令，用于部署helm chart。默认值为ci / deploy.sh， 应该是这里的command\n\n> testCommand: <b>Optional arguments</b>\n\nOptional shell command to deploy the helm chart. Default value is `ci/test.sh`\n\n可选的shell命令，用于部署helm chart。默认值为ci / test.sh\n\n> logsCommand: <b>Optional arguments</b>\n\nOptional shell command to run at the end of the pipeline to collect logs. Default value is `gather-artifacts.sh` Will be executed always even if deploy or test fails. To ensure that all logs are collected make sure that the command handles error cases correctly.\n\n可选的shell命令在pipeline末端运行以收集日志。失败后的log收集，为确保收集所有日志，请确保该命令正确处理错误情况。\n\nIf using `bash` script you can use `+e` flag to ignore errors:\n\n如果使用bash脚本，则可以使用+ e标志忽略错误： `#!/bin/bash +e`\n\n```Jenkins\nList tests = [\n    [\n        name: 'Test fhproxy container mvp',\n\t\trunOnOpenEdge: true,\n\t\ttersyParams: tersyParamsMvp,\n\t\thelmName: 'fhproxy',\n        agent: 'single-node-container-k8s-dpdk',\n        prepareCommand: 'ci/prepare mvp_logs',\n        command: 'ci/docker-test mvp_logs',\n        logsCommand: 'ci/helm-log.sh mvp_logs',\n        cleanCommand: 'ci/helm-delete.sh mvp_logs',\n        artifacts: 'mvp_logs/*',\n        addSkipParam: true,\n        timeout: '30'\n    ],\n    [\n        name: 'Test fhproxy container l3 call',\n        runOnOpenEdge: true,\n        tersyParams: tersyParams,\n        helmName: 'fhproxy',\n        agent: 'single-node-container-k8s-dpdk',\n        prepareCommand: 'ci/prepare l3_call_logs',\n        command: 'ci/docker-test l3_call_logs',\n        logsCommand: 'ci/helm-log.sh l3_call_logs',\n        cleanCommand: 'ci/helm-delete.sh l3_call_logs',\n        artifacts: 'l3_call_logs/*',\n        addSkipParam: true,\n        timeout: '30'\n    ]\n]\n```\n\n### jobParams\n\n```Jenkins\nList jobParams =  [\n    [\n        name: 'CASE_TAG',\n        description: '--test RCP_TRH_FHP_001*; -s FHP_first_temp_test_case; --include owner-XXX; --exclude not-ready;',\n        defaultValue: '',\n        type: 'string'\n    ],\n    [\n        name: 'UP_HELM_BRANCH',\n        description: \"This parameter is the branch of rcp-pod-up helm. 'master' are set by default.\",\n        defaultValue: 'master',\n        type: 'string'\n    ],\n    [\n        name: 'MN_HELM_BRANCH',\n        description: \"This parameter is the branch of rcp-pod-mn helm. 'master' are set by default.\",\n        defaultValue: 'master',\n        type: 'string'\n    ]\n]\n```\n\n### Notification Recipients\n\nSpecifies if email or office365 (yammer/teams) notification should be sent. By default no notifications are sent.\n\nFor each of the notification type define a Map which has [webhookUrl](#webhookurl) and/or [emailAddresses](#emailaddresses) defined.\n\nAn example where all the notifications are sent:\n\n> notifyMainBranchFailure: <b>Optional arguments</b>\n\nSet to receive notifications when pipeline failed on the branch defined by [mainBranch](). Do not define to not receive these notifications.\n\n设置为在mainBranch定义的分支上的pipeline 发生故障时接收通知。别定义为不接收这些通知。\n\n> notifyTagSuccess: <b>Optional arguments</b>\n\nSet to receive notifications of successful publishing of helm chart. Do not define to not receive these notifications.\n\n> notifyTagFailure: <b>Optional arguments</b>\n\nSet to receive information when pipeline failed when helm chart was tried to be published. Do not define to not receive these notifications.\n\n> webhookUrl: <b>Optional arguments</b>\n\nProvide the webhook from yammer or teams to get notifications sent there. In yammer you can add Jenkins app from the \"Add or Remove Apps\" link. In teams this is done via the \"Connectors\" link for the channel.\n\n> emailAddresses: <b>Optional arguments</b>\n\nComma separated list of email addresses to sent notifications to.\n\n```Jenkins\nMap defaultNotificationRecipients = [\n    webhookUrl: 'https://outlook.office.com/webhook/1aace586-e82a-49e8-8031-1d5686283369@5d471751-9675-428d-917b-70f44f9630b0/JenkinsCI/a4f01ac738d74f35a2f9d8c5407fb860/64e29d73-1461-434c-9aa1-3c353689ffd6',\n    emailAddresses: 'I_NSB_MN_CRAN_RD_CF_RCPTRS_SQUAD_TOUCHDOWN@internal.nsn.com'\n]\n```\n\n```Jenkins\nMap notifications = [\n    notifyMainBranchFailure: defaultNotificationRecipients,\n    notifyMainBranchSuccess: defaultNotificationRecipients,\n    notifyTagSuccess: defaultNotificationRecipients,\n    notifyTagFailure: defaultNotificationRecipients\n]\n```\n\n### containerPipeline\n\ncalling the pipeline from container Jenkinsfile:\n\n> gitlabConnection:  <b>Mandatory arguments</b>\n\nTells Jenkins which gitlab connection to use when reporting. Valid values are:\n\n- 'IT gitlab' for gitlabe1.ext.net.nokia.com\n- 'Gitlabe2' for gitlabe2.ext.net.nokia.com\n\n> tagPublishRegexp: <b>Optional arguments</b>\n\nBy default all tags trigger image publishing if [publishTags](#publishtags) is set to `true`. With this argument it is possible to filter which tags are published. The format is regular expression. Some examples:\n\n默认情况下，如果publishTags设置为true，则所有标签都会触发图像发布。使用此参数，可以过滤发布哪些标签。格式为正则表达式。\n\n- `^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$` would match only semVer formatted tags e.g. 1.2.0  --将仅匹配semVer格式的标签，例如1.2.0\n- `^release-.*` would match only tags which start with release- prefix  --将仅匹配以release-前缀开头的标签\n- `^\\\\d+\\\\.\\\\d+\\\\.\\\\d+([-_]hb)?$` when publishing for Heart Beat build  --在发布Heart Beat版本时\n\n```Jenkins\ncontainerPipeline   containers: containers,\n                    jobParams: jobParams,\n                    gitlabConnection: 'Gitlabe2',\n                    builds: builds,\n                    tests: tests,\n                    tagPublishRegexp: '^\\\\d+\\\\.\\\\d+\\\\.\\\\d+.*',\n                    relNoteCategory: 'ContainerImages',\n                    configFile: 'config',\n                    notifications: notifications\n```\n\n### Set environment variables\n\nSome environment variables name and value are printed to ./env_vars file. Scripts like config.deployCommand, config.testCommand, config.cleanCommand can source env_vars file and use the listed env variables.\n\n一些环境变量的名称和值会打印到./env_vars文件中。诸如config.deployCommand，config.testCommand，config.cleanCommand之类的脚本可以获取env_vars文件并使用列出的env变量。\n\nExample env_vars:\n\n```verilog\n17:59:24  + cat env_vars\n17:59:24  HELM_NAME=\"fhproxy-10-change-the-rpm-name-of-testca\"\n17:59:24  NAMESPACE=\"cran2\"\n17:59:24  TARGET_FILE=\"OE19-TT-O5-AIO-1_cran2.yaml\"\n17:59:24  RUN_ON_OPEN_EDGE=\"true\"\n17:59:24  RUN_ON_HW=\"true\"\n17:59:24  PLATFORM=\"NCIR19\"\n17:59:24  WORKING_DIR=\"CONTAINER_PIPELINE_WORKDIR-fhproxy/fhproxy\"\n17:59:24  K8S_NODE_HOST_IP=\"192.168.81.26\"\n17:59:24  BUILD_ID=\"10\"\n17:59:24  BRANCH_NAME=\"Change_the_rpm_name_of_testcase\"\n17:59:24  BUILDING_TAG=\"null\"\n17:59:24  PUBLISHING_TAG=\"null\"\n17:59:24  DockerImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  DockerTestImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy-test:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  NwInitImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwinit:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  NwMgmtImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwmgmt:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  CASE_TAG=\"\"\n17:59:24  UP_HELM_BRANCH=\"master\"\n17:59:24  MN_HELM_BRANCH=\"master\"\n```\n\n**RUN_ON_OPEN_EDGE** env variable is deprecated. Scripts should be changed to use RUN_ON_HW instead of RUN_ON_OPEN_EDGE.\n\n不赞成使用RUN_ON_OPEN_EDGE环境变量。应将脚本更改为使用RUN_ON_HW而不是RUN_ON_OPEN_EDGE。\n\n**BUILD_ID** is the Jenkins job build number. This and **BRANCH_NAME** are also appended to the **HELM_NAME** variable so that it does not conflict with other pipelines running tests for the same helm chart. `The name is limited to 40 characters.` This allows container developers to add possible pre- and postfixes, but the name should not exceed the maximum allowed for helm release name (53 characters).\n\nBUILD_ID变量和BRANCH_NAME也附加到HELM_NAME变量中，以使其与运行针对同一helm chart的测试中的其他pipelines不冲突。\n\n### 3. 参考链接\n\nhttps://gitlabe1.ext.net.nokia.com/RCP/pipeline-utils/blob/pkg-mgmt-pipes/vars/helmChartPipeline.md#products\n\nhttps://www.w3cschool.cn/jenkins/jenkins-jg9528pb.html\n\nhttps://confluence.int.net.nokia.com/display/MPP/Jenkinsfile+Template\n\nhttps://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/","source":"_posts/cloud_md/Jenkinsfile introduce.md","raw":"---\ntitle: Jenkinsfile introduce\ndate: '2020/12/31 23:59'\ntags:\n - jenkins\ncategories:\n - 个人项目\nabbrlink: 12007\ncover: \n---\n# Jenkinsfile introduce\n\n## Jenkinsfile 基本语法\n\n### Defining a Pipeline\n\nJenkins Pipeline is a suite of plugins that supports implementing and integrating continuous delivery pipelines into Jenkins. \n\nA Pipeline can be created in one of the following ways:\n\n- [Through Blue Ocean](https://jenkins.io/doc/book/pipeline/getting-started/#through-blue-ocean) - after setting up a Pipeline project in Blue Ocean, the Blue Ocean UI helps you write your Pipeline’s `Jenkinsfile` and commit it to source control.\n- [Through the classic UI](https://jenkins.io/doc/book/pipeline/getting-started/#through-the-classic-ui) - you can enter a basic Pipeline directly in Jenkins through the classic UI.\n- [In SCM](https://jenkins.io/doc/book/pipeline/getting-started/#defining-a-pipeline-in-scm) - you can write a `Jenkinsfile` manually, which you can commit to your project’s source control repository.\n\n### Using Environmental Variables\n\nEnvironment variables can be set globally or per stage.\n\nSetting environment variables per stage means they will only apply to the stage in which they’re defined.\n\n```Jenkins\n// setting environment variables globally\npipeline {\n environment {\n BUILD_NUMBER=\"${Calendar.getInstance()format('yyyyMMddHHmmssSSS')}\"\n BUILD_ID = \"${env.BUILD_NUMBER}\"\n }\n}\n```\n\n### Agent\n\nIn declarative pipelines the **agent** directive is used for specifying which agent/slave the job/task is to be executed on. This directive only allows you to specify where the task can be executed (On which agent, slave, label or docker image)\n\n```\nagent { kubernetes { label 'my-defined-label' inheritFrom 'my-defined-build' containerTemplate { name 'build-name' image 'my-docker-image:latest' workingDir 'my/working/dir' } } }\n```\n\n### Parameters\n\nThe parameters directive provides a list of parameters which a user should provide when triggering the Pipeline. The values for these user-specified parameters are made available to Pipeline steps via the '`params'` object.\n\n```Jenkins\nString parameter:\nparameters {\n string(name: 'DEPLOY_ENV', defaultValue: 'staging', description: '')\n}\nBoolean parameter:\nparameters {\n booleanParam(name: 'DEBUG_BUILD', defaultValue: true, description: '')\n}\nChoice parameter:\nparameters {\n choice(name:'OPTIONS', description:'Select an option', choices:'Option1\\nOption2\\nOption3')\n}\n```\n\n### Gerrit Triggers\n\nThis plugin integrates Jenkins to Gerrit code review for triggering builds when a \"patch set\" is created.\n\n<u>**Trigger configuration in pipeline job:**</u>\n\nIn the \"Build Triggers\" section of your Job configuration page; tick \"Gerrit event\"\n\nSpecify what type of event(s) to trigger on:\n\n- **Draft Published:** Sent when a change moves from draft state to new. (only available in version 2.5 or higher of Gerrit).\n- **Patchset Created:** Sent when a new patchset arrives on a change. Before version 2.6.0, this was the only event you could trigger on.\n- **Change Merged:** Sent when a change is merged on the Gerrit server.\n- **Comment Added:** Sent when a comment is added to a change. Which category and value to trigger on can be configured. The available categories can be configured in the server settings for the plugin.\n- **Ref Updated:** Sent when a ref is updated on the Gerrit server, i.e. someone pushes past code review.\n\n{% asset_img image-20200729094356824.png %}\n\n<img src=\"Jenkinsfile%20introduce/image-20200729094356824.png\" alt=\"image-20200729094356824\" style=\"zoom: 67%;\" />\n\n<u>**Trigger configuration in Jenkinsfile:**</u>\n\nJenkinsfile will overwrite the configuration done in pipeline job. \n\n```\ntriggers {\n gerrit(\n   customUrl: '',\n   gerritProjects: [[\n     branches: [[\n      compareType: 'PLAIN',\n      pattern: 'master'\n     ]],\n    compareType: 'PLAIN',\n    disableStrictForbiddenFileVerification: false,\n    pattern: 'repo-name'\n   ]],\n   serverName: 'user-name',\n   triggerOnEvents: [\n     changeMerged(),\n     patchsetCreated(\n       excludeDrafts: true,\n       excludeNoCodeChange: false,\n       excludeTrivialRebase: false\n     ),\n     commentAdded(\n       verdictCategory: 'Code-Review',\n       commentAddedTriggerApprovalValue: '+2'\n     )\n   ]\n  )\n}\n```\n\n## Jenkinsfile simple\n\n### @Library\n\n```Jenkins\n@Library(['scm@<pipeline-utils branch or tag>']) _\n```\n\nExample:\n\n```Jenkins\n@Library(['scm@container-stable-2.x', 'commonLibs@0.0.3']) _\n```\n\n### extraOnboardingImages\n\nList containing the extra images that need to onboard to Open Edge server. \n\n列出包含需要附加到Open Edge服务器的其他图像的列表。\n\nExample:\n\n```Jenkins\nMap containers = [\n    DockerImage: [\n        name: 'fhproxy/docker-fhproxy',\n        buildName: 'fhproxy',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: true,\n        type: 'runtime'\n    ],\n    DockerTestImage: [\n        name: 'fhproxy/docker-fhproxy-test',\n        buildName: 'fhproxy',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: true,\n        type: 'runtime'\n    ],\n    NwInitImage: [\n        name: \"fhproxy/docker-nwinit\",\n        buildName: 'Onboarding',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: false\n    ],\n    NwMgmtImage: [\n        name: \"fhproxy/docker-nwmgmt\",\n        buildName: 'Onboarding',\n        testNames: ['Test fhproxy container mvp','Test fhproxy container l3 call'],\n        published: false\n    ]\n]\n```\n\n### tersyParams\n\n> platform: <b>Optional arguments</b>\n\nString containing platform type of NESC node.  包含NESC节点的平台类型的字符串\n\nPossible values:\n\n- any\n- TPI3-like\n- NCIR-like\n\nDefault value: NCIR-like\n\nWhen test is executed in real HW [tersyParams](#tersyparams) will define which kind of environment is selected\n\n在实际硬件中执行测试时，tersyParams将定义选择哪种环境\n\nMap containing information that is used for test environment reservation from Tersy. \n\n映射包含用于从Tersy保留测试环境的信息。\n\nDuration and pool or tenant attributes in tersyParams are mandatory if RUN_ON_HW is set to true. \n\n如果将**RUN_ON_HW**设置为true，则tersyParams中的**duration**和**pool**或**tenant**属性是必需的。\n\nOther attributes are optional.\n\nTersy parameters:\n\nFor details on supported parameters see documentation of [tersycli create](https://pypi.dynamic.nsn-net.net/rcp/prod/tersycli/latest/+doc/CLI.html#create) command.\n\n有关支持的参数的详细信息，请参见tersycli create命令的文档。\n\nOnly long format of the named arguments are supported, use for example 'duration' instead of 'd'. \n\nNote that '**reservation_name**' is not needed as it is automatically set to Jenkins job name. \n\nDefault value of **queue_timeout** parameter is 1 hour if priority is given. \n\nDefault value of **env_type** is CAAS. \n\nAdditionally a specific tersycli version can be requested with `tersycliVersion`, 2.3.5 is used by default.\n\n仅支持长格式的命名参数，例如使用“duration”代替“ d”。\n\n```Jenkins\nMap tersyParamsMvp = [    \n    pool: \"CAAS_test\",\n    priority: \"3\",\n    duration: \"1\",\n    queue_timeout: \"6\",\n    tag: \"NIC=Intel-XXV710\",\n    platform: \"NCIR19\"\n]\n\nMap tersyParams = [\n    pool: \"CAAS_Host_VLAN\",\n    priority: \"3\",\n    duration: \"1\",\n    queue_timeout: \"6\",\n    tag: \"NIC=Intel-XXV710\",\n    platform: \"NCIR19\"\n]\n```\n\n### builds\n\n```Jenkins\nList builds = [\n    [\n        name: 'fhproxy',\n        agent: 'docker_helmci',\n        command: 'ci/docker-build'\n    ],\n    [\n        name: 'Onboarding',\n        agent: 'docker_helmci',\n        command: 'ci/get-onboarding-images'\n    ]\n]\n```\n\n### agent\n\n> agent: <b>Optional arguments</b>\n\nJenkins agent where the test is executed. 执行测试的Jenkins代理。\n\nSome possible values are:\n\n- `single-node-container-k8s-dpdk`  for 8 core [cloud-development](https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/) environment with dpdk support\n- `single-node-pod-k8s-dpdk`  for 16 core [cloud-development](https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/) environment with dpdk support\n- `multi-node-pod-k8s-dpdk`  for 1+1 node, 13 core each, [container-infra-system](https://gitlabe2.ext.net.nokia.com/cloud-tools/container-infra-system) environment with dpdk support\n- TODO: IT kubernetes cluster agent\n\nDefault value for the parameter is `single-node-container-k8s-dpdk`\n\n> cleanCommand: <b>Optional arguments</b>\n\nOptional shell command to run before and after test to clean up resources. \n\n在测试之前和之后运行的可选shell命令，以清理资源。\n\n要注意的是，pipeline检测v2和v3的Helm命令，并将它们分别暴露为环境变量$ {HELM2}和$ {HELM3}。因此最好在shell脚本中使用这些变量，以避免在'helm'命令更改为指向helm3而不是旧的helm2时更改脚本。\n\n> helmName:  <b>Mandatory arguments</b>\n\nName of the helm chart to be tested and published. Helm chart will be cloned to a directory with this name regardless what the repository name is. All scripts are executed in this directory.\n\n要测试和发布的helm chart的名称, 无论存储库名称是什么，Helm chart都会被克隆到具有该名称的目录中。所有脚本都在此目录中执行。\n\nTo allow for more than one pipeline to be executed for same helm chart, pipeline appends automatically Jenkins build id and branch name to the helm name defined in the [env_vars file]().\n\n为了允许对同一helm chart执行多个管道，管道会自动将Jenkins构建ID和分支名称附加到env_vars文件中定义的helm名称。\n\n> deployCommand: <b>Optional arguments</b>\n\nOptional shell command to deploy the helm chart. Default value is `ci/deploy.sh`\n\n可选的shell命令，用于部署helm chart。默认值为ci / deploy.sh， 应该是这里的command\n\n> testCommand: <b>Optional arguments</b>\n\nOptional shell command to deploy the helm chart. Default value is `ci/test.sh`\n\n可选的shell命令，用于部署helm chart。默认值为ci / test.sh\n\n> logsCommand: <b>Optional arguments</b>\n\nOptional shell command to run at the end of the pipeline to collect logs. Default value is `gather-artifacts.sh` Will be executed always even if deploy or test fails. To ensure that all logs are collected make sure that the command handles error cases correctly.\n\n可选的shell命令在pipeline末端运行以收集日志。失败后的log收集，为确保收集所有日志，请确保该命令正确处理错误情况。\n\nIf using `bash` script you can use `+e` flag to ignore errors:\n\n如果使用bash脚本，则可以使用+ e标志忽略错误： `#!/bin/bash +e`\n\n```Jenkins\nList tests = [\n    [\n        name: 'Test fhproxy container mvp',\n\t\trunOnOpenEdge: true,\n\t\ttersyParams: tersyParamsMvp,\n\t\thelmName: 'fhproxy',\n        agent: 'single-node-container-k8s-dpdk',\n        prepareCommand: 'ci/prepare mvp_logs',\n        command: 'ci/docker-test mvp_logs',\n        logsCommand: 'ci/helm-log.sh mvp_logs',\n        cleanCommand: 'ci/helm-delete.sh mvp_logs',\n        artifacts: 'mvp_logs/*',\n        addSkipParam: true,\n        timeout: '30'\n    ],\n    [\n        name: 'Test fhproxy container l3 call',\n        runOnOpenEdge: true,\n        tersyParams: tersyParams,\n        helmName: 'fhproxy',\n        agent: 'single-node-container-k8s-dpdk',\n        prepareCommand: 'ci/prepare l3_call_logs',\n        command: 'ci/docker-test l3_call_logs',\n        logsCommand: 'ci/helm-log.sh l3_call_logs',\n        cleanCommand: 'ci/helm-delete.sh l3_call_logs',\n        artifacts: 'l3_call_logs/*',\n        addSkipParam: true,\n        timeout: '30'\n    ]\n]\n```\n\n### jobParams\n\n```Jenkins\nList jobParams =  [\n    [\n        name: 'CASE_TAG',\n        description: '--test RCP_TRH_FHP_001*; -s FHP_first_temp_test_case; --include owner-XXX; --exclude not-ready;',\n        defaultValue: '',\n        type: 'string'\n    ],\n    [\n        name: 'UP_HELM_BRANCH',\n        description: \"This parameter is the branch of rcp-pod-up helm. 'master' are set by default.\",\n        defaultValue: 'master',\n        type: 'string'\n    ],\n    [\n        name: 'MN_HELM_BRANCH',\n        description: \"This parameter is the branch of rcp-pod-mn helm. 'master' are set by default.\",\n        defaultValue: 'master',\n        type: 'string'\n    ]\n]\n```\n\n### Notification Recipients\n\nSpecifies if email or office365 (yammer/teams) notification should be sent. By default no notifications are sent.\n\nFor each of the notification type define a Map which has [webhookUrl](#webhookurl) and/or [emailAddresses](#emailaddresses) defined.\n\nAn example where all the notifications are sent:\n\n> notifyMainBranchFailure: <b>Optional arguments</b>\n\nSet to receive notifications when pipeline failed on the branch defined by [mainBranch](). Do not define to not receive these notifications.\n\n设置为在mainBranch定义的分支上的pipeline 发生故障时接收通知。别定义为不接收这些通知。\n\n> notifyTagSuccess: <b>Optional arguments</b>\n\nSet to receive notifications of successful publishing of helm chart. Do not define to not receive these notifications.\n\n> notifyTagFailure: <b>Optional arguments</b>\n\nSet to receive information when pipeline failed when helm chart was tried to be published. Do not define to not receive these notifications.\n\n> webhookUrl: <b>Optional arguments</b>\n\nProvide the webhook from yammer or teams to get notifications sent there. In yammer you can add Jenkins app from the \"Add or Remove Apps\" link. In teams this is done via the \"Connectors\" link for the channel.\n\n> emailAddresses: <b>Optional arguments</b>\n\nComma separated list of email addresses to sent notifications to.\n\n```Jenkins\nMap defaultNotificationRecipients = [\n    webhookUrl: 'https://outlook.office.com/webhook/1aace586-e82a-49e8-8031-1d5686283369@5d471751-9675-428d-917b-70f44f9630b0/JenkinsCI/a4f01ac738d74f35a2f9d8c5407fb860/64e29d73-1461-434c-9aa1-3c353689ffd6',\n    emailAddresses: 'I_NSB_MN_CRAN_RD_CF_RCPTRS_SQUAD_TOUCHDOWN@internal.nsn.com'\n]\n```\n\n```Jenkins\nMap notifications = [\n    notifyMainBranchFailure: defaultNotificationRecipients,\n    notifyMainBranchSuccess: defaultNotificationRecipients,\n    notifyTagSuccess: defaultNotificationRecipients,\n    notifyTagFailure: defaultNotificationRecipients\n]\n```\n\n### containerPipeline\n\ncalling the pipeline from container Jenkinsfile:\n\n> gitlabConnection:  <b>Mandatory arguments</b>\n\nTells Jenkins which gitlab connection to use when reporting. Valid values are:\n\n- 'IT gitlab' for gitlabe1.ext.net.nokia.com\n- 'Gitlabe2' for gitlabe2.ext.net.nokia.com\n\n> tagPublishRegexp: <b>Optional arguments</b>\n\nBy default all tags trigger image publishing if [publishTags](#publishtags) is set to `true`. With this argument it is possible to filter which tags are published. The format is regular expression. Some examples:\n\n默认情况下，如果publishTags设置为true，则所有标签都会触发图像发布。使用此参数，可以过滤发布哪些标签。格式为正则表达式。\n\n- `^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$` would match only semVer formatted tags e.g. 1.2.0  --将仅匹配semVer格式的标签，例如1.2.0\n- `^release-.*` would match only tags which start with release- prefix  --将仅匹配以release-前缀开头的标签\n- `^\\\\d+\\\\.\\\\d+\\\\.\\\\d+([-_]hb)?$` when publishing for Heart Beat build  --在发布Heart Beat版本时\n\n```Jenkins\ncontainerPipeline   containers: containers,\n                    jobParams: jobParams,\n                    gitlabConnection: 'Gitlabe2',\n                    builds: builds,\n                    tests: tests,\n                    tagPublishRegexp: '^\\\\d+\\\\.\\\\d+\\\\.\\\\d+.*',\n                    relNoteCategory: 'ContainerImages',\n                    configFile: 'config',\n                    notifications: notifications\n```\n\n### Set environment variables\n\nSome environment variables name and value are printed to ./env_vars file. Scripts like config.deployCommand, config.testCommand, config.cleanCommand can source env_vars file and use the listed env variables.\n\n一些环境变量的名称和值会打印到./env_vars文件中。诸如config.deployCommand，config.testCommand，config.cleanCommand之类的脚本可以获取env_vars文件并使用列出的env变量。\n\nExample env_vars:\n\n```verilog\n17:59:24  + cat env_vars\n17:59:24  HELM_NAME=\"fhproxy-10-change-the-rpm-name-of-testca\"\n17:59:24  NAMESPACE=\"cran2\"\n17:59:24  TARGET_FILE=\"OE19-TT-O5-AIO-1_cran2.yaml\"\n17:59:24  RUN_ON_OPEN_EDGE=\"true\"\n17:59:24  RUN_ON_HW=\"true\"\n17:59:24  PLATFORM=\"NCIR19\"\n17:59:24  WORKING_DIR=\"CONTAINER_PIPELINE_WORKDIR-fhproxy/fhproxy\"\n17:59:24  K8S_NODE_HOST_IP=\"192.168.81.26\"\n17:59:24  BUILD_ID=\"10\"\n17:59:24  BRANCH_NAME=\"Change_the_rpm_name_of_testcase\"\n17:59:24  BUILDING_TAG=\"null\"\n17:59:24  PUBLISHING_TAG=\"null\"\n17:59:24  DockerImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  DockerTestImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy-test:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  NwInitImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwinit:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  NwMgmtImage=\"registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwmgmt:0.0.0-78-g80c0c0f_21595482723715_10\"\n17:59:24  CASE_TAG=\"\"\n17:59:24  UP_HELM_BRANCH=\"master\"\n17:59:24  MN_HELM_BRANCH=\"master\"\n```\n\n**RUN_ON_OPEN_EDGE** env variable is deprecated. Scripts should be changed to use RUN_ON_HW instead of RUN_ON_OPEN_EDGE.\n\n不赞成使用RUN_ON_OPEN_EDGE环境变量。应将脚本更改为使用RUN_ON_HW而不是RUN_ON_OPEN_EDGE。\n\n**BUILD_ID** is the Jenkins job build number. This and **BRANCH_NAME** are also appended to the **HELM_NAME** variable so that it does not conflict with other pipelines running tests for the same helm chart. `The name is limited to 40 characters.` This allows container developers to add possible pre- and postfixes, but the name should not exceed the maximum allowed for helm release name (53 characters).\n\nBUILD_ID变量和BRANCH_NAME也附加到HELM_NAME变量中，以使其与运行针对同一helm chart的测试中的其他pipelines不冲突。\n\n### 3. 参考链接\n\nhttps://gitlabe1.ext.net.nokia.com/RCP/pipeline-utils/blob/pkg-mgmt-pipes/vars/helmChartPipeline.md#products\n\nhttps://www.w3cschool.cn/jenkins/jenkins-jg9528pb.html\n\nhttps://confluence.int.net.nokia.com/display/MPP/Jenkinsfile+Template\n\nhttps://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/","slug":"cloud_md/Jenkinsfile introduce","published":1,"updated":"2021-04-09T13:01:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5p0007w9q9g0zgh8cn","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Jenkinsfile-introduce\"><a href=\"#Jenkinsfile-introduce\" class=\"headerlink\" title=\"Jenkinsfile introduce\"></a>Jenkinsfile introduce</h1><h2 id=\"Jenkinsfile-基本语法\"><a href=\"#Jenkinsfile-基本语法\" class=\"headerlink\" title=\"Jenkinsfile 基本语法\"></a>Jenkinsfile 基本语法</h2><h3 id=\"Defining-a-Pipeline\"><a href=\"#Defining-a-Pipeline\" class=\"headerlink\" title=\"Defining a Pipeline\"></a>Defining a Pipeline</h3><p>Jenkins Pipeline is a suite of plugins that supports implementing and integrating continuous delivery pipelines into Jenkins. </p>\n<p>A Pipeline can be created in one of the following ways:</p>\n<ul>\n<li><a href=\"https://jenkins.io/doc/book/pipeline/getting-started/#through-blue-ocean\">Through Blue Ocean</a> - after setting up a Pipeline project in Blue Ocean, the Blue Ocean UI helps you write your Pipeline’s <code>Jenkinsfile</code> and commit it to source control.</li>\n<li><a href=\"https://jenkins.io/doc/book/pipeline/getting-started/#through-the-classic-ui\">Through the classic UI</a> - you can enter a basic Pipeline directly in Jenkins through the classic UI.</li>\n<li><a href=\"https://jenkins.io/doc/book/pipeline/getting-started/#defining-a-pipeline-in-scm\">In SCM</a> - you can write a <code>Jenkinsfile</code> manually, which you can commit to your project’s source control repository.</li>\n</ul>\n<h3 id=\"Using-Environmental-Variables\"><a href=\"#Using-Environmental-Variables\" class=\"headerlink\" title=\"Using Environmental Variables\"></a>Using Environmental Variables</h3><p>Environment variables can be set globally or per stage.</p>\n<p>Setting environment variables per stage means they will only apply to the stage in which they’re defined.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; setting environment variables globally</span><br><span class=\"line\">pipeline &#123;</span><br><span class=\"line\"> environment &#123;</span><br><span class=\"line\"> BUILD_NUMBER&#x3D;&quot;$&#123;Calendar.getInstance()format(&#39;yyyyMMddHHmmssSSS&#39;)&#125;&quot;</span><br><span class=\"line\"> BUILD_ID &#x3D; &quot;$&#123;env.BUILD_NUMBER&#125;&quot;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Agent\"><a href=\"#Agent\" class=\"headerlink\" title=\"Agent\"></a>Agent</h3><p>In declarative pipelines the <strong>agent</strong> directive is used for specifying which agent/slave the job/task is to be executed on. This directive only allows you to specify where the task can be executed (On which agent, slave, label or docker image)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agent &#123; kubernetes &#123; label &#39;my-defined-label&#39; inheritFrom &#39;my-defined-build&#39; containerTemplate &#123; name &#39;build-name&#39; image &#39;my-docker-image:latest&#39; workingDir &#39;my&#x2F;working&#x2F;dir&#39; &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h3><p>The parameters directive provides a list of parameters which a user should provide when triggering the Pipeline. The values for these user-specified parameters are made available to Pipeline steps via the ‘<code>params&#39;</code> object.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String parameter:</span><br><span class=\"line\">parameters &#123;</span><br><span class=\"line\"> string(name: &#39;DEPLOY_ENV&#39;, defaultValue: &#39;staging&#39;, description: &#39;&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Boolean parameter:</span><br><span class=\"line\">parameters &#123;</span><br><span class=\"line\"> booleanParam(name: &#39;DEBUG_BUILD&#39;, defaultValue: true, description: &#39;&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Choice parameter:</span><br><span class=\"line\">parameters &#123;</span><br><span class=\"line\"> choice(name:&#39;OPTIONS&#39;, description:&#39;Select an option&#39;, choices:&#39;Option1\\nOption2\\nOption3&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Gerrit-Triggers\"><a href=\"#Gerrit-Triggers\" class=\"headerlink\" title=\"Gerrit Triggers\"></a>Gerrit Triggers</h3><p>This plugin integrates Jenkins to Gerrit code review for triggering builds when a “patch set” is created.</p>\n<p><u><strong>Trigger configuration in pipeline job:</strong></u></p>\n<p>In the “Build Triggers” section of your Job configuration page; tick “Gerrit event”</p>\n<p>Specify what type of event(s) to trigger on:</p>\n<ul>\n<li><strong>Draft Published:</strong> Sent when a change moves from draft state to new. (only available in version 2.5 or higher of Gerrit).</li>\n<li><strong>Patchset Created:</strong> Sent when a new patchset arrives on a change. Before version 2.6.0, this was the only event you could trigger on.</li>\n<li><strong>Change Merged:</strong> Sent when a change is merged on the Gerrit server.</li>\n<li><strong>Comment Added:</strong> Sent when a comment is added to a change. Which category and value to trigger on can be configured. The available categories can be configured in the server settings for the plugin.</li>\n<li><strong>Ref Updated:</strong> Sent when a ref is updated on the Gerrit server, i.e. someone pushes past code review.</li>\n</ul>\n<img src=\"/Blog/posts/12007/image-20200729094356824.png\" class=\"\">\n\n<img src=\"Jenkinsfile%20introduce/image-20200729094356824.png\" alt=\"image-20200729094356824\" style=\"zoom: 67%;\" />\n\n<p><u><strong>Trigger configuration in Jenkinsfile:</strong></u></p>\n<p>Jenkinsfile will overwrite the configuration done in pipeline job. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triggers &#123;</span><br><span class=\"line\"> gerrit(</span><br><span class=\"line\">   customUrl: &#39;&#39;,</span><br><span class=\"line\">   gerritProjects: [[</span><br><span class=\"line\">     branches: [[</span><br><span class=\"line\">      compareType: &#39;PLAIN&#39;,</span><br><span class=\"line\">      pattern: &#39;master&#39;</span><br><span class=\"line\">     ]],</span><br><span class=\"line\">    compareType: &#39;PLAIN&#39;,</span><br><span class=\"line\">    disableStrictForbiddenFileVerification: false,</span><br><span class=\"line\">    pattern: &#39;repo-name&#39;</span><br><span class=\"line\">   ]],</span><br><span class=\"line\">   serverName: &#39;user-name&#39;,</span><br><span class=\"line\">   triggerOnEvents: [</span><br><span class=\"line\">     changeMerged(),</span><br><span class=\"line\">     patchsetCreated(</span><br><span class=\"line\">       excludeDrafts: true,</span><br><span class=\"line\">       excludeNoCodeChange: false,</span><br><span class=\"line\">       excludeTrivialRebase: false</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     commentAdded(</span><br><span class=\"line\">       verdictCategory: &#39;Code-Review&#39;,</span><br><span class=\"line\">       commentAddedTriggerApprovalValue: &#39;+2&#39;</span><br><span class=\"line\">     )</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Jenkinsfile-simple\"><a href=\"#Jenkinsfile-simple\" class=\"headerlink\" title=\"Jenkinsfile simple\"></a>Jenkinsfile simple</h2><h3 id=\"Library\"><a href=\"#Library\" class=\"headerlink\" title=\"@Library\"></a>@Library</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Library([&#39;scm@&lt;pipeline-utils branch or tag&gt;&#39;]) _</span><br></pre></td></tr></table></figure>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Library([&#39;scm@container-stable-2.x&#39;, &#39;commonLibs@0.0.3&#39;]) _</span><br></pre></td></tr></table></figure>\n<h3 id=\"extraOnboardingImages\"><a href=\"#extraOnboardingImages\" class=\"headerlink\" title=\"extraOnboardingImages\"></a>extraOnboardingImages</h3><p>List containing the extra images that need to onboard to Open Edge server. </p>\n<p>列出包含需要附加到Open Edge服务器的其他图像的列表。</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map containers &#x3D; [</span><br><span class=\"line\">    DockerImage: [</span><br><span class=\"line\">        name: &#39;fhproxy&#x2F;docker-fhproxy&#39;,</span><br><span class=\"line\">        buildName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: true,</span><br><span class=\"line\">        type: &#39;runtime&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    DockerTestImage: [</span><br><span class=\"line\">        name: &#39;fhproxy&#x2F;docker-fhproxy-test&#39;,</span><br><span class=\"line\">        buildName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: true,</span><br><span class=\"line\">        type: &#39;runtime&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    NwInitImage: [</span><br><span class=\"line\">        name: &quot;fhproxy&#x2F;docker-nwinit&quot;,</span><br><span class=\"line\">        buildName: &#39;Onboarding&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: false</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    NwMgmtImage: [</span><br><span class=\"line\">        name: &quot;fhproxy&#x2F;docker-nwmgmt&quot;,</span><br><span class=\"line\">        buildName: &#39;Onboarding&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: false</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"tersyParams\"><a href=\"#tersyParams\" class=\"headerlink\" title=\"tersyParams\"></a>tersyParams</h3><blockquote>\n<p>platform: <b>Optional arguments</b></p>\n</blockquote>\n<p>String containing platform type of NESC node.  包含NESC节点的平台类型的字符串</p>\n<p>Possible values:</p>\n<ul>\n<li>any</li>\n<li>TPI3-like</li>\n<li>NCIR-like</li>\n</ul>\n<p>Default value: NCIR-like</p>\n<p>When test is executed in real HW <a href=\"#tersyparams\">tersyParams</a> will define which kind of environment is selected</p>\n<p>在实际硬件中执行测试时，tersyParams将定义选择哪种环境</p>\n<p>Map containing information that is used for test environment reservation from Tersy. </p>\n<p>映射包含用于从Tersy保留测试环境的信息。</p>\n<p>Duration and pool or tenant attributes in tersyParams are mandatory if RUN_ON_HW is set to true. </p>\n<p>如果将<strong>RUN_ON_HW</strong>设置为true，则tersyParams中的<strong>duration</strong>和<strong>pool</strong>或<strong>tenant</strong>属性是必需的。</p>\n<p>Other attributes are optional.</p>\n<p>Tersy parameters:</p>\n<p>For details on supported parameters see documentation of <a href=\"https://pypi.dynamic.nsn-net.net/rcp/prod/tersycli/latest/+doc/CLI.html#create\">tersycli create</a> command.</p>\n<p>有关支持的参数的详细信息，请参见tersycli create命令的文档。</p>\n<p>Only long format of the named arguments are supported, use for example ‘duration’ instead of ‘d’. </p>\n<p>Note that ‘<strong>reservation_name</strong>‘ is not needed as it is automatically set to Jenkins job name. </p>\n<p>Default value of <strong>queue_timeout</strong> parameter is 1 hour if priority is given. </p>\n<p>Default value of <strong>env_type</strong> is CAAS. </p>\n<p>Additionally a specific tersycli version can be requested with <code>tersycliVersion</code>, 2.3.5 is used by default.</p>\n<p>仅支持长格式的命名参数，例如使用“duration”代替“ d”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map tersyParamsMvp &#x3D; [    </span><br><span class=\"line\">    pool: &quot;CAAS_test&quot;,</span><br><span class=\"line\">    priority: &quot;3&quot;,</span><br><span class=\"line\">    duration: &quot;1&quot;,</span><br><span class=\"line\">    queue_timeout: &quot;6&quot;,</span><br><span class=\"line\">    tag: &quot;NIC&#x3D;Intel-XXV710&quot;,</span><br><span class=\"line\">    platform: &quot;NCIR19&quot;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Map tersyParams &#x3D; [</span><br><span class=\"line\">    pool: &quot;CAAS_Host_VLAN&quot;,</span><br><span class=\"line\">    priority: &quot;3&quot;,</span><br><span class=\"line\">    duration: &quot;1&quot;,</span><br><span class=\"line\">    queue_timeout: &quot;6&quot;,</span><br><span class=\"line\">    tag: &quot;NIC&#x3D;Intel-XXV710&quot;,</span><br><span class=\"line\">    platform: &quot;NCIR19&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"builds\"><a href=\"#builds\" class=\"headerlink\" title=\"builds\"></a>builds</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List builds &#x3D; [</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;fhproxy&#39;,</span><br><span class=\"line\">        agent: &#39;docker_helmci&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;docker-build&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;Onboarding&#39;,</span><br><span class=\"line\">        agent: &#39;docker_helmci&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;get-onboarding-images&#39;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"agent\"><a href=\"#agent\" class=\"headerlink\" title=\"agent\"></a>agent</h3><blockquote>\n<p>agent: <b>Optional arguments</b></p>\n</blockquote>\n<p>Jenkins agent where the test is executed. 执行测试的Jenkins代理。</p>\n<p>Some possible values are:</p>\n<ul>\n<li><code>single-node-container-k8s-dpdk</code>  for 8 core <a href=\"https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/\">cloud-development</a> environment with dpdk support</li>\n<li><code>single-node-pod-k8s-dpdk</code>  for 16 core <a href=\"https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/\">cloud-development</a> environment with dpdk support</li>\n<li><code>multi-node-pod-k8s-dpdk</code>  for 1+1 node, 13 core each, <a href=\"https://gitlabe2.ext.net.nokia.com/cloud-tools/container-infra-system\">container-infra-system</a> environment with dpdk support</li>\n<li>TODO: IT kubernetes cluster agent</li>\n</ul>\n<p>Default value for the parameter is <code>single-node-container-k8s-dpdk</code></p>\n<blockquote>\n<p>cleanCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to run before and after test to clean up resources. </p>\n<p>在测试之前和之后运行的可选shell命令，以清理资源。</p>\n<p>要注意的是，pipeline检测v2和v3的Helm命令，并将它们分别暴露为环境变量$ {HELM2}和$ {HELM3}。因此最好在shell脚本中使用这些变量，以避免在’helm’命令更改为指向helm3而不是旧的helm2时更改脚本。</p>\n<blockquote>\n<p>helmName:  <b>Mandatory arguments</b></p>\n</blockquote>\n<p>Name of the helm chart to be tested and published. Helm chart will be cloned to a directory with this name regardless what the repository name is. All scripts are executed in this directory.</p>\n<p>要测试和发布的helm chart的名称, 无论存储库名称是什么，Helm chart都会被克隆到具有该名称的目录中。所有脚本都在此目录中执行。</p>\n<p>To allow for more than one pipeline to be executed for same helm chart, pipeline appends automatically Jenkins build id and branch name to the helm name defined in the <a href=\"\">env_vars file</a>.</p>\n<p>为了允许对同一helm chart执行多个管道，管道会自动将Jenkins构建ID和分支名称附加到env_vars文件中定义的helm名称。</p>\n<blockquote>\n<p>deployCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to deploy the helm chart. Default value is <code>ci/deploy.sh</code></p>\n<p>可选的shell命令，用于部署helm chart。默认值为ci / deploy.sh， 应该是这里的command</p>\n<blockquote>\n<p>testCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to deploy the helm chart. Default value is <code>ci/test.sh</code></p>\n<p>可选的shell命令，用于部署helm chart。默认值为ci / test.sh</p>\n<blockquote>\n<p>logsCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to run at the end of the pipeline to collect logs. Default value is <code>gather-artifacts.sh</code> Will be executed always even if deploy or test fails. To ensure that all logs are collected make sure that the command handles error cases correctly.</p>\n<p>可选的shell命令在pipeline末端运行以收集日志。失败后的log收集，为确保收集所有日志，请确保该命令正确处理错误情况。</p>\n<p>If using <code>bash</code> script you can use <code>+e</code> flag to ignore errors:</p>\n<p>如果使用bash脚本，则可以使用+ e标志忽略错误： <code>#!/bin/bash +e</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List tests &#x3D; [</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;Test fhproxy container mvp&#39;,</span><br><span class=\"line\">\t\trunOnOpenEdge: true,</span><br><span class=\"line\">\t\ttersyParams: tersyParamsMvp,</span><br><span class=\"line\">\t\thelmName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        agent: &#39;single-node-container-k8s-dpdk&#39;,</span><br><span class=\"line\">        prepareCommand: &#39;ci&#x2F;prepare mvp_logs&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;docker-test mvp_logs&#39;,</span><br><span class=\"line\">        logsCommand: &#39;ci&#x2F;helm-log.sh mvp_logs&#39;,</span><br><span class=\"line\">        cleanCommand: &#39;ci&#x2F;helm-delete.sh mvp_logs&#39;,</span><br><span class=\"line\">        artifacts: &#39;mvp_logs&#x2F;*&#39;,</span><br><span class=\"line\">        addSkipParam: true,</span><br><span class=\"line\">        timeout: &#39;30&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;Test fhproxy container l3 call&#39;,</span><br><span class=\"line\">        runOnOpenEdge: true,</span><br><span class=\"line\">        tersyParams: tersyParams,</span><br><span class=\"line\">        helmName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        agent: &#39;single-node-container-k8s-dpdk&#39;,</span><br><span class=\"line\">        prepareCommand: &#39;ci&#x2F;prepare l3_call_logs&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;docker-test l3_call_logs&#39;,</span><br><span class=\"line\">        logsCommand: &#39;ci&#x2F;helm-log.sh l3_call_logs&#39;,</span><br><span class=\"line\">        cleanCommand: &#39;ci&#x2F;helm-delete.sh l3_call_logs&#39;,</span><br><span class=\"line\">        artifacts: &#39;l3_call_logs&#x2F;*&#39;,</span><br><span class=\"line\">        addSkipParam: true,</span><br><span class=\"line\">        timeout: &#39;30&#39;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"jobParams\"><a href=\"#jobParams\" class=\"headerlink\" title=\"jobParams\"></a>jobParams</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List jobParams &#x3D;  [</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;CASE_TAG&#39;,</span><br><span class=\"line\">        description: &#39;--test RCP_TRH_FHP_001*; -s FHP_first_temp_test_case; --include owner-XXX; --exclude not-ready;&#39;,</span><br><span class=\"line\">        defaultValue: &#39;&#39;,</span><br><span class=\"line\">        type: &#39;string&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;UP_HELM_BRANCH&#39;,</span><br><span class=\"line\">        description: &quot;This parameter is the branch of rcp-pod-up helm. &#39;master&#39; are set by default.&quot;,</span><br><span class=\"line\">        defaultValue: &#39;master&#39;,</span><br><span class=\"line\">        type: &#39;string&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;MN_HELM_BRANCH&#39;,</span><br><span class=\"line\">        description: &quot;This parameter is the branch of rcp-pod-mn helm. &#39;master&#39; are set by default.&quot;,</span><br><span class=\"line\">        defaultValue: &#39;master&#39;,</span><br><span class=\"line\">        type: &#39;string&#39;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"Notification-Recipients\"><a href=\"#Notification-Recipients\" class=\"headerlink\" title=\"Notification Recipients\"></a>Notification Recipients</h3><p>Specifies if email or office365 (yammer/teams) notification should be sent. By default no notifications are sent.</p>\n<p>For each of the notification type define a Map which has <a href=\"#webhookurl\">webhookUrl</a> and/or <a href=\"#emailaddresses\">emailAddresses</a> defined.</p>\n<p>An example where all the notifications are sent:</p>\n<blockquote>\n<p>notifyMainBranchFailure: <b>Optional arguments</b></p>\n</blockquote>\n<p>Set to receive notifications when pipeline failed on the branch defined by <a href=\"\">mainBranch</a>. Do not define to not receive these notifications.</p>\n<p>设置为在mainBranch定义的分支上的pipeline 发生故障时接收通知。别定义为不接收这些通知。</p>\n<blockquote>\n<p>notifyTagSuccess: <b>Optional arguments</b></p>\n</blockquote>\n<p>Set to receive notifications of successful publishing of helm chart. Do not define to not receive these notifications.</p>\n<blockquote>\n<p>notifyTagFailure: <b>Optional arguments</b></p>\n</blockquote>\n<p>Set to receive information when pipeline failed when helm chart was tried to be published. Do not define to not receive these notifications.</p>\n<blockquote>\n<p>webhookUrl: <b>Optional arguments</b></p>\n</blockquote>\n<p>Provide the webhook from yammer or teams to get notifications sent there. In yammer you can add Jenkins app from the “Add or Remove Apps” link. In teams this is done via the “Connectors” link for the channel.</p>\n<blockquote>\n<p>emailAddresses: <b>Optional arguments</b></p>\n</blockquote>\n<p>Comma separated list of email addresses to sent notifications to.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map defaultNotificationRecipients &#x3D; [</span><br><span class=\"line\">    webhookUrl: &#39;https:&#x2F;&#x2F;outlook.office.com&#x2F;webhook&#x2F;1aace586-e82a-49e8-8031-1d5686283369@5d471751-9675-428d-917b-70f44f9630b0&#x2F;JenkinsCI&#x2F;a4f01ac738d74f35a2f9d8c5407fb860&#x2F;64e29d73-1461-434c-9aa1-3c353689ffd6&#39;,</span><br><span class=\"line\">    emailAddresses: &#39;I_NSB_MN_CRAN_RD_CF_RCPTRS_SQUAD_TOUCHDOWN@internal.nsn.com&#39;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map notifications &#x3D; [</span><br><span class=\"line\">    notifyMainBranchFailure: defaultNotificationRecipients,</span><br><span class=\"line\">    notifyMainBranchSuccess: defaultNotificationRecipients,</span><br><span class=\"line\">    notifyTagSuccess: defaultNotificationRecipients,</span><br><span class=\"line\">    notifyTagFailure: defaultNotificationRecipients</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"containerPipeline\"><a href=\"#containerPipeline\" class=\"headerlink\" title=\"containerPipeline\"></a>containerPipeline</h3><p>calling the pipeline from container Jenkinsfile:</p>\n<blockquote>\n<p>gitlabConnection:  <b>Mandatory arguments</b></p>\n</blockquote>\n<p>Tells Jenkins which gitlab connection to use when reporting. Valid values are:</p>\n<ul>\n<li>‘IT gitlab’ for gitlabe1.ext.net.nokia.com</li>\n<li>‘Gitlabe2’ for gitlabe2.ext.net.nokia.com</li>\n</ul>\n<blockquote>\n<p>tagPublishRegexp: <b>Optional arguments</b></p>\n</blockquote>\n<p>By default all tags trigger image publishing if <a href=\"#publishtags\">publishTags</a> is set to <code>true</code>. With this argument it is possible to filter which tags are published. The format is regular expression. Some examples:</p>\n<p>默认情况下，如果publishTags设置为true，则所有标签都会触发图像发布。使用此参数，可以过滤发布哪些标签。格式为正则表达式。</p>\n<ul>\n<li><code>^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$</code> would match only semVer formatted tags e.g. 1.2.0  –将仅匹配semVer格式的标签，例如1.2.0</li>\n<li><code>^release-.*</code> would match only tags which start with release- prefix  –将仅匹配以release-前缀开头的标签</li>\n<li><code>^\\\\d+\\\\.\\\\d+\\\\.\\\\d+([-_]hb)?$</code> when publishing for Heart Beat build  –在发布Heart Beat版本时</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">containerPipeline   containers: containers,</span><br><span class=\"line\">                    jobParams: jobParams,</span><br><span class=\"line\">                    gitlabConnection: &#39;Gitlabe2&#39;,</span><br><span class=\"line\">                    builds: builds,</span><br><span class=\"line\">                    tests: tests,</span><br><span class=\"line\">                    tagPublishRegexp: &#39;^\\\\d+\\\\.\\\\d+\\\\.\\\\d+.*&#39;,</span><br><span class=\"line\">                    relNoteCategory: &#39;ContainerImages&#39;,</span><br><span class=\"line\">                    configFile: &#39;config&#39;,</span><br><span class=\"line\">                    notifications: notifications</span><br></pre></td></tr></table></figure>\n<h3 id=\"Set-environment-variables\"><a href=\"#Set-environment-variables\" class=\"headerlink\" title=\"Set environment variables\"></a>Set environment variables</h3><p>Some environment variables name and value are printed to ./env_vars file. Scripts like config.deployCommand, config.testCommand, config.cleanCommand can source env_vars file and use the listed env variables.</p>\n<p>一些环境变量的名称和值会打印到./env_vars文件中。诸如config.deployCommand，config.testCommand，config.cleanCommand之类的脚本可以获取env_vars文件并使用列出的env变量。</p>\n<p>Example env_vars:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  + cat env_vars</span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  HELM_NAME=<span class=\"string\">&quot;fhproxy-10-change-the-rpm-name-of-testca&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  NAMESPACE=<span class=\"string\">&quot;cran2&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  TARGET_FILE=<span class=\"string\">&quot;OE19-TT-O5-AIO-1_cran2.yaml&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  RUN_ON_OPEN_EDGE=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  RUN_ON_HW=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  PLATFORM=<span class=\"string\">&quot;NCIR19&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  WORKING_DIR=<span class=\"string\">&quot;CONTAINER_PIPELINE_WORKDIR-fhproxy/fhproxy&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  K8S_NODE_HOST_IP=<span class=\"string\">&quot;192.168.81.26&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  BUILD_ID=<span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  BRANCH_NAME=<span class=\"string\">&quot;Change_the_rpm_name_of_testcase&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  BUILDING_TAG=<span class=\"string\">&quot;null&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  PUBLISHING_TAG=<span class=\"string\">&quot;null&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  DockerImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  DockerTestImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy-test:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  NwInitImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwinit:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  NwMgmtImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwmgmt:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  CASE_TAG=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  UP_HELM_BRANCH=<span class=\"string\">&quot;master&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  MN_HELM_BRANCH=<span class=\"string\">&quot;master&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>RUN_ON_OPEN_EDGE</strong> env variable is deprecated. Scripts should be changed to use RUN_ON_HW instead of RUN_ON_OPEN_EDGE.</p>\n<p>不赞成使用RUN_ON_OPEN_EDGE环境变量。应将脚本更改为使用RUN_ON_HW而不是RUN_ON_OPEN_EDGE。</p>\n<p><strong>BUILD_ID</strong> is the Jenkins job build number. This and <strong>BRANCH_NAME</strong> are also appended to the <strong>HELM_NAME</strong> variable so that it does not conflict with other pipelines running tests for the same helm chart. <code>The name is limited to 40 characters.</code> This allows container developers to add possible pre- and postfixes, but the name should not exceed the maximum allowed for helm release name (53 characters).</p>\n<p>BUILD_ID变量和BRANCH_NAME也附加到HELM_NAME变量中，以使其与运行针对同一helm chart的测试中的其他pipelines不冲突。</p>\n<h3 id=\"3-参考链接\"><a href=\"#3-参考链接\" class=\"headerlink\" title=\"3. 参考链接\"></a>3. 参考链接</h3><p><a href=\"https://gitlabe1.ext.net.nokia.com/RCP/pipeline-utils/blob/pkg-mgmt-pipes/vars/helmChartPipeline.md#products\">https://gitlabe1.ext.net.nokia.com/RCP/pipeline-utils/blob/pkg-mgmt-pipes/vars/helmChartPipeline.md#products</a></p>\n<p><a href=\"https://www.w3cschool.cn/jenkins/jenkins-jg9528pb.html\">https://www.w3cschool.cn/jenkins/jenkins-jg9528pb.html</a></p>\n<p><a href=\"https://confluence.int.net.nokia.com/display/MPP/Jenkinsfile+Template\">https://confluence.int.net.nokia.com/display/MPP/Jenkinsfile+Template</a></p>\n<p><a href=\"https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/\">https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Jenkinsfile-introduce\"><a href=\"#Jenkinsfile-introduce\" class=\"headerlink\" title=\"Jenkinsfile introduce\"></a>Jenkinsfile introduce</h1><h2 id=\"Jenkinsfile-基本语法\"><a href=\"#Jenkinsfile-基本语法\" class=\"headerlink\" title=\"Jenkinsfile 基本语法\"></a>Jenkinsfile 基本语法</h2><h3 id=\"Defining-a-Pipeline\"><a href=\"#Defining-a-Pipeline\" class=\"headerlink\" title=\"Defining a Pipeline\"></a>Defining a Pipeline</h3><p>Jenkins Pipeline is a suite of plugins that supports implementing and integrating continuous delivery pipelines into Jenkins. </p>\n<p>A Pipeline can be created in one of the following ways:</p>\n<ul>\n<li><a href=\"https://jenkins.io/doc/book/pipeline/getting-started/#through-blue-ocean\">Through Blue Ocean</a> - after setting up a Pipeline project in Blue Ocean, the Blue Ocean UI helps you write your Pipeline’s <code>Jenkinsfile</code> and commit it to source control.</li>\n<li><a href=\"https://jenkins.io/doc/book/pipeline/getting-started/#through-the-classic-ui\">Through the classic UI</a> - you can enter a basic Pipeline directly in Jenkins through the classic UI.</li>\n<li><a href=\"https://jenkins.io/doc/book/pipeline/getting-started/#defining-a-pipeline-in-scm\">In SCM</a> - you can write a <code>Jenkinsfile</code> manually, which you can commit to your project’s source control repository.</li>\n</ul>\n<h3 id=\"Using-Environmental-Variables\"><a href=\"#Using-Environmental-Variables\" class=\"headerlink\" title=\"Using Environmental Variables\"></a>Using Environmental Variables</h3><p>Environment variables can be set globally or per stage.</p>\n<p>Setting environment variables per stage means they will only apply to the stage in which they’re defined.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; setting environment variables globally</span><br><span class=\"line\">pipeline &#123;</span><br><span class=\"line\"> environment &#123;</span><br><span class=\"line\"> BUILD_NUMBER&#x3D;&quot;$&#123;Calendar.getInstance()format(&#39;yyyyMMddHHmmssSSS&#39;)&#125;&quot;</span><br><span class=\"line\"> BUILD_ID &#x3D; &quot;$&#123;env.BUILD_NUMBER&#125;&quot;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Agent\"><a href=\"#Agent\" class=\"headerlink\" title=\"Agent\"></a>Agent</h3><p>In declarative pipelines the <strong>agent</strong> directive is used for specifying which agent/slave the job/task is to be executed on. This directive only allows you to specify where the task can be executed (On which agent, slave, label or docker image)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">agent &#123; kubernetes &#123; label &#39;my-defined-label&#39; inheritFrom &#39;my-defined-build&#39; containerTemplate &#123; name &#39;build-name&#39; image &#39;my-docker-image:latest&#39; workingDir &#39;my&#x2F;working&#x2F;dir&#39; &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Parameters\"><a href=\"#Parameters\" class=\"headerlink\" title=\"Parameters\"></a>Parameters</h3><p>The parameters directive provides a list of parameters which a user should provide when triggering the Pipeline. The values for these user-specified parameters are made available to Pipeline steps via the ‘<code>params&#39;</code> object.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String parameter:</span><br><span class=\"line\">parameters &#123;</span><br><span class=\"line\"> string(name: &#39;DEPLOY_ENV&#39;, defaultValue: &#39;staging&#39;, description: &#39;&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Boolean parameter:</span><br><span class=\"line\">parameters &#123;</span><br><span class=\"line\"> booleanParam(name: &#39;DEBUG_BUILD&#39;, defaultValue: true, description: &#39;&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Choice parameter:</span><br><span class=\"line\">parameters &#123;</span><br><span class=\"line\"> choice(name:&#39;OPTIONS&#39;, description:&#39;Select an option&#39;, choices:&#39;Option1\\nOption2\\nOption3&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Gerrit-Triggers\"><a href=\"#Gerrit-Triggers\" class=\"headerlink\" title=\"Gerrit Triggers\"></a>Gerrit Triggers</h3><p>This plugin integrates Jenkins to Gerrit code review for triggering builds when a “patch set” is created.</p>\n<p><u><strong>Trigger configuration in pipeline job:</strong></u></p>\n<p>In the “Build Triggers” section of your Job configuration page; tick “Gerrit event”</p>\n<p>Specify what type of event(s) to trigger on:</p>\n<ul>\n<li><strong>Draft Published:</strong> Sent when a change moves from draft state to new. (only available in version 2.5 or higher of Gerrit).</li>\n<li><strong>Patchset Created:</strong> Sent when a new patchset arrives on a change. Before version 2.6.0, this was the only event you could trigger on.</li>\n<li><strong>Change Merged:</strong> Sent when a change is merged on the Gerrit server.</li>\n<li><strong>Comment Added:</strong> Sent when a comment is added to a change. Which category and value to trigger on can be configured. The available categories can be configured in the server settings for the plugin.</li>\n<li><strong>Ref Updated:</strong> Sent when a ref is updated on the Gerrit server, i.e. someone pushes past code review.</li>\n</ul>\n<img src=\"/Blog/posts/12007/image-20200729094356824.png\" class=\"\">\n\n<img src=\"Jenkinsfile%20introduce/image-20200729094356824.png\" alt=\"image-20200729094356824\" style=\"zoom: 67%;\" />\n\n<p><u><strong>Trigger configuration in Jenkinsfile:</strong></u></p>\n<p>Jenkinsfile will overwrite the configuration done in pipeline job. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triggers &#123;</span><br><span class=\"line\"> gerrit(</span><br><span class=\"line\">   customUrl: &#39;&#39;,</span><br><span class=\"line\">   gerritProjects: [[</span><br><span class=\"line\">     branches: [[</span><br><span class=\"line\">      compareType: &#39;PLAIN&#39;,</span><br><span class=\"line\">      pattern: &#39;master&#39;</span><br><span class=\"line\">     ]],</span><br><span class=\"line\">    compareType: &#39;PLAIN&#39;,</span><br><span class=\"line\">    disableStrictForbiddenFileVerification: false,</span><br><span class=\"line\">    pattern: &#39;repo-name&#39;</span><br><span class=\"line\">   ]],</span><br><span class=\"line\">   serverName: &#39;user-name&#39;,</span><br><span class=\"line\">   triggerOnEvents: [</span><br><span class=\"line\">     changeMerged(),</span><br><span class=\"line\">     patchsetCreated(</span><br><span class=\"line\">       excludeDrafts: true,</span><br><span class=\"line\">       excludeNoCodeChange: false,</span><br><span class=\"line\">       excludeTrivialRebase: false</span><br><span class=\"line\">     ),</span><br><span class=\"line\">     commentAdded(</span><br><span class=\"line\">       verdictCategory: &#39;Code-Review&#39;,</span><br><span class=\"line\">       commentAddedTriggerApprovalValue: &#39;+2&#39;</span><br><span class=\"line\">     )</span><br><span class=\"line\">   ]</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Jenkinsfile-simple\"><a href=\"#Jenkinsfile-simple\" class=\"headerlink\" title=\"Jenkinsfile simple\"></a>Jenkinsfile simple</h2><h3 id=\"Library\"><a href=\"#Library\" class=\"headerlink\" title=\"@Library\"></a>@Library</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Library([&#39;scm@&lt;pipeline-utils branch or tag&gt;&#39;]) _</span><br></pre></td></tr></table></figure>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Library([&#39;scm@container-stable-2.x&#39;, &#39;commonLibs@0.0.3&#39;]) _</span><br></pre></td></tr></table></figure>\n<h3 id=\"extraOnboardingImages\"><a href=\"#extraOnboardingImages\" class=\"headerlink\" title=\"extraOnboardingImages\"></a>extraOnboardingImages</h3><p>List containing the extra images that need to onboard to Open Edge server. </p>\n<p>列出包含需要附加到Open Edge服务器的其他图像的列表。</p>\n<p>Example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map containers &#x3D; [</span><br><span class=\"line\">    DockerImage: [</span><br><span class=\"line\">        name: &#39;fhproxy&#x2F;docker-fhproxy&#39;,</span><br><span class=\"line\">        buildName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: true,</span><br><span class=\"line\">        type: &#39;runtime&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    DockerTestImage: [</span><br><span class=\"line\">        name: &#39;fhproxy&#x2F;docker-fhproxy-test&#39;,</span><br><span class=\"line\">        buildName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: true,</span><br><span class=\"line\">        type: &#39;runtime&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    NwInitImage: [</span><br><span class=\"line\">        name: &quot;fhproxy&#x2F;docker-nwinit&quot;,</span><br><span class=\"line\">        buildName: &#39;Onboarding&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: false</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    NwMgmtImage: [</span><br><span class=\"line\">        name: &quot;fhproxy&#x2F;docker-nwmgmt&quot;,</span><br><span class=\"line\">        buildName: &#39;Onboarding&#39;,</span><br><span class=\"line\">        testNames: [&#39;Test fhproxy container mvp&#39;,&#39;Test fhproxy container l3 call&#39;],</span><br><span class=\"line\">        published: false</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"tersyParams\"><a href=\"#tersyParams\" class=\"headerlink\" title=\"tersyParams\"></a>tersyParams</h3><blockquote>\n<p>platform: <b>Optional arguments</b></p>\n</blockquote>\n<p>String containing platform type of NESC node.  包含NESC节点的平台类型的字符串</p>\n<p>Possible values:</p>\n<ul>\n<li>any</li>\n<li>TPI3-like</li>\n<li>NCIR-like</li>\n</ul>\n<p>Default value: NCIR-like</p>\n<p>When test is executed in real HW <a href=\"#tersyparams\">tersyParams</a> will define which kind of environment is selected</p>\n<p>在实际硬件中执行测试时，tersyParams将定义选择哪种环境</p>\n<p>Map containing information that is used for test environment reservation from Tersy. </p>\n<p>映射包含用于从Tersy保留测试环境的信息。</p>\n<p>Duration and pool or tenant attributes in tersyParams are mandatory if RUN_ON_HW is set to true. </p>\n<p>如果将<strong>RUN_ON_HW</strong>设置为true，则tersyParams中的<strong>duration</strong>和<strong>pool</strong>或<strong>tenant</strong>属性是必需的。</p>\n<p>Other attributes are optional.</p>\n<p>Tersy parameters:</p>\n<p>For details on supported parameters see documentation of <a href=\"https://pypi.dynamic.nsn-net.net/rcp/prod/tersycli/latest/+doc/CLI.html#create\">tersycli create</a> command.</p>\n<p>有关支持的参数的详细信息，请参见tersycli create命令的文档。</p>\n<p>Only long format of the named arguments are supported, use for example ‘duration’ instead of ‘d’. </p>\n<p>Note that ‘<strong>reservation_name</strong>‘ is not needed as it is automatically set to Jenkins job name. </p>\n<p>Default value of <strong>queue_timeout</strong> parameter is 1 hour if priority is given. </p>\n<p>Default value of <strong>env_type</strong> is CAAS. </p>\n<p>Additionally a specific tersycli version can be requested with <code>tersycliVersion</code>, 2.3.5 is used by default.</p>\n<p>仅支持长格式的命名参数，例如使用“duration”代替“ d”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map tersyParamsMvp &#x3D; [    </span><br><span class=\"line\">    pool: &quot;CAAS_test&quot;,</span><br><span class=\"line\">    priority: &quot;3&quot;,</span><br><span class=\"line\">    duration: &quot;1&quot;,</span><br><span class=\"line\">    queue_timeout: &quot;6&quot;,</span><br><span class=\"line\">    tag: &quot;NIC&#x3D;Intel-XXV710&quot;,</span><br><span class=\"line\">    platform: &quot;NCIR19&quot;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">Map tersyParams &#x3D; [</span><br><span class=\"line\">    pool: &quot;CAAS_Host_VLAN&quot;,</span><br><span class=\"line\">    priority: &quot;3&quot;,</span><br><span class=\"line\">    duration: &quot;1&quot;,</span><br><span class=\"line\">    queue_timeout: &quot;6&quot;,</span><br><span class=\"line\">    tag: &quot;NIC&#x3D;Intel-XXV710&quot;,</span><br><span class=\"line\">    platform: &quot;NCIR19&quot;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"builds\"><a href=\"#builds\" class=\"headerlink\" title=\"builds\"></a>builds</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List builds &#x3D; [</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;fhproxy&#39;,</span><br><span class=\"line\">        agent: &#39;docker_helmci&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;docker-build&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;Onboarding&#39;,</span><br><span class=\"line\">        agent: &#39;docker_helmci&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;get-onboarding-images&#39;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"agent\"><a href=\"#agent\" class=\"headerlink\" title=\"agent\"></a>agent</h3><blockquote>\n<p>agent: <b>Optional arguments</b></p>\n</blockquote>\n<p>Jenkins agent where the test is executed. 执行测试的Jenkins代理。</p>\n<p>Some possible values are:</p>\n<ul>\n<li><code>single-node-container-k8s-dpdk</code>  for 8 core <a href=\"https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/\">cloud-development</a> environment with dpdk support</li>\n<li><code>single-node-pod-k8s-dpdk</code>  for 16 core <a href=\"https://gitlabe2.ext.net.nokia.com/cloud-tools/cloud-development/\">cloud-development</a> environment with dpdk support</li>\n<li><code>multi-node-pod-k8s-dpdk</code>  for 1+1 node, 13 core each, <a href=\"https://gitlabe2.ext.net.nokia.com/cloud-tools/container-infra-system\">container-infra-system</a> environment with dpdk support</li>\n<li>TODO: IT kubernetes cluster agent</li>\n</ul>\n<p>Default value for the parameter is <code>single-node-container-k8s-dpdk</code></p>\n<blockquote>\n<p>cleanCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to run before and after test to clean up resources. </p>\n<p>在测试之前和之后运行的可选shell命令，以清理资源。</p>\n<p>要注意的是，pipeline检测v2和v3的Helm命令，并将它们分别暴露为环境变量$ {HELM2}和$ {HELM3}。因此最好在shell脚本中使用这些变量，以避免在’helm’命令更改为指向helm3而不是旧的helm2时更改脚本。</p>\n<blockquote>\n<p>helmName:  <b>Mandatory arguments</b></p>\n</blockquote>\n<p>Name of the helm chart to be tested and published. Helm chart will be cloned to a directory with this name regardless what the repository name is. All scripts are executed in this directory.</p>\n<p>要测试和发布的helm chart的名称, 无论存储库名称是什么，Helm chart都会被克隆到具有该名称的目录中。所有脚本都在此目录中执行。</p>\n<p>To allow for more than one pipeline to be executed for same helm chart, pipeline appends automatically Jenkins build id and branch name to the helm name defined in the <a href=\"\">env_vars file</a>.</p>\n<p>为了允许对同一helm chart执行多个管道，管道会自动将Jenkins构建ID和分支名称附加到env_vars文件中定义的helm名称。</p>\n<blockquote>\n<p>deployCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to deploy the helm chart. Default value is <code>ci/deploy.sh</code></p>\n<p>可选的shell命令，用于部署helm chart。默认值为ci / deploy.sh， 应该是这里的command</p>\n<blockquote>\n<p>testCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to deploy the helm chart. Default value is <code>ci/test.sh</code></p>\n<p>可选的shell命令，用于部署helm chart。默认值为ci / test.sh</p>\n<blockquote>\n<p>logsCommand: <b>Optional arguments</b></p>\n</blockquote>\n<p>Optional shell command to run at the end of the pipeline to collect logs. Default value is <code>gather-artifacts.sh</code> Will be executed always even if deploy or test fails. To ensure that all logs are collected make sure that the command handles error cases correctly.</p>\n<p>可选的shell命令在pipeline末端运行以收集日志。失败后的log收集，为确保收集所有日志，请确保该命令正确处理错误情况。</p>\n<p>If using <code>bash</code> script you can use <code>+e</code> flag to ignore errors:</p>\n<p>如果使用bash脚本，则可以使用+ e标志忽略错误： <code>#!/bin/bash +e</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List tests &#x3D; [</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;Test fhproxy container mvp&#39;,</span><br><span class=\"line\">\t\trunOnOpenEdge: true,</span><br><span class=\"line\">\t\ttersyParams: tersyParamsMvp,</span><br><span class=\"line\">\t\thelmName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        agent: &#39;single-node-container-k8s-dpdk&#39;,</span><br><span class=\"line\">        prepareCommand: &#39;ci&#x2F;prepare mvp_logs&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;docker-test mvp_logs&#39;,</span><br><span class=\"line\">        logsCommand: &#39;ci&#x2F;helm-log.sh mvp_logs&#39;,</span><br><span class=\"line\">        cleanCommand: &#39;ci&#x2F;helm-delete.sh mvp_logs&#39;,</span><br><span class=\"line\">        artifacts: &#39;mvp_logs&#x2F;*&#39;,</span><br><span class=\"line\">        addSkipParam: true,</span><br><span class=\"line\">        timeout: &#39;30&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;Test fhproxy container l3 call&#39;,</span><br><span class=\"line\">        runOnOpenEdge: true,</span><br><span class=\"line\">        tersyParams: tersyParams,</span><br><span class=\"line\">        helmName: &#39;fhproxy&#39;,</span><br><span class=\"line\">        agent: &#39;single-node-container-k8s-dpdk&#39;,</span><br><span class=\"line\">        prepareCommand: &#39;ci&#x2F;prepare l3_call_logs&#39;,</span><br><span class=\"line\">        command: &#39;ci&#x2F;docker-test l3_call_logs&#39;,</span><br><span class=\"line\">        logsCommand: &#39;ci&#x2F;helm-log.sh l3_call_logs&#39;,</span><br><span class=\"line\">        cleanCommand: &#39;ci&#x2F;helm-delete.sh l3_call_logs&#39;,</span><br><span class=\"line\">        artifacts: &#39;l3_call_logs&#x2F;*&#39;,</span><br><span class=\"line\">        addSkipParam: true,</span><br><span class=\"line\">        timeout: &#39;30&#39;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"jobParams\"><a href=\"#jobParams\" class=\"headerlink\" title=\"jobParams\"></a>jobParams</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">List jobParams &#x3D;  [</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;CASE_TAG&#39;,</span><br><span class=\"line\">        description: &#39;--test RCP_TRH_FHP_001*; -s FHP_first_temp_test_case; --include owner-XXX; --exclude not-ready;&#39;,</span><br><span class=\"line\">        defaultValue: &#39;&#39;,</span><br><span class=\"line\">        type: &#39;string&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;UP_HELM_BRANCH&#39;,</span><br><span class=\"line\">        description: &quot;This parameter is the branch of rcp-pod-up helm. &#39;master&#39; are set by default.&quot;,</span><br><span class=\"line\">        defaultValue: &#39;master&#39;,</span><br><span class=\"line\">        type: &#39;string&#39;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    [</span><br><span class=\"line\">        name: &#39;MN_HELM_BRANCH&#39;,</span><br><span class=\"line\">        description: &quot;This parameter is the branch of rcp-pod-mn helm. &#39;master&#39; are set by default.&quot;,</span><br><span class=\"line\">        defaultValue: &#39;master&#39;,</span><br><span class=\"line\">        type: &#39;string&#39;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"Notification-Recipients\"><a href=\"#Notification-Recipients\" class=\"headerlink\" title=\"Notification Recipients\"></a>Notification Recipients</h3><p>Specifies if email or office365 (yammer/teams) notification should be sent. By default no notifications are sent.</p>\n<p>For each of the notification type define a Map which has <a href=\"#webhookurl\">webhookUrl</a> and/or <a href=\"#emailaddresses\">emailAddresses</a> defined.</p>\n<p>An example where all the notifications are sent:</p>\n<blockquote>\n<p>notifyMainBranchFailure: <b>Optional arguments</b></p>\n</blockquote>\n<p>Set to receive notifications when pipeline failed on the branch defined by <a href=\"\">mainBranch</a>. Do not define to not receive these notifications.</p>\n<p>设置为在mainBranch定义的分支上的pipeline 发生故障时接收通知。别定义为不接收这些通知。</p>\n<blockquote>\n<p>notifyTagSuccess: <b>Optional arguments</b></p>\n</blockquote>\n<p>Set to receive notifications of successful publishing of helm chart. Do not define to not receive these notifications.</p>\n<blockquote>\n<p>notifyTagFailure: <b>Optional arguments</b></p>\n</blockquote>\n<p>Set to receive information when pipeline failed when helm chart was tried to be published. Do not define to not receive these notifications.</p>\n<blockquote>\n<p>webhookUrl: <b>Optional arguments</b></p>\n</blockquote>\n<p>Provide the webhook from yammer or teams to get notifications sent there. In yammer you can add Jenkins app from the “Add or Remove Apps” link. In teams this is done via the “Connectors” link for the channel.</p>\n<blockquote>\n<p>emailAddresses: <b>Optional arguments</b></p>\n</blockquote>\n<p>Comma separated list of email addresses to sent notifications to.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map defaultNotificationRecipients &#x3D; [</span><br><span class=\"line\">    webhookUrl: &#39;https:&#x2F;&#x2F;outlook.office.com&#x2F;webhook&#x2F;1aace586-e82a-49e8-8031-1d5686283369@5d471751-9675-428d-917b-70f44f9630b0&#x2F;JenkinsCI&#x2F;a4f01ac738d74f35a2f9d8c5407fb860&#x2F;64e29d73-1461-434c-9aa1-3c353689ffd6&#39;,</span><br><span class=\"line\">    emailAddresses: &#39;I_NSB_MN_CRAN_RD_CF_RCPTRS_SQUAD_TOUCHDOWN@internal.nsn.com&#39;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map notifications &#x3D; [</span><br><span class=\"line\">    notifyMainBranchFailure: defaultNotificationRecipients,</span><br><span class=\"line\">    notifyMainBranchSuccess: defaultNotificationRecipients,</span><br><span class=\"line\">    notifyTagSuccess: defaultNotificationRecipients,</span><br><span class=\"line\">    notifyTagFailure: defaultNotificationRecipients</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<h3 id=\"containerPipeline\"><a href=\"#containerPipeline\" class=\"headerlink\" title=\"containerPipeline\"></a>containerPipeline</h3><p>calling the pipeline from container Jenkinsfile:</p>\n<blockquote>\n<p>gitlabConnection:  <b>Mandatory arguments</b></p>\n</blockquote>\n<p>Tells Jenkins which gitlab connection to use when reporting. Valid values are:</p>\n<ul>\n<li>‘IT gitlab’ for gitlabe1.ext.net.nokia.com</li>\n<li>‘Gitlabe2’ for gitlabe2.ext.net.nokia.com</li>\n</ul>\n<blockquote>\n<p>tagPublishRegexp: <b>Optional arguments</b></p>\n</blockquote>\n<p>By default all tags trigger image publishing if <a href=\"#publishtags\">publishTags</a> is set to <code>true</code>. With this argument it is possible to filter which tags are published. The format is regular expression. Some examples:</p>\n<p>默认情况下，如果publishTags设置为true，则所有标签都会触发图像发布。使用此参数，可以过滤发布哪些标签。格式为正则表达式。</p>\n<ul>\n<li><code>^\\\\d+\\\\.\\\\d+\\\\.\\\\d+$</code> would match only semVer formatted tags e.g. 1.2.0  –将仅匹配semVer格式的标签，例如1.2.0</li>\n<li><code>^release-.*</code> would match only tags which start with release- prefix  –将仅匹配以release-前缀开头的标签</li>\n<li><code>^\\\\d+\\\\.\\\\d+\\\\.\\\\d+([-_]hb)?$</code> when publishing for Heart Beat build  –在发布Heart Beat版本时</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">containerPipeline   containers: containers,</span><br><span class=\"line\">                    jobParams: jobParams,</span><br><span class=\"line\">                    gitlabConnection: &#39;Gitlabe2&#39;,</span><br><span class=\"line\">                    builds: builds,</span><br><span class=\"line\">                    tests: tests,</span><br><span class=\"line\">                    tagPublishRegexp: &#39;^\\\\d+\\\\.\\\\d+\\\\.\\\\d+.*&#39;,</span><br><span class=\"line\">                    relNoteCategory: &#39;ContainerImages&#39;,</span><br><span class=\"line\">                    configFile: &#39;config&#39;,</span><br><span class=\"line\">                    notifications: notifications</span><br></pre></td></tr></table></figure>\n<h3 id=\"Set-environment-variables\"><a href=\"#Set-environment-variables\" class=\"headerlink\" title=\"Set environment variables\"></a>Set environment variables</h3><p>Some environment variables name and value are printed to ./env_vars file. Scripts like config.deployCommand, config.testCommand, config.cleanCommand can source env_vars file and use the listed env variables.</p>\n<p>一些环境变量的名称和值会打印到./env_vars文件中。诸如config.deployCommand，config.testCommand，config.cleanCommand之类的脚本可以获取env_vars文件并使用列出的env变量。</p>\n<p>Example env_vars:</p>\n<figure class=\"highlight verilog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  + cat env_vars</span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  HELM_NAME=<span class=\"string\">&quot;fhproxy-10-change-the-rpm-name-of-testca&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  NAMESPACE=<span class=\"string\">&quot;cran2&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  TARGET_FILE=<span class=\"string\">&quot;OE19-TT-O5-AIO-1_cran2.yaml&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  RUN_ON_OPEN_EDGE=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  RUN_ON_HW=<span class=\"string\">&quot;true&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  PLATFORM=<span class=\"string\">&quot;NCIR19&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  WORKING_DIR=<span class=\"string\">&quot;CONTAINER_PIPELINE_WORKDIR-fhproxy/fhproxy&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  K8S_NODE_HOST_IP=<span class=\"string\">&quot;192.168.81.26&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  BUILD_ID=<span class=\"string\">&quot;10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  BRANCH_NAME=<span class=\"string\">&quot;Change_the_rpm_name_of_testcase&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  BUILDING_TAG=<span class=\"string\">&quot;null&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  PUBLISHING_TAG=<span class=\"string\">&quot;null&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  DockerImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  DockerTestImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-fhproxy-test:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  NwInitImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwinit:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  NwMgmtImage=<span class=\"string\">&quot;registry.kube-system.svc.nokia.net:5555/fhproxy/docker-nwmgmt:0.0.0-78-g80c0c0f_21595482723715_10&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  CASE_TAG=<span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  UP_HELM_BRANCH=<span class=\"string\">&quot;master&quot;</span></span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">59</span>:<span class=\"number\">24</span>  MN_HELM_BRANCH=<span class=\"string\">&quot;master&quot;</span></span><br></pre></td></tr></table></figure>\n<p><strong>RUN_ON_OPEN_EDGE</strong> env variable is deprecated. Scripts should be changed to use RUN_ON_HW instead of RUN_ON_OPEN_EDGE.</p>\n<p>不赞成使用RUN_ON_OPEN_EDGE环境变量。应将脚本更改为使用RUN_ON_HW而不是RUN_ON_OPEN_EDGE。</p>\n<p><strong>BUILD_ID</strong> is the Jenkins job build number. This and <strong>BRANCH_NAME</strong> are also appended to the <strong>HELM_NAME</strong> variable so that it does not conflict with other pipelines running tests for the same helm chart. <code>The name is limited to 40 characters.</code> This allows container developers to add possible pre- and postfixes, but the name should not exceed the maximum allowed for helm release name (53 characters).</p>\n<p>BUILD_ID变量和BRANCH_NAME也附加到HELM_NAME变量中，以使其与运行针对同一helm chart的测试中的其他pipelines不冲突。</p>\n<h3 id=\"3-参考链接\"><a href=\"#3-参考链接\" class=\"headerlink\" title=\"3. 参考链接\"></a>3. 参考链接</h3><p><a href=\"https://gitlabe1.ext.net.nokia.com/RCP/pipeline-utils/blob/pkg-mgmt-pipes/vars/helmChartPipeline.md#products\">https://gitlabe1.ext.net.nokia.com/RCP/pipeline-utils/blob/pkg-mgmt-pipes/vars/helmChartPipeline.md#products</a></p>\n<p><a href=\"https://www.w3cschool.cn/jenkins/jenkins-jg9528pb.html\">https://www.w3cschool.cn/jenkins/jenkins-jg9528pb.html</a></p>\n<p><a href=\"https://confluence.int.net.nokia.com/display/MPP/Jenkinsfile+Template\">https://confluence.int.net.nokia.com/display/MPP/Jenkinsfile+Template</a></p>\n<p><a href=\"https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/\">https://www.jenkins.io/zh/doc/book/pipeline/jenkinsfile/</a></p>\n"},{"title":"Helm Introduction","date":"2020-12-31T15:59:00.000Z","abbrlink":12008,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"# Helm Introduction\n\n### 1. Chart的结构\n\n#### 1.1. 什么是chart\n\nHelm uses a packaging format called charts. A chart is a collection of files that describe a related set of Kubernetes resources.\n\nCharts are created as files laid out in a particular directory tree, then they can be packaged into versioned archives to be deployed.\n\n#### 1.2 chart的目录结构\n\n```yaml\nwordpress/\n  Chart.yaml            # A YAML file containing information about the chart -包含chart信息的YAML文件\n  LICENSE               # OPTIONAL: A plain text file containing the license for the chart\n  README.md             # OPTIONAL: A human-readable README file\n  requirements.yaml     # OPTIONAL: A YAML file listing dependencies for the chart  -列出chart依赖关系的YAML文件\n  values.yaml           # The default configuration values for this chart  -chart的默认配置值\n  charts/               # A directory containing any charts upon which this chart depends.  -包含chart所依赖的所有chart的目录\n  templates/            # A directory of templates that, when combined with values,  -模板目录，生成有效的k8s清单文件\n                        # will generate valid Kubernetes manifest files.\n  templates/NOTES.txt   # OPTIONAL: A plain text file containing short usage notes\n```\n\n#### 1.3 chart.yaml文件\n\n```yaml\napiVersion: The chart API version, always \"v1\" (required)\nname: The name of the chart (required)\nversion: A SemVer 2 version (required)\nkubeVersion: A SemVer range of compatible Kubernetes versions (optional)\ndescription: A single-sentence description of this project (optional)\nkeywords:\n  - A list of keywords about this project (optional)\nhome: The URL of this project's home page (optional)\nsources:\n  - A list of URLs to source code for this project (optional)\nmaintainers: # (optional)\n  - name: The maintainer's name (required for each maintainer)\n    email: The maintainer's email (optional for each maintainer)\n    url: A URL for the maintainer (optional for each maintainer)\nengine: gotpl # The name of the template engine (optional, defaults to gotpl)\nicon: A URL to an SVG or PNG image to be used as an icon (optional).\nappVersion: The version of the app that this contains (optional). This needn't be SemVer.\ndeprecated: Whether this chart is deprecated (optional, boolean)\ntillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer \n```\n\n一个例子：\n\n```yaml\napiVersion: v1\nappVersion: \"1.0\"   #这是指定应用程序版本的一种方式\ndescription: A Helm chart for Kubernetes\nname: up\nversion: 1.5.0\n```\n\n> 1)    Every chart must have a **version number**. A version must follow the [SemVer 2](http://semver.org/) standard. Unlike Helm Classic, Kubernetes Helm uses version numbers as release markers. Packages in repositories are identified by name plus version.\n>\n> 2)    Note that the **appVersion** field is not related to the version field. It is a way of specifying the version of the application.\n>\n> 3)    When managing charts in a Chart Repository, it is sometimes necessary to deprecate a chart. The optional deprecated field in Chart.yaml can be used to mark a chart as deprecated. If the latest version of a chart in the repository is marked as deprecated, then the chart as a whole is considered to be deprecated.\n\n#### 1.4 requirements.yaml\n\nThese dependencies can be dynamically linked through the requirements.yaml file or brought in to the charts/directory and managed manually. \n\n依赖关系可以通过requirements.yaml文件动态链接，也可以引入charts/directory并手动进行管理\n\nAnd the preferred method of declaring dependencies is by using a requirements.yaml file inside of your chart.\n\n声明依赖关系的首选方法是使用图表内部的requirements.yaml文件。\n\n一个例子：\n\n```yaml\ndependencies:\n  - name: apache\n    version: 1.2.3\n    repository: http://example.com/charts\n  - name: mysql\n    version: 3.2.1\n    repository: http://another.example.com/charts\n \n    condition: subchart1.enabled, global. subchart1.enabled\n    tags:\n      - front-end\n      - subchart1\n```\n\n* The **name** field is the name of the chart you want. \n\n* The **version** field is the version of the chart you want.\n\n    > Where possible, use version ranges instead of an exact version. \n\n    * Example of a patch-level version match:\n\n        version: ~1.2.3\n\n        This will match version 1.2.3 and any patches to that release. In other words, ~1.2.3 is equivalent to >= 1.2.3, < 1.3.0\n\n    * Example of a minor-level version match:\n\n        version: ^1.2.0\n\n        This will match version 1.2.0 and any minor version increments from it. In other words, ~1.2.0 is equivalent to >= 1.2.0, < 2.0.0\n\n> ​\tMore information available at https://v2.helm.sh/docs/chart_best_practices/#requirements-files\n\n* The **repository** field is the full URL to the chart repository. Note that you must also use helm repo add to add that repo locally. It’s a **mandatory** field.\n\n* **condition** - The condition field holds one or more YAML paths (delimited by commas). 条件字段包含一个或多个YAML路径（以逗号分隔）。\n\n    If this path exists in the top parent’s values and resolves to a Boolean value, the chart will be enabled or disabled based on that Boolean value. \n\n    Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect.\n\n    如果此路径存在于父级的最高值中并且解析为布尔值，则将基于该布尔值启用或禁用图表。\n    仅评估列表中找到的第一个有效路径，如果不存在路径，则该条件无效\n\n* **tags** - The tags field is a YAML list of labels to associate with this chart.  标签字段是与该图表关联的YAML标签列表。\n\n    In the top parent’s values, all charts with tags can be enabled or disabled by specifying the tag and a Boolean value.\n\n    在最高父级的值中，可以通过指定标签和布尔值来启用或禁用所有带有标签的图表。\n\n> •    Conditions (when set in values) always override tags.   <!--这个怎么理解-->？\n>\n> •    The first condition path that exists wins and subsequent ones for that chart are ignored. \n>\n> •    Tags are evaluated as ‘if any of the chart’s tags are true then enable the chart’.\n>\n> •    Tags and conditions values must be set in the top parent’s values. 标签和条件值必须设置在父级的最高值中。\n>\n> •    The tags: key in values must be a top level key. Global and nested tags: tables are not currently supported.\n\nOnce you have a dependencies file, you can run *helm dependency update* and it will use your dependency file to download all the specified charts into your charts/ directory for you.\n\n#### 1.5 Template file\n\nAll template files are stored in a chart’s templates/ folder. When Helm renders the charts, it will pass every file in that directory through the template engine. 通过模板引擎传递该目录中的每个文件。\n\nValues for the templates are supplied two ways:\n\n* Chart developers may supply a file called values.yaml inside of a chart. This file can contain **default values**.\n\n* Chart users may supply a YAML file that contains values. This can be provided on the command line with helm install.\n\nWhen a user supplies custom values, these values will override the values in the chart’s **values.yaml** file.\n\n当用户提供自定义值时，这些值将覆盖图表的values.yaml 文件中的值。\n\nBelow is an example template files for a Kubernetes replication controller:\n\n```yaml\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: deis-database\n  namespace: deis\n  labels:\n    app.kubernetes.io/managed-by: deis\nspec:\n  replicas: 1\n  selector:\n    app.kubernetes.io/name: deis-database\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: deis-database\n    spec:\n      serviceAccount: deis-database\n      containers:\n        - name: deis-database\n          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}\n          imagePullPolicy: {{.Values.pullPolicy}}\n          ports:\n            - containerPort: 5432\n          env:\n            - name: DATABASE_STORAGE\n              value: {{default \"minio\" .Values.storage}}\n\n```\n\nIt can use the following four template values (usually defined in a values.yaml file):\n\n* **imageRegistry**: The source registry for the Docker image.\n\n* **dockerTag**: The tag for the docker image.\n\n* **pullPolicy**: The Kubernetes pull policy.\n\n* **storage**: The storage backend, whose default is set to \"minio\"\n\nAll of these values are defined by the template author. Helm does not require or dictate parameters.","source":"_posts/cloud_md/Helm Introduction.md","raw":"---\ntitle: Helm Introduction\ndate: '2020/12/31 23:59'\ntags:\n - helm\ncategories:\n - 个人项目\nabbrlink: 12008\ncover: \n---\n# Helm Introduction\n\n### 1. Chart的结构\n\n#### 1.1. 什么是chart\n\nHelm uses a packaging format called charts. A chart is a collection of files that describe a related set of Kubernetes resources.\n\nCharts are created as files laid out in a particular directory tree, then they can be packaged into versioned archives to be deployed.\n\n#### 1.2 chart的目录结构\n\n```yaml\nwordpress/\n  Chart.yaml            # A YAML file containing information about the chart -包含chart信息的YAML文件\n  LICENSE               # OPTIONAL: A plain text file containing the license for the chart\n  README.md             # OPTIONAL: A human-readable README file\n  requirements.yaml     # OPTIONAL: A YAML file listing dependencies for the chart  -列出chart依赖关系的YAML文件\n  values.yaml           # The default configuration values for this chart  -chart的默认配置值\n  charts/               # A directory containing any charts upon which this chart depends.  -包含chart所依赖的所有chart的目录\n  templates/            # A directory of templates that, when combined with values,  -模板目录，生成有效的k8s清单文件\n                        # will generate valid Kubernetes manifest files.\n  templates/NOTES.txt   # OPTIONAL: A plain text file containing short usage notes\n```\n\n#### 1.3 chart.yaml文件\n\n```yaml\napiVersion: The chart API version, always \"v1\" (required)\nname: The name of the chart (required)\nversion: A SemVer 2 version (required)\nkubeVersion: A SemVer range of compatible Kubernetes versions (optional)\ndescription: A single-sentence description of this project (optional)\nkeywords:\n  - A list of keywords about this project (optional)\nhome: The URL of this project's home page (optional)\nsources:\n  - A list of URLs to source code for this project (optional)\nmaintainers: # (optional)\n  - name: The maintainer's name (required for each maintainer)\n    email: The maintainer's email (optional for each maintainer)\n    url: A URL for the maintainer (optional for each maintainer)\nengine: gotpl # The name of the template engine (optional, defaults to gotpl)\nicon: A URL to an SVG or PNG image to be used as an icon (optional).\nappVersion: The version of the app that this contains (optional). This needn't be SemVer.\ndeprecated: Whether this chart is deprecated (optional, boolean)\ntillerVersion: The version of Tiller that this chart requires. This should be expressed as a SemVer \n```\n\n一个例子：\n\n```yaml\napiVersion: v1\nappVersion: \"1.0\"   #这是指定应用程序版本的一种方式\ndescription: A Helm chart for Kubernetes\nname: up\nversion: 1.5.0\n```\n\n> 1)    Every chart must have a **version number**. A version must follow the [SemVer 2](http://semver.org/) standard. Unlike Helm Classic, Kubernetes Helm uses version numbers as release markers. Packages in repositories are identified by name plus version.\n>\n> 2)    Note that the **appVersion** field is not related to the version field. It is a way of specifying the version of the application.\n>\n> 3)    When managing charts in a Chart Repository, it is sometimes necessary to deprecate a chart. The optional deprecated field in Chart.yaml can be used to mark a chart as deprecated. If the latest version of a chart in the repository is marked as deprecated, then the chart as a whole is considered to be deprecated.\n\n#### 1.4 requirements.yaml\n\nThese dependencies can be dynamically linked through the requirements.yaml file or brought in to the charts/directory and managed manually. \n\n依赖关系可以通过requirements.yaml文件动态链接，也可以引入charts/directory并手动进行管理\n\nAnd the preferred method of declaring dependencies is by using a requirements.yaml file inside of your chart.\n\n声明依赖关系的首选方法是使用图表内部的requirements.yaml文件。\n\n一个例子：\n\n```yaml\ndependencies:\n  - name: apache\n    version: 1.2.3\n    repository: http://example.com/charts\n  - name: mysql\n    version: 3.2.1\n    repository: http://another.example.com/charts\n \n    condition: subchart1.enabled, global. subchart1.enabled\n    tags:\n      - front-end\n      - subchart1\n```\n\n* The **name** field is the name of the chart you want. \n\n* The **version** field is the version of the chart you want.\n\n    > Where possible, use version ranges instead of an exact version. \n\n    * Example of a patch-level version match:\n\n        version: ~1.2.3\n\n        This will match version 1.2.3 and any patches to that release. In other words, ~1.2.3 is equivalent to >= 1.2.3, < 1.3.0\n\n    * Example of a minor-level version match:\n\n        version: ^1.2.0\n\n        This will match version 1.2.0 and any minor version increments from it. In other words, ~1.2.0 is equivalent to >= 1.2.0, < 2.0.0\n\n> ​\tMore information available at https://v2.helm.sh/docs/chart_best_practices/#requirements-files\n\n* The **repository** field is the full URL to the chart repository. Note that you must also use helm repo add to add that repo locally. It’s a **mandatory** field.\n\n* **condition** - The condition field holds one or more YAML paths (delimited by commas). 条件字段包含一个或多个YAML路径（以逗号分隔）。\n\n    If this path exists in the top parent’s values and resolves to a Boolean value, the chart will be enabled or disabled based on that Boolean value. \n\n    Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect.\n\n    如果此路径存在于父级的最高值中并且解析为布尔值，则将基于该布尔值启用或禁用图表。\n    仅评估列表中找到的第一个有效路径，如果不存在路径，则该条件无效\n\n* **tags** - The tags field is a YAML list of labels to associate with this chart.  标签字段是与该图表关联的YAML标签列表。\n\n    In the top parent’s values, all charts with tags can be enabled or disabled by specifying the tag and a Boolean value.\n\n    在最高父级的值中，可以通过指定标签和布尔值来启用或禁用所有带有标签的图表。\n\n> •    Conditions (when set in values) always override tags.   <!--这个怎么理解-->？\n>\n> •    The first condition path that exists wins and subsequent ones for that chart are ignored. \n>\n> •    Tags are evaluated as ‘if any of the chart’s tags are true then enable the chart’.\n>\n> •    Tags and conditions values must be set in the top parent’s values. 标签和条件值必须设置在父级的最高值中。\n>\n> •    The tags: key in values must be a top level key. Global and nested tags: tables are not currently supported.\n\nOnce you have a dependencies file, you can run *helm dependency update* and it will use your dependency file to download all the specified charts into your charts/ directory for you.\n\n#### 1.5 Template file\n\nAll template files are stored in a chart’s templates/ folder. When Helm renders the charts, it will pass every file in that directory through the template engine. 通过模板引擎传递该目录中的每个文件。\n\nValues for the templates are supplied two ways:\n\n* Chart developers may supply a file called values.yaml inside of a chart. This file can contain **default values**.\n\n* Chart users may supply a YAML file that contains values. This can be provided on the command line with helm install.\n\nWhen a user supplies custom values, these values will override the values in the chart’s **values.yaml** file.\n\n当用户提供自定义值时，这些值将覆盖图表的values.yaml 文件中的值。\n\nBelow is an example template files for a Kubernetes replication controller:\n\n```yaml\napiVersion: v1\nkind: ReplicationController\nmetadata:\n  name: deis-database\n  namespace: deis\n  labels:\n    app.kubernetes.io/managed-by: deis\nspec:\n  replicas: 1\n  selector:\n    app.kubernetes.io/name: deis-database\n  template:\n    metadata:\n      labels:\n        app.kubernetes.io/name: deis-database\n    spec:\n      serviceAccount: deis-database\n      containers:\n        - name: deis-database\n          image: {{.Values.imageRegistry}}/postgres:{{.Values.dockerTag}}\n          imagePullPolicy: {{.Values.pullPolicy}}\n          ports:\n            - containerPort: 5432\n          env:\n            - name: DATABASE_STORAGE\n              value: {{default \"minio\" .Values.storage}}\n\n```\n\nIt can use the following four template values (usually defined in a values.yaml file):\n\n* **imageRegistry**: The source registry for the Docker image.\n\n* **dockerTag**: The tag for the docker image.\n\n* **pullPolicy**: The Kubernetes pull policy.\n\n* **storage**: The storage backend, whose default is set to \"minio\"\n\nAll of these values are defined by the template author. Helm does not require or dictate parameters.","slug":"cloud_md/Helm Introduction","published":1,"updated":"2021-04-09T12:52:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5q0009w9q92a505xh4","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Helm-Introduction\"><a href=\"#Helm-Introduction\" class=\"headerlink\" title=\"Helm Introduction\"></a>Helm Introduction</h1><h3 id=\"1-Chart的结构\"><a href=\"#1-Chart的结构\" class=\"headerlink\" title=\"1. Chart的结构\"></a>1. Chart的结构</h3><h4 id=\"1-1-什么是chart\"><a href=\"#1-1-什么是chart\" class=\"headerlink\" title=\"1.1. 什么是chart\"></a>1.1. 什么是chart</h4><p>Helm uses a packaging format called charts. A chart is a collection of files that describe a related set of Kubernetes resources.</p>\n<p>Charts are created as files laid out in a particular directory tree, then they can be packaged into versioned archives to be deployed.</p>\n<h4 id=\"1-2-chart的目录结构\"><a href=\"#1-2-chart的目录结构\" class=\"headerlink\" title=\"1.2 chart的目录结构\"></a>1.2 chart的目录结构</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">wordpress/</span></span><br><span class=\"line\">  <span class=\"string\">Chart.yaml</span>            <span class=\"comment\"># A YAML file containing information about the chart -包含chart信息的YAML文件</span></span><br><span class=\"line\">  <span class=\"string\">LICENSE</span>               <span class=\"comment\"># OPTIONAL: A plain text file containing the license for the chart</span></span><br><span class=\"line\">  <span class=\"string\">README.md</span>             <span class=\"comment\"># OPTIONAL: A human-readable README file</span></span><br><span class=\"line\">  <span class=\"string\">requirements.yaml</span>     <span class=\"comment\"># OPTIONAL: A YAML file listing dependencies for the chart  -列出chart依赖关系的YAML文件</span></span><br><span class=\"line\">  <span class=\"string\">values.yaml</span>           <span class=\"comment\"># The default configuration values for this chart  -chart的默认配置值</span></span><br><span class=\"line\">  <span class=\"string\">charts/</span>               <span class=\"comment\"># A directory containing any charts upon which this chart depends.  -包含chart所依赖的所有chart的目录</span></span><br><span class=\"line\">  <span class=\"string\">templates/</span>            <span class=\"comment\"># A directory of templates that, when combined with values,  -模板目录，生成有效的k8s清单文件</span></span><br><span class=\"line\">                        <span class=\"comment\"># will generate valid Kubernetes manifest files.</span></span><br><span class=\"line\">  <span class=\"string\">templates/NOTES.txt</span>   <span class=\"comment\"># OPTIONAL: A plain text file containing short usage notes</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-chart-yaml文件\"><a href=\"#1-3-chart-yaml文件\" class=\"headerlink\" title=\"1.3 chart.yaml文件\"></a>1.3 chart.yaml文件</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">The</span> <span class=\"string\">chart</span> <span class=\"string\">API</span> <span class=\"string\">version,</span> <span class=\"string\">always</span> <span class=\"string\">&quot;v1&quot;</span> <span class=\"string\">(required)</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">The</span> <span class=\"string\">name</span> <span class=\"string\">of</span> <span class=\"string\">the</span> <span class=\"string\">chart</span> <span class=\"string\">(required)</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">A</span> <span class=\"string\">SemVer</span> <span class=\"number\">2</span> <span class=\"string\">version</span> <span class=\"string\">(required)</span></span><br><span class=\"line\"><span class=\"attr\">kubeVersion:</span> <span class=\"string\">A</span> <span class=\"string\">SemVer</span> <span class=\"string\">range</span> <span class=\"string\">of</span> <span class=\"string\">compatible</span> <span class=\"string\">Kubernetes</span> <span class=\"string\">versions</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">A</span> <span class=\"string\">single-sentence</span> <span class=\"string\">description</span> <span class=\"string\">of</span> <span class=\"string\">this</span> <span class=\"string\">project</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">A</span> <span class=\"string\">list</span> <span class=\"string\">of</span> <span class=\"string\">keywords</span> <span class=\"string\">about</span> <span class=\"string\">this</span> <span class=\"string\">project</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">home:</span> <span class=\"string\">The</span> <span class=\"string\">URL</span> <span class=\"string\">of</span> <span class=\"string\">this</span> <span class=\"string\">project&#x27;s</span> <span class=\"string\">home</span> <span class=\"string\">page</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">sources:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">A</span> <span class=\"string\">list</span> <span class=\"string\">of</span> <span class=\"string\">URLs</span> <span class=\"string\">to</span> <span class=\"string\">source</span> <span class=\"string\">code</span> <span class=\"string\">for</span> <span class=\"string\">this</span> <span class=\"string\">project</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">maintainers:</span> <span class=\"comment\"># (optional)</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">The</span> <span class=\"string\">maintainer&#x27;s</span> <span class=\"string\">name</span> <span class=\"string\">(required</span> <span class=\"string\">for</span> <span class=\"string\">each</span> <span class=\"string\">maintainer)</span></span><br><span class=\"line\">    <span class=\"attr\">email:</span> <span class=\"string\">The</span> <span class=\"string\">maintainer&#x27;s</span> <span class=\"string\">email</span> <span class=\"string\">(optional</span> <span class=\"string\">for</span> <span class=\"string\">each</span> <span class=\"string\">maintainer)</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">A</span> <span class=\"string\">URL</span> <span class=\"string\">for</span> <span class=\"string\">the</span> <span class=\"string\">maintainer</span> <span class=\"string\">(optional</span> <span class=\"string\">for</span> <span class=\"string\">each</span> <span class=\"string\">maintainer)</span></span><br><span class=\"line\"><span class=\"attr\">engine:</span> <span class=\"string\">gotpl</span> <span class=\"comment\"># The name of the template engine (optional, defaults to gotpl)</span></span><br><span class=\"line\"><span class=\"attr\">icon:</span> <span class=\"string\">A</span> <span class=\"string\">URL</span> <span class=\"string\">to</span> <span class=\"string\">an</span> <span class=\"string\">SVG</span> <span class=\"string\">or</span> <span class=\"string\">PNG</span> <span class=\"string\">image</span> <span class=\"string\">to</span> <span class=\"string\">be</span> <span class=\"string\">used</span> <span class=\"string\">as</span> <span class=\"string\">an</span> <span class=\"string\">icon</span> <span class=\"string\">(optional).</span></span><br><span class=\"line\"><span class=\"attr\">appVersion:</span> <span class=\"string\">The</span> <span class=\"string\">version</span> <span class=\"string\">of</span> <span class=\"string\">the</span> <span class=\"string\">app</span> <span class=\"string\">that</span> <span class=\"string\">this</span> <span class=\"string\">contains</span> <span class=\"string\">(optional).</span> <span class=\"string\">This</span> <span class=\"string\">needn&#x27;t</span> <span class=\"string\">be</span> <span class=\"string\">SemVer.</span></span><br><span class=\"line\"><span class=\"attr\">deprecated:</span> <span class=\"string\">Whether</span> <span class=\"string\">this</span> <span class=\"string\">chart</span> <span class=\"string\">is</span> <span class=\"string\">deprecated</span> <span class=\"string\">(optional,</span> <span class=\"string\">boolean)</span></span><br><span class=\"line\"><span class=\"attr\">tillerVersion:</span> <span class=\"string\">The</span> <span class=\"string\">version</span> <span class=\"string\">of</span> <span class=\"string\">Tiller</span> <span class=\"string\">that</span> <span class=\"string\">this</span> <span class=\"string\">chart</span> <span class=\"string\">requires.</span> <span class=\"string\">This</span> <span class=\"string\">should</span> <span class=\"string\">be</span> <span class=\"string\">expressed</span> <span class=\"string\">as</span> <span class=\"string\">a</span> <span class=\"string\">SemVer</span> </span><br></pre></td></tr></table></figure>\n<p>一个例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">appVersion:</span> <span class=\"string\">&quot;1.0&quot;</span>   <span class=\"comment\">#这是指定应用程序版本的一种方式</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">A</span> <span class=\"string\">Helm</span> <span class=\"string\">chart</span> <span class=\"string\">for</span> <span class=\"string\">Kubernetes</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">up</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"number\">1.5</span><span class=\"number\">.0</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><p>   Every chart must have a <strong>version number</strong>. A version must follow the <a href=\"http://semver.org/\">SemVer 2</a> standard. Unlike Helm Classic, Kubernetes Helm uses version numbers as release markers. Packages in repositories are identified by name plus version.</p>\n</li>\n<li><p>   Note that the <strong>appVersion</strong> field is not related to the version field. It is a way of specifying the version of the application.</p>\n</li>\n<li><p>   When managing charts in a Chart Repository, it is sometimes necessary to deprecate a chart. The optional deprecated field in Chart.yaml can be used to mark a chart as deprecated. If the latest version of a chart in the repository is marked as deprecated, then the chart as a whole is considered to be deprecated.</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"1-4-requirements-yaml\"><a href=\"#1-4-requirements-yaml\" class=\"headerlink\" title=\"1.4 requirements.yaml\"></a>1.4 requirements.yaml</h4><p>These dependencies can be dynamically linked through the requirements.yaml file or brought in to the charts/directory and managed manually. </p>\n<p>依赖关系可以通过requirements.yaml文件动态链接，也可以引入charts/directory并手动进行管理</p>\n<p>And the preferred method of declaring dependencies is by using a requirements.yaml file inside of your chart.</p>\n<p>声明依赖关系的首选方法是使用图表内部的requirements.yaml文件。</p>\n<p>一个例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dependencies:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">apache</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">1.2</span><span class=\"number\">.3</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">http://example.com/charts</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mysql</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">3.2</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">http://another.example.com/charts</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"attr\">condition:</span> <span class=\"string\">subchart1.enabled,</span> <span class=\"string\">global.</span> <span class=\"string\">subchart1.enabled</span></span><br><span class=\"line\">    <span class=\"attr\">tags:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">front-end</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">subchart1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>The <strong>name</strong> field is the name of the chart you want. </p>\n</li>\n<li><p>The <strong>version</strong> field is the version of the chart you want.</p>\n<blockquote>\n<p>Where possible, use version ranges instead of an exact version. </p>\n</blockquote>\n<ul>\n<li><p>Example of a patch-level version match:</p>\n<p>  version: ~1.2.3</p>\n<p>  This will match version 1.2.3 and any patches to that release. In other words, ~1.2.3 is equivalent to &gt;= 1.2.3, &lt; 1.3.0</p>\n</li>\n<li><p>Example of a minor-level version match:</p>\n<p>  version: ^1.2.0</p>\n<p>  This will match version 1.2.0 and any minor version increments from it. In other words, ~1.2.0 is equivalent to &gt;= 1.2.0, &lt; 2.0.0</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>​    More information available at <a href=\"https://v2.helm.sh/docs/chart_best_practices/#requirements-files\">https://v2.helm.sh/docs/chart_best_practices/#requirements-files</a></p>\n</blockquote>\n<ul>\n<li><p>The <strong>repository</strong> field is the full URL to the chart repository. Note that you must also use helm repo add to add that repo locally. It’s a <strong>mandatory</strong> field.</p>\n</li>\n<li><p><strong>condition</strong> - The condition field holds one or more YAML paths (delimited by commas). 条件字段包含一个或多个YAML路径（以逗号分隔）。</p>\n<p>  If this path exists in the top parent’s values and resolves to a Boolean value, the chart will be enabled or disabled based on that Boolean value. </p>\n<p>  Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect.</p>\n<p>  如果此路径存在于父级的最高值中并且解析为布尔值，则将基于该布尔值启用或禁用图表。<br>  仅评估列表中找到的第一个有效路径，如果不存在路径，则该条件无效</p>\n</li>\n<li><p><strong>tags</strong> - The tags field is a YAML list of labels to associate with this chart.  标签字段是与该图表关联的YAML标签列表。</p>\n<p>  In the top parent’s values, all charts with tags can be enabled or disabled by specifying the tag and a Boolean value.</p>\n<p>  在最高父级的值中，可以通过指定标签和布尔值来启用或禁用所有带有标签的图表。</p>\n</li>\n</ul>\n<blockquote>\n<p>•    Conditions (when set in values) always override tags.   <!--这个怎么理解-->？</p>\n<p>•    The first condition path that exists wins and subsequent ones for that chart are ignored. </p>\n<p>•    Tags are evaluated as ‘if any of the chart’s tags are true then enable the chart’.</p>\n<p>•    Tags and conditions values must be set in the top parent’s values. 标签和条件值必须设置在父级的最高值中。</p>\n<p>•    The tags: key in values must be a top level key. Global and nested tags: tables are not currently supported.</p>\n</blockquote>\n<p>Once you have a dependencies file, you can run <em>helm dependency update</em> and it will use your dependency file to download all the specified charts into your charts/ directory for you.</p>\n<h4 id=\"1-5-Template-file\"><a href=\"#1-5-Template-file\" class=\"headerlink\" title=\"1.5 Template file\"></a>1.5 Template file</h4><p>All template files are stored in a chart’s templates/ folder. When Helm renders the charts, it will pass every file in that directory through the template engine. 通过模板引擎传递该目录中的每个文件。</p>\n<p>Values for the templates are supplied two ways:</p>\n<ul>\n<li><p>Chart developers may supply a file called values.yaml inside of a chart. This file can contain <strong>default values</strong>.</p>\n</li>\n<li><p>Chart users may supply a YAML file that contains values. This can be provided on the command line with helm install.</p>\n</li>\n</ul>\n<p>When a user supplies custom values, these values will override the values in the chart’s <strong>values.yaml</strong> file.</p>\n<p>当用户提供自定义值时，这些值将覆盖图表的values.yaml 文件中的值。</p>\n<p>Below is an example template files for a Kubernetes replication controller:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ReplicationController</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">deis</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app.kubernetes.io/managed-by:</span> <span class=\"string\">deis</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app.kubernetes.io/name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app.kubernetes.io/name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">serviceAccount:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> &#123;&#123;<span class=\"string\">.Values.imageRegistry</span>&#125;&#125;<span class=\"string\">/postgres:&#123;&#123;.Values.dockerTag&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> &#123;&#123;<span class=\"string\">.Values.pullPolicy</span>&#125;&#125;</span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">5432</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">DATABASE_STORAGE</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> &#123;&#123;<span class=\"string\">default</span> <span class=\"string\">&quot;minio&quot;</span> <span class=\"string\">.Values.storage</span>&#125;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>It can use the following four template values (usually defined in a values.yaml file):</p>\n<ul>\n<li><p><strong>imageRegistry</strong>: The source registry for the Docker image.</p>\n</li>\n<li><p><strong>dockerTag</strong>: The tag for the docker image.</p>\n</li>\n<li><p><strong>pullPolicy</strong>: The Kubernetes pull policy.</p>\n</li>\n<li><p><strong>storage</strong>: The storage backend, whose default is set to “minio”</p>\n</li>\n</ul>\n<p>All of these values are defined by the template author. Helm does not require or dictate parameters.</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Helm-Introduction\"><a href=\"#Helm-Introduction\" class=\"headerlink\" title=\"Helm Introduction\"></a>Helm Introduction</h1><h3 id=\"1-Chart的结构\"><a href=\"#1-Chart的结构\" class=\"headerlink\" title=\"1. Chart的结构\"></a>1. Chart的结构</h3><h4 id=\"1-1-什么是chart\"><a href=\"#1-1-什么是chart\" class=\"headerlink\" title=\"1.1. 什么是chart\"></a>1.1. 什么是chart</h4><p>Helm uses a packaging format called charts. A chart is a collection of files that describe a related set of Kubernetes resources.</p>\n<p>Charts are created as files laid out in a particular directory tree, then they can be packaged into versioned archives to be deployed.</p>\n<h4 id=\"1-2-chart的目录结构\"><a href=\"#1-2-chart的目录结构\" class=\"headerlink\" title=\"1.2 chart的目录结构\"></a>1.2 chart的目录结构</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">wordpress/</span></span><br><span class=\"line\">  <span class=\"string\">Chart.yaml</span>            <span class=\"comment\"># A YAML file containing information about the chart -包含chart信息的YAML文件</span></span><br><span class=\"line\">  <span class=\"string\">LICENSE</span>               <span class=\"comment\"># OPTIONAL: A plain text file containing the license for the chart</span></span><br><span class=\"line\">  <span class=\"string\">README.md</span>             <span class=\"comment\"># OPTIONAL: A human-readable README file</span></span><br><span class=\"line\">  <span class=\"string\">requirements.yaml</span>     <span class=\"comment\"># OPTIONAL: A YAML file listing dependencies for the chart  -列出chart依赖关系的YAML文件</span></span><br><span class=\"line\">  <span class=\"string\">values.yaml</span>           <span class=\"comment\"># The default configuration values for this chart  -chart的默认配置值</span></span><br><span class=\"line\">  <span class=\"string\">charts/</span>               <span class=\"comment\"># A directory containing any charts upon which this chart depends.  -包含chart所依赖的所有chart的目录</span></span><br><span class=\"line\">  <span class=\"string\">templates/</span>            <span class=\"comment\"># A directory of templates that, when combined with values,  -模板目录，生成有效的k8s清单文件</span></span><br><span class=\"line\">                        <span class=\"comment\"># will generate valid Kubernetes manifest files.</span></span><br><span class=\"line\">  <span class=\"string\">templates/NOTES.txt</span>   <span class=\"comment\"># OPTIONAL: A plain text file containing short usage notes</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"1-3-chart-yaml文件\"><a href=\"#1-3-chart-yaml文件\" class=\"headerlink\" title=\"1.3 chart.yaml文件\"></a>1.3 chart.yaml文件</h4><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">The</span> <span class=\"string\">chart</span> <span class=\"string\">API</span> <span class=\"string\">version,</span> <span class=\"string\">always</span> <span class=\"string\">&quot;v1&quot;</span> <span class=\"string\">(required)</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">The</span> <span class=\"string\">name</span> <span class=\"string\">of</span> <span class=\"string\">the</span> <span class=\"string\">chart</span> <span class=\"string\">(required)</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">A</span> <span class=\"string\">SemVer</span> <span class=\"number\">2</span> <span class=\"string\">version</span> <span class=\"string\">(required)</span></span><br><span class=\"line\"><span class=\"attr\">kubeVersion:</span> <span class=\"string\">A</span> <span class=\"string\">SemVer</span> <span class=\"string\">range</span> <span class=\"string\">of</span> <span class=\"string\">compatible</span> <span class=\"string\">Kubernetes</span> <span class=\"string\">versions</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">A</span> <span class=\"string\">single-sentence</span> <span class=\"string\">description</span> <span class=\"string\">of</span> <span class=\"string\">this</span> <span class=\"string\">project</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">keywords:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">A</span> <span class=\"string\">list</span> <span class=\"string\">of</span> <span class=\"string\">keywords</span> <span class=\"string\">about</span> <span class=\"string\">this</span> <span class=\"string\">project</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">home:</span> <span class=\"string\">The</span> <span class=\"string\">URL</span> <span class=\"string\">of</span> <span class=\"string\">this</span> <span class=\"string\">project&#x27;s</span> <span class=\"string\">home</span> <span class=\"string\">page</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">sources:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"string\">A</span> <span class=\"string\">list</span> <span class=\"string\">of</span> <span class=\"string\">URLs</span> <span class=\"string\">to</span> <span class=\"string\">source</span> <span class=\"string\">code</span> <span class=\"string\">for</span> <span class=\"string\">this</span> <span class=\"string\">project</span> <span class=\"string\">(optional)</span></span><br><span class=\"line\"><span class=\"attr\">maintainers:</span> <span class=\"comment\"># (optional)</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">The</span> <span class=\"string\">maintainer&#x27;s</span> <span class=\"string\">name</span> <span class=\"string\">(required</span> <span class=\"string\">for</span> <span class=\"string\">each</span> <span class=\"string\">maintainer)</span></span><br><span class=\"line\">    <span class=\"attr\">email:</span> <span class=\"string\">The</span> <span class=\"string\">maintainer&#x27;s</span> <span class=\"string\">email</span> <span class=\"string\">(optional</span> <span class=\"string\">for</span> <span class=\"string\">each</span> <span class=\"string\">maintainer)</span></span><br><span class=\"line\">    <span class=\"attr\">url:</span> <span class=\"string\">A</span> <span class=\"string\">URL</span> <span class=\"string\">for</span> <span class=\"string\">the</span> <span class=\"string\">maintainer</span> <span class=\"string\">(optional</span> <span class=\"string\">for</span> <span class=\"string\">each</span> <span class=\"string\">maintainer)</span></span><br><span class=\"line\"><span class=\"attr\">engine:</span> <span class=\"string\">gotpl</span> <span class=\"comment\"># The name of the template engine (optional, defaults to gotpl)</span></span><br><span class=\"line\"><span class=\"attr\">icon:</span> <span class=\"string\">A</span> <span class=\"string\">URL</span> <span class=\"string\">to</span> <span class=\"string\">an</span> <span class=\"string\">SVG</span> <span class=\"string\">or</span> <span class=\"string\">PNG</span> <span class=\"string\">image</span> <span class=\"string\">to</span> <span class=\"string\">be</span> <span class=\"string\">used</span> <span class=\"string\">as</span> <span class=\"string\">an</span> <span class=\"string\">icon</span> <span class=\"string\">(optional).</span></span><br><span class=\"line\"><span class=\"attr\">appVersion:</span> <span class=\"string\">The</span> <span class=\"string\">version</span> <span class=\"string\">of</span> <span class=\"string\">the</span> <span class=\"string\">app</span> <span class=\"string\">that</span> <span class=\"string\">this</span> <span class=\"string\">contains</span> <span class=\"string\">(optional).</span> <span class=\"string\">This</span> <span class=\"string\">needn&#x27;t</span> <span class=\"string\">be</span> <span class=\"string\">SemVer.</span></span><br><span class=\"line\"><span class=\"attr\">deprecated:</span> <span class=\"string\">Whether</span> <span class=\"string\">this</span> <span class=\"string\">chart</span> <span class=\"string\">is</span> <span class=\"string\">deprecated</span> <span class=\"string\">(optional,</span> <span class=\"string\">boolean)</span></span><br><span class=\"line\"><span class=\"attr\">tillerVersion:</span> <span class=\"string\">The</span> <span class=\"string\">version</span> <span class=\"string\">of</span> <span class=\"string\">Tiller</span> <span class=\"string\">that</span> <span class=\"string\">this</span> <span class=\"string\">chart</span> <span class=\"string\">requires.</span> <span class=\"string\">This</span> <span class=\"string\">should</span> <span class=\"string\">be</span> <span class=\"string\">expressed</span> <span class=\"string\">as</span> <span class=\"string\">a</span> <span class=\"string\">SemVer</span> </span><br></pre></td></tr></table></figure>\n<p>一个例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">appVersion:</span> <span class=\"string\">&quot;1.0&quot;</span>   <span class=\"comment\">#这是指定应用程序版本的一种方式</span></span><br><span class=\"line\"><span class=\"attr\">description:</span> <span class=\"string\">A</span> <span class=\"string\">Helm</span> <span class=\"string\">chart</span> <span class=\"string\">for</span> <span class=\"string\">Kubernetes</span></span><br><span class=\"line\"><span class=\"attr\">name:</span> <span class=\"string\">up</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"number\">1.5</span><span class=\"number\">.0</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><p>   Every chart must have a <strong>version number</strong>. A version must follow the <a href=\"http://semver.org/\">SemVer 2</a> standard. Unlike Helm Classic, Kubernetes Helm uses version numbers as release markers. Packages in repositories are identified by name plus version.</p>\n</li>\n<li><p>   Note that the <strong>appVersion</strong> field is not related to the version field. It is a way of specifying the version of the application.</p>\n</li>\n<li><p>   When managing charts in a Chart Repository, it is sometimes necessary to deprecate a chart. The optional deprecated field in Chart.yaml can be used to mark a chart as deprecated. If the latest version of a chart in the repository is marked as deprecated, then the chart as a whole is considered to be deprecated.</p>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"1-4-requirements-yaml\"><a href=\"#1-4-requirements-yaml\" class=\"headerlink\" title=\"1.4 requirements.yaml\"></a>1.4 requirements.yaml</h4><p>These dependencies can be dynamically linked through the requirements.yaml file or brought in to the charts/directory and managed manually. </p>\n<p>依赖关系可以通过requirements.yaml文件动态链接，也可以引入charts/directory并手动进行管理</p>\n<p>And the preferred method of declaring dependencies is by using a requirements.yaml file inside of your chart.</p>\n<p>声明依赖关系的首选方法是使用图表内部的requirements.yaml文件。</p>\n<p>一个例子：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dependencies:</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">apache</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">1.2</span><span class=\"number\">.3</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">http://example.com/charts</span></span><br><span class=\"line\">  <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">mysql</span></span><br><span class=\"line\">    <span class=\"attr\">version:</span> <span class=\"number\">3.2</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">repository:</span> <span class=\"string\">http://another.example.com/charts</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"attr\">condition:</span> <span class=\"string\">subchart1.enabled,</span> <span class=\"string\">global.</span> <span class=\"string\">subchart1.enabled</span></span><br><span class=\"line\">    <span class=\"attr\">tags:</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">front-end</span></span><br><span class=\"line\">      <span class=\"bullet\">-</span> <span class=\"string\">subchart1</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>The <strong>name</strong> field is the name of the chart you want. </p>\n</li>\n<li><p>The <strong>version</strong> field is the version of the chart you want.</p>\n<blockquote>\n<p>Where possible, use version ranges instead of an exact version. </p>\n</blockquote>\n<ul>\n<li><p>Example of a patch-level version match:</p>\n<p>  version: ~1.2.3</p>\n<p>  This will match version 1.2.3 and any patches to that release. In other words, ~1.2.3 is equivalent to &gt;= 1.2.3, &lt; 1.3.0</p>\n</li>\n<li><p>Example of a minor-level version match:</p>\n<p>  version: ^1.2.0</p>\n<p>  This will match version 1.2.0 and any minor version increments from it. In other words, ~1.2.0 is equivalent to &gt;= 1.2.0, &lt; 2.0.0</p>\n</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>​    More information available at <a href=\"https://v2.helm.sh/docs/chart_best_practices/#requirements-files\">https://v2.helm.sh/docs/chart_best_practices/#requirements-files</a></p>\n</blockquote>\n<ul>\n<li><p>The <strong>repository</strong> field is the full URL to the chart repository. Note that you must also use helm repo add to add that repo locally. It’s a <strong>mandatory</strong> field.</p>\n</li>\n<li><p><strong>condition</strong> - The condition field holds one or more YAML paths (delimited by commas). 条件字段包含一个或多个YAML路径（以逗号分隔）。</p>\n<p>  If this path exists in the top parent’s values and resolves to a Boolean value, the chart will be enabled or disabled based on that Boolean value. </p>\n<p>  Only the first valid path found in the list is evaluated and if no paths exist then the condition has no effect.</p>\n<p>  如果此路径存在于父级的最高值中并且解析为布尔值，则将基于该布尔值启用或禁用图表。<br>  仅评估列表中找到的第一个有效路径，如果不存在路径，则该条件无效</p>\n</li>\n<li><p><strong>tags</strong> - The tags field is a YAML list of labels to associate with this chart.  标签字段是与该图表关联的YAML标签列表。</p>\n<p>  In the top parent’s values, all charts with tags can be enabled or disabled by specifying the tag and a Boolean value.</p>\n<p>  在最高父级的值中，可以通过指定标签和布尔值来启用或禁用所有带有标签的图表。</p>\n</li>\n</ul>\n<blockquote>\n<p>•    Conditions (when set in values) always override tags.   <!--这个怎么理解-->？</p>\n<p>•    The first condition path that exists wins and subsequent ones for that chart are ignored. </p>\n<p>•    Tags are evaluated as ‘if any of the chart’s tags are true then enable the chart’.</p>\n<p>•    Tags and conditions values must be set in the top parent’s values. 标签和条件值必须设置在父级的最高值中。</p>\n<p>•    The tags: key in values must be a top level key. Global and nested tags: tables are not currently supported.</p>\n</blockquote>\n<p>Once you have a dependencies file, you can run <em>helm dependency update</em> and it will use your dependency file to download all the specified charts into your charts/ directory for you.</p>\n<h4 id=\"1-5-Template-file\"><a href=\"#1-5-Template-file\" class=\"headerlink\" title=\"1.5 Template file\"></a>1.5 Template file</h4><p>All template files are stored in a chart’s templates/ folder. When Helm renders the charts, it will pass every file in that directory through the template engine. 通过模板引擎传递该目录中的每个文件。</p>\n<p>Values for the templates are supplied two ways:</p>\n<ul>\n<li><p>Chart developers may supply a file called values.yaml inside of a chart. This file can contain <strong>default values</strong>.</p>\n</li>\n<li><p>Chart users may supply a YAML file that contains values. This can be provided on the command line with helm install.</p>\n</li>\n</ul>\n<p>When a user supplies custom values, these values will override the values in the chart’s <strong>values.yaml</strong> file.</p>\n<p>当用户提供自定义值时，这些值将覆盖图表的values.yaml 文件中的值。</p>\n<p>Below is an example template files for a Kubernetes replication controller:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">apiVersion:</span> <span class=\"string\">v1</span></span><br><span class=\"line\"><span class=\"attr\">kind:</span> <span class=\"string\">ReplicationController</span></span><br><span class=\"line\"><span class=\"attr\">metadata:</span></span><br><span class=\"line\">  <span class=\"attr\">name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">  <span class=\"attr\">namespace:</span> <span class=\"string\">deis</span></span><br><span class=\"line\">  <span class=\"attr\">labels:</span></span><br><span class=\"line\">    <span class=\"attr\">app.kubernetes.io/managed-by:</span> <span class=\"string\">deis</span></span><br><span class=\"line\"><span class=\"attr\">spec:</span></span><br><span class=\"line\">  <span class=\"attr\">replicas:</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"attr\">selector:</span></span><br><span class=\"line\">    <span class=\"attr\">app.kubernetes.io/name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">  <span class=\"attr\">template:</span></span><br><span class=\"line\">    <span class=\"attr\">metadata:</span></span><br><span class=\"line\">      <span class=\"attr\">labels:</span></span><br><span class=\"line\">        <span class=\"attr\">app.kubernetes.io/name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">    <span class=\"attr\">spec:</span></span><br><span class=\"line\">      <span class=\"attr\">serviceAccount:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">      <span class=\"attr\">containers:</span></span><br><span class=\"line\">        <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">deis-database</span></span><br><span class=\"line\">          <span class=\"attr\">image:</span> &#123;&#123;<span class=\"string\">.Values.imageRegistry</span>&#125;&#125;<span class=\"string\">/postgres:&#123;&#123;.Values.dockerTag&#125;&#125;</span></span><br><span class=\"line\">          <span class=\"attr\">imagePullPolicy:</span> &#123;&#123;<span class=\"string\">.Values.pullPolicy</span>&#125;&#125;</span><br><span class=\"line\">          <span class=\"attr\">ports:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">containerPort:</span> <span class=\"number\">5432</span></span><br><span class=\"line\">          <span class=\"attr\">env:</span></span><br><span class=\"line\">            <span class=\"bullet\">-</span> <span class=\"attr\">name:</span> <span class=\"string\">DATABASE_STORAGE</span></span><br><span class=\"line\">              <span class=\"attr\">value:</span> &#123;&#123;<span class=\"string\">default</span> <span class=\"string\">&quot;minio&quot;</span> <span class=\"string\">.Values.storage</span>&#125;&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>It can use the following four template values (usually defined in a values.yaml file):</p>\n<ul>\n<li><p><strong>imageRegistry</strong>: The source registry for the Docker image.</p>\n</li>\n<li><p><strong>dockerTag</strong>: The tag for the docker image.</p>\n</li>\n<li><p><strong>pullPolicy</strong>: The Kubernetes pull policy.</p>\n</li>\n<li><p><strong>storage</strong>: The storage backend, whose default is set to “minio”</p>\n</li>\n</ul>\n<p>All of these values are defined by the template author. Helm does not require or dictate parameters.</p>\n"},{"title":"Golang flag包简介","date":"2020-12-31T15:59:00.000Z","abbrlink":14002,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# Golang  flag 包简介\n\n在 Golang 程序中有很多种方法来处理命令行参数。简单的情况下可以不使用任何库，直接处理 os.Args；其实 Golang 的标准库提供了 flag 包来处理命令行参数；还有第三方提供的处理命令行参数的库，比如 Pflag 等。本文将介绍 Golang 标准库中 flag 包的用法。本文的演示环境为 ubuntu 18.04。\n\n## 入门 demo\n\n在 Go workspace 的 src 目录下创建 flagdemo 目录，并在目录下创建 main.go 文件，编辑其内容如下：\n\n```go\npackage main\n\nimport \"flag\"\nimport \"fmt\"\n\n// 定义命令行参数对应的变量，这三个变量都是指针类型\nvar cliName = flag.String(\"name\", \"nick\", \"Input Your Name\")\nvar cliAge = flag.Int(\"age\", 28, \"Input Your Age\")\nvar cliGender = flag.String(\"gender\", \"male\", \"Input Your Gender\")\n\n// 定义一个值类型的命令行参数变量，在 Init() 函数中对其初始化\n// 因此，命令行参数对应变量的定义和初始化是可以分开的\nvar cliFlag int\nfunc Init() {\n    flag.IntVar(&cliFlag, \"flagname\", 1234, \"Just for demo\")\n}\n\nfunc main() {\n    // 初始化变量 cliFlag\n    Init()\n    // 把用户传递的命令行参数解析为对应变量的值\n    flag.Parse()\n    \n    // flag.Args() 函数返回没有被解析的命令行参数\n    // func NArg() 函数返回没有被解析的命令行参数的个数\n    fmt.Printf(\"args=%s, num=%d\\n\", flag.Args(), flag.NArg())\n    for i := 0; i != flag.NArg(); i++ {\n        fmt.Printf(\"arg[%d]=%s\\n\", i, flag.Arg(i))\n    }\n    \n    // 输出命令行参数\n    fmt.Println(\"name=\", *cliName)\n    fmt.Println(\"age=\", *cliAge)\n    fmt.Println(\"gender=\", *cliGender)\n    fmt.Println(\"flagname=\", cliFlag)\n}\n```\n\n使用 flag 包前要通过 import 命令导入该包：\n\n```go\nimport \"flag\"\n```\n\n定义一个整型的参数 age，返回指针类型的变量：\n\n```go\nvar cliAge = flag.Int(\"age\", 28, \"Input Your Age\")\n```\n\n创建值类型的参数变量，并在 Init() 函数中对其初始化(注意这里调用的是 flag.IntVar 方法)：\n\n```go\nvar cliFlag int\nfunc Init() {\n    flag.IntVar(&cliFlag, \"flagname\", 1234, \"Just for demo\")\n}\n```\n\n通过 flag.Parse() 函数接下命令行参数，解析函数将会在碰到第一个非 flag 命令行参数时停止：\n\n```go\nflag.Parse()\n```\n\n命令行传参的格式：\n\n```go\n-isbool    (一个 - 符号，布尔类型该写法等同于 -isbool=true)\n-age=x     (一个 - 符号，使用等号)\n-age x     (一个 - 符号，使用空格)\n--age=x    (两个 - 符号，使用等号)\n--age x    (两个 - 符号，使用空格)\n```\n\n## 运行 demo\n\n在 flagdemo 目录下执行 go build 命令编译 demo 生成可执行文件 flagdemo。\n**不传递命令行参数**\n\n![img](Golang flag包简介/952033-20190505130449855-404730543.png)\n\n此时输出的命令行参数都是定义的默认值。\n\n**传递命令行参数**\n\n![img](Golang flag包简介/952033-20190505130535776-1276148478.png)\n\n传递的命令行参数会覆盖默认值。\n\n**传递多余的命令行参数**\n\n![img](Golang flag包简介/952033-20190505130619082-1720959137.png)\n\n可以通过 flag.Args() 和 flag.NArg() 函数获取未能解析的命令行参数。\n\n**传递错误的命令行参**\n\n![img](Golang flag包简介/952033-20190505130707783-39205152.png)\n\n如果通过 -xx 传入未定义的命令行参数，则会直接报错退出，并输出帮助信息。\n\n**查看帮助信息**\n通过命令行参数 -h 或 --help 可以查看帮助信息：\n\n![img](Golang flag包简介/952033-20190505130753330-702637440.png)\n\n## 解读 flag 包源码\n\nflag 包支持的类型有 Bool、Duration、Float64、Int、Int64、String、Uint、Uint64。这些类型的参数被封装到其对应的后端类型中，比如 Int 类型的参数被封装为 intValue，String 类型的参数被封装为 stringValue。这些后端的类型都实现了 Value 接口，因此可以把一个命令行参数抽象为一个 Flag 类型的实例。下面是 Value 接口和 Flag 类型的代码：\n\n```go\n// Value 接口\ntype Value interface {\n    String() string\n    Set(string) error\n}\n\n// Flag 类型\ntype Flag struct {\n    Name     string // name as it appears on command line\n    Usage    string // help message\n    Value    Value  // value as set 是个 interface，因此可以是不同类型的实例。\n    DefValue string // default value (as text); for usage message\n}\n```\n\nintValue 等类型实现了 Value 接口，因此可以赋值给 Flag 类型中的 Value 字段，下面是 intValue 类型的定义：\n\n```go\n// -- int Value\ntype intValue int\n\nfunc newIntValue(val int, p *int) *intValue {\n    *p = val\n    return (*intValue)(p)\n}\n\nfunc (i *intValue) Set(s string) error {\n    v, err := strconv.ParseInt(s, 0, strconv.IntSize)\n    *i = intValue(v)\n    return err\n}\n\nfunc (i *intValue) Get() interface{} { return int(*i) }\nfunc (i *intValue) String() string { return strconv.Itoa(int(*i)) }\n```\n\n所有的参数被保存在 FlagSet 类型的实例中，FlagSet 类型的定义如下：\n\n```go\n// A FlagSet represents a set of defined flags.\ntype FlagSet struct {\n    Usage func()\n\n    name          string\n    parsed        bool\n    actual         map[string]*Flag    // 中保存从命令行参数中解析到的参数实例\n    formal        map[string]*Flag    // 中保存定义的命令行参数实例(实例中包含了默认值)\n    args          []string // arguments after flags\n    errorHandling ErrorHandling\n    output        io.Writer // nil means stderr; use out() accessor\n}\n```\n\nFlag 包被导入时创建了 FlagSet 类型的对象 CommandLine：\n\n```go\nvar CommandLine = NewFlagSet(os.Args[0], ExitOnError)\n```\n\n在程序中定义的所有命令行参数变量都会被加入到 CommandLine 的 formal 属性中，其具体的调用过程如下：\n\n```go\nvar cliAge = flag.Int(\"age\", 28, \"Input Your Age\")\nfunc Int(name string, value int, usage string) *int {\n    return CommandLine.Int(name, value, usage)\n}\nfunc (f *FlagSet) Int(name string, value int, usage string) *int {\n    p := new(int)\n    f.IntVar(p, name, value, usage)\n    return p\n}\nfunc (f *FlagSet) IntVar(p *int, name string, value int, usage string) {\n    f.Var(newIntValue(value, p), name, usage)\n}\nfunc (f *FlagSet) Var(value Value, name string, usage string) {\n    // Remember the default value as a string; it won't change.\n    flag := &Flag{name, usage, value, value.String()}\n    _, alreadythere := f.formal[name]\n    if alreadythere {\n        var msg string\n        if f.name == \"\" {\n            msg = fmt.Sprintf(\"flag redefined: %s\", name)\n        } else {\n            msg = fmt.Sprintf(\"%s flag redefined: %s\", f.name, name)\n        }\n        fmt.Fprintln(f.Output(), msg)\n        panic(msg) // Happens only if flags are declared with identical names\n    }\n    if f.formal == nil {\n        f.formal = make(map[string]*Flag)\n    }\n    // 把命令行参数对应的变量添加到 formal 中\n    f.formal[name] = flag\n}\n```\n\n命令行参数的解析过程则由 flag.Parse() 函数完成，其调用过程大致如下：\n\n```go\nfunc Parse() {\n    CommandLine.Parse(os.Args[1:])\n}\nfunc (f *FlagSet) Parse(arguments []string) error {\n    f.parsed = true\n    f.args = arguments\n    for {\n        seen, err := f.parseOne()\n        if seen {\n            continue\n        }\n        if err == nil {\n            break\n        }\n        switch f.errorHandling {\n        case ContinueOnError:\n            return err\n        case ExitOnError:\n            os.Exit(2)\n        case PanicOnError:\n            panic(err)\n        }\n    }\n    return nil\n}\n```\n\n最终由 FlagSet 的 parseOne() 方法执行解析任务：\n\n```go\nfunc (f *FlagSet) parseOne() (bool, error) {\n…\nflag.Value.Set(value)\n…\nf.actual[name] = flag\n…\n}\n```\n\n并在解析完成后由 flag.Value.Set 方法把用户传递的命令行参数设置给 flag 实例，最后添加到 FlagSet 的 actual 属性中。\n\n## 总结\n\n本文介绍了 Golang 标准库中 flag 包的基本用法，并进一步分析了其主要的代码逻辑。其实 flag 包还支持用户自定义类型的命令行参数，本文不再赘述，有兴趣的朋友请参考官方 demo。\n\n**参考：**\n[package flag](https://golang.org/pkg/flag/)\n[Go by Example: Command-Line Flags](https://gobyexample.com/command-line-flags)\n[USING COMMAND LINE FLAGS IN GO](https://flaviocopes.com/go-command-line-flags/)\n[Golang之使用Flag和Pflag](https://o-my-chenjian.com/2017/09/20/Using-Flag-And-Pflag-With-Golang/)\n[Go语言学习之flag包(The way to go)](https://blog.csdn.net/wangshubo1989/article/details/72914384?locationNum=14&fps=1)\n[Golang flag demo](https://golang.org/pkg/flag/#example_)","source":"_posts/go_md/Golang flag包简介.md","raw":"---\ntitle: Golang flag包简介\ndate: '2020/12/31 23:59'\ntags:\n - go\ncategories:\n - 学习笔记\nabbrlink: 14002\ncover: \n---\n\n# Golang  flag 包简介\n\n在 Golang 程序中有很多种方法来处理命令行参数。简单的情况下可以不使用任何库，直接处理 os.Args；其实 Golang 的标准库提供了 flag 包来处理命令行参数；还有第三方提供的处理命令行参数的库，比如 Pflag 等。本文将介绍 Golang 标准库中 flag 包的用法。本文的演示环境为 ubuntu 18.04。\n\n## 入门 demo\n\n在 Go workspace 的 src 目录下创建 flagdemo 目录，并在目录下创建 main.go 文件，编辑其内容如下：\n\n```go\npackage main\n\nimport \"flag\"\nimport \"fmt\"\n\n// 定义命令行参数对应的变量，这三个变量都是指针类型\nvar cliName = flag.String(\"name\", \"nick\", \"Input Your Name\")\nvar cliAge = flag.Int(\"age\", 28, \"Input Your Age\")\nvar cliGender = flag.String(\"gender\", \"male\", \"Input Your Gender\")\n\n// 定义一个值类型的命令行参数变量，在 Init() 函数中对其初始化\n// 因此，命令行参数对应变量的定义和初始化是可以分开的\nvar cliFlag int\nfunc Init() {\n    flag.IntVar(&cliFlag, \"flagname\", 1234, \"Just for demo\")\n}\n\nfunc main() {\n    // 初始化变量 cliFlag\n    Init()\n    // 把用户传递的命令行参数解析为对应变量的值\n    flag.Parse()\n    \n    // flag.Args() 函数返回没有被解析的命令行参数\n    // func NArg() 函数返回没有被解析的命令行参数的个数\n    fmt.Printf(\"args=%s, num=%d\\n\", flag.Args(), flag.NArg())\n    for i := 0; i != flag.NArg(); i++ {\n        fmt.Printf(\"arg[%d]=%s\\n\", i, flag.Arg(i))\n    }\n    \n    // 输出命令行参数\n    fmt.Println(\"name=\", *cliName)\n    fmt.Println(\"age=\", *cliAge)\n    fmt.Println(\"gender=\", *cliGender)\n    fmt.Println(\"flagname=\", cliFlag)\n}\n```\n\n使用 flag 包前要通过 import 命令导入该包：\n\n```go\nimport \"flag\"\n```\n\n定义一个整型的参数 age，返回指针类型的变量：\n\n```go\nvar cliAge = flag.Int(\"age\", 28, \"Input Your Age\")\n```\n\n创建值类型的参数变量，并在 Init() 函数中对其初始化(注意这里调用的是 flag.IntVar 方法)：\n\n```go\nvar cliFlag int\nfunc Init() {\n    flag.IntVar(&cliFlag, \"flagname\", 1234, \"Just for demo\")\n}\n```\n\n通过 flag.Parse() 函数接下命令行参数，解析函数将会在碰到第一个非 flag 命令行参数时停止：\n\n```go\nflag.Parse()\n```\n\n命令行传参的格式：\n\n```go\n-isbool    (一个 - 符号，布尔类型该写法等同于 -isbool=true)\n-age=x     (一个 - 符号，使用等号)\n-age x     (一个 - 符号，使用空格)\n--age=x    (两个 - 符号，使用等号)\n--age x    (两个 - 符号，使用空格)\n```\n\n## 运行 demo\n\n在 flagdemo 目录下执行 go build 命令编译 demo 生成可执行文件 flagdemo。\n**不传递命令行参数**\n\n![img](Golang flag包简介/952033-20190505130449855-404730543.png)\n\n此时输出的命令行参数都是定义的默认值。\n\n**传递命令行参数**\n\n![img](Golang flag包简介/952033-20190505130535776-1276148478.png)\n\n传递的命令行参数会覆盖默认值。\n\n**传递多余的命令行参数**\n\n![img](Golang flag包简介/952033-20190505130619082-1720959137.png)\n\n可以通过 flag.Args() 和 flag.NArg() 函数获取未能解析的命令行参数。\n\n**传递错误的命令行参**\n\n![img](Golang flag包简介/952033-20190505130707783-39205152.png)\n\n如果通过 -xx 传入未定义的命令行参数，则会直接报错退出，并输出帮助信息。\n\n**查看帮助信息**\n通过命令行参数 -h 或 --help 可以查看帮助信息：\n\n![img](Golang flag包简介/952033-20190505130753330-702637440.png)\n\n## 解读 flag 包源码\n\nflag 包支持的类型有 Bool、Duration、Float64、Int、Int64、String、Uint、Uint64。这些类型的参数被封装到其对应的后端类型中，比如 Int 类型的参数被封装为 intValue，String 类型的参数被封装为 stringValue。这些后端的类型都实现了 Value 接口，因此可以把一个命令行参数抽象为一个 Flag 类型的实例。下面是 Value 接口和 Flag 类型的代码：\n\n```go\n// Value 接口\ntype Value interface {\n    String() string\n    Set(string) error\n}\n\n// Flag 类型\ntype Flag struct {\n    Name     string // name as it appears on command line\n    Usage    string // help message\n    Value    Value  // value as set 是个 interface，因此可以是不同类型的实例。\n    DefValue string // default value (as text); for usage message\n}\n```\n\nintValue 等类型实现了 Value 接口，因此可以赋值给 Flag 类型中的 Value 字段，下面是 intValue 类型的定义：\n\n```go\n// -- int Value\ntype intValue int\n\nfunc newIntValue(val int, p *int) *intValue {\n    *p = val\n    return (*intValue)(p)\n}\n\nfunc (i *intValue) Set(s string) error {\n    v, err := strconv.ParseInt(s, 0, strconv.IntSize)\n    *i = intValue(v)\n    return err\n}\n\nfunc (i *intValue) Get() interface{} { return int(*i) }\nfunc (i *intValue) String() string { return strconv.Itoa(int(*i)) }\n```\n\n所有的参数被保存在 FlagSet 类型的实例中，FlagSet 类型的定义如下：\n\n```go\n// A FlagSet represents a set of defined flags.\ntype FlagSet struct {\n    Usage func()\n\n    name          string\n    parsed        bool\n    actual         map[string]*Flag    // 中保存从命令行参数中解析到的参数实例\n    formal        map[string]*Flag    // 中保存定义的命令行参数实例(实例中包含了默认值)\n    args          []string // arguments after flags\n    errorHandling ErrorHandling\n    output        io.Writer // nil means stderr; use out() accessor\n}\n```\n\nFlag 包被导入时创建了 FlagSet 类型的对象 CommandLine：\n\n```go\nvar CommandLine = NewFlagSet(os.Args[0], ExitOnError)\n```\n\n在程序中定义的所有命令行参数变量都会被加入到 CommandLine 的 formal 属性中，其具体的调用过程如下：\n\n```go\nvar cliAge = flag.Int(\"age\", 28, \"Input Your Age\")\nfunc Int(name string, value int, usage string) *int {\n    return CommandLine.Int(name, value, usage)\n}\nfunc (f *FlagSet) Int(name string, value int, usage string) *int {\n    p := new(int)\n    f.IntVar(p, name, value, usage)\n    return p\n}\nfunc (f *FlagSet) IntVar(p *int, name string, value int, usage string) {\n    f.Var(newIntValue(value, p), name, usage)\n}\nfunc (f *FlagSet) Var(value Value, name string, usage string) {\n    // Remember the default value as a string; it won't change.\n    flag := &Flag{name, usage, value, value.String()}\n    _, alreadythere := f.formal[name]\n    if alreadythere {\n        var msg string\n        if f.name == \"\" {\n            msg = fmt.Sprintf(\"flag redefined: %s\", name)\n        } else {\n            msg = fmt.Sprintf(\"%s flag redefined: %s\", f.name, name)\n        }\n        fmt.Fprintln(f.Output(), msg)\n        panic(msg) // Happens only if flags are declared with identical names\n    }\n    if f.formal == nil {\n        f.formal = make(map[string]*Flag)\n    }\n    // 把命令行参数对应的变量添加到 formal 中\n    f.formal[name] = flag\n}\n```\n\n命令行参数的解析过程则由 flag.Parse() 函数完成，其调用过程大致如下：\n\n```go\nfunc Parse() {\n    CommandLine.Parse(os.Args[1:])\n}\nfunc (f *FlagSet) Parse(arguments []string) error {\n    f.parsed = true\n    f.args = arguments\n    for {\n        seen, err := f.parseOne()\n        if seen {\n            continue\n        }\n        if err == nil {\n            break\n        }\n        switch f.errorHandling {\n        case ContinueOnError:\n            return err\n        case ExitOnError:\n            os.Exit(2)\n        case PanicOnError:\n            panic(err)\n        }\n    }\n    return nil\n}\n```\n\n最终由 FlagSet 的 parseOne() 方法执行解析任务：\n\n```go\nfunc (f *FlagSet) parseOne() (bool, error) {\n…\nflag.Value.Set(value)\n…\nf.actual[name] = flag\n…\n}\n```\n\n并在解析完成后由 flag.Value.Set 方法把用户传递的命令行参数设置给 flag 实例，最后添加到 FlagSet 的 actual 属性中。\n\n## 总结\n\n本文介绍了 Golang 标准库中 flag 包的基本用法，并进一步分析了其主要的代码逻辑。其实 flag 包还支持用户自定义类型的命令行参数，本文不再赘述，有兴趣的朋友请参考官方 demo。\n\n**参考：**\n[package flag](https://golang.org/pkg/flag/)\n[Go by Example: Command-Line Flags](https://gobyexample.com/command-line-flags)\n[USING COMMAND LINE FLAGS IN GO](https://flaviocopes.com/go-command-line-flags/)\n[Golang之使用Flag和Pflag](https://o-my-chenjian.com/2017/09/20/Using-Flag-And-Pflag-With-Golang/)\n[Go语言学习之flag包(The way to go)](https://blog.csdn.net/wangshubo1989/article/details/72914384?locationNum=14&fps=1)\n[Golang flag demo](https://golang.org/pkg/flag/#example_)","slug":"go_md/Golang flag包简介","published":1,"updated":"2021-04-09T12:49:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5q000bw9q9cwzkh50f","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Golang-flag-包简介\"><a href=\"#Golang-flag-包简介\" class=\"headerlink\" title=\"Golang  flag 包简介\"></a>Golang  flag 包简介</h1><p>在 Golang 程序中有很多种方法来处理命令行参数。简单的情况下可以不使用任何库，直接处理 os.Args；其实 Golang 的标准库提供了 flag 包来处理命令行参数；还有第三方提供的处理命令行参数的库，比如 Pflag 等。本文将介绍 Golang 标准库中 flag 包的用法。本文的演示环境为 ubuntu 18.04。</p>\n<h2 id=\"入门-demo\"><a href=\"#入门-demo\" class=\"headerlink\" title=\"入门 demo\"></a>入门 demo</h2><p>在 Go workspace 的 src 目录下创建 flagdemo 目录，并在目录下创建 main.go 文件，编辑其内容如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;flag&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义命令行参数对应的变量，这三个变量都是指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cliName = flag.String(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;nick&quot;</span>, <span class=\"string\">&quot;Input Your Name&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> cliAge = flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>, <span class=\"string\">&quot;Input Your Age&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> cliGender = flag.String(<span class=\"string\">&quot;gender&quot;</span>, <span class=\"string\">&quot;male&quot;</span>, <span class=\"string\">&quot;Input Your Gender&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个值类型的命令行参数变量，在 Init() 函数中对其初始化</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，命令行参数对应变量的定义和初始化是可以分开的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cliFlag <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    flag.IntVar(&amp;cliFlag, <span class=\"string\">&quot;flagname&quot;</span>, <span class=\"number\">1234</span>, <span class=\"string\">&quot;Just for demo&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化变量 cliFlag</span></span><br><span class=\"line\">    Init()</span><br><span class=\"line\">    <span class=\"comment\">// 把用户传递的命令行参数解析为对应变量的值</span></span><br><span class=\"line\">    flag.Parse()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// flag.Args() 函数返回没有被解析的命令行参数</span></span><br><span class=\"line\">    <span class=\"comment\">// func NArg() 函数返回没有被解析的命令行参数的个数</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;args=%s, num=%d\\n&quot;</span>, flag.Args(), flag.NArg())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i != flag.NArg(); i++ &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;arg[%d]=%s\\n&quot;</span>, i, flag.Arg(i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 输出命令行参数</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;name=&quot;</span>, *cliName)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;age=&quot;</span>, *cliAge)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;gender=&quot;</span>, *cliGender)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;flagname=&quot;</span>, cliFlag)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 flag 包前要通过 import 命令导入该包：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;flag&quot;</span></span><br></pre></td></tr></table></figure>\n<p>定义一个整型的参数 age，返回指针类型的变量：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cliAge = flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>, <span class=\"string\">&quot;Input Your Age&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>创建值类型的参数变量，并在 Init() 函数中对其初始化(注意这里调用的是 flag.IntVar 方法)：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cliFlag <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    flag.IntVar(&amp;cliFlag, <span class=\"string\">&quot;flagname&quot;</span>, <span class=\"number\">1234</span>, <span class=\"string\">&quot;Just for demo&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 flag.Parse() 函数接下命令行参数，解析函数将会在碰到第一个非 flag 命令行参数时停止：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag.Parse()</span><br></pre></td></tr></table></figure>\n<p>命令行传参的格式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-isbool    (一个 - 符号，布尔类型该写法等同于 -isbool=<span class=\"literal\">true</span>)</span><br><span class=\"line\">-age=x     (一个 - 符号，使用等号)</span><br><span class=\"line\">-age x     (一个 - 符号，使用空格)</span><br><span class=\"line\">--age=x    (两个 - 符号，使用等号)</span><br><span class=\"line\">--age x    (两个 - 符号，使用空格)</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行-demo\"><a href=\"#运行-demo\" class=\"headerlink\" title=\"运行 demo\"></a>运行 demo</h2><p>在 flagdemo 目录下执行 go build 命令编译 demo 生成可执行文件 flagdemo。<br><strong>不传递命令行参数</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130449855-404730543.png)</p>\n<p>此时输出的命令行参数都是定义的默认值。</p>\n<p><strong>传递命令行参数</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130535776-1276148478.png)</p>\n<p>传递的命令行参数会覆盖默认值。</p>\n<p><strong>传递多余的命令行参数</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130619082-1720959137.png)</p>\n<p>可以通过 flag.Args() 和 flag.NArg() 函数获取未能解析的命令行参数。</p>\n<p><strong>传递错误的命令行参</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130707783-39205152.png)</p>\n<p>如果通过 -xx 传入未定义的命令行参数，则会直接报错退出，并输出帮助信息。</p>\n<p><strong>查看帮助信息</strong><br>通过命令行参数 -h 或 –help 可以查看帮助信息：</p>\n<p>![img](Golang flag包简介/952033-20190505130753330-702637440.png)</p>\n<h2 id=\"解读-flag-包源码\"><a href=\"#解读-flag-包源码\" class=\"headerlink\" title=\"解读 flag 包源码\"></a>解读 flag 包源码</h2><p>flag 包支持的类型有 Bool、Duration、Float64、Int、Int64、String、Uint、Uint64。这些类型的参数被封装到其对应的后端类型中，比如 Int 类型的参数被封装为 intValue，String 类型的参数被封装为 stringValue。这些后端的类型都实现了 Value 接口，因此可以把一个命令行参数抽象为一个 Flag 类型的实例。下面是 Value 接口和 Flag 类型的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value 接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Value <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    String() <span class=\"keyword\">string</span></span><br><span class=\"line\">    Set(<span class=\"keyword\">string</span>) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flag 类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Flag <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name     <span class=\"keyword\">string</span> <span class=\"comment\">// name as it appears on command line</span></span><br><span class=\"line\">    Usage    <span class=\"keyword\">string</span> <span class=\"comment\">// help message</span></span><br><span class=\"line\">    Value    Value  <span class=\"comment\">// value as set 是个 interface，因此可以是不同类型的实例。</span></span><br><span class=\"line\">    DefValue <span class=\"keyword\">string</span> <span class=\"comment\">// default value (as text); for usage message</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>intValue 等类型实现了 Value 接口，因此可以赋值给 Flag 类型中的 Value 字段，下面是 intValue 类型的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- int Value</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> intValue <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newIntValue</span><span class=\"params\">(val <span class=\"keyword\">int</span>, p *<span class=\"keyword\">int</span>)</span> *<span class=\"title\">intValue</span></span> &#123;</span><br><span class=\"line\">    *p = val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*intValue)(p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(i *intValue)</span> <span class=\"title\">Set</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    v, err := strconv.ParseInt(s, <span class=\"number\">0</span>, strconv.IntSize)</span><br><span class=\"line\">    *i = intValue(v)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(i *intValue)</span> <span class=\"title\">Get</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(*i) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(i *intValue)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> strconv.Itoa(<span class=\"keyword\">int</span>(*i)) &#125;</span><br></pre></td></tr></table></figure>\n<p>所有的参数被保存在 FlagSet 类型的实例中，FlagSet 类型的定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A FlagSet represents a set of defined flags.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> FlagSet <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Usage <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    name          <span class=\"keyword\">string</span></span><br><span class=\"line\">    parsed        <span class=\"keyword\">bool</span></span><br><span class=\"line\">    actual         <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Flag    <span class=\"comment\">// 中保存从命令行参数中解析到的参数实例</span></span><br><span class=\"line\">    formal        <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Flag    <span class=\"comment\">// 中保存定义的命令行参数实例(实例中包含了默认值)</span></span><br><span class=\"line\">    args          []<span class=\"keyword\">string</span> <span class=\"comment\">// arguments after flags</span></span><br><span class=\"line\">    errorHandling ErrorHandling</span><br><span class=\"line\">    output        io.Writer <span class=\"comment\">// nil means stderr; use out() accessor</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Flag 包被导入时创建了 FlagSet 类型的对象 CommandLine：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CommandLine = NewFlagSet(os.Args[<span class=\"number\">0</span>], ExitOnError)</span><br></pre></td></tr></table></figure>\n<p>在程序中定义的所有命令行参数变量都会被加入到 CommandLine 的 formal 属性中，其具体的调用过程如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cliAge = flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>, <span class=\"string\">&quot;Input Your Age&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Int</span><span class=\"params\">(name <span class=\"keyword\">string</span>, value <span class=\"keyword\">int</span>, usage <span class=\"keyword\">string</span>)</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CommandLine.Int(name, value, usage)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">Int</span><span class=\"params\">(name <span class=\"keyword\">string</span>, value <span class=\"keyword\">int</span>, usage <span class=\"keyword\">string</span>)</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    p := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    f.IntVar(p, name, value, usage)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">IntVar</span><span class=\"params\">(p *<span class=\"keyword\">int</span>, name <span class=\"keyword\">string</span>, value <span class=\"keyword\">int</span>, usage <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    f.Var(newIntValue(value, p), name, usage)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">Var</span><span class=\"params\">(value Value, name <span class=\"keyword\">string</span>, usage <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remember the default value as a string; it won&#x27;t change.</span></span><br><span class=\"line\">    flag := &amp;Flag&#123;name, usage, value, value.String()&#125;</span><br><span class=\"line\">    _, alreadythere := f.formal[name]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> alreadythere &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> msg <span class=\"keyword\">string</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> f.name == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">            msg = fmt.Sprintf(<span class=\"string\">&quot;flag redefined: %s&quot;</span>, name)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = fmt.Sprintf(<span class=\"string\">&quot;%s flag redefined: %s&quot;</span>, f.name, name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Fprintln(f.Output(), msg)</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(msg) <span class=\"comment\">// Happens only if flags are declared with identical names</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f.formal == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        f.formal = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Flag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把命令行参数对应的变量添加到 formal 中</span></span><br><span class=\"line\">    f.formal[name] = flag</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>命令行参数的解析过程则由 flag.Parse() 函数完成，其调用过程大致如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    CommandLine.Parse(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">Parse</span><span class=\"params\">(arguments []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    f.parsed = <span class=\"literal\">true</span></span><br><span class=\"line\">    f.args = arguments</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        seen, err := f.parseOne()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> seen &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> f.errorHandling &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ContinueOnError:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ExitOnError:</span><br><span class=\"line\">            os.Exit(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PanicOnError:</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终由 FlagSet 的 parseOne() 方法执行解析任务：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">parseOne</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">bool</span>, error)</span></span> &#123;</span><br><span class=\"line\">…</span><br><span class=\"line\">flag.Value.Set(value)</span><br><span class=\"line\">…</span><br><span class=\"line\">f.actual[name] = flag</span><br><span class=\"line\">…</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并在解析完成后由 flag.Value.Set 方法把用户传递的命令行参数设置给 flag 实例，最后添加到 FlagSet 的 actual 属性中。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 Golang 标准库中 flag 包的基本用法，并进一步分析了其主要的代码逻辑。其实 flag 包还支持用户自定义类型的命令行参数，本文不再赘述，有兴趣的朋友请参考官方 demo。</p>\n<p><strong>参考：</strong><br><a href=\"https://golang.org/pkg/flag/\">package flag</a><br><a href=\"https://gobyexample.com/command-line-flags\">Go by Example: Command-Line Flags</a><br><a href=\"https://flaviocopes.com/go-command-line-flags/\">USING COMMAND LINE FLAGS IN GO</a><br><a href=\"https://o-my-chenjian.com/2017/09/20/Using-Flag-And-Pflag-With-Golang/\">Golang之使用Flag和Pflag</a><br><a href=\"https://blog.csdn.net/wangshubo1989/article/details/72914384?locationNum=14&fps=1\">Go语言学习之flag包(The way to go)</a><br><a href=\"https://golang.org/pkg/flag/#example_\">Golang flag demo</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Golang-flag-包简介\"><a href=\"#Golang-flag-包简介\" class=\"headerlink\" title=\"Golang  flag 包简介\"></a>Golang  flag 包简介</h1><p>在 Golang 程序中有很多种方法来处理命令行参数。简单的情况下可以不使用任何库，直接处理 os.Args；其实 Golang 的标准库提供了 flag 包来处理命令行参数；还有第三方提供的处理命令行参数的库，比如 Pflag 等。本文将介绍 Golang 标准库中 flag 包的用法。本文的演示环境为 ubuntu 18.04。</p>\n<h2 id=\"入门-demo\"><a href=\"#入门-demo\" class=\"headerlink\" title=\"入门 demo\"></a>入门 demo</h2><p>在 Go workspace 的 src 目录下创建 flagdemo 目录，并在目录下创建 main.go 文件，编辑其内容如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;flag&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义命令行参数对应的变量，这三个变量都是指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cliName = flag.String(<span class=\"string\">&quot;name&quot;</span>, <span class=\"string\">&quot;nick&quot;</span>, <span class=\"string\">&quot;Input Your Name&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> cliAge = flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>, <span class=\"string\">&quot;Input Your Age&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> cliGender = flag.String(<span class=\"string\">&quot;gender&quot;</span>, <span class=\"string\">&quot;male&quot;</span>, <span class=\"string\">&quot;Input Your Gender&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个值类型的命令行参数变量，在 Init() 函数中对其初始化</span></span><br><span class=\"line\"><span class=\"comment\">// 因此，命令行参数对应变量的定义和初始化是可以分开的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> cliFlag <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    flag.IntVar(&amp;cliFlag, <span class=\"string\">&quot;flagname&quot;</span>, <span class=\"number\">1234</span>, <span class=\"string\">&quot;Just for demo&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化变量 cliFlag</span></span><br><span class=\"line\">    Init()</span><br><span class=\"line\">    <span class=\"comment\">// 把用户传递的命令行参数解析为对应变量的值</span></span><br><span class=\"line\">    flag.Parse()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// flag.Args() 函数返回没有被解析的命令行参数</span></span><br><span class=\"line\">    <span class=\"comment\">// func NArg() 函数返回没有被解析的命令行参数的个数</span></span><br><span class=\"line\">    fmt.Printf(<span class=\"string\">&quot;args=%s, num=%d\\n&quot;</span>, flag.Args(), flag.NArg())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i != flag.NArg(); i++ &#123;</span><br><span class=\"line\">        fmt.Printf(<span class=\"string\">&quot;arg[%d]=%s\\n&quot;</span>, i, flag.Arg(i))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 输出命令行参数</span></span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;name=&quot;</span>, *cliName)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;age=&quot;</span>, *cliAge)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;gender=&quot;</span>, *cliGender)</span><br><span class=\"line\">    fmt.Println(<span class=\"string\">&quot;flagname=&quot;</span>, cliFlag)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 flag 包前要通过 import 命令导入该包：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;flag&quot;</span></span><br></pre></td></tr></table></figure>\n<p>定义一个整型的参数 age，返回指针类型的变量：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cliAge = flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>, <span class=\"string\">&quot;Input Your Age&quot;</span>)</span><br></pre></td></tr></table></figure>\n<p>创建值类型的参数变量，并在 Init() 函数中对其初始化(注意这里调用的是 flag.IntVar 方法)：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cliFlag <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Init</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    flag.IntVar(&amp;cliFlag, <span class=\"string\">&quot;flagname&quot;</span>, <span class=\"number\">1234</span>, <span class=\"string\">&quot;Just for demo&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过 flag.Parse() 函数接下命令行参数，解析函数将会在碰到第一个非 flag 命令行参数时停止：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flag.Parse()</span><br></pre></td></tr></table></figure>\n<p>命令行传参的格式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-isbool    (一个 - 符号，布尔类型该写法等同于 -isbool=<span class=\"literal\">true</span>)</span><br><span class=\"line\">-age=x     (一个 - 符号，使用等号)</span><br><span class=\"line\">-age x     (一个 - 符号，使用空格)</span><br><span class=\"line\">--age=x    (两个 - 符号，使用等号)</span><br><span class=\"line\">--age x    (两个 - 符号，使用空格)</span><br></pre></td></tr></table></figure>\n<h2 id=\"运行-demo\"><a href=\"#运行-demo\" class=\"headerlink\" title=\"运行 demo\"></a>运行 demo</h2><p>在 flagdemo 目录下执行 go build 命令编译 demo 生成可执行文件 flagdemo。<br><strong>不传递命令行参数</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130449855-404730543.png)</p>\n<p>此时输出的命令行参数都是定义的默认值。</p>\n<p><strong>传递命令行参数</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130535776-1276148478.png)</p>\n<p>传递的命令行参数会覆盖默认值。</p>\n<p><strong>传递多余的命令行参数</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130619082-1720959137.png)</p>\n<p>可以通过 flag.Args() 和 flag.NArg() 函数获取未能解析的命令行参数。</p>\n<p><strong>传递错误的命令行参</strong></p>\n<p>![img](Golang flag包简介/952033-20190505130707783-39205152.png)</p>\n<p>如果通过 -xx 传入未定义的命令行参数，则会直接报错退出，并输出帮助信息。</p>\n<p><strong>查看帮助信息</strong><br>通过命令行参数 -h 或 –help 可以查看帮助信息：</p>\n<p>![img](Golang flag包简介/952033-20190505130753330-702637440.png)</p>\n<h2 id=\"解读-flag-包源码\"><a href=\"#解读-flag-包源码\" class=\"headerlink\" title=\"解读 flag 包源码\"></a>解读 flag 包源码</h2><p>flag 包支持的类型有 Bool、Duration、Float64、Int、Int64、String、Uint、Uint64。这些类型的参数被封装到其对应的后端类型中，比如 Int 类型的参数被封装为 intValue，String 类型的参数被封装为 stringValue。这些后端的类型都实现了 Value 接口，因此可以把一个命令行参数抽象为一个 Flag 类型的实例。下面是 Value 接口和 Flag 类型的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value 接口</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Value <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    String() <span class=\"keyword\">string</span></span><br><span class=\"line\">    Set(<span class=\"keyword\">string</span>) error</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Flag 类型</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> Flag <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Name     <span class=\"keyword\">string</span> <span class=\"comment\">// name as it appears on command line</span></span><br><span class=\"line\">    Usage    <span class=\"keyword\">string</span> <span class=\"comment\">// help message</span></span><br><span class=\"line\">    Value    Value  <span class=\"comment\">// value as set 是个 interface，因此可以是不同类型的实例。</span></span><br><span class=\"line\">    DefValue <span class=\"keyword\">string</span> <span class=\"comment\">// default value (as text); for usage message</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>intValue 等类型实现了 Value 接口，因此可以赋值给 Flag 类型中的 Value 字段，下面是 intValue 类型的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -- int Value</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> intValue <span class=\"keyword\">int</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">newIntValue</span><span class=\"params\">(val <span class=\"keyword\">int</span>, p *<span class=\"keyword\">int</span>)</span> *<span class=\"title\">intValue</span></span> &#123;</span><br><span class=\"line\">    *p = val</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (*intValue)(p)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(i *intValue)</span> <span class=\"title\">Set</span><span class=\"params\">(s <span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    v, err := strconv.ParseInt(s, <span class=\"number\">0</span>, strconv.IntSize)</span><br><span class=\"line\">    *i = intValue(v)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> err</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(i *intValue)</span> <span class=\"title\">Get</span><span class=\"params\">()</span> <span class=\"title\">interface</span></span>&#123;&#125; &#123; <span class=\"keyword\">return</span> <span class=\"keyword\">int</span>(*i) &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(i *intValue)</span> <span class=\"title\">String</span><span class=\"params\">()</span> <span class=\"title\">string</span></span> &#123; <span class=\"keyword\">return</span> strconv.Itoa(<span class=\"keyword\">int</span>(*i)) &#125;</span><br></pre></td></tr></table></figure>\n<p>所有的参数被保存在 FlagSet 类型的实例中，FlagSet 类型的定义如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A FlagSet represents a set of defined flags.</span></span><br><span class=\"line\"><span class=\"keyword\">type</span> FlagSet <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Usage <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    name          <span class=\"keyword\">string</span></span><br><span class=\"line\">    parsed        <span class=\"keyword\">bool</span></span><br><span class=\"line\">    actual         <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Flag    <span class=\"comment\">// 中保存从命令行参数中解析到的参数实例</span></span><br><span class=\"line\">    formal        <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Flag    <span class=\"comment\">// 中保存定义的命令行参数实例(实例中包含了默认值)</span></span><br><span class=\"line\">    args          []<span class=\"keyword\">string</span> <span class=\"comment\">// arguments after flags</span></span><br><span class=\"line\">    errorHandling ErrorHandling</span><br><span class=\"line\">    output        io.Writer <span class=\"comment\">// nil means stderr; use out() accessor</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Flag 包被导入时创建了 FlagSet 类型的对象 CommandLine：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> CommandLine = NewFlagSet(os.Args[<span class=\"number\">0</span>], ExitOnError)</span><br></pre></td></tr></table></figure>\n<p>在程序中定义的所有命令行参数变量都会被加入到 CommandLine 的 formal 属性中，其具体的调用过程如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> cliAge = flag.Int(<span class=\"string\">&quot;age&quot;</span>, <span class=\"number\">28</span>, <span class=\"string\">&quot;Input Your Age&quot;</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Int</span><span class=\"params\">(name <span class=\"keyword\">string</span>, value <span class=\"keyword\">int</span>, usage <span class=\"keyword\">string</span>)</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> CommandLine.Int(name, value, usage)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">Int</span><span class=\"params\">(name <span class=\"keyword\">string</span>, value <span class=\"keyword\">int</span>, usage <span class=\"keyword\">string</span>)</span> *<span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    p := <span class=\"built_in\">new</span>(<span class=\"keyword\">int</span>)</span><br><span class=\"line\">    f.IntVar(p, name, value, usage)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">IntVar</span><span class=\"params\">(p *<span class=\"keyword\">int</span>, name <span class=\"keyword\">string</span>, value <span class=\"keyword\">int</span>, usage <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    f.Var(newIntValue(value, p), name, usage)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">Var</span><span class=\"params\">(value Value, name <span class=\"keyword\">string</span>, usage <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Remember the default value as a string; it won&#x27;t change.</span></span><br><span class=\"line\">    flag := &amp;Flag&#123;name, usage, value, value.String()&#125;</span><br><span class=\"line\">    _, alreadythere := f.formal[name]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> alreadythere &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> msg <span class=\"keyword\">string</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> f.name == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">            msg = fmt.Sprintf(<span class=\"string\">&quot;flag redefined: %s&quot;</span>, name)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            msg = fmt.Sprintf(<span class=\"string\">&quot;%s flag redefined: %s&quot;</span>, f.name, name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fmt.Fprintln(f.Output(), msg)</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(msg) <span class=\"comment\">// Happens only if flags are declared with identical names</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> f.formal == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        f.formal = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]*Flag)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 把命令行参数对应的变量添加到 formal 中</span></span><br><span class=\"line\">    f.formal[name] = flag</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>命令行参数的解析过程则由 flag.Parse() 函数完成，其调用过程大致如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Parse</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    CommandLine.Parse(os.Args[<span class=\"number\">1</span>:])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">Parse</span><span class=\"params\">(arguments []<span class=\"keyword\">string</span>)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    f.parsed = <span class=\"literal\">true</span></span><br><span class=\"line\">    f.args = arguments</span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        seen, err := f.parseOne()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> seen &#123;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> f.errorHandling &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ContinueOnError:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> err</span><br><span class=\"line\">        <span class=\"keyword\">case</span> ExitOnError:</span><br><span class=\"line\">            os.Exit(<span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">case</span> PanicOnError:</span><br><span class=\"line\">            <span class=\"built_in\">panic</span>(err)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>最终由 FlagSet 的 parseOne() 方法执行解析任务：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f *FlagSet)</span> <span class=\"title\">parseOne</span><span class=\"params\">()</span> <span class=\"params\">(<span class=\"keyword\">bool</span>, error)</span></span> &#123;</span><br><span class=\"line\">…</span><br><span class=\"line\">flag.Value.Set(value)</span><br><span class=\"line\">…</span><br><span class=\"line\">f.actual[name] = flag</span><br><span class=\"line\">…</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>并在解析完成后由 flag.Value.Set 方法把用户传递的命令行参数设置给 flag 实例，最后添加到 FlagSet 的 actual 属性中。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文介绍了 Golang 标准库中 flag 包的基本用法，并进一步分析了其主要的代码逻辑。其实 flag 包还支持用户自定义类型的命令行参数，本文不再赘述，有兴趣的朋友请参考官方 demo。</p>\n<p><strong>参考：</strong><br><a href=\"https://golang.org/pkg/flag/\">package flag</a><br><a href=\"https://gobyexample.com/command-line-flags\">Go by Example: Command-Line Flags</a><br><a href=\"https://flaviocopes.com/go-command-line-flags/\">USING COMMAND LINE FLAGS IN GO</a><br><a href=\"https://o-my-chenjian.com/2017/09/20/Using-Flag-And-Pflag-With-Golang/\">Golang之使用Flag和Pflag</a><br><a href=\"https://blog.csdn.net/wangshubo1989/article/details/72914384?locationNum=14&fps=1\">Go语言学习之flag包(The way to go)</a><br><a href=\"https://golang.org/pkg/flag/#example_\">Golang flag demo</a></p>\n"},{"title":"Go Handler和HandlerFunc","date":"2020-12-31T15:59:00.000Z","abbrlink":14001,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# Go Handler 和 HandlerFunc\n\n## 例子\n\n先看一个简单的例子：\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype HelloHandler struct{}\n\nfunc (h HelloHandler) ServeHTTP (w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello Handler!\")\n}\n\nfunc hello (w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello!\")\n}\n\nfunc main() {\n    server := http.Server{\n        Addr: \"127.0.0.1:8080\",\n    }\n    helloHandler := HelloHandler{}\n    http.Handle(\"/hello1\", helloHandler)\n    http.HandleFunc(\"/hello2\", hello)\n    server.ListenAndServe()\n}\n```\n\n上述代码启动了一个 http 服务器，监听 8080 端口，分别实现了 `/hello1` 和 `/hello2` 两个路由。实现这两个路由的方法有点不同，一个使用 `http.Handle`，另一个使用 `http.HandleFunc` ，下面来看看这两个之间的区别；\n\n## http.Handle\n\n首先，简单分析一下 `http.Handle(pattern string, handler Handler)`，`http.Handle(pattern string, handler Handler)` 接收两个参数，一个是路由匹配的字符串，另外一个是 `Handler` 类型的值：\n\n```go\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n```\n\n第二个参数是Handler这个接口, 这个接口有一个ServeHTTP()的方法\n\n```go\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n```\n\n所以这个方法使用的时候需要自己去定义struct实现这个**Handler**接口。\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"log\"\n)\n\ntype httpServer struct {\n}\n\nfunc (server httpServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(r.URL.Path))\n}\n\nfunc main() {\n\tvar server httpServer\n\thttp.Handle(\"/\", server)\n\tlog.Fatal(http.ListenAndServe(\"localhost:9000\", nil))\n}\n```\n\n然后由继续调用 `DefaultServeMux.Handle(pattern string, handler Handler)`，该函数接收的参数与上面的函数一样：\n\n```go\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) {\n...\n}\n```\n\n这个 `Handler` 类型是什么呢，其实它就是一个接口，包含一个 `ServeHttp()` 的方法：\n\n```tsx\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n所以，传入 `http.Handle(pattern string, handler Handler)` 第二个参数必须实现 `ServeHTTP` 这个方法，当接收到一个匹配路由的请求时，会调用该方法。\n\n## http.HandleFunc\n\n该方法接收两个参数，一个是路由匹配的字符串，另外一个是 `func(ResponseWriter, *Request)` 类型的函数：\n\n```go\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n```\n\n这个第二个参数是一个方法，参数是ResponseWriter, 和 *Request 所以使用的时候需要传方法。\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(r.URL.Path))\n\t})\n\tlog.Fatal(http.ListenAndServe(\"localhost:9000\", nil))\n}\n```\n\n然后继续调用 `DefaultServeMux.HandleFunc(pattern, handler)`：\n\n```go\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n可以看到，这里把 `handler` 转换成了 `HandlerFunc` 类型，而 `HandlerFunc` 类型则如下所示：\n\n```go\ntype HandlerFunc func(ResponseWriter, *Request)\n\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n```\n\n该类型实现了 `ServeHTTP` 接口，所以其也可以转换成 `Handler` 类型，接下来调用 `mux.Handle(pattern string, handler Handler)` 就跟 `http.Handle` 的流程是一样的了。\n\n\n\n","source":"_posts/go_md/Go Handler和HandlerFunc.md","raw":"---\ntitle: Go Handler和HandlerFunc\ndate: '2020/12/31 23:59'\ntags:\n - go\ncategories:\n - 学习笔记\nabbrlink: 14001\ncover: \n---\n\n# Go Handler 和 HandlerFunc\n\n## 例子\n\n先看一个简单的例子：\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype HelloHandler struct{}\n\nfunc (h HelloHandler) ServeHTTP (w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello Handler!\")\n}\n\nfunc hello (w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello!\")\n}\n\nfunc main() {\n    server := http.Server{\n        Addr: \"127.0.0.1:8080\",\n    }\n    helloHandler := HelloHandler{}\n    http.Handle(\"/hello1\", helloHandler)\n    http.HandleFunc(\"/hello2\", hello)\n    server.ListenAndServe()\n}\n```\n\n上述代码启动了一个 http 服务器，监听 8080 端口，分别实现了 `/hello1` 和 `/hello2` 两个路由。实现这两个路由的方法有点不同，一个使用 `http.Handle`，另一个使用 `http.HandleFunc` ，下面来看看这两个之间的区别；\n\n## http.Handle\n\n首先，简单分析一下 `http.Handle(pattern string, handler Handler)`，`http.Handle(pattern string, handler Handler)` 接收两个参数，一个是路由匹配的字符串，另外一个是 `Handler` 类型的值：\n\n```go\nfunc Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }\n```\n\n第二个参数是Handler这个接口, 这个接口有一个ServeHTTP()的方法\n\n```go\ntype Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}\n```\n\n所以这个方法使用的时候需要自己去定义struct实现这个**Handler**接口。\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"log\"\n)\n\ntype httpServer struct {\n}\n\nfunc (server httpServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(r.URL.Path))\n}\n\nfunc main() {\n\tvar server httpServer\n\thttp.Handle(\"/\", server)\n\tlog.Fatal(http.ListenAndServe(\"localhost:9000\", nil))\n}\n```\n\n然后由继续调用 `DefaultServeMux.Handle(pattern string, handler Handler)`，该函数接收的参数与上面的函数一样：\n\n```go\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) {\n...\n}\n```\n\n这个 `Handler` 类型是什么呢，其实它就是一个接口，包含一个 `ServeHttp()` 的方法：\n\n```tsx\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n所以，传入 `http.Handle(pattern string, handler Handler)` 第二个参数必须实现 `ServeHTTP` 这个方法，当接收到一个匹配路由的请求时，会调用该方法。\n\n## http.HandleFunc\n\n该方法接收两个参数，一个是路由匹配的字符串，另外一个是 `func(ResponseWriter, *Request)` 类型的函数：\n\n```go\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n```\n\n这个第二个参数是一个方法，参数是ResponseWriter, 和 *Request 所以使用的时候需要传方法。\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"log\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(r.URL.Path))\n\t})\n\tlog.Fatal(http.ListenAndServe(\"localhost:9000\", nil))\n}\n```\n\n然后继续调用 `DefaultServeMux.HandleFunc(pattern, handler)`：\n\n```go\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n可以看到，这里把 `handler` 转换成了 `HandlerFunc` 类型，而 `HandlerFunc` 类型则如下所示：\n\n```go\ntype HandlerFunc func(ResponseWriter, *Request)\n\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n```\n\n该类型实现了 `ServeHTTP` 接口，所以其也可以转换成 `Handler` 类型，接下来调用 `mux.Handle(pattern string, handler Handler)` 就跟 `http.Handle` 的流程是一样的了。\n\n\n\n","slug":"go_md/Go Handler和HandlerFunc","published":1,"updated":"2021-04-09T12:49:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5s000gw9q919uw9vf1","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Go-Handler-和-HandlerFunc\"><a href=\"#Go-Handler-和-HandlerFunc\" class=\"headerlink\" title=\"Go Handler 和 HandlerFunc\"></a>Go Handler 和 HandlerFunc</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>先看一个简单的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HelloHandler <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h HelloHandler)</span> <span class=\"title\">ServeHTTP</span> <span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello Handler!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span> <span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    server := http.Server&#123;</span><br><span class=\"line\">        Addr: <span class=\"string\">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    helloHandler := HelloHandler&#123;&#125;</span><br><span class=\"line\">    http.Handle(<span class=\"string\">&quot;/hello1&quot;</span>, helloHandler)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/hello2&quot;</span>, hello)</span><br><span class=\"line\">    server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码启动了一个 http 服务器，监听 8080 端口，分别实现了 <code>/hello1</code> 和 <code>/hello2</code> 两个路由。实现这两个路由的方法有点不同，一个使用 <code>http.Handle</code>，另一个使用 <code>http.HandleFunc</code> ，下面来看看这两个之间的区别；</p>\n<h2 id=\"http-Handle\"><a href=\"#http-Handle\" class=\"headerlink\" title=\"http.Handle\"></a>http.Handle</h2><p>首先，简单分析一下 <code>http.Handle(pattern string, handler Handler)</code>，<code>http.Handle(pattern string, handler Handler)</code> 接收两个参数，一个是路由匹配的字符串，另外一个是 <code>Handler</code> 类型的值：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br></pre></td></tr></table></figure>\n<p>第二个参数是Handler这个接口, 这个接口有一个ServeHTTP()的方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以这个方法使用的时候需要自己去定义struct实现这个<strong>Handler</strong>接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> httpServer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server httpServer)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(r.URL.Path))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> server httpServer</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/&quot;</span>, server)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:9000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后由继续调用 <code>DefaultServeMux.Handle(pattern string, handler Handler)</code>，该函数接收的参数与上面的函数一样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 <code>Handler</code> 类型是什么呢，其实它就是一个接口，包含一个 <code>ServeHttp()</code> 的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Handler interface &#123;</span><br><span class=\"line\">    ServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，传入 <code>http.Handle(pattern string, handler Handler)</code> 第二个参数必须实现 <code>ServeHTTP</code> 这个方法，当接收到一个匹配路由的请求时，会调用该方法。</p>\n<h2 id=\"http-HandleFunc\"><a href=\"#http-HandleFunc\" class=\"headerlink\" title=\"http.HandleFunc\"></a>http.HandleFunc</h2><p>该方法接收两个参数，一个是路由匹配的字符串，另外一个是 <code>func(ResponseWriter, *Request)</code> 类型的函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个第二个参数是一个方法，参数是ResponseWriter, 和 *Request 所以使用的时候需要传方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(r.URL.Path))</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:9000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后继续调用 <code>DefaultServeMux.HandleFunc(pattern, handler)</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这里把 <code>handler</code> 转换成了 <code>HandlerFunc</code> 类型，而 <code>HandlerFunc</code> 类型则如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    f(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类型实现了 <code>ServeHTTP</code> 接口，所以其也可以转换成 <code>Handler</code> 类型，接下来调用 <code>mux.Handle(pattern string, handler Handler)</code> 就跟 <code>http.Handle</code> 的流程是一样的了。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Go-Handler-和-HandlerFunc\"><a href=\"#Go-Handler-和-HandlerFunc\" class=\"headerlink\" title=\"Go Handler 和 HandlerFunc\"></a>Go Handler 和 HandlerFunc</h1><h2 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h2><p>先看一个简单的例子：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HelloHandler <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(h HelloHandler)</span> <span class=\"title\">ServeHTTP</span> <span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello Handler!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">hello</span> <span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    server := http.Server&#123;</span><br><span class=\"line\">        Addr: <span class=\"string\">&quot;127.0.0.1:8080&quot;</span>,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    helloHandler := HelloHandler&#123;&#125;</span><br><span class=\"line\">    http.Handle(<span class=\"string\">&quot;/hello1&quot;</span>, helloHandler)</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">&quot;/hello2&quot;</span>, hello)</span><br><span class=\"line\">    server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上述代码启动了一个 http 服务器，监听 8080 端口，分别实现了 <code>/hello1</code> 和 <code>/hello2</code> 两个路由。实现这两个路由的方法有点不同，一个使用 <code>http.Handle</code>，另一个使用 <code>http.HandleFunc</code> ，下面来看看这两个之间的区别；</p>\n<h2 id=\"http-Handle\"><a href=\"#http-Handle\" class=\"headerlink\" title=\"http.Handle\"></a>http.Handle</h2><p>首先，简单分析一下 <code>http.Handle(pattern string, handler Handler)</code>，<code>http.Handle(pattern string, handler Handler)</code> 接收两个参数，一个是路由匹配的字符串，另外一个是 <code>Handler</code> 类型的值：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123; DefaultServeMux.Handle(pattern, handler) &#125;</span><br></pre></td></tr></table></figure>\n<p>第二个参数是Handler这个接口, 这个接口有一个ServeHTTP()的方法</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">\tServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以这个方法使用的时候需要自己去定义struct实现这个<strong>Handler</strong>接口。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> httpServer <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(server httpServer)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\tw.Write([]<span class=\"keyword\">byte</span>(r.URL.Path))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> server httpServer</span><br><span class=\"line\">\thttp.Handle(<span class=\"string\">&quot;/&quot;</span>, server)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:9000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后由继续调用 <code>DefaultServeMux.Handle(pattern string, handler Handler)</code>，该函数接收的参数与上面的函数一样：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个 <code>Handler</code> 类型是什么呢，其实它就是一个接口，包含一个 <code>ServeHttp()</code> 的方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Handler interface &#123;</span><br><span class=\"line\">    ServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>所以，传入 <code>http.Handle(pattern string, handler Handler)</code> 第二个参数必须实现 <code>ServeHTTP</code> 这个方法，当接收到一个匹配路由的请求时，会调用该方法。</p>\n<h2 id=\"http-HandleFunc\"><a href=\"#http-HandleFunc\" class=\"headerlink\" title=\"http.HandleFunc\"></a>http.HandleFunc</h2><p>该方法接收两个参数，一个是路由匹配的字符串，另外一个是 <code>func(ResponseWriter, *Request)</code> 类型的函数：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个第二个参数是一个方法，参数是ResponseWriter, 和 *Request 所以使用的时候需要传方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\thttp.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">\t\tw.Write([]<span class=\"keyword\">byte</span>(r.URL.Path))</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tlog.Fatal(http.ListenAndServe(<span class=\"string\">&quot;localhost:9000&quot;</span>, <span class=\"literal\">nil</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然后继续调用 <code>DefaultServeMux.HandleFunc(pattern, handler)</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，这里把 <code>handler</code> 转换成了 <code>HandlerFunc</code> 类型，而 <code>HandlerFunc</code> 类型则如下所示：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    f(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该类型实现了 <code>ServeHTTP</code> 接口，所以其也可以转换成 <code>Handler</code> 类型，接下来调用 <code>mux.Handle(pattern string, handler Handler)</code> 就跟 <code>http.Handle</code> 的流程是一样的了。</p>\n"},{"title":"Go项目结构规范","date":"2020-12-31T15:59:00.000Z","abbrlink":14000,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# [译] Go 项目结构规范\n\n> 英文原文及项目结构示例: https://github.com/golang-standards/project-layout\n\n这里列举的是一个 Go 项目的基础布局. 它并不是由 Go 核心开发团队定义的官方标准; 然而, 它是 Go 生态圈中新老项目常用的一组布局模式. 其中一些模式较其他更流行一些. 它也包含一些小的改进以及支持目录, 这在真实世界中足够大的项目里是很常见的.\n\n如果你正准备学习 Go 语言, 或者你只是想验证一些概念, 做个玩具项目, 那使用这套项目布局就有些小题大做了. 从最简单的实现开始 (一个 `main.go` 文件就绰绰有余了). 随着项目逐渐成长, 请记得保持良好的项目结构是一件很重要的事情, 否则结果只会一团乱麻, 代码包含着大量的隐藏依赖和全局状态. 当你的项目有更多人参与的时候, 就需要更多的结构. 这时候引入一种通用的方式来管理包和库就很重要了. 当你管理一个开源项目, 或者当你知道有其他项目会引入你的代码时, 拥有一个私有 private (或叫 `内部 internal`) 的包和代码也很必要. 你可以克隆这个仓库, 留下需要的删掉其他所有文件! 只是因为它们在那儿并不意味着你一定得都用上. 这些模式中没有哪个是每个项目都得用的. 即便是 `vendor` 模式也没那么通用.\n\n这个项目结构刻意做得很通用, 它并没有强套某一种特定的包结构.\n\n这也是社区努力的成果. 如果你见到一个新模式, 或是认为某个模式需要改进都可以开新的 issue.\n\n如果你需要一些命名, 代码格式化和风格上的帮助, 可以从 [gofmt](https://golang.org/cmd/gofmt/) 及 [golint](https://github.com/golang/lint) 开始. 同时也请确保读过这些 Go 代码规范和建议:\n\n- https://talks.golang.org/2014/names.slide\n- https://golang.org/doc/effective_go.html#names\n- https://blog.golang.org/package-names\n- https://github.com/golang/go/wiki/CodeReviewComments\n\n参考 [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) 来了解更多背景知识.\n\n还有更多其他关于命名, 包结构组织, 代码结构方面的建议在这里:\n\n- [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n- [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n- [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n- [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\n## Go 目录\n\n### /cmd\n\n该项目的主程序.\n\n每个程序目录的名字应该和可执行文件的名字保持一致 (比如 `/cmd/myapp`).\n\n不要在程序目录中放太多代码. 如果你觉得这些代码会被其他项目引用, 那它们应该被放在 `/pkg` 目录中. 如果这些代码不能被重用, 或者说你不希望别人重用这些代码, 那么就把它们放在 `/internal` 目录中. 你也许会惊讶于别人使用你代码的方式, 所以一定要保持你的意图足够明确!\n\n一般来说一个足够小的 `main` 函数, 用于引入并执行 `/internal` 和 `/pkg` 下的代码就足够了.\n\n例子请参考 [`/cmd`](https://github.com/golang-standards/project-layout/blob/master/cmd/README.md) 目录\n\n### /internal\n\n程序和库的私有代码. 这里的代码都是你不希望被别的应用和库所引用的.\n\n把你真正的应用代码放在 `/internal/app` 目录 (比如: `/internal/app/myapp`) 把你的应用间共享的代码放在 `/internal/pkg` 目录 (比如: `internal/pkg/myprivlib`)\n\n### /pkg\n\n可以被其他外部应用引用的代码 (比如: `/pkg/mypubliclib`). 其他项目会引入这些库并期望它们能正常工作, 所以把代码放在这里之前还请三思 :-)\n\n如果你的代码仓库根目录中包含很多非 Go 的组件和目录, 那么把 Go 代码组织到同一个目录下也算是一种方式, 这么做可以让你更轻松地使用不少 Go 工具 (GopherCon EU 2018 里的 [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) 有提过这部分的内容 ).\n\n如果你想看看有哪些热门项目使用了这种项目结构可以参考 [`/pkg`](https://github.com/golang-standards/project-layout/blob/master/pkg/README.md) 目录. 这是一种常见的布局模式, 但它并没有被完全接受, 有些 Go 社区并不推荐使用.\n\n### /vendor\n\n应用的依赖 (手工管理或者是通过你最爱的依赖管理工具像是 [`dep`](https://github.com/golang/dep)).\n\n如果你在构建一个库项目, 那注意不要把依赖也提交上去了.\n\n## Service 应用目录\n\n### /api\n\nOpenAPI/Swagger 规范, JSON schema 文件, 协议定义文件.\n\n例子请参考 [`/api`](https://github.com/golang-standards/project-layout/blob/master/api/README.md)\n\n## Web 应用目录\n\n### /web\n\nWeb 应用标准组件: 静态 Web 资源, 服务端模板, 单页应用.\n\n## 常规应用目录\n\n### /configs\n\n配置文件模板或者默认配置.\n\n在这里放置你的 `confd` 或者 `consul-template` 模板文件.\n\n### /init\n\n系统初始化 (systemd, upstart, sysv) 及进程管理/监控 (runit, supervisord) 配置.\n\n### /scripts\n\n执行各种构建, 安装, 分析等其他操作的脚本.\n\n这些脚本要保持根级别的 Makefile 小而简单 (比如: https://github.com/hashicorp/terraform/blob/master/Makefile).\n\n例子请参考 [`/scripts`](https://github.com/golang-standards/project-layout/blob/master/scripts/README.md) 目录\n\n### /build\n\n打包及持续集成.\n\n将 cloud (AMI), container (Docker), OS (deb, rpm, pkg) 包配置放在 `/build/package` 目录下.\n\n将 CI (travis, circle, drone) 配置和脚本放在 `/build/ci` 目录. 需要注意的是, 有些 CI 工具 (比如 Travis CI) 对它们配置文件的位置非常挑剔. 尝试把配置文件放在 `/build/ci` 目录, 然后将它们软链接到 CI 工具希望它们出现的位置 (如果可能的话).\n\n### /deployments\n\nIaaS, Paas, 系统, 容器编排的部署配置和模板 (docker-compose, kubernetes/helm, mesos, terraform, bosh)\n\n### /test\n\n额外的外部测试软件和测试数据. 你可以用任意方式自由地组织 `/test` 目录的结构. 大型项目则有必要包含一个 data 子目录. 比如你可以建立 `/test/data` 或者 `/test/testdata` 目录, 如果你希望 Go 忽略里面的内容. 注意, Go 也会忽略任何以 \".\" 和 \"_\" 开头的文件和目录, 所以就如何命名测试数据目录而言, 你拥有更多的灵活性.\n\n例子请参考 [`/test`](https://github.com/golang-standards/project-layout/blob/master/test/README.md) 目录.\n\n## 其他目录\n\n### /docs\n\n用户及设计文档 (除了 godc 生成的文档).\n\n例子请参考  [`/docs`](https://github.com/golang-standards/project-layout/blob/master/docs/README.md) 目录.\n\n### /tools\n\n项目的支持工具. 注意, 这些工具可以引入 `/pkg` 和 `/internal` 目录的代码.\n\n例子请参考 [`/tools`](https://github.com/golang-standards/project-layout/blob/master/tools/README.md) 目录.\n\n### /examples\n\n应用或者库的示例文件.\n\n例子请参考 [`/examples`](https://github.com/golang-standards/project-layout/blob/master/examples/README.md) 目录.\n\n### /third_party\n\n外部辅助工具, forked 代码, 以及其他第三方工具 (例如: Swagger UI)\n\n### /githooks\n\nGit hooks.\n\n### /assets\n\n其他和你的代码仓库一起的资源文件 (图片, logo 等).\n\n### /website\n\n如果你不用 Github pages 的话, 这里放置你的项目站点数据.\n\n例子参考 [`/website`](https://github.com/golang-standards/project-layout/blob/master/website/README.md) 目录.\n\n## 不应该存在的目录\n\n### /src\n\n有些 Go 项目确实有个 `src` 目录, 但是这一般发生在从 Java 世界过来的开发者身上, 在那里这是一个很常见的模式. 如果做得到就尽量控制住自己不要采用 Java 的目录模式. 你不会希望你的 Go 代码和 Go 工程看起来像 Java 一样 :-)\n\n不过别搞混项目级别的 `/src` 目录和 Go 本身用作工作空间的 `/src` 目录, 在 [`How to Write Go Code`](https://golang.org/doc/code.html) 有对它的描述. `$GOPATH` 环境变量指向你 (当前) 的工作空间 (在非 Windows 系统中它默认指向 `$HOME/go`). 这个工作空间包括顶层的 `/pkg`, `/bin` 和 `/src` 目录. 你的实际项目最终被放在 `/src` 的一个子目录中, 所以如果你在你的项目中包含 `/src` 目录, 那么你的项目路径看起来会是这个样子 `/some/path/to/workspace/src/your_project/src/your_code.go`. 需要注意的是 尽管 Go 1.11 中你可以把你的项目放在 `GOPATH` 之外, 但采用这种布局模式依然不是个好主意.\n\n## 徽章\n\n- [Go Report Card](https://goreportcard.com/) - 它会使用 `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` 和 `misspell` 扫描你的代码. 用你自己的项目地址替换掉 `github.com/golang-standards/project-layout` 就可以了.\n- [GoDoc](http://godoc.org/) - 它会提供在线版的 GoDoc 自动生成的文档. 把项目链接改成你自己的就行了.\n- Release - 它会显示你项目的最新版本号. 修改 GitHub 链接指向你自己的项目即可.\n\n## Notes\n\nA more opinionated project template with sample/reusable configs, scripts and code is a WIP. (作者的一个冷笑话)\n\n\n\n作者：GotaX\n链接：https://www.jianshu.com/p/4726b9ac5fb1\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","source":"_posts/go_md/[译] Go 项目结构规范.md","raw":"---\ntitle: Go项目结构规范\ndate: '2020/12/31 23:59'\ntags:\n - go\ncategories:\n - 学习笔记\nabbrlink: 14000\ncover: \n---\n\n# [译] Go 项目结构规范\n\n> 英文原文及项目结构示例: https://github.com/golang-standards/project-layout\n\n这里列举的是一个 Go 项目的基础布局. 它并不是由 Go 核心开发团队定义的官方标准; 然而, 它是 Go 生态圈中新老项目常用的一组布局模式. 其中一些模式较其他更流行一些. 它也包含一些小的改进以及支持目录, 这在真实世界中足够大的项目里是很常见的.\n\n如果你正准备学习 Go 语言, 或者你只是想验证一些概念, 做个玩具项目, 那使用这套项目布局就有些小题大做了. 从最简单的实现开始 (一个 `main.go` 文件就绰绰有余了). 随着项目逐渐成长, 请记得保持良好的项目结构是一件很重要的事情, 否则结果只会一团乱麻, 代码包含着大量的隐藏依赖和全局状态. 当你的项目有更多人参与的时候, 就需要更多的结构. 这时候引入一种通用的方式来管理包和库就很重要了. 当你管理一个开源项目, 或者当你知道有其他项目会引入你的代码时, 拥有一个私有 private (或叫 `内部 internal`) 的包和代码也很必要. 你可以克隆这个仓库, 留下需要的删掉其他所有文件! 只是因为它们在那儿并不意味着你一定得都用上. 这些模式中没有哪个是每个项目都得用的. 即便是 `vendor` 模式也没那么通用.\n\n这个项目结构刻意做得很通用, 它并没有强套某一种特定的包结构.\n\n这也是社区努力的成果. 如果你见到一个新模式, 或是认为某个模式需要改进都可以开新的 issue.\n\n如果你需要一些命名, 代码格式化和风格上的帮助, 可以从 [gofmt](https://golang.org/cmd/gofmt/) 及 [golint](https://github.com/golang/lint) 开始. 同时也请确保读过这些 Go 代码规范和建议:\n\n- https://talks.golang.org/2014/names.slide\n- https://golang.org/doc/effective_go.html#names\n- https://blog.golang.org/package-names\n- https://github.com/golang/go/wiki/CodeReviewComments\n\n参考 [`Go Project Layout`](https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2) 来了解更多背景知识.\n\n还有更多其他关于命名, 包结构组织, 代码结构方面的建议在这里:\n\n- [GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming](https://www.youtube.com/watch?v=PTE4VJIdHPg)\n- [GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.](https://www.youtube.com/watch?v=MzTcsI6tn-0)\n- [GopherCon 2017: Edward Muller - Go Anti-Patterns](https://www.youtube.com/watch?v=ltqV6pDKZD8)\n- [GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps](https://www.youtube.com/watch?v=oL6JBUk6tj0)\n\n## Go 目录\n\n### /cmd\n\n该项目的主程序.\n\n每个程序目录的名字应该和可执行文件的名字保持一致 (比如 `/cmd/myapp`).\n\n不要在程序目录中放太多代码. 如果你觉得这些代码会被其他项目引用, 那它们应该被放在 `/pkg` 目录中. 如果这些代码不能被重用, 或者说你不希望别人重用这些代码, 那么就把它们放在 `/internal` 目录中. 你也许会惊讶于别人使用你代码的方式, 所以一定要保持你的意图足够明确!\n\n一般来说一个足够小的 `main` 函数, 用于引入并执行 `/internal` 和 `/pkg` 下的代码就足够了.\n\n例子请参考 [`/cmd`](https://github.com/golang-standards/project-layout/blob/master/cmd/README.md) 目录\n\n### /internal\n\n程序和库的私有代码. 这里的代码都是你不希望被别的应用和库所引用的.\n\n把你真正的应用代码放在 `/internal/app` 目录 (比如: `/internal/app/myapp`) 把你的应用间共享的代码放在 `/internal/pkg` 目录 (比如: `internal/pkg/myprivlib`)\n\n### /pkg\n\n可以被其他外部应用引用的代码 (比如: `/pkg/mypubliclib`). 其他项目会引入这些库并期望它们能正常工作, 所以把代码放在这里之前还请三思 :-)\n\n如果你的代码仓库根目录中包含很多非 Go 的组件和目录, 那么把 Go 代码组织到同一个目录下也算是一种方式, 这么做可以让你更轻松地使用不少 Go 工具 (GopherCon EU 2018 里的 [`Best Practices for Industrial Programming`](https://www.youtube.com/watch?v=PTE4VJIdHPg) 有提过这部分的内容 ).\n\n如果你想看看有哪些热门项目使用了这种项目结构可以参考 [`/pkg`](https://github.com/golang-standards/project-layout/blob/master/pkg/README.md) 目录. 这是一种常见的布局模式, 但它并没有被完全接受, 有些 Go 社区并不推荐使用.\n\n### /vendor\n\n应用的依赖 (手工管理或者是通过你最爱的依赖管理工具像是 [`dep`](https://github.com/golang/dep)).\n\n如果你在构建一个库项目, 那注意不要把依赖也提交上去了.\n\n## Service 应用目录\n\n### /api\n\nOpenAPI/Swagger 规范, JSON schema 文件, 协议定义文件.\n\n例子请参考 [`/api`](https://github.com/golang-standards/project-layout/blob/master/api/README.md)\n\n## Web 应用目录\n\n### /web\n\nWeb 应用标准组件: 静态 Web 资源, 服务端模板, 单页应用.\n\n## 常规应用目录\n\n### /configs\n\n配置文件模板或者默认配置.\n\n在这里放置你的 `confd` 或者 `consul-template` 模板文件.\n\n### /init\n\n系统初始化 (systemd, upstart, sysv) 及进程管理/监控 (runit, supervisord) 配置.\n\n### /scripts\n\n执行各种构建, 安装, 分析等其他操作的脚本.\n\n这些脚本要保持根级别的 Makefile 小而简单 (比如: https://github.com/hashicorp/terraform/blob/master/Makefile).\n\n例子请参考 [`/scripts`](https://github.com/golang-standards/project-layout/blob/master/scripts/README.md) 目录\n\n### /build\n\n打包及持续集成.\n\n将 cloud (AMI), container (Docker), OS (deb, rpm, pkg) 包配置放在 `/build/package` 目录下.\n\n将 CI (travis, circle, drone) 配置和脚本放在 `/build/ci` 目录. 需要注意的是, 有些 CI 工具 (比如 Travis CI) 对它们配置文件的位置非常挑剔. 尝试把配置文件放在 `/build/ci` 目录, 然后将它们软链接到 CI 工具希望它们出现的位置 (如果可能的话).\n\n### /deployments\n\nIaaS, Paas, 系统, 容器编排的部署配置和模板 (docker-compose, kubernetes/helm, mesos, terraform, bosh)\n\n### /test\n\n额外的外部测试软件和测试数据. 你可以用任意方式自由地组织 `/test` 目录的结构. 大型项目则有必要包含一个 data 子目录. 比如你可以建立 `/test/data` 或者 `/test/testdata` 目录, 如果你希望 Go 忽略里面的内容. 注意, Go 也会忽略任何以 \".\" 和 \"_\" 开头的文件和目录, 所以就如何命名测试数据目录而言, 你拥有更多的灵活性.\n\n例子请参考 [`/test`](https://github.com/golang-standards/project-layout/blob/master/test/README.md) 目录.\n\n## 其他目录\n\n### /docs\n\n用户及设计文档 (除了 godc 生成的文档).\n\n例子请参考  [`/docs`](https://github.com/golang-standards/project-layout/blob/master/docs/README.md) 目录.\n\n### /tools\n\n项目的支持工具. 注意, 这些工具可以引入 `/pkg` 和 `/internal` 目录的代码.\n\n例子请参考 [`/tools`](https://github.com/golang-standards/project-layout/blob/master/tools/README.md) 目录.\n\n### /examples\n\n应用或者库的示例文件.\n\n例子请参考 [`/examples`](https://github.com/golang-standards/project-layout/blob/master/examples/README.md) 目录.\n\n### /third_party\n\n外部辅助工具, forked 代码, 以及其他第三方工具 (例如: Swagger UI)\n\n### /githooks\n\nGit hooks.\n\n### /assets\n\n其他和你的代码仓库一起的资源文件 (图片, logo 等).\n\n### /website\n\n如果你不用 Github pages 的话, 这里放置你的项目站点数据.\n\n例子参考 [`/website`](https://github.com/golang-standards/project-layout/blob/master/website/README.md) 目录.\n\n## 不应该存在的目录\n\n### /src\n\n有些 Go 项目确实有个 `src` 目录, 但是这一般发生在从 Java 世界过来的开发者身上, 在那里这是一个很常见的模式. 如果做得到就尽量控制住自己不要采用 Java 的目录模式. 你不会希望你的 Go 代码和 Go 工程看起来像 Java 一样 :-)\n\n不过别搞混项目级别的 `/src` 目录和 Go 本身用作工作空间的 `/src` 目录, 在 [`How to Write Go Code`](https://golang.org/doc/code.html) 有对它的描述. `$GOPATH` 环境变量指向你 (当前) 的工作空间 (在非 Windows 系统中它默认指向 `$HOME/go`). 这个工作空间包括顶层的 `/pkg`, `/bin` 和 `/src` 目录. 你的实际项目最终被放在 `/src` 的一个子目录中, 所以如果你在你的项目中包含 `/src` 目录, 那么你的项目路径看起来会是这个样子 `/some/path/to/workspace/src/your_project/src/your_code.go`. 需要注意的是 尽管 Go 1.11 中你可以把你的项目放在 `GOPATH` 之外, 但采用这种布局模式依然不是个好主意.\n\n## 徽章\n\n- [Go Report Card](https://goreportcard.com/) - 它会使用 `gofmt`, `go vet`, `gocyclo`, `golint`, `ineffassign`, `license` 和 `misspell` 扫描你的代码. 用你自己的项目地址替换掉 `github.com/golang-standards/project-layout` 就可以了.\n- [GoDoc](http://godoc.org/) - 它会提供在线版的 GoDoc 自动生成的文档. 把项目链接改成你自己的就行了.\n- Release - 它会显示你项目的最新版本号. 修改 GitHub 链接指向你自己的项目即可.\n\n## Notes\n\nA more opinionated project template with sample/reusable configs, scripts and code is a WIP. (作者的一个冷笑话)\n\n\n\n作者：GotaX\n链接：https://www.jianshu.com/p/4726b9ac5fb1\n来源：简书\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","slug":"go_md/[译] Go 项目结构规范","published":1,"updated":"2021-04-09T12:49:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5t000iw9q99324663o","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"译-Go-项目结构规范\"><a href=\"#译-Go-项目结构规范\" class=\"headerlink\" title=\"[译] Go 项目结构规范\"></a>[译] Go 项目结构规范</h1><blockquote>\n<p>英文原文及项目结构示例: <a href=\"https://github.com/golang-standards/project-layout\">https://github.com/golang-standards/project-layout</a></p>\n</blockquote>\n<p>这里列举的是一个 Go 项目的基础布局. 它并不是由 Go 核心开发团队定义的官方标准; 然而, 它是 Go 生态圈中新老项目常用的一组布局模式. 其中一些模式较其他更流行一些. 它也包含一些小的改进以及支持目录, 这在真实世界中足够大的项目里是很常见的.</p>\n<p>如果你正准备学习 Go 语言, 或者你只是想验证一些概念, 做个玩具项目, 那使用这套项目布局就有些小题大做了. 从最简单的实现开始 (一个 <code>main.go</code> 文件就绰绰有余了). 随着项目逐渐成长, 请记得保持良好的项目结构是一件很重要的事情, 否则结果只会一团乱麻, 代码包含着大量的隐藏依赖和全局状态. 当你的项目有更多人参与的时候, 就需要更多的结构. 这时候引入一种通用的方式来管理包和库就很重要了. 当你管理一个开源项目, 或者当你知道有其他项目会引入你的代码时, 拥有一个私有 private (或叫 <code>内部 internal</code>) 的包和代码也很必要. 你可以克隆这个仓库, 留下需要的删掉其他所有文件! 只是因为它们在那儿并不意味着你一定得都用上. 这些模式中没有哪个是每个项目都得用的. 即便是 <code>vendor</code> 模式也没那么通用.</p>\n<p>这个项目结构刻意做得很通用, 它并没有强套某一种特定的包结构.</p>\n<p>这也是社区努力的成果. 如果你见到一个新模式, 或是认为某个模式需要改进都可以开新的 issue.</p>\n<p>如果你需要一些命名, 代码格式化和风格上的帮助, 可以从 <a href=\"https://golang.org/cmd/gofmt/\">gofmt</a> 及 <a href=\"https://github.com/golang/lint\">golint</a> 开始. 同时也请确保读过这些 Go 代码规范和建议:</p>\n<ul>\n<li><a href=\"https://talks.golang.org/2014/names.slide\">https://talks.golang.org/2014/names.slide</a></li>\n<li><a href=\"https://golang.org/doc/effective_go.html#names\">https://golang.org/doc/effective_go.html#names</a></li>\n<li><a href=\"https://blog.golang.org/package-names\">https://blog.golang.org/package-names</a></li>\n<li><a href=\"https://github.com/golang/go/wiki/CodeReviewComments\">https://github.com/golang/go/wiki/CodeReviewComments</a></li>\n</ul>\n<p>参考 <a href=\"https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2\"><code>Go Project Layout</code></a> 来了解更多背景知识.</p>\n<p>还有更多其他关于命名, 包结构组织, 代码结构方面的建议在这里:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=PTE4VJIdHPg\">GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=MzTcsI6tn-0\">GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=ltqV6pDKZD8\">GopherCon 2017: Edward Muller - Go Anti-Patterns</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=oL6JBUk6tj0\">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a></li>\n</ul>\n<h2 id=\"Go-目录\"><a href=\"#Go-目录\" class=\"headerlink\" title=\"Go 目录\"></a>Go 目录</h2><h3 id=\"cmd\"><a href=\"#cmd\" class=\"headerlink\" title=\"/cmd\"></a>/cmd</h3><p>该项目的主程序.</p>\n<p>每个程序目录的名字应该和可执行文件的名字保持一致 (比如 <code>/cmd/myapp</code>).</p>\n<p>不要在程序目录中放太多代码. 如果你觉得这些代码会被其他项目引用, 那它们应该被放在 <code>/pkg</code> 目录中. 如果这些代码不能被重用, 或者说你不希望别人重用这些代码, 那么就把它们放在 <code>/internal</code> 目录中. 你也许会惊讶于别人使用你代码的方式, 所以一定要保持你的意图足够明确!</p>\n<p>一般来说一个足够小的 <code>main</code> 函数, 用于引入并执行 <code>/internal</code> 和 <code>/pkg</code> 下的代码就足够了.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/cmd/README.md\"><code>/cmd</code></a> 目录</p>\n<h3 id=\"internal\"><a href=\"#internal\" class=\"headerlink\" title=\"/internal\"></a>/internal</h3><p>程序和库的私有代码. 这里的代码都是你不希望被别的应用和库所引用的.</p>\n<p>把你真正的应用代码放在 <code>/internal/app</code> 目录 (比如: <code>/internal/app/myapp</code>) 把你的应用间共享的代码放在 <code>/internal/pkg</code> 目录 (比如: <code>internal/pkg/myprivlib</code>)</p>\n<h3 id=\"pkg\"><a href=\"#pkg\" class=\"headerlink\" title=\"/pkg\"></a>/pkg</h3><p>可以被其他外部应用引用的代码 (比如: <code>/pkg/mypubliclib</code>). 其他项目会引入这些库并期望它们能正常工作, 所以把代码放在这里之前还请三思 :-)</p>\n<p>如果你的代码仓库根目录中包含很多非 Go 的组件和目录, 那么把 Go 代码组织到同一个目录下也算是一种方式, 这么做可以让你更轻松地使用不少 Go 工具 (GopherCon EU 2018 里的 <a href=\"https://www.youtube.com/watch?v=PTE4VJIdHPg\"><code>Best Practices for Industrial Programming</code></a> 有提过这部分的内容 ).</p>\n<p>如果你想看看有哪些热门项目使用了这种项目结构可以参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/pkg/README.md\"><code>/pkg</code></a> 目录. 这是一种常见的布局模式, 但它并没有被完全接受, 有些 Go 社区并不推荐使用.</p>\n<h3 id=\"vendor\"><a href=\"#vendor\" class=\"headerlink\" title=\"/vendor\"></a>/vendor</h3><p>应用的依赖 (手工管理或者是通过你最爱的依赖管理工具像是 <a href=\"https://github.com/golang/dep\"><code>dep</code></a>).</p>\n<p>如果你在构建一个库项目, 那注意不要把依赖也提交上去了.</p>\n<h2 id=\"Service-应用目录\"><a href=\"#Service-应用目录\" class=\"headerlink\" title=\"Service 应用目录\"></a>Service 应用目录</h2><h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"/api\"></a>/api</h3><p>OpenAPI/Swagger 规范, JSON schema 文件, 协议定义文件.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/api/README.md\"><code>/api</code></a></p>\n<h2 id=\"Web-应用目录\"><a href=\"#Web-应用目录\" class=\"headerlink\" title=\"Web 应用目录\"></a>Web 应用目录</h2><h3 id=\"web\"><a href=\"#web\" class=\"headerlink\" title=\"/web\"></a>/web</h3><p>Web 应用标准组件: 静态 Web 资源, 服务端模板, 单页应用.</p>\n<h2 id=\"常规应用目录\"><a href=\"#常规应用目录\" class=\"headerlink\" title=\"常规应用目录\"></a>常规应用目录</h2><h3 id=\"configs\"><a href=\"#configs\" class=\"headerlink\" title=\"/configs\"></a>/configs</h3><p>配置文件模板或者默认配置.</p>\n<p>在这里放置你的 <code>confd</code> 或者 <code>consul-template</code> 模板文件.</p>\n<h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"/init\"></a>/init</h3><p>系统初始化 (systemd, upstart, sysv) 及进程管理/监控 (runit, supervisord) 配置.</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"/scripts\"></a>/scripts</h3><p>执行各种构建, 安装, 分析等其他操作的脚本.</p>\n<p>这些脚本要保持根级别的 Makefile 小而简单 (比如: <a href=\"https://github.com/hashicorp/terraform/blob/master/Makefile\">https://github.com/hashicorp/terraform/blob/master/Makefile</a>).</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/scripts/README.md\"><code>/scripts</code></a> 目录</p>\n<h3 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"/build\"></a>/build</h3><p>打包及持续集成.</p>\n<p>将 cloud (AMI), container (Docker), OS (deb, rpm, pkg) 包配置放在 <code>/build/package</code> 目录下.</p>\n<p>将 CI (travis, circle, drone) 配置和脚本放在 <code>/build/ci</code> 目录. 需要注意的是, 有些 CI 工具 (比如 Travis CI) 对它们配置文件的位置非常挑剔. 尝试把配置文件放在 <code>/build/ci</code> 目录, 然后将它们软链接到 CI 工具希望它们出现的位置 (如果可能的话).</p>\n<h3 id=\"deployments\"><a href=\"#deployments\" class=\"headerlink\" title=\"/deployments\"></a>/deployments</h3><p>IaaS, Paas, 系统, 容器编排的部署配置和模板 (docker-compose, kubernetes/helm, mesos, terraform, bosh)</p>\n<h3 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"/test\"></a>/test</h3><p>额外的外部测试软件和测试数据. 你可以用任意方式自由地组织 <code>/test</code> 目录的结构. 大型项目则有必要包含一个 data 子目录. 比如你可以建立 <code>/test/data</code> 或者 <code>/test/testdata</code> 目录, 如果你希望 Go 忽略里面的内容. 注意, Go 也会忽略任何以 “.” 和 “_” 开头的文件和目录, 所以就如何命名测试数据目录而言, 你拥有更多的灵活性.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/test/README.md\"><code>/test</code></a> 目录.</p>\n<h2 id=\"其他目录\"><a href=\"#其他目录\" class=\"headerlink\" title=\"其他目录\"></a>其他目录</h2><h3 id=\"docs\"><a href=\"#docs\" class=\"headerlink\" title=\"/docs\"></a>/docs</h3><p>用户及设计文档 (除了 godc 生成的文档).</p>\n<p>例子请参考  <a href=\"https://github.com/golang-standards/project-layout/blob/master/docs/README.md\"><code>/docs</code></a> 目录.</p>\n<h3 id=\"tools\"><a href=\"#tools\" class=\"headerlink\" title=\"/tools\"></a>/tools</h3><p>项目的支持工具. 注意, 这些工具可以引入 <code>/pkg</code> 和 <code>/internal</code> 目录的代码.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/tools/README.md\"><code>/tools</code></a> 目录.</p>\n<h3 id=\"examples\"><a href=\"#examples\" class=\"headerlink\" title=\"/examples\"></a>/examples</h3><p>应用或者库的示例文件.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/examples/README.md\"><code>/examples</code></a> 目录.</p>\n<h3 id=\"third-party\"><a href=\"#third-party\" class=\"headerlink\" title=\"/third_party\"></a>/third_party</h3><p>外部辅助工具, forked 代码, 以及其他第三方工具 (例如: Swagger UI)</p>\n<h3 id=\"githooks\"><a href=\"#githooks\" class=\"headerlink\" title=\"/githooks\"></a>/githooks</h3><p>Git hooks.</p>\n<h3 id=\"assets\"><a href=\"#assets\" class=\"headerlink\" title=\"/assets\"></a>/assets</h3><p>其他和你的代码仓库一起的资源文件 (图片, logo 等).</p>\n<h3 id=\"website\"><a href=\"#website\" class=\"headerlink\" title=\"/website\"></a>/website</h3><p>如果你不用 Github pages 的话, 这里放置你的项目站点数据.</p>\n<p>例子参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/website/README.md\"><code>/website</code></a> 目录.</p>\n<h2 id=\"不应该存在的目录\"><a href=\"#不应该存在的目录\" class=\"headerlink\" title=\"不应该存在的目录\"></a>不应该存在的目录</h2><h3 id=\"src\"><a href=\"#src\" class=\"headerlink\" title=\"/src\"></a>/src</h3><p>有些 Go 项目确实有个 <code>src</code> 目录, 但是这一般发生在从 Java 世界过来的开发者身上, 在那里这是一个很常见的模式. 如果做得到就尽量控制住自己不要采用 Java 的目录模式. 你不会希望你的 Go 代码和 Go 工程看起来像 Java 一样 :-)</p>\n<p>不过别搞混项目级别的 <code>/src</code> 目录和 Go 本身用作工作空间的 <code>/src</code> 目录, 在 <a href=\"https://golang.org/doc/code.html\"><code>How to Write Go Code</code></a> 有对它的描述. <code>$GOPATH</code> 环境变量指向你 (当前) 的工作空间 (在非 Windows 系统中它默认指向 <code>$HOME/go</code>). 这个工作空间包括顶层的 <code>/pkg</code>, <code>/bin</code> 和 <code>/src</code> 目录. 你的实际项目最终被放在 <code>/src</code> 的一个子目录中, 所以如果你在你的项目中包含 <code>/src</code> 目录, 那么你的项目路径看起来会是这个样子 <code>/some/path/to/workspace/src/your_project/src/your_code.go</code>. 需要注意的是 尽管 Go 1.11 中你可以把你的项目放在 <code>GOPATH</code> 之外, 但采用这种布局模式依然不是个好主意.</p>\n<h2 id=\"徽章\"><a href=\"#徽章\" class=\"headerlink\" title=\"徽章\"></a>徽章</h2><ul>\n<li><a href=\"https://goreportcard.com/\">Go Report Card</a> - 它会使用 <code>gofmt</code>, <code>go vet</code>, <code>gocyclo</code>, <code>golint</code>, <code>ineffassign</code>, <code>license</code> 和 <code>misspell</code> 扫描你的代码. 用你自己的项目地址替换掉 <code>github.com/golang-standards/project-layout</code> 就可以了.</li>\n<li><a href=\"http://godoc.org/\">GoDoc</a> - 它会提供在线版的 GoDoc 自动生成的文档. 把项目链接改成你自己的就行了.</li>\n<li>Release - 它会显示你项目的最新版本号. 修改 GitHub 链接指向你自己的项目即可.</li>\n</ul>\n<h2 id=\"Notes\"><a href=\"#Notes\" class=\"headerlink\" title=\"Notes\"></a>Notes</h2><p>A more opinionated project template with sample/reusable configs, scripts and code is a WIP. (作者的一个冷笑话)</p>\n<p>作者：GotaX<br>链接：<a href=\"https://www.jianshu.com/p/4726b9ac5fb1\">https://www.jianshu.com/p/4726b9ac5fb1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"译-Go-项目结构规范\"><a href=\"#译-Go-项目结构规范\" class=\"headerlink\" title=\"[译] Go 项目结构规范\"></a>[译] Go 项目结构规范</h1><blockquote>\n<p>英文原文及项目结构示例: <a href=\"https://github.com/golang-standards/project-layout\">https://github.com/golang-standards/project-layout</a></p>\n</blockquote>\n<p>这里列举的是一个 Go 项目的基础布局. 它并不是由 Go 核心开发团队定义的官方标准; 然而, 它是 Go 生态圈中新老项目常用的一组布局模式. 其中一些模式较其他更流行一些. 它也包含一些小的改进以及支持目录, 这在真实世界中足够大的项目里是很常见的.</p>\n<p>如果你正准备学习 Go 语言, 或者你只是想验证一些概念, 做个玩具项目, 那使用这套项目布局就有些小题大做了. 从最简单的实现开始 (一个 <code>main.go</code> 文件就绰绰有余了). 随着项目逐渐成长, 请记得保持良好的项目结构是一件很重要的事情, 否则结果只会一团乱麻, 代码包含着大量的隐藏依赖和全局状态. 当你的项目有更多人参与的时候, 就需要更多的结构. 这时候引入一种通用的方式来管理包和库就很重要了. 当你管理一个开源项目, 或者当你知道有其他项目会引入你的代码时, 拥有一个私有 private (或叫 <code>内部 internal</code>) 的包和代码也很必要. 你可以克隆这个仓库, 留下需要的删掉其他所有文件! 只是因为它们在那儿并不意味着你一定得都用上. 这些模式中没有哪个是每个项目都得用的. 即便是 <code>vendor</code> 模式也没那么通用.</p>\n<p>这个项目结构刻意做得很通用, 它并没有强套某一种特定的包结构.</p>\n<p>这也是社区努力的成果. 如果你见到一个新模式, 或是认为某个模式需要改进都可以开新的 issue.</p>\n<p>如果你需要一些命名, 代码格式化和风格上的帮助, 可以从 <a href=\"https://golang.org/cmd/gofmt/\">gofmt</a> 及 <a href=\"https://github.com/golang/lint\">golint</a> 开始. 同时也请确保读过这些 Go 代码规范和建议:</p>\n<ul>\n<li><a href=\"https://talks.golang.org/2014/names.slide\">https://talks.golang.org/2014/names.slide</a></li>\n<li><a href=\"https://golang.org/doc/effective_go.html#names\">https://golang.org/doc/effective_go.html#names</a></li>\n<li><a href=\"https://blog.golang.org/package-names\">https://blog.golang.org/package-names</a></li>\n<li><a href=\"https://github.com/golang/go/wiki/CodeReviewComments\">https://github.com/golang/go/wiki/CodeReviewComments</a></li>\n</ul>\n<p>参考 <a href=\"https://medium.com/golang-learn/go-project-layout-e5213cdcfaa2\"><code>Go Project Layout</code></a> 来了解更多背景知识.</p>\n<p>还有更多其他关于命名, 包结构组织, 代码结构方面的建议在这里:</p>\n<ul>\n<li><a href=\"https://www.youtube.com/watch?v=PTE4VJIdHPg\">GopherCon EU 2018: Peter Bourgon - Best Practices for Industrial Programming</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=MzTcsI6tn-0\">GopherCon Russia 2018: Ashley McNamara + Brian Ketelsen - Go best practices.</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=ltqV6pDKZD8\">GopherCon 2017: Edward Muller - Go Anti-Patterns</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=oL6JBUk6tj0\">GopherCon 2018: Kat Zien - How Do You Structure Your Go Apps</a></li>\n</ul>\n<h2 id=\"Go-目录\"><a href=\"#Go-目录\" class=\"headerlink\" title=\"Go 目录\"></a>Go 目录</h2><h3 id=\"cmd\"><a href=\"#cmd\" class=\"headerlink\" title=\"/cmd\"></a>/cmd</h3><p>该项目的主程序.</p>\n<p>每个程序目录的名字应该和可执行文件的名字保持一致 (比如 <code>/cmd/myapp</code>).</p>\n<p>不要在程序目录中放太多代码. 如果你觉得这些代码会被其他项目引用, 那它们应该被放在 <code>/pkg</code> 目录中. 如果这些代码不能被重用, 或者说你不希望别人重用这些代码, 那么就把它们放在 <code>/internal</code> 目录中. 你也许会惊讶于别人使用你代码的方式, 所以一定要保持你的意图足够明确!</p>\n<p>一般来说一个足够小的 <code>main</code> 函数, 用于引入并执行 <code>/internal</code> 和 <code>/pkg</code> 下的代码就足够了.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/cmd/README.md\"><code>/cmd</code></a> 目录</p>\n<h3 id=\"internal\"><a href=\"#internal\" class=\"headerlink\" title=\"/internal\"></a>/internal</h3><p>程序和库的私有代码. 这里的代码都是你不希望被别的应用和库所引用的.</p>\n<p>把你真正的应用代码放在 <code>/internal/app</code> 目录 (比如: <code>/internal/app/myapp</code>) 把你的应用间共享的代码放在 <code>/internal/pkg</code> 目录 (比如: <code>internal/pkg/myprivlib</code>)</p>\n<h3 id=\"pkg\"><a href=\"#pkg\" class=\"headerlink\" title=\"/pkg\"></a>/pkg</h3><p>可以被其他外部应用引用的代码 (比如: <code>/pkg/mypubliclib</code>). 其他项目会引入这些库并期望它们能正常工作, 所以把代码放在这里之前还请三思 :-)</p>\n<p>如果你的代码仓库根目录中包含很多非 Go 的组件和目录, 那么把 Go 代码组织到同一个目录下也算是一种方式, 这么做可以让你更轻松地使用不少 Go 工具 (GopherCon EU 2018 里的 <a href=\"https://www.youtube.com/watch?v=PTE4VJIdHPg\"><code>Best Practices for Industrial Programming</code></a> 有提过这部分的内容 ).</p>\n<p>如果你想看看有哪些热门项目使用了这种项目结构可以参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/pkg/README.md\"><code>/pkg</code></a> 目录. 这是一种常见的布局模式, 但它并没有被完全接受, 有些 Go 社区并不推荐使用.</p>\n<h3 id=\"vendor\"><a href=\"#vendor\" class=\"headerlink\" title=\"/vendor\"></a>/vendor</h3><p>应用的依赖 (手工管理或者是通过你最爱的依赖管理工具像是 <a href=\"https://github.com/golang/dep\"><code>dep</code></a>).</p>\n<p>如果你在构建一个库项目, 那注意不要把依赖也提交上去了.</p>\n<h2 id=\"Service-应用目录\"><a href=\"#Service-应用目录\" class=\"headerlink\" title=\"Service 应用目录\"></a>Service 应用目录</h2><h3 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"/api\"></a>/api</h3><p>OpenAPI/Swagger 规范, JSON schema 文件, 协议定义文件.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/api/README.md\"><code>/api</code></a></p>\n<h2 id=\"Web-应用目录\"><a href=\"#Web-应用目录\" class=\"headerlink\" title=\"Web 应用目录\"></a>Web 应用目录</h2><h3 id=\"web\"><a href=\"#web\" class=\"headerlink\" title=\"/web\"></a>/web</h3><p>Web 应用标准组件: 静态 Web 资源, 服务端模板, 单页应用.</p>\n<h2 id=\"常规应用目录\"><a href=\"#常规应用目录\" class=\"headerlink\" title=\"常规应用目录\"></a>常规应用目录</h2><h3 id=\"configs\"><a href=\"#configs\" class=\"headerlink\" title=\"/configs\"></a>/configs</h3><p>配置文件模板或者默认配置.</p>\n<p>在这里放置你的 <code>confd</code> 或者 <code>consul-template</code> 模板文件.</p>\n<h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"/init\"></a>/init</h3><p>系统初始化 (systemd, upstart, sysv) 及进程管理/监控 (runit, supervisord) 配置.</p>\n<h3 id=\"scripts\"><a href=\"#scripts\" class=\"headerlink\" title=\"/scripts\"></a>/scripts</h3><p>执行各种构建, 安装, 分析等其他操作的脚本.</p>\n<p>这些脚本要保持根级别的 Makefile 小而简单 (比如: <a href=\"https://github.com/hashicorp/terraform/blob/master/Makefile\">https://github.com/hashicorp/terraform/blob/master/Makefile</a>).</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/scripts/README.md\"><code>/scripts</code></a> 目录</p>\n<h3 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"/build\"></a>/build</h3><p>打包及持续集成.</p>\n<p>将 cloud (AMI), container (Docker), OS (deb, rpm, pkg) 包配置放在 <code>/build/package</code> 目录下.</p>\n<p>将 CI (travis, circle, drone) 配置和脚本放在 <code>/build/ci</code> 目录. 需要注意的是, 有些 CI 工具 (比如 Travis CI) 对它们配置文件的位置非常挑剔. 尝试把配置文件放在 <code>/build/ci</code> 目录, 然后将它们软链接到 CI 工具希望它们出现的位置 (如果可能的话).</p>\n<h3 id=\"deployments\"><a href=\"#deployments\" class=\"headerlink\" title=\"/deployments\"></a>/deployments</h3><p>IaaS, Paas, 系统, 容器编排的部署配置和模板 (docker-compose, kubernetes/helm, mesos, terraform, bosh)</p>\n<h3 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"/test\"></a>/test</h3><p>额外的外部测试软件和测试数据. 你可以用任意方式自由地组织 <code>/test</code> 目录的结构. 大型项目则有必要包含一个 data 子目录. 比如你可以建立 <code>/test/data</code> 或者 <code>/test/testdata</code> 目录, 如果你希望 Go 忽略里面的内容. 注意, Go 也会忽略任何以 “.” 和 “_” 开头的文件和目录, 所以就如何命名测试数据目录而言, 你拥有更多的灵活性.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/test/README.md\"><code>/test</code></a> 目录.</p>\n<h2 id=\"其他目录\"><a href=\"#其他目录\" class=\"headerlink\" title=\"其他目录\"></a>其他目录</h2><h3 id=\"docs\"><a href=\"#docs\" class=\"headerlink\" title=\"/docs\"></a>/docs</h3><p>用户及设计文档 (除了 godc 生成的文档).</p>\n<p>例子请参考  <a href=\"https://github.com/golang-standards/project-layout/blob/master/docs/README.md\"><code>/docs</code></a> 目录.</p>\n<h3 id=\"tools\"><a href=\"#tools\" class=\"headerlink\" title=\"/tools\"></a>/tools</h3><p>项目的支持工具. 注意, 这些工具可以引入 <code>/pkg</code> 和 <code>/internal</code> 目录的代码.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/tools/README.md\"><code>/tools</code></a> 目录.</p>\n<h3 id=\"examples\"><a href=\"#examples\" class=\"headerlink\" title=\"/examples\"></a>/examples</h3><p>应用或者库的示例文件.</p>\n<p>例子请参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/examples/README.md\"><code>/examples</code></a> 目录.</p>\n<h3 id=\"third-party\"><a href=\"#third-party\" class=\"headerlink\" title=\"/third_party\"></a>/third_party</h3><p>外部辅助工具, forked 代码, 以及其他第三方工具 (例如: Swagger UI)</p>\n<h3 id=\"githooks\"><a href=\"#githooks\" class=\"headerlink\" title=\"/githooks\"></a>/githooks</h3><p>Git hooks.</p>\n<h3 id=\"assets\"><a href=\"#assets\" class=\"headerlink\" title=\"/assets\"></a>/assets</h3><p>其他和你的代码仓库一起的资源文件 (图片, logo 等).</p>\n<h3 id=\"website\"><a href=\"#website\" class=\"headerlink\" title=\"/website\"></a>/website</h3><p>如果你不用 Github pages 的话, 这里放置你的项目站点数据.</p>\n<p>例子参考 <a href=\"https://github.com/golang-standards/project-layout/blob/master/website/README.md\"><code>/website</code></a> 目录.</p>\n<h2 id=\"不应该存在的目录\"><a href=\"#不应该存在的目录\" class=\"headerlink\" title=\"不应该存在的目录\"></a>不应该存在的目录</h2><h3 id=\"src\"><a href=\"#src\" class=\"headerlink\" title=\"/src\"></a>/src</h3><p>有些 Go 项目确实有个 <code>src</code> 目录, 但是这一般发生在从 Java 世界过来的开发者身上, 在那里这是一个很常见的模式. 如果做得到就尽量控制住自己不要采用 Java 的目录模式. 你不会希望你的 Go 代码和 Go 工程看起来像 Java 一样 :-)</p>\n<p>不过别搞混项目级别的 <code>/src</code> 目录和 Go 本身用作工作空间的 <code>/src</code> 目录, 在 <a href=\"https://golang.org/doc/code.html\"><code>How to Write Go Code</code></a> 有对它的描述. <code>$GOPATH</code> 环境变量指向你 (当前) 的工作空间 (在非 Windows 系统中它默认指向 <code>$HOME/go</code>). 这个工作空间包括顶层的 <code>/pkg</code>, <code>/bin</code> 和 <code>/src</code> 目录. 你的实际项目最终被放在 <code>/src</code> 的一个子目录中, 所以如果你在你的项目中包含 <code>/src</code> 目录, 那么你的项目路径看起来会是这个样子 <code>/some/path/to/workspace/src/your_project/src/your_code.go</code>. 需要注意的是 尽管 Go 1.11 中你可以把你的项目放在 <code>GOPATH</code> 之外, 但采用这种布局模式依然不是个好主意.</p>\n<h2 id=\"徽章\"><a href=\"#徽章\" class=\"headerlink\" title=\"徽章\"></a>徽章</h2><ul>\n<li><a href=\"https://goreportcard.com/\">Go Report Card</a> - 它会使用 <code>gofmt</code>, <code>go vet</code>, <code>gocyclo</code>, <code>golint</code>, <code>ineffassign</code>, <code>license</code> 和 <code>misspell</code> 扫描你的代码. 用你自己的项目地址替换掉 <code>github.com/golang-standards/project-layout</code> 就可以了.</li>\n<li><a href=\"http://godoc.org/\">GoDoc</a> - 它会提供在线版的 GoDoc 自动生成的文档. 把项目链接改成你自己的就行了.</li>\n<li>Release - 它会显示你项目的最新版本号. 修改 GitHub 链接指向你自己的项目即可.</li>\n</ul>\n<h2 id=\"Notes\"><a href=\"#Notes\" class=\"headerlink\" title=\"Notes\"></a>Notes</h2><p>A more opinionated project template with sample/reusable configs, scripts and code is a WIP. (作者的一个冷笑话)</p>\n<p>作者：GotaX<br>链接：<a href=\"https://www.jianshu.com/p/4726b9ac5fb1\">https://www.jianshu.com/p/4726b9ac5fb1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>\n"},{"title":"用Go编写HTTP服务器","date":"2020-12-31T15:59:00.000Z","abbrlink":14004,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n\n# 用Go编写HTTP服务器\n\nGo是一门通用的编程语言，想要学习 Go 语言的 Web 开发，就必须知道如何用 Go 启动一个 HTTP 服务器用于接收和响应来自客户端的 HTTP 请求。用 Go实现一个`http server`非常容易，Go 语言标准库`net/http`自带了一系列结构和方法来帮助开发者简化 HTTP 服务开发的相关流程。因此，我们不需要依赖任何第三方组件就能构建并启动一个高并发的 HTTP 服务器。这篇文章会学习如何用`net/http`自己编写实现一个`HTTP Serve`并探究其实现原理，以此来学习了解网络编程的常见范式以及设计思路。\n\n## HTTP 服务处理流程\n\n基于HTTP构建的服务标准模型包括两个端，客户端(`Client`)和服务端(`Server`)。HTTP 请求从客户端发出，服务端接受到请求后进行处理然后将响应返回给客户端。所以http服务器的工作就在于如何接受来自客户端的请求，并向客户端返回响应。\n\n典型的 HTTP 服务的处理流程如下图所示：\n\n![image-20210331100841458](%E7%94%A8Go%E7%BC%96%E5%86%99HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210331100841458.png)\n\n服务器在接收到请求时，首先会进入路由(`router`)，也成为服务复用器（`Multiplexe`），路由的工作在于请求找到对应的处理器(`handler`)，处理器对接收到的请求进行相应处理后构建响应并返回给客户端。Go实现的`http server`同样遵循这样的处理流程。\n\n我们先看看Go如何实现一个简单的返回 `\"Hello World\"` 的`http server`：\n\n```go\npackage main\n\nimport (\n   \"fmt\"\n   \"net/http\"\n)\n\nfunc HelloHandler(w http.ResponseWriter, r *http.Request) {\n   fmt.Fprintf(w, \"Hello World\")\n}\n\nfunc main () {\n   http.HandleFunc(\"/\", HelloHandler)\n   http.ListenAndServe(\":8000\", nil)\n}\n```\n\n运行代码之后，在浏览器中打开`localhost:8000`就可以看到`Hello World`。这段代码先利用`http.HandleFunc`在根路由`/`上注册了一个`HelloHandler`, 然后利用`http.ListenAndServe`启动服务器并监听本地的 8000 端口。当有请求过来时，则根据路由执行对应的`handler`函数。\n\n我们再看一下另外一种常见的实现方式：\n\n```go\npackage main\n\nimport (\n   \"fmt\"\n   \"net/http\"\n)\n\ntype HelloHandlerStruct struct {\n   content string\n}\n\nfunc (handler *HelloHandlerStruct) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n   fmt.Fprintf(w, handler.content)\n}\n\nfunc main()  {\n   http.Handle(\"/\", &HelloHandlerStruct{content: \"Hello World\"})\n   http.ListenAndServe(\":8000\", nil)\n}\n```\n\n这段代码不再使用 `http.HandleFunc` 函数，取而代之的是直接调用 `http.Handle` 并传入我们自定义的 `http.Handler` 接口的实例。\n\nGo实现的`http`服务步骤非常简单，首先注册路由，然后创建服务并开启监听即可。下文我们将从注册路由、开启服务、处理请求，以及关闭服务这几个步骤了解Go如何实现`http`服务。\n\n## 路由注册\n\n`http.HandleFunc`和`http.Handle`都是用于给路由规则指定处理器，`http.HandleFunc`的第一个参数为路由的匹配规则(pattern)第二个参数是一个签名为`func(w http.ResponseWriter, r *http.Requests)`的函数。而`http.Handle`的第二个参数为实现了`http.Handler`接口的类型的实例。\n\n`http.HandleFunc`和`http.Handle`的源码如下：\n\n```go\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n\n// HandleFunc registers the handler function for the given pattern.\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n\nfunc Handle(pattern string, handler Handler) { \n    DefaultServeMux.Handle(pattern, handler)\n}\n```\n\n可以看到这两个函数最终都由`DefaultServeMux`调用`Handle`方法来完成路由处理器的注册。\n这里我们遇到两种类型的对象：`ServeMux`和`Handler`。\n\n### Handler\n\n`http.Handler` 是`net/http`中定义的接口用来表示 HTTP 请求：\n\n```go\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n`Handler`接口中声明了名为`ServeHTTP`的函数签名，也就是说任何结构只要实现了这个`ServeHTTP`方法，那么这个结构体就是一个`Handler`对象。其实go的`http`服务都是基于`Handler`进行处理，而`Handler`对象的`ServeHTTP`方法会读取`Request`进行逻辑处理然后向`ResponseWriter`中写入响应的头部信息和响应内容。\n\n回到上面的`HandleFunc`函数，它调用了`*ServeMux.HandleFunc`将处理器注册到指定路由规则上：\n\n```go\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n注意一下这行代码：\n\n```go\nmux.Handle(pattern, HandlerFunc(handler))\n```\n\n这里`HandlerFunc`实际上是将`handler`函数做了一个类型转换，将函数转换为了`http.HandlerFunc`类型（注意：注册路由时调用的是 `http.HandleFunc`，这里类型是`http.HandlerFunc`）。看一下`HandlerFunc`的定义：\n\n```go\ntype HandlerFunc func(ResponseWriter, *Request)\n\n// ServeHTTP calls f(w, r).\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n```\n\n`HandlerFunc`类型表示的是一个具有`func(ResponseWriter, *Request)`签名的函数类型，并且这种类型实现了`ServeHTTP`方法（在其实现的`ServeHTTP`方法中又调用了被转换的函数自身）。也就是说这个类型的函数其实就是一个`Handler`类型的对象。利用这种类型转换，我们可以将将具有`func(ResponseWriter, *Request)`签名的普通函数转换为一个`Handler`对象，而不需要定义一个结构体，再让这个结构实现`ServeHTTP`方法。\n\n### ServeMux(服务复用器)\n\n上面的代码中可以看到不论是使用`http.HandleFunc`还是`http.Handle`注册路由的处理函数时最后都会用到`ServerMux`结构的`Handle`方法去注册路由处理函数。\n\n我们先来看一下`ServeMux`的定义：\n\n```go\ntype ServeMux struct {\n    mu    sync.RWMutex\n    m     map[string]muxEntry\n    es    []muxEntry // slice of entries sorted from longest to shortest.\n    hosts bool       // whether any patterns contain hostnames\n}\n\ntype muxEntry struct {\n    h       Handler\n    pattern string\n}\n```\n\n`ServeMux`中的字段`m`，是一个`map`，`key`是路由表达式，`value`是一个`muxEntry`结构，`muxEntry`结构体存储了路由表达式和对应的`handler`。字段`m`对应的 `map`用于路由的精确匹配而`es`字段的`slice`会用于路由的部分匹配，这个到了路由匹配部分再细讲。\n\n`ServeMux`也实现了`ServeHTTP`方法：\n\n```go\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n    if r.RequestURI == \"*\" {\n        if r.ProtoAtLeast(1, 1) {\n            w.Header().Set(\"Connection\", \"close\")\n        }\n        w.WriteHeader(StatusBadRequest)\n        return\n    }\n    h, _ := mux.Handler(r)\n    h.ServeHTTP(w, r)\n}\n```\n\n也就是说`ServeMux`结构体也是`Handler`对象，只不过`ServeMux`的`ServeHTTP`方法不是用来处理具体的`request`和构建`response`，而是用来通过路由查找对应的路由处理器`Handler`对象，再去调用路由处理器的ServeHTTP 方法去处理`request`和构建`reponse`。\n\n### 注册路由\n\n搞明白`Handler`和`ServeMux`之后，我们再回到之前的代码：\n\n```go\nDefaultServeMux.Handle(pattern, handler)\n```\n\n这里的`DefaultServeMux`表示一个默认的`ServeMux`实例，在上面的例子中我们没有创建自定义的`ServeMux`，所以会自动使用`DefaultServeMux`\n\n然后再看一下`ServeMux`的`Handle`方法是怎么注册路由的处理函数的：\n\n```go\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) {\n    mux.mu.Lock()\n    defer mux.mu.Unlock()\n\n    if pattern == \"\" {\n        panic(\"http: invalid pattern\")\n    }\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n  // 路由已经注册过处理器函数，直接panic\n    if _, exist := mux.m[pattern]; exist {\n        panic(\"http: multiple registrations for \" + pattern)\n    }\n\n    if mux.m == nil {\n        mux.m = make(map[string]muxEntry)\n    }\n  // 用路由的pattern和处理函数创建 muxEntry 对象\n    e := muxEntry{h: handler, pattern: pattern}\n  // 向ServeMux的m 字段增加新的路由匹配规则\n    mux.m[pattern] = e\n    if pattern[len(pattern)-1] == '/' {\n  // 如果路由patterm以'/'结尾，则将对应的muxEntry对象加入到[]muxEntry中，路由长的位于切片的前面\n        mux.es = appendSorted(mux.es, e)\n    }\n\n    if pattern[0] != '/' {\n        mux.hosts = true\n    }\n}\n```\n\n`Handle`方法注册路由时主要做了两件事情：一个就是向`ServeMux`的`map[string]muxEntry`增加给定的路由匹配规则；然后如果路由表达式以`'/'`结尾，则将对应的`muxEntry`对象加入到`[]muxEntry`中，按照路由表达式长度倒序排列。前者用于路由精确匹配，后者用于部分匹配，具体怎么匹配的后面再看。\n\n### 自定义 ServeMux\n\n通过`http.NewServeMux()`可以创建一个`ServeMux`实例取代默认的`DefaultServeMux`\n\n我们把上面输出`Hello World`的 `http server`再次改造一下，使用自定义的 `ServeMux`实例作为`ListenAndServe()`方法的第二个参数，并且增加一个`/welcome`路由（下面的代码主要是展示用`Handle `和 `HandleFunc `注册路由，实际使用的时候不必这么麻烦，选一种就好）：\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype WelcomeHandlerStruct struct {\n\n}\n\nfunc HelloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello World\")\n}\n\nfunc (*WelcomeHandlerStruct) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Welcome\")\n}\n\nfunc main () {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/\", HelloHandler)\n    mux.Handle(\"/welcome\", &WelcomeHandlerStruct{})\n    http.ListenAndServe(\":8080\", mux)\n}\n```\n\n之前提到`ServeMux`也实现了`ServeHTTP`方法，因此`mux`也是一个`Handler`对象。对于`ListenAndServe()`方法，如果第二个参数是自定义`ServeMux`实例，那么`Server`实例接收到的`ServeMux`服务复用器对象将不再是`DefaultServeMux`而是`mux`。\n\n## 启动服务\n\n路由注册完成后，使用`http.ListenAndServe`方法就能启动服务器开始监听指定端口过来的请求。\n\n```go\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n\nfunc (srv *Server) ListenAndServe() error {\n    if srv.shuttingDown() {\n        return ErrServerClosed\n    }\n    addr := srv.Addr\n    if addr == \"\" {\n        addr = \":http\"\n    }\n    ln, err := net.Listen(\"tcp\", addr)\n    if err != nil {\n        return err\n    }\n    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})\n}\n```\n\n这先创建了一个`Server`对象，传入了地址和`handler`参数（这里的`handler`参数时 `ServeMux `实例），然后调用`Server`对象`ListenAndServe()`方法。\n\n### Server（服务器对象）\n\n先看一下`Server`这个结构体的定义，字段比较多，可以先大致了解一下：\n\n```go\ntype Server struct {\n    Addr    string  // TCP address to listen on, \":http\" if empty\n    Handler Handler // handler to invoke, http.DefaultServeMux if nil\n    TLSConfig *tls.Config\n    ReadTimeout time.Duration\n    ReadHeaderTimeout time.Duration\n    WriteTimeout time.Duration\n    IdleTimeout time.Duration\n    MaxHeaderBytes int\n    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)\n    ConnState func(net.Conn, ConnState)\n    ErrorLog *log.Logger\n\n    disableKeepAlives int32     // accessed atomically.\n    inShutdown        int32     \n    nextProtoOnce     sync.Once \n    nextProtoErr      error     \n\n    mu         sync.Mutex\n    listeners  map[*net.Listener]struct{}\n    activeConn map[*conn]struct{}// 活跃连接\n    doneChan   chan struct{}\n    onShutdown []func()\n}\n```\n\n在`Server`的`ListenAndServe`方法中，会初始化监听地址`Addr`，同时调用`Listen`方法设置监听。最后将监听的TCP对象传入其`Serve`方法。Server 对象的 Serve 方法会接收 Listener 中过来的连接，为每个连接创建一个`goroutine`，在`goroutine `中会用路由处理 `Handler` 对请求进行处理并构建响应。\n\n```go\nfunc (srv *Server) Serve(l net.Listener) error {\n......\n   baseCtx := context.Background() // base is always background, per Issue 16220 \n   ctx := context.WithValue(baseCtx, ServerContextKey, srv)\n   for {\n      rw, e := l.Accept()// 接收 listener 过来的网络连接请求\n      ......\n      c := srv.newConn(rw)\n      c.setState(c.rwc, StateNew) // 将连接放在 Server.activeConn这个 map 中\n      go c.serve(ctx)// 创建协程处理请求\n   }\n}\n```\n\n这里隐去了一些细节，以便了解`Serve`方法的主要逻辑。首先创建一个上下文对象，然后调用`Listener`的`Accept()`接收监听到的网络连接；一旦有新的连接建立，则调用`Server`的`newConn()`创建新的连接对象，并将连接的状态标志为`StateNew`，然后开启一个`goroutine`处理连接请求。\n\n## 处理连接\n\n在开启的 `goroutine`中`conn`的`serve()`会进行路由匹配找到路由处理函数然后调用处理函数。这个方法很长，我们保留关键逻辑。\n\n```go\nfunc (c *conn) serve(ctx context.Context) {\n\n    ...\n\n    for {\n        w, err := c.readRequest(ctx)\n        if c.r.remain != c.server.initialReadLimitSize() {\n            // If we read any bytes off the wire, we're active.\n            c.setState(c.rwc, StateActive)\n        }\n\n        ...\n        serverHandler{c.server}.ServeHTTP(w, w.req)\n        w.cancelCtx()\n        if c.hijacked() {\n            return\n        }\n        w.finishRequest()\n        if !w.shouldReuseConnection() {\n            if w.requestBodyLimitHit || w.closedRequestBodyEarly() {\n                c.closeWriteAndWait()\n            }\n            return\n        }\n        c.setState(c.rwc, StateIdle)\n        c.curReq.Store((*response)(nil))\n\n        ...\n    }\n}\n```\n\n当一个连接建立之后，该连接中所有的请求都将在这个协程中进行处理，直到连接被关闭。在`serve()`方法中会循环调用`readRequest()`方法读取下一个请求进行处理，其中最关键的逻辑是下面行代码：\n\n```go\nserverHandler{c.server}.ServeHTTP(w, w.req)\n```\n\n`serverHandler`是一个结构体类型，它会代理`Server`对象：\n\n```go\ntype serverHandler struct {\n   srv *Server\n}\n\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    handler := sh.srv.Handler\n    if handler == nil {\n        handler = DefaultServeMux\n    }\n    if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n        handler = globalOptionsHandler{}\n    }\n    handler.ServeHTTP(rw, req)\n}\n```\n\n在`serverHandler`实现的`ServeHTTP()`方法里的`sh.srv.Handler`就是我们最初在`http.ListenAndServe()`中传入的`Handler`参数，也就是我们自定义的`ServeMux`对象。如果该`Handler`对象为`nil`，则会使用默认的`DefaultServeMux`。最后调用`ServeMux`的`ServeHTTP()`方法匹配当前路由对应的`handler`方法。\n\n```go\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n   if r.RequestURI == \"*\" {\n      if r.ProtoAtLeast(1, 1) {\n         w.Header().Set(\"Connection\", \"close\")\n      }\n      w.WriteHeader(StatusBadRequest)\n      return\n   }\n   h, _ := mux.Handler(r)\n   h.ServeHTTP(w, r)\n}\n\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n\n    if r.Method == \"CONNECT\" {\n        if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {\n            return RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n        }\n\n        return mux.handler(r.Host, r.URL.Path)\n    }\n\n    // All other requests have any port stripped and path cleaned\n    // before passing to mux.handler.\n    host := stripHostPort(r.Host)\n    path := cleanPath(r.URL.Path)\n\n    // If the given path is /tree and its handler is not registered,\n    // redirect for /tree/.\n    if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {\n        return RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n    }\n\n    if path != r.URL.Path {\n        _, pattern = mux.handler(host, path)\n        url := *r.URL\n        url.Path = path\n        return RedirectHandler(url.String(), StatusMovedPermanently), pattern\n    }\n\n    return mux.handler(host, r.URL.Path)\n}\n\n// handler is the main implementation of Handler.\n// The path is known to be in canonical form, except for CONNECT methods.\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n    mux.mu.RLock()\n    defer mux.mu.RUnlock()\n\n    // Host-specific pattern takes precedence over generic ones\n    if mux.hosts {\n        h, pattern = mux.match(host + path)\n    }\n    if h == nil {\n        h, pattern = mux.match(path)\n    }\n    if h == nil {\n        h, pattern = NotFoundHandler(), \"\"\n    }\n    return\n}\n\n// Find a handler on a handler map given a path string.\n// Most-specific (longest) pattern wins.\nfunc (mux *ServeMux) match(path string) (h Handler, pattern string) {\n    // Check for exact match first.\n    v, ok := mux.m[path]\n    if ok {\n        return v.h, v.pattern\n    }\n\n    // Check for longest valid match.  mux.es contains all patterns\n    // that end in / sorted from longest to shortest.\n    for _, e := range mux.es {\n        if strings.HasPrefix(path, e.pattern) {\n            return e.h, e.pattern\n        }\n    }\n    return nil, \"\"\n}\n```\n\n在`match`方法里我们看到之前提到的mux的`m`字段(类型为`map[string]muxEntry`)和`es`(类型为`[]muxEntry`)。这个方法里首先会利用进行精确匹配，在`map[string]muxEntry`中查找是否有对应的路由规则存在；如果没有匹配的路由规则，则会利用`es`进行近似匹配。\n\n之前提到在注册路由时会把以`'/'`结尾的路由（可称为**节点路由**）加入到`es`字段的`[]muxEntry`中。对于类似`/path1/path2/path3`这样的路由，如果不能找到精确匹配的路由规则，那么则会去匹配和当前路由最接近的已注册的父节点路由，所以如果路由`/path1/path2/`已注册，那么该路由会被匹配，否则继续匹配下一个父节点路由，直到根路由`/`。\n\n由于`[]muxEntry`中的`muxEntry`按照路由表达式从长到短排序，所以进行近似匹配时匹配到的节点路由一定是已注册父节点路由中最相近的。\n\n查找到路由实际的处理器`Handler`对象返回给调用者`ServerMux.ServeHTTP`方法后，最后在方法里就会调用处理器`Handler`的`ServeHTTP`方法处理请求、构建写入响应：\n\n```go\nh.ServeHTTP(w, r)\n```\n\n实际上如果根据路由查找不到处理器`Handler`那么也会返回`NotFoundHandler`:\n\n```go\nfunc NotFound(w ResponseWriter, r *Request) { Error(w, \"404 page not found\", StatusNotFound) }\n\nfunc NotFoundHandler() Handler { return HandlerFunc(NotFound) }\n```\n\n这样标准统一，在调用` h.ServeHTTP(w, r)`后则会想响应中写入 404 的错误信息。\n\n## 停止服务\n\n我们写的`http server`已经能监听网络连接、把请求路由到处理器函数处理请求并返回响应了，但是还需要能优雅的关停服务，在生产环境中，当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。\n\n从 Go 1.8 版本开始，`net/http`原生支持使用`http.ShutDown`来优雅的关停HTTP 服务。这种方案同样要求用户创建自定义的 `http.Server` 对象，因为`Shutdown`方法无法通过其它途径调用。\n\n我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：\n\n```go\npackage main\n\nimport (\n   \"context\"\n   \"fmt\"\n   \"log\"\n   \"net/http\"\n   \"os\"\n   \"os/signal\"\n   \"syscall\"\n)\n\nfunc main() {\n   mux := http.NewServeMux()\n   mux.Handle(\"/\", &helloHandler{})\n\n   server := &http.Server{\n      Addr:    \":8081\",\n      Handler: mux,\n   }\n\n   // 创建系统信号接收器\n   done := make(chan os.Signal)\n   signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)\n   go func() {\n      <-done\n\n      if err := server.Shutdown(context.Background()); err != nil {\n         log.Fatal(\"Shutdown server:\", err)\n      }\n   }()\n\n   log.Println(\"Starting HTTP server...\")\n   err := server.ListenAndServe()\n   if err != nil {\n      if err == http.ErrServerClosed {\n         log.Print(\"Server closed under request\")\n      } else {\n         log.Fatal(\"Server closed unexpected\")\n      }\n   }\n}\n\ntype helloHandler struct{}\n\nfunc (*helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n   fmt.Fprintf(w, \"Hello World\")\n}\n```\n\n这段代码通过捕捉 `os.Interrupt` 信号（Ctrl+C）和`syscall,SIGTERM`信号（kill 进程时传递给进程的信号）然后调用 `server.Shutdown` 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 `http.ErrServerClosed`，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。\n\n用Go 编写`http server`的流程就大致学习完了，当然要写出一个高性能的服务器还有很多要学习的地方，`net/http`标准库里还有很多结构和方法来完善`http server`，学会这些最基本的方法后再看其他Web 框架的代码时就清晰很多。甚至熟练了觉得框架用着太复杂也能自己封装一个HTTP 服务的脚手架（我用echo 和 gin 觉得还挺简单的，跟PHP 的Laravel框架比起来他们也就算个脚手架吧，没黑 PHP，关注我的用 Laravel 的小伙伴可别取关【哈哈哈...嗝】）。\n\n参考文章：\n\n[https://juejin.im/post/5dd11b...](https://juejin.im/post/5dd11baff265da0c0c1fe813)\n\n[https://github.com/unknwon/bu...](https://github.com/unknwon/building-web-applications-in-go/blob/master/articles/01.md)\n\n[https://medium.com/honestbee-...](https://medium.com/honestbee-tw-engineer/gracefully-shutdown-in-go-http-server-5f5e6b83da5a)","source":"_posts/go_md/用Go编写HTTP服务器.md","raw":"---\ntitle: 用Go编写HTTP服务器\ndate: '2020/12/31 23:59'\ntags:\n - go\ncategories:\n - 学习笔记\nabbrlink: 14004\ncover: \n---\n\n\n# 用Go编写HTTP服务器\n\nGo是一门通用的编程语言，想要学习 Go 语言的 Web 开发，就必须知道如何用 Go 启动一个 HTTP 服务器用于接收和响应来自客户端的 HTTP 请求。用 Go实现一个`http server`非常容易，Go 语言标准库`net/http`自带了一系列结构和方法来帮助开发者简化 HTTP 服务开发的相关流程。因此，我们不需要依赖任何第三方组件就能构建并启动一个高并发的 HTTP 服务器。这篇文章会学习如何用`net/http`自己编写实现一个`HTTP Serve`并探究其实现原理，以此来学习了解网络编程的常见范式以及设计思路。\n\n## HTTP 服务处理流程\n\n基于HTTP构建的服务标准模型包括两个端，客户端(`Client`)和服务端(`Server`)。HTTP 请求从客户端发出，服务端接受到请求后进行处理然后将响应返回给客户端。所以http服务器的工作就在于如何接受来自客户端的请求，并向客户端返回响应。\n\n典型的 HTTP 服务的处理流程如下图所示：\n\n![image-20210331100841458](%E7%94%A8Go%E7%BC%96%E5%86%99HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210331100841458.png)\n\n服务器在接收到请求时，首先会进入路由(`router`)，也成为服务复用器（`Multiplexe`），路由的工作在于请求找到对应的处理器(`handler`)，处理器对接收到的请求进行相应处理后构建响应并返回给客户端。Go实现的`http server`同样遵循这样的处理流程。\n\n我们先看看Go如何实现一个简单的返回 `\"Hello World\"` 的`http server`：\n\n```go\npackage main\n\nimport (\n   \"fmt\"\n   \"net/http\"\n)\n\nfunc HelloHandler(w http.ResponseWriter, r *http.Request) {\n   fmt.Fprintf(w, \"Hello World\")\n}\n\nfunc main () {\n   http.HandleFunc(\"/\", HelloHandler)\n   http.ListenAndServe(\":8000\", nil)\n}\n```\n\n运行代码之后，在浏览器中打开`localhost:8000`就可以看到`Hello World`。这段代码先利用`http.HandleFunc`在根路由`/`上注册了一个`HelloHandler`, 然后利用`http.ListenAndServe`启动服务器并监听本地的 8000 端口。当有请求过来时，则根据路由执行对应的`handler`函数。\n\n我们再看一下另外一种常见的实现方式：\n\n```go\npackage main\n\nimport (\n   \"fmt\"\n   \"net/http\"\n)\n\ntype HelloHandlerStruct struct {\n   content string\n}\n\nfunc (handler *HelloHandlerStruct) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n   fmt.Fprintf(w, handler.content)\n}\n\nfunc main()  {\n   http.Handle(\"/\", &HelloHandlerStruct{content: \"Hello World\"})\n   http.ListenAndServe(\":8000\", nil)\n}\n```\n\n这段代码不再使用 `http.HandleFunc` 函数，取而代之的是直接调用 `http.Handle` 并传入我们自定义的 `http.Handler` 接口的实例。\n\nGo实现的`http`服务步骤非常简单，首先注册路由，然后创建服务并开启监听即可。下文我们将从注册路由、开启服务、处理请求，以及关闭服务这几个步骤了解Go如何实现`http`服务。\n\n## 路由注册\n\n`http.HandleFunc`和`http.Handle`都是用于给路由规则指定处理器，`http.HandleFunc`的第一个参数为路由的匹配规则(pattern)第二个参数是一个签名为`func(w http.ResponseWriter, r *http.Requests)`的函数。而`http.Handle`的第二个参数为实现了`http.Handler`接口的类型的实例。\n\n`http.HandleFunc`和`http.Handle`的源码如下：\n\n```go\nfunc HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    DefaultServeMux.HandleFunc(pattern, handler)\n}\n\n// HandleFunc registers the handler function for the given pattern.\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n\nfunc Handle(pattern string, handler Handler) { \n    DefaultServeMux.Handle(pattern, handler)\n}\n```\n\n可以看到这两个函数最终都由`DefaultServeMux`调用`Handle`方法来完成路由处理器的注册。\n这里我们遇到两种类型的对象：`ServeMux`和`Handler`。\n\n### Handler\n\n`http.Handler` 是`net/http`中定义的接口用来表示 HTTP 请求：\n\n```go\ntype Handler interface {\n    ServeHTTP(ResponseWriter, *Request)\n}\n```\n\n`Handler`接口中声明了名为`ServeHTTP`的函数签名，也就是说任何结构只要实现了这个`ServeHTTP`方法，那么这个结构体就是一个`Handler`对象。其实go的`http`服务都是基于`Handler`进行处理，而`Handler`对象的`ServeHTTP`方法会读取`Request`进行逻辑处理然后向`ResponseWriter`中写入响应的头部信息和响应内容。\n\n回到上面的`HandleFunc`函数，它调用了`*ServeMux.HandleFunc`将处理器注册到指定路由规则上：\n\n```go\nfunc (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n    mux.Handle(pattern, HandlerFunc(handler))\n}\n```\n\n注意一下这行代码：\n\n```go\nmux.Handle(pattern, HandlerFunc(handler))\n```\n\n这里`HandlerFunc`实际上是将`handler`函数做了一个类型转换，将函数转换为了`http.HandlerFunc`类型（注意：注册路由时调用的是 `http.HandleFunc`，这里类型是`http.HandlerFunc`）。看一下`HandlerFunc`的定义：\n\n```go\ntype HandlerFunc func(ResponseWriter, *Request)\n\n// ServeHTTP calls f(w, r).\nfunc (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n    f(w, r)\n}\n```\n\n`HandlerFunc`类型表示的是一个具有`func(ResponseWriter, *Request)`签名的函数类型，并且这种类型实现了`ServeHTTP`方法（在其实现的`ServeHTTP`方法中又调用了被转换的函数自身）。也就是说这个类型的函数其实就是一个`Handler`类型的对象。利用这种类型转换，我们可以将将具有`func(ResponseWriter, *Request)`签名的普通函数转换为一个`Handler`对象，而不需要定义一个结构体，再让这个结构实现`ServeHTTP`方法。\n\n### ServeMux(服务复用器)\n\n上面的代码中可以看到不论是使用`http.HandleFunc`还是`http.Handle`注册路由的处理函数时最后都会用到`ServerMux`结构的`Handle`方法去注册路由处理函数。\n\n我们先来看一下`ServeMux`的定义：\n\n```go\ntype ServeMux struct {\n    mu    sync.RWMutex\n    m     map[string]muxEntry\n    es    []muxEntry // slice of entries sorted from longest to shortest.\n    hosts bool       // whether any patterns contain hostnames\n}\n\ntype muxEntry struct {\n    h       Handler\n    pattern string\n}\n```\n\n`ServeMux`中的字段`m`，是一个`map`，`key`是路由表达式，`value`是一个`muxEntry`结构，`muxEntry`结构体存储了路由表达式和对应的`handler`。字段`m`对应的 `map`用于路由的精确匹配而`es`字段的`slice`会用于路由的部分匹配，这个到了路由匹配部分再细讲。\n\n`ServeMux`也实现了`ServeHTTP`方法：\n\n```go\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n    if r.RequestURI == \"*\" {\n        if r.ProtoAtLeast(1, 1) {\n            w.Header().Set(\"Connection\", \"close\")\n        }\n        w.WriteHeader(StatusBadRequest)\n        return\n    }\n    h, _ := mux.Handler(r)\n    h.ServeHTTP(w, r)\n}\n```\n\n也就是说`ServeMux`结构体也是`Handler`对象，只不过`ServeMux`的`ServeHTTP`方法不是用来处理具体的`request`和构建`response`，而是用来通过路由查找对应的路由处理器`Handler`对象，再去调用路由处理器的ServeHTTP 方法去处理`request`和构建`reponse`。\n\n### 注册路由\n\n搞明白`Handler`和`ServeMux`之后，我们再回到之前的代码：\n\n```go\nDefaultServeMux.Handle(pattern, handler)\n```\n\n这里的`DefaultServeMux`表示一个默认的`ServeMux`实例，在上面的例子中我们没有创建自定义的`ServeMux`，所以会自动使用`DefaultServeMux`\n\n然后再看一下`ServeMux`的`Handle`方法是怎么注册路由的处理函数的：\n\n```go\nfunc (mux *ServeMux) Handle(pattern string, handler Handler) {\n    mux.mu.Lock()\n    defer mux.mu.Unlock()\n\n    if pattern == \"\" {\n        panic(\"http: invalid pattern\")\n    }\n    if handler == nil {\n        panic(\"http: nil handler\")\n    }\n  // 路由已经注册过处理器函数，直接panic\n    if _, exist := mux.m[pattern]; exist {\n        panic(\"http: multiple registrations for \" + pattern)\n    }\n\n    if mux.m == nil {\n        mux.m = make(map[string]muxEntry)\n    }\n  // 用路由的pattern和处理函数创建 muxEntry 对象\n    e := muxEntry{h: handler, pattern: pattern}\n  // 向ServeMux的m 字段增加新的路由匹配规则\n    mux.m[pattern] = e\n    if pattern[len(pattern)-1] == '/' {\n  // 如果路由patterm以'/'结尾，则将对应的muxEntry对象加入到[]muxEntry中，路由长的位于切片的前面\n        mux.es = appendSorted(mux.es, e)\n    }\n\n    if pattern[0] != '/' {\n        mux.hosts = true\n    }\n}\n```\n\n`Handle`方法注册路由时主要做了两件事情：一个就是向`ServeMux`的`map[string]muxEntry`增加给定的路由匹配规则；然后如果路由表达式以`'/'`结尾，则将对应的`muxEntry`对象加入到`[]muxEntry`中，按照路由表达式长度倒序排列。前者用于路由精确匹配，后者用于部分匹配，具体怎么匹配的后面再看。\n\n### 自定义 ServeMux\n\n通过`http.NewServeMux()`可以创建一个`ServeMux`实例取代默认的`DefaultServeMux`\n\n我们把上面输出`Hello World`的 `http server`再次改造一下，使用自定义的 `ServeMux`实例作为`ListenAndServe()`方法的第二个参数，并且增加一个`/welcome`路由（下面的代码主要是展示用`Handle `和 `HandleFunc `注册路由，实际使用的时候不必这么麻烦，选一种就好）：\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"net/http\"\n)\n\ntype WelcomeHandlerStruct struct {\n\n}\n\nfunc HelloHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Hello World\")\n}\n\nfunc (*WelcomeHandlerStruct) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \"Welcome\")\n}\n\nfunc main () {\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"/\", HelloHandler)\n    mux.Handle(\"/welcome\", &WelcomeHandlerStruct{})\n    http.ListenAndServe(\":8080\", mux)\n}\n```\n\n之前提到`ServeMux`也实现了`ServeHTTP`方法，因此`mux`也是一个`Handler`对象。对于`ListenAndServe()`方法，如果第二个参数是自定义`ServeMux`实例，那么`Server`实例接收到的`ServeMux`服务复用器对象将不再是`DefaultServeMux`而是`mux`。\n\n## 启动服务\n\n路由注册完成后，使用`http.ListenAndServe`方法就能启动服务器开始监听指定端口过来的请求。\n\n```go\nfunc ListenAndServe(addr string, handler Handler) error {\n    server := &Server{Addr: addr, Handler: handler}\n    return server.ListenAndServe()\n}\n\nfunc (srv *Server) ListenAndServe() error {\n    if srv.shuttingDown() {\n        return ErrServerClosed\n    }\n    addr := srv.Addr\n    if addr == \"\" {\n        addr = \":http\"\n    }\n    ln, err := net.Listen(\"tcp\", addr)\n    if err != nil {\n        return err\n    }\n    return srv.Serve(tcpKeepAliveListener{ln.(*net.TCPListener)})\n}\n```\n\n这先创建了一个`Server`对象，传入了地址和`handler`参数（这里的`handler`参数时 `ServeMux `实例），然后调用`Server`对象`ListenAndServe()`方法。\n\n### Server（服务器对象）\n\n先看一下`Server`这个结构体的定义，字段比较多，可以先大致了解一下：\n\n```go\ntype Server struct {\n    Addr    string  // TCP address to listen on, \":http\" if empty\n    Handler Handler // handler to invoke, http.DefaultServeMux if nil\n    TLSConfig *tls.Config\n    ReadTimeout time.Duration\n    ReadHeaderTimeout time.Duration\n    WriteTimeout time.Duration\n    IdleTimeout time.Duration\n    MaxHeaderBytes int\n    TLSNextProto map[string]func(*Server, *tls.Conn, Handler)\n    ConnState func(net.Conn, ConnState)\n    ErrorLog *log.Logger\n\n    disableKeepAlives int32     // accessed atomically.\n    inShutdown        int32     \n    nextProtoOnce     sync.Once \n    nextProtoErr      error     \n\n    mu         sync.Mutex\n    listeners  map[*net.Listener]struct{}\n    activeConn map[*conn]struct{}// 活跃连接\n    doneChan   chan struct{}\n    onShutdown []func()\n}\n```\n\n在`Server`的`ListenAndServe`方法中，会初始化监听地址`Addr`，同时调用`Listen`方法设置监听。最后将监听的TCP对象传入其`Serve`方法。Server 对象的 Serve 方法会接收 Listener 中过来的连接，为每个连接创建一个`goroutine`，在`goroutine `中会用路由处理 `Handler` 对请求进行处理并构建响应。\n\n```go\nfunc (srv *Server) Serve(l net.Listener) error {\n......\n   baseCtx := context.Background() // base is always background, per Issue 16220 \n   ctx := context.WithValue(baseCtx, ServerContextKey, srv)\n   for {\n      rw, e := l.Accept()// 接收 listener 过来的网络连接请求\n      ......\n      c := srv.newConn(rw)\n      c.setState(c.rwc, StateNew) // 将连接放在 Server.activeConn这个 map 中\n      go c.serve(ctx)// 创建协程处理请求\n   }\n}\n```\n\n这里隐去了一些细节，以便了解`Serve`方法的主要逻辑。首先创建一个上下文对象，然后调用`Listener`的`Accept()`接收监听到的网络连接；一旦有新的连接建立，则调用`Server`的`newConn()`创建新的连接对象，并将连接的状态标志为`StateNew`，然后开启一个`goroutine`处理连接请求。\n\n## 处理连接\n\n在开启的 `goroutine`中`conn`的`serve()`会进行路由匹配找到路由处理函数然后调用处理函数。这个方法很长，我们保留关键逻辑。\n\n```go\nfunc (c *conn) serve(ctx context.Context) {\n\n    ...\n\n    for {\n        w, err := c.readRequest(ctx)\n        if c.r.remain != c.server.initialReadLimitSize() {\n            // If we read any bytes off the wire, we're active.\n            c.setState(c.rwc, StateActive)\n        }\n\n        ...\n        serverHandler{c.server}.ServeHTTP(w, w.req)\n        w.cancelCtx()\n        if c.hijacked() {\n            return\n        }\n        w.finishRequest()\n        if !w.shouldReuseConnection() {\n            if w.requestBodyLimitHit || w.closedRequestBodyEarly() {\n                c.closeWriteAndWait()\n            }\n            return\n        }\n        c.setState(c.rwc, StateIdle)\n        c.curReq.Store((*response)(nil))\n\n        ...\n    }\n}\n```\n\n当一个连接建立之后，该连接中所有的请求都将在这个协程中进行处理，直到连接被关闭。在`serve()`方法中会循环调用`readRequest()`方法读取下一个请求进行处理，其中最关键的逻辑是下面行代码：\n\n```go\nserverHandler{c.server}.ServeHTTP(w, w.req)\n```\n\n`serverHandler`是一个结构体类型，它会代理`Server`对象：\n\n```go\ntype serverHandler struct {\n   srv *Server\n}\n\nfunc (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request) {\n    handler := sh.srv.Handler\n    if handler == nil {\n        handler = DefaultServeMux\n    }\n    if req.RequestURI == \"*\" && req.Method == \"OPTIONS\" {\n        handler = globalOptionsHandler{}\n    }\n    handler.ServeHTTP(rw, req)\n}\n```\n\n在`serverHandler`实现的`ServeHTTP()`方法里的`sh.srv.Handler`就是我们最初在`http.ListenAndServe()`中传入的`Handler`参数，也就是我们自定义的`ServeMux`对象。如果该`Handler`对象为`nil`，则会使用默认的`DefaultServeMux`。最后调用`ServeMux`的`ServeHTTP()`方法匹配当前路由对应的`handler`方法。\n\n```go\nfunc (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n   if r.RequestURI == \"*\" {\n      if r.ProtoAtLeast(1, 1) {\n         w.Header().Set(\"Connection\", \"close\")\n      }\n      w.WriteHeader(StatusBadRequest)\n      return\n   }\n   h, _ := mux.Handler(r)\n   h.ServeHTTP(w, r)\n}\n\nfunc (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {\n\n    if r.Method == \"CONNECT\" {\n        if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {\n            return RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n        }\n\n        return mux.handler(r.Host, r.URL.Path)\n    }\n\n    // All other requests have any port stripped and path cleaned\n    // before passing to mux.handler.\n    host := stripHostPort(r.Host)\n    path := cleanPath(r.URL.Path)\n\n    // If the given path is /tree and its handler is not registered,\n    // redirect for /tree/.\n    if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {\n        return RedirectHandler(u.String(), StatusMovedPermanently), u.Path\n    }\n\n    if path != r.URL.Path {\n        _, pattern = mux.handler(host, path)\n        url := *r.URL\n        url.Path = path\n        return RedirectHandler(url.String(), StatusMovedPermanently), pattern\n    }\n\n    return mux.handler(host, r.URL.Path)\n}\n\n// handler is the main implementation of Handler.\n// The path is known to be in canonical form, except for CONNECT methods.\nfunc (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {\n    mux.mu.RLock()\n    defer mux.mu.RUnlock()\n\n    // Host-specific pattern takes precedence over generic ones\n    if mux.hosts {\n        h, pattern = mux.match(host + path)\n    }\n    if h == nil {\n        h, pattern = mux.match(path)\n    }\n    if h == nil {\n        h, pattern = NotFoundHandler(), \"\"\n    }\n    return\n}\n\n// Find a handler on a handler map given a path string.\n// Most-specific (longest) pattern wins.\nfunc (mux *ServeMux) match(path string) (h Handler, pattern string) {\n    // Check for exact match first.\n    v, ok := mux.m[path]\n    if ok {\n        return v.h, v.pattern\n    }\n\n    // Check for longest valid match.  mux.es contains all patterns\n    // that end in / sorted from longest to shortest.\n    for _, e := range mux.es {\n        if strings.HasPrefix(path, e.pattern) {\n            return e.h, e.pattern\n        }\n    }\n    return nil, \"\"\n}\n```\n\n在`match`方法里我们看到之前提到的mux的`m`字段(类型为`map[string]muxEntry`)和`es`(类型为`[]muxEntry`)。这个方法里首先会利用进行精确匹配，在`map[string]muxEntry`中查找是否有对应的路由规则存在；如果没有匹配的路由规则，则会利用`es`进行近似匹配。\n\n之前提到在注册路由时会把以`'/'`结尾的路由（可称为**节点路由**）加入到`es`字段的`[]muxEntry`中。对于类似`/path1/path2/path3`这样的路由，如果不能找到精确匹配的路由规则，那么则会去匹配和当前路由最接近的已注册的父节点路由，所以如果路由`/path1/path2/`已注册，那么该路由会被匹配，否则继续匹配下一个父节点路由，直到根路由`/`。\n\n由于`[]muxEntry`中的`muxEntry`按照路由表达式从长到短排序，所以进行近似匹配时匹配到的节点路由一定是已注册父节点路由中最相近的。\n\n查找到路由实际的处理器`Handler`对象返回给调用者`ServerMux.ServeHTTP`方法后，最后在方法里就会调用处理器`Handler`的`ServeHTTP`方法处理请求、构建写入响应：\n\n```go\nh.ServeHTTP(w, r)\n```\n\n实际上如果根据路由查找不到处理器`Handler`那么也会返回`NotFoundHandler`:\n\n```go\nfunc NotFound(w ResponseWriter, r *Request) { Error(w, \"404 page not found\", StatusNotFound) }\n\nfunc NotFoundHandler() Handler { return HandlerFunc(NotFound) }\n```\n\n这样标准统一，在调用` h.ServeHTTP(w, r)`后则会想响应中写入 404 的错误信息。\n\n## 停止服务\n\n我们写的`http server`已经能监听网络连接、把请求路由到处理器函数处理请求并返回响应了，但是还需要能优雅的关停服务，在生产环境中，当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。\n\n从 Go 1.8 版本开始，`net/http`原生支持使用`http.ShutDown`来优雅的关停HTTP 服务。这种方案同样要求用户创建自定义的 `http.Server` 对象，因为`Shutdown`方法无法通过其它途径调用。\n\n我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：\n\n```go\npackage main\n\nimport (\n   \"context\"\n   \"fmt\"\n   \"log\"\n   \"net/http\"\n   \"os\"\n   \"os/signal\"\n   \"syscall\"\n)\n\nfunc main() {\n   mux := http.NewServeMux()\n   mux.Handle(\"/\", &helloHandler{})\n\n   server := &http.Server{\n      Addr:    \":8081\",\n      Handler: mux,\n   }\n\n   // 创建系统信号接收器\n   done := make(chan os.Signal)\n   signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)\n   go func() {\n      <-done\n\n      if err := server.Shutdown(context.Background()); err != nil {\n         log.Fatal(\"Shutdown server:\", err)\n      }\n   }()\n\n   log.Println(\"Starting HTTP server...\")\n   err := server.ListenAndServe()\n   if err != nil {\n      if err == http.ErrServerClosed {\n         log.Print(\"Server closed under request\")\n      } else {\n         log.Fatal(\"Server closed unexpected\")\n      }\n   }\n}\n\ntype helloHandler struct{}\n\nfunc (*helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n   fmt.Fprintf(w, \"Hello World\")\n}\n```\n\n这段代码通过捕捉 `os.Interrupt` 信号（Ctrl+C）和`syscall,SIGTERM`信号（kill 进程时传递给进程的信号）然后调用 `server.Shutdown` 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 `http.ErrServerClosed`，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。\n\n用Go 编写`http server`的流程就大致学习完了，当然要写出一个高性能的服务器还有很多要学习的地方，`net/http`标准库里还有很多结构和方法来完善`http server`，学会这些最基本的方法后再看其他Web 框架的代码时就清晰很多。甚至熟练了觉得框架用着太复杂也能自己封装一个HTTP 服务的脚手架（我用echo 和 gin 觉得还挺简单的，跟PHP 的Laravel框架比起来他们也就算个脚手架吧，没黑 PHP，关注我的用 Laravel 的小伙伴可别取关【哈哈哈...嗝】）。\n\n参考文章：\n\n[https://juejin.im/post/5dd11b...](https://juejin.im/post/5dd11baff265da0c0c1fe813)\n\n[https://github.com/unknwon/bu...](https://github.com/unknwon/building-web-applications-in-go/blob/master/articles/01.md)\n\n[https://medium.com/honestbee-...](https://medium.com/honestbee-tw-engineer/gracefully-shutdown-in-go-http-server-5f5e6b83da5a)","slug":"go_md/用Go编写HTTP服务器","published":1,"updated":"2021-04-09T12:36:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5u000ow9q9esbdfdfx","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"用Go编写HTTP服务器\"><a href=\"#用Go编写HTTP服务器\" class=\"headerlink\" title=\"用Go编写HTTP服务器\"></a>用Go编写HTTP服务器</h1><p>Go是一门通用的编程语言，想要学习 Go 语言的 Web 开发，就必须知道如何用 Go 启动一个 HTTP 服务器用于接收和响应来自客户端的 HTTP 请求。用 Go实现一个<code>http server</code>非常容易，Go 语言标准库<code>net/http</code>自带了一系列结构和方法来帮助开发者简化 HTTP 服务开发的相关流程。因此，我们不需要依赖任何第三方组件就能构建并启动一个高并发的 HTTP 服务器。这篇文章会学习如何用<code>net/http</code>自己编写实现一个<code>HTTP Serve</code>并探究其实现原理，以此来学习了解网络编程的常见范式以及设计思路。</p>\n<h2 id=\"HTTP-服务处理流程\"><a href=\"#HTTP-服务处理流程\" class=\"headerlink\" title=\"HTTP 服务处理流程\"></a>HTTP 服务处理流程</h2><p>基于HTTP构建的服务标准模型包括两个端，客户端(<code>Client</code>)和服务端(<code>Server</code>)。HTTP 请求从客户端发出，服务端接受到请求后进行处理然后将响应返回给客户端。所以http服务器的工作就在于如何接受来自客户端的请求，并向客户端返回响应。</p>\n<p>典型的 HTTP 服务的处理流程如下图所示：</p>\n<p><img src=\"%E7%94%A8Go%E7%BC%96%E5%86%99HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210331100841458.png\" alt=\"image-20210331100841458\"></p>\n<p>服务器在接收到请求时，首先会进入路由(<code>router</code>)，也成为服务复用器（<code>Multiplexe</code>），路由的工作在于请求找到对应的处理器(<code>handler</code>)，处理器对接收到的请求进行相应处理后构建响应并返回给客户端。Go实现的<code>http server</code>同样遵循这样的处理流程。</p>\n<p>我们先看看Go如何实现一个简单的返回 <code>&quot;Hello World&quot;</code> 的<code>http server</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">   <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HelloHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">   fmt.Fprintf(w, <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, HelloHandler)</span><br><span class=\"line\">   http.ListenAndServe(<span class=\"string\">&quot;:8000&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行代码之后，在浏览器中打开<code>localhost:8000</code>就可以看到<code>Hello World</code>。这段代码先利用<code>http.HandleFunc</code>在根路由<code>/</code>上注册了一个<code>HelloHandler</code>, 然后利用<code>http.ListenAndServe</code>启动服务器并监听本地的 8000 端口。当有请求过来时，则根据路由执行对应的<code>handler</code>函数。</p>\n<p>我们再看一下另外一种常见的实现方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">   <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HelloHandlerStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   content <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(handler *HelloHandlerStruct)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">   fmt.Fprintf(w, handler.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">   http.Handle(<span class=\"string\">&quot;/&quot;</span>, &amp;HelloHandlerStruct&#123;content: <span class=\"string\">&quot;Hello World&quot;</span>&#125;)</span><br><span class=\"line\">   http.ListenAndServe(<span class=\"string\">&quot;:8000&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码不再使用 <code>http.HandleFunc</code> 函数，取而代之的是直接调用 <code>http.Handle</code> 并传入我们自定义的 <code>http.Handler</code> 接口的实例。</p>\n<p>Go实现的<code>http</code>服务步骤非常简单，首先注册路由，然后创建服务并开启监听即可。下文我们将从注册路由、开启服务、处理请求，以及关闭服务这几个步骤了解Go如何实现<code>http</code>服务。</p>\n<h2 id=\"路由注册\"><a href=\"#路由注册\" class=\"headerlink\" title=\"路由注册\"></a>路由注册</h2><p><code>http.HandleFunc</code>和<code>http.Handle</code>都是用于给路由规则指定处理器，<code>http.HandleFunc</code>的第一个参数为路由的匹配规则(pattern)第二个参数是一个签名为<code>func(w http.ResponseWriter, r *http.Requests)</code>的函数。而<code>http.Handle</code>的第二个参数为实现了<code>http.Handler</code>接口的类型的实例。</p>\n<p><code>http.HandleFunc</code>和<code>http.Handle</code>的源码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: nil handler&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123; </span><br><span class=\"line\">    DefaultServeMux.Handle(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这两个函数最终都由<code>DefaultServeMux</code>调用<code>Handle</code>方法来完成路由处理器的注册。<br>这里我们遇到两种类型的对象：<code>ServeMux</code>和<code>Handler</code>。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><p><code>http.Handler</code> 是<code>net/http</code>中定义的接口用来表示 HTTP 请求：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Handler</code>接口中声明了名为<code>ServeHTTP</code>的函数签名，也就是说任何结构只要实现了这个<code>ServeHTTP</code>方法，那么这个结构体就是一个<code>Handler</code>对象。其实go的<code>http</code>服务都是基于<code>Handler</code>进行处理，而<code>Handler</code>对象的<code>ServeHTTP</code>方法会读取<code>Request</code>进行逻辑处理然后向<code>ResponseWriter</code>中写入响应的头部信息和响应内容。</p>\n<p>回到上面的<code>HandleFunc</code>函数，它调用了<code>*ServeMux.HandleFunc</code>将处理器注册到指定路由规则上：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: nil handler&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意一下这行代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mux.Handle(pattern, HandlerFunc(handler))</span><br></pre></td></tr></table></figure>\n<p>这里<code>HandlerFunc</code>实际上是将<code>handler</code>函数做了一个类型转换，将函数转换为了<code>http.HandlerFunc</code>类型（注意：注册路由时调用的是 <code>http.HandleFunc</code>，这里类型是<code>http.HandlerFunc</code>）。看一下<code>HandlerFunc</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ServeHTTP calls f(w, r).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    f(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>HandlerFunc</code>类型表示的是一个具有<code>func(ResponseWriter, *Request)</code>签名的函数类型，并且这种类型实现了<code>ServeHTTP</code>方法（在其实现的<code>ServeHTTP</code>方法中又调用了被转换的函数自身）。也就是说这个类型的函数其实就是一个<code>Handler</code>类型的对象。利用这种类型转换，我们可以将将具有<code>func(ResponseWriter, *Request)</code>签名的普通函数转换为一个<code>Handler</code>对象，而不需要定义一个结构体，再让这个结构实现<code>ServeHTTP</code>方法。</p>\n<h3 id=\"ServeMux-服务复用器\"><a href=\"#ServeMux-服务复用器\" class=\"headerlink\" title=\"ServeMux(服务复用器)\"></a>ServeMux(服务复用器)</h3><p>上面的代码中可以看到不论是使用<code>http.HandleFunc</code>还是<code>http.Handle</code>注册路由的处理函数时最后都会用到<code>ServerMux</code>结构的<code>Handle</code>方法去注册路由处理函数。</p>\n<p>我们先来看一下<code>ServeMux</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    mu    sync.RWMutex</span><br><span class=\"line\">    m     <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry</span><br><span class=\"line\">    es    []muxEntry <span class=\"comment\">// slice of entries sorted from longest to shortest.</span></span><br><span class=\"line\">    hosts <span class=\"keyword\">bool</span>       <span class=\"comment\">// whether any patterns contain hostnames</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    h       Handler</span><br><span class=\"line\">    pattern <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ServeMux</code>中的字段<code>m</code>，是一个<code>map</code>，<code>key</code>是路由表达式，<code>value</code>是一个<code>muxEntry</code>结构，<code>muxEntry</code>结构体存储了路由表达式和对应的<code>handler</code>。字段<code>m</code>对应的 <code>map</code>用于路由的精确匹配而<code>es</code>字段的<code>slice</code>会用于路由的部分匹配，这个到了路由匹配部分再细讲。</p>\n<p><code>ServeMux</code>也实现了<code>ServeHTTP</code>方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            w.Header().Set(<span class=\"string\">&quot;Connection&quot;</span>, <span class=\"string\">&quot;close&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        w.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h, _ := mux.Handler(r)</span><br><span class=\"line\">    h.ServeHTTP(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说<code>ServeMux</code>结构体也是<code>Handler</code>对象，只不过<code>ServeMux</code>的<code>ServeHTTP</code>方法不是用来处理具体的<code>request</code>和构建<code>response</code>，而是用来通过路由查找对应的路由处理器<code>Handler</code>对象，再去调用路由处理器的ServeHTTP 方法去处理<code>request</code>和构建<code>reponse</code>。</p>\n<h3 id=\"注册路由\"><a href=\"#注册路由\" class=\"headerlink\" title=\"注册路由\"></a>注册路由</h3><p>搞明白<code>Handler</code>和<code>ServeMux</code>之后，我们再回到之前的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultServeMux.Handle(pattern, handler)</span><br></pre></td></tr></table></figure>\n<p>这里的<code>DefaultServeMux</code>表示一个默认的<code>ServeMux</code>实例，在上面的例子中我们没有创建自定义的<code>ServeMux</code>，所以会自动使用<code>DefaultServeMux</code></p>\n<p>然后再看一下<code>ServeMux</code>的<code>Handle</code>方法是怎么注册路由的处理函数的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123;</span><br><span class=\"line\">    mux.mu.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pattern == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: invalid pattern&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: nil handler&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 路由已经注册过处理器函数，直接panic</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: multiple registrations for &quot;</span> + pattern)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> mux.m == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        mux.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 用路由的pattern和处理函数创建 muxEntry 对象</span></span><br><span class=\"line\">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向ServeMux的m 字段增加新的路由匹配规则</span></span><br><span class=\"line\">    mux.m[pattern] = e</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pattern[<span class=\"built_in\">len</span>(pattern)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;/&#x27;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果路由patterm以&#x27;/&#x27;结尾，则将对应的muxEntry对象加入到[]muxEntry中，路由长的位于切片的前面</span></span><br><span class=\"line\">        mux.es = appendSorted(mux.es, e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pattern[<span class=\"number\">0</span>] != <span class=\"string\">&#x27;/&#x27;</span> &#123;</span><br><span class=\"line\">        mux.hosts = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Handle</code>方法注册路由时主要做了两件事情：一个就是向<code>ServeMux</code>的<code>map[string]muxEntry</code>增加给定的路由匹配规则；然后如果路由表达式以<code>&#39;/&#39;</code>结尾，则将对应的<code>muxEntry</code>对象加入到<code>[]muxEntry</code>中，按照路由表达式长度倒序排列。前者用于路由精确匹配，后者用于部分匹配，具体怎么匹配的后面再看。</p>\n<h3 id=\"自定义-ServeMux\"><a href=\"#自定义-ServeMux\" class=\"headerlink\" title=\"自定义 ServeMux\"></a>自定义 ServeMux</h3><p>通过<code>http.NewServeMux()</code>可以创建一个<code>ServeMux</code>实例取代默认的<code>DefaultServeMux</code></p>\n<p>我们把上面输出<code>Hello World</code>的 <code>http server</code>再次改造一下，使用自定义的 <code>ServeMux</code>实例作为<code>ListenAndServe()</code>方法的第二个参数，并且增加一个<code>/welcome</code>路由（下面的代码主要是展示用<code>Handle </code>和 <code>HandleFunc </code>注册路由，实际使用的时候不必这么麻烦，选一种就好）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> WelcomeHandlerStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HelloHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*WelcomeHandlerStruct)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Welcome&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := http.NewServeMux()</span><br><span class=\"line\">    mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, HelloHandler)</span><br><span class=\"line\">    mux.Handle(<span class=\"string\">&quot;/welcome&quot;</span>, &amp;WelcomeHandlerStruct&#123;&#125;)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前提到<code>ServeMux</code>也实现了<code>ServeHTTP</code>方法，因此<code>mux</code>也是一个<code>Handler</code>对象。对于<code>ListenAndServe()</code>方法，如果第二个参数是自定义<code>ServeMux</code>实例，那么<code>Server</code>实例接收到的<code>ServeMux</code>服务复用器对象将不再是<code>DefaultServeMux</code>而是<code>mux</code>。</p>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><p>路由注册完成后，使用<code>http.ListenAndServe</code>方法就能启动服务器开始监听指定端口过来的请求。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> srv.shuttingDown() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrServerClosed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addr := srv.Addr</span><br><span class=\"line\">    <span class=\"keyword\">if</span> addr == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        addr = <span class=\"string\">&quot;:http&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ln, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, addr)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这先创建了一个<code>Server</code>对象，传入了地址和<code>handler</code>参数（这里的<code>handler</code>参数时 <code>ServeMux </code>实例），然后调用<code>Server</code>对象<code>ListenAndServe()</code>方法。</p>\n<h3 id=\"Server（服务器对象）\"><a href=\"#Server（服务器对象）\" class=\"headerlink\" title=\"Server（服务器对象）\"></a>Server（服务器对象）</h3><p>先看一下<code>Server</code>这个结构体的定义，字段比较多，可以先大致了解一下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Addr    <span class=\"keyword\">string</span>  <span class=\"comment\">// TCP address to listen on, &quot;:http&quot; if empty</span></span><br><span class=\"line\">    Handler Handler <span class=\"comment\">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class=\"line\">    TLSConfig *tls.Config</span><br><span class=\"line\">    ReadTimeout time.Duration</span><br><span class=\"line\">    ReadHeaderTimeout time.Duration</span><br><span class=\"line\">    WriteTimeout time.Duration</span><br><span class=\"line\">    IdleTimeout time.Duration</span><br><span class=\"line\">    MaxHeaderBytes <span class=\"keyword\">int</span></span><br><span class=\"line\">    TLSNextProto <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*Server, *tls.Conn, Handler)</span></span></span><br><span class=\"line\">    ConnState <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(net.Conn, ConnState)</span></span></span><br><span class=\"line\">    ErrorLog *log.Logger</span><br><span class=\"line\"></span><br><span class=\"line\">    disableKeepAlives <span class=\"keyword\">int32</span>     <span class=\"comment\">// accessed atomically.</span></span><br><span class=\"line\">    inShutdown        <span class=\"keyword\">int32</span>     </span><br><span class=\"line\">    nextProtoOnce     sync.Once </span><br><span class=\"line\">    nextProtoErr      error     </span><br><span class=\"line\"></span><br><span class=\"line\">    mu         sync.Mutex</span><br><span class=\"line\">    listeners  <span class=\"keyword\">map</span>[*net.Listener]<span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">    activeConn <span class=\"keyword\">map</span>[*conn]<span class=\"keyword\">struct</span>&#123;&#125;<span class=\"comment\">// 活跃连接</span></span><br><span class=\"line\">    doneChan   <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">    onShutdown []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>Server</code>的<code>ListenAndServe</code>方法中，会初始化监听地址<code>Addr</code>，同时调用<code>Listen</code>方法设置监听。最后将监听的TCP对象传入其<code>Serve</code>方法。Server 对象的 Serve 方法会接收 Listener 中过来的连接，为每个连接创建一个<code>goroutine</code>，在<code>goroutine </code>中会用路由处理 <code>Handler</code> 对请求进行处理并构建响应。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">   baseCtx := context.Background() <span class=\"comment\">// base is always background, per Issue 16220 </span></span><br><span class=\"line\">   ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class=\"line\">   <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">      rw, e := l.Accept()<span class=\"comment\">// 接收 listener 过来的网络连接请求</span></span><br><span class=\"line\">      ......</span><br><span class=\"line\">      c := srv.newConn(rw)</span><br><span class=\"line\">      c.setState(c.rwc, StateNew) <span class=\"comment\">// 将连接放在 Server.activeConn这个 map 中</span></span><br><span class=\"line\">      <span class=\"keyword\">go</span> c.serve(ctx)<span class=\"comment\">// 创建协程处理请求</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里隐去了一些细节，以便了解<code>Serve</code>方法的主要逻辑。首先创建一个上下文对象，然后调用<code>Listener</code>的<code>Accept()</code>接收监听到的网络连接；一旦有新的连接建立，则调用<code>Server</code>的<code>newConn()</code>创建新的连接对象，并将连接的状态标志为<code>StateNew</code>，然后开启一个<code>goroutine</code>处理连接请求。</p>\n<h2 id=\"处理连接\"><a href=\"#处理连接\" class=\"headerlink\" title=\"处理连接\"></a>处理连接</h2><p>在开启的 <code>goroutine</code>中<code>conn</code>的<code>serve()</code>会进行路由匹配找到路由处理函数然后调用处理函数。这个方法很长，我们保留关键逻辑。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">serve</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        w, err := c.readRequest(ctx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If we read any bytes off the wire, we&#x27;re active.</span></span><br><span class=\"line\">            c.setState(c.rwc, StateActive)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class=\"line\">        w.cancelCtx()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c.hijacked() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        w.finishRequest()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !w.shouldReuseConnection() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class=\"line\">                c.closeWriteAndWait()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        c.setState(c.rwc, StateIdle)</span><br><span class=\"line\">        c.curReq.Store((*response)(<span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当一个连接建立之后，该连接中所有的请求都将在这个协程中进行处理，直到连接被关闭。在<code>serve()</code>方法中会循环调用<code>readRequest()</code>方法读取下一个请求进行处理，其中最关键的逻辑是下面行代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br></pre></td></tr></table></figure>\n<p><code>serverHandler</code>是一个结构体类型，它会代理<code>Server</code>对象：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> serverHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   srv *Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sh serverHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class=\"line\">    handler := sh.srv.Handler</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        handler = DefaultServeMux</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> req.RequestURI == <span class=\"string\">&quot;*&quot;</span> &amp;&amp; req.Method == <span class=\"string\">&quot;OPTIONS&quot;</span> &#123;</span><br><span class=\"line\">        handler = globalOptionsHandler&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handler.ServeHTTP(rw, req)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>serverHandler</code>实现的<code>ServeHTTP()</code>方法里的<code>sh.srv.Handler</code>就是我们最初在<code>http.ListenAndServe()</code>中传入的<code>Handler</code>参数，也就是我们自定义的<code>ServeMux</code>对象。如果该<code>Handler</code>对象为<code>nil</code>，则会使用默认的<code>DefaultServeMux</code>。最后调用<code>ServeMux</code>的<code>ServeHTTP()</code>方法匹配当前路由对应的<code>handler</code>方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">         w.Header().Set(<span class=\"string\">&quot;Connection&quot;</span>, <span class=\"string\">&quot;close&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      w.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   h, _ := mux.Handler(r)</span><br><span class=\"line\">   h.ServeHTTP(w, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;CONNECT&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// All other requests have any port stripped and path cleaned</span></span><br><span class=\"line\">    <span class=\"comment\">// before passing to mux.handler.</span></span><br><span class=\"line\">    host := stripHostPort(r.Host)</span><br><span class=\"line\">    path := cleanPath(r.URL.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the given path is /tree and its handler is not registered,</span></span><br><span class=\"line\">    <span class=\"comment\">// redirect for /tree/.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> path != r.URL.Path &#123;</span><br><span class=\"line\">        _, pattern = mux.handler(host, path)</span><br><span class=\"line\">        url := *r.URL</span><br><span class=\"line\">        url.Path = path</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mux.handler(host, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler is the main implementation of Handler.</span></span><br><span class=\"line\"><span class=\"comment\">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    mux.mu.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> mux.hosts &#123;</span><br><span class=\"line\">        h, pattern = mux.match(host + path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = mux.match(path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = NotFoundHandler(), <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Find a handler on a handler map given a path string.</span></span><br><span class=\"line\"><span class=\"comment\">// Most-specific (longest) pattern wins.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">match</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check for exact match first.</span></span><br><span class=\"line\">    v, ok := mux.m[path]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.h, v.pattern</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check for longest valid match.  mux.es contains all patterns</span></span><br><span class=\"line\">    <span class=\"comment\">// that end in / sorted from longest to shortest.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, e := <span class=\"keyword\">range</span> mux.es &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.h, e.pattern</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>match</code>方法里我们看到之前提到的mux的<code>m</code>字段(类型为<code>map[string]muxEntry</code>)和<code>es</code>(类型为<code>[]muxEntry</code>)。这个方法里首先会利用进行精确匹配，在<code>map[string]muxEntry</code>中查找是否有对应的路由规则存在；如果没有匹配的路由规则，则会利用<code>es</code>进行近似匹配。</p>\n<p>之前提到在注册路由时会把以<code>&#39;/&#39;</code>结尾的路由（可称为<strong>节点路由</strong>）加入到<code>es</code>字段的<code>[]muxEntry</code>中。对于类似<code>/path1/path2/path3</code>这样的路由，如果不能找到精确匹配的路由规则，那么则会去匹配和当前路由最接近的已注册的父节点路由，所以如果路由<code>/path1/path2/</code>已注册，那么该路由会被匹配，否则继续匹配下一个父节点路由，直到根路由<code>/</code>。</p>\n<p>由于<code>[]muxEntry</code>中的<code>muxEntry</code>按照路由表达式从长到短排序，所以进行近似匹配时匹配到的节点路由一定是已注册父节点路由中最相近的。</p>\n<p>查找到路由实际的处理器<code>Handler</code>对象返回给调用者<code>ServerMux.ServeHTTP</code>方法后，最后在方法里就会调用处理器<code>Handler</code>的<code>ServeHTTP</code>方法处理请求、构建写入响应：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h.ServeHTTP(w, r)</span><br></pre></td></tr></table></figure>\n<p>实际上如果根据路由查找不到处理器<code>Handler</code>那么也会返回<code>NotFoundHandler</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotFound</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123; Error(w, <span class=\"string\">&quot;404 page not found&quot;</span>, StatusNotFound) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotFoundHandler</span><span class=\"params\">()</span> <span class=\"title\">Handler</span></span> &#123; <span class=\"keyword\">return</span> HandlerFunc(NotFound) &#125;</span><br></pre></td></tr></table></figure>\n<p>这样标准统一，在调用<code> h.ServeHTTP(w, r)</code>后则会想响应中写入 404 的错误信息。</p>\n<h2 id=\"停止服务\"><a href=\"#停止服务\" class=\"headerlink\" title=\"停止服务\"></a>停止服务</h2><p>我们写的<code>http server</code>已经能监听网络连接、把请求路由到处理器函数处理请求并返回响应了，但是还需要能优雅的关停服务，在生产环境中，当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。</p>\n<p>从 Go 1.8 版本开始，<code>net/http</code>原生支持使用<code>http.ShutDown</code>来优雅的关停HTTP 服务。这种方案同样要求用户创建自定义的 <code>http.Server</code> 对象，因为<code>Shutdown</code>方法无法通过其它途径调用。</p>\n<p>我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">   <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;os/signal&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;syscall&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   mux := http.NewServeMux()</span><br><span class=\"line\">   mux.Handle(<span class=\"string\">&quot;/&quot;</span>, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   server := &amp;http.Server&#123;</span><br><span class=\"line\">      Addr:    <span class=\"string\">&quot;:8081&quot;</span>,</span><br><span class=\"line\">      Handler: mux,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 创建系统信号接收器</span></span><br><span class=\"line\">   done := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> os.Signal)</span><br><span class=\"line\">   signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)</span><br><span class=\"line\">   <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      &lt;-done</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> err := server.Shutdown(context.Background()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">         log.Fatal(<span class=\"string\">&quot;Shutdown server:&quot;</span>, err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">   log.Println(<span class=\"string\">&quot;Starting HTTP server...&quot;</span>)</span><br><span class=\"line\">   err := server.ListenAndServe()</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> err == http.ErrServerClosed &#123;</span><br><span class=\"line\">         log.Print(<span class=\"string\">&quot;Server closed under request&quot;</span>)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         log.Fatal(<span class=\"string\">&quot;Server closed unexpected&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> helloHandler <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*helloHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">   fmt.Fprintf(w, <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码通过捕捉 <code>os.Interrupt</code> 信号（Ctrl+C）和<code>syscall,SIGTERM</code>信号（kill 进程时传递给进程的信号）然后调用 <code>server.Shutdown</code> 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 <code>http.ErrServerClosed</code>，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。</p>\n<p>用Go 编写<code>http server</code>的流程就大致学习完了，当然要写出一个高性能的服务器还有很多要学习的地方，<code>net/http</code>标准库里还有很多结构和方法来完善<code>http server</code>，学会这些最基本的方法后再看其他Web 框架的代码时就清晰很多。甚至熟练了觉得框架用着太复杂也能自己封装一个HTTP 服务的脚手架（我用echo 和 gin 觉得还挺简单的，跟PHP 的Laravel框架比起来他们也就算个脚手架吧，没黑 PHP，关注我的用 Laravel 的小伙伴可别取关【哈哈哈…嗝】）。</p>\n<p>参考文章：</p>\n<p><a href=\"https://juejin.im/post/5dd11baff265da0c0c1fe813\">https://juejin.im/post/5dd11b…</a></p>\n<p><a href=\"https://github.com/unknwon/building-web-applications-in-go/blob/master/articles/01.md\">https://github.com/unknwon/bu…</a></p>\n<p><a href=\"https://medium.com/honestbee-tw-engineer/gracefully-shutdown-in-go-http-server-5f5e6b83da5a\">https://medium.com/honestbee-…</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"用Go编写HTTP服务器\"><a href=\"#用Go编写HTTP服务器\" class=\"headerlink\" title=\"用Go编写HTTP服务器\"></a>用Go编写HTTP服务器</h1><p>Go是一门通用的编程语言，想要学习 Go 语言的 Web 开发，就必须知道如何用 Go 启动一个 HTTP 服务器用于接收和响应来自客户端的 HTTP 请求。用 Go实现一个<code>http server</code>非常容易，Go 语言标准库<code>net/http</code>自带了一系列结构和方法来帮助开发者简化 HTTP 服务开发的相关流程。因此，我们不需要依赖任何第三方组件就能构建并启动一个高并发的 HTTP 服务器。这篇文章会学习如何用<code>net/http</code>自己编写实现一个<code>HTTP Serve</code>并探究其实现原理，以此来学习了解网络编程的常见范式以及设计思路。</p>\n<h2 id=\"HTTP-服务处理流程\"><a href=\"#HTTP-服务处理流程\" class=\"headerlink\" title=\"HTTP 服务处理流程\"></a>HTTP 服务处理流程</h2><p>基于HTTP构建的服务标准模型包括两个端，客户端(<code>Client</code>)和服务端(<code>Server</code>)。HTTP 请求从客户端发出，服务端接受到请求后进行处理然后将响应返回给客户端。所以http服务器的工作就在于如何接受来自客户端的请求，并向客户端返回响应。</p>\n<p>典型的 HTTP 服务的处理流程如下图所示：</p>\n<p><img src=\"%E7%94%A8Go%E7%BC%96%E5%86%99HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20210331100841458.png\" alt=\"image-20210331100841458\"></p>\n<p>服务器在接收到请求时，首先会进入路由(<code>router</code>)，也成为服务复用器（<code>Multiplexe</code>），路由的工作在于请求找到对应的处理器(<code>handler</code>)，处理器对接收到的请求进行相应处理后构建响应并返回给客户端。Go实现的<code>http server</code>同样遵循这样的处理流程。</p>\n<p>我们先看看Go如何实现一个简单的返回 <code>&quot;Hello World&quot;</code> 的<code>http server</code>：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">   <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HelloHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">   fmt.Fprintf(w, <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   http.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, HelloHandler)</span><br><span class=\"line\">   http.ListenAndServe(<span class=\"string\">&quot;:8000&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>运行代码之后，在浏览器中打开<code>localhost:8000</code>就可以看到<code>Hello World</code>。这段代码先利用<code>http.HandleFunc</code>在根路由<code>/</code>上注册了一个<code>HelloHandler</code>, 然后利用<code>http.ListenAndServe</code>启动服务器并监听本地的 8000 端口。当有请求过来时，则根据路由执行对应的<code>handler</code>函数。</p>\n<p>我们再看一下另外一种常见的实现方式：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">   <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> HelloHandlerStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   content <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(handler *HelloHandlerStruct)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">   fmt.Fprintf(w, handler.content)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">   http.Handle(<span class=\"string\">&quot;/&quot;</span>, &amp;HelloHandlerStruct&#123;content: <span class=\"string\">&quot;Hello World&quot;</span>&#125;)</span><br><span class=\"line\">   http.ListenAndServe(<span class=\"string\">&quot;:8000&quot;</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码不再使用 <code>http.HandleFunc</code> 函数，取而代之的是直接调用 <code>http.Handle</code> 并传入我们自定义的 <code>http.Handler</code> 接口的实例。</p>\n<p>Go实现的<code>http</code>服务步骤非常简单，首先注册路由，然后创建服务并开启监听即可。下文我们将从注册路由、开启服务、处理请求，以及关闭服务这几个步骤了解Go如何实现<code>http</code>服务。</p>\n<h2 id=\"路由注册\"><a href=\"#路由注册\" class=\"headerlink\" title=\"路由注册\"></a>路由注册</h2><p><code>http.HandleFunc</code>和<code>http.Handle</code>都是用于给路由规则指定处理器，<code>http.HandleFunc</code>的第一个参数为路由的匹配规则(pattern)第二个参数是一个签名为<code>func(w http.ResponseWriter, r *http.Requests)</code>的函数。而<code>http.Handle</code>的第二个参数为实现了<code>http.Handler</code>接口的类型的实例。</p>\n<p><code>http.HandleFunc</code>和<code>http.Handle</code>的源码如下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// HandleFunc registers the handler function for the given pattern.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: nil handler&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123; </span><br><span class=\"line\">    DefaultServeMux.Handle(pattern, handler)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这两个函数最终都由<code>DefaultServeMux</code>调用<code>Handle</code>方法来完成路由处理器的注册。<br>这里我们遇到两种类型的对象：<code>ServeMux</code>和<code>Handler</code>。</p>\n<h3 id=\"Handler\"><a href=\"#Handler\" class=\"headerlink\" title=\"Handler\"></a>Handler</h3><p><code>http.Handler</code> 是<code>net/http</code>中定义的接口用来表示 HTTP 请求：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Handler <span class=\"keyword\">interface</span> &#123;</span><br><span class=\"line\">    ServeHTTP(ResponseWriter, *Request)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Handler</code>接口中声明了名为<code>ServeHTTP</code>的函数签名，也就是说任何结构只要实现了这个<code>ServeHTTP</code>方法，那么这个结构体就是一个<code>Handler</code>对象。其实go的<code>http</code>服务都是基于<code>Handler</code>进行处理，而<code>Handler</code>对象的<code>ServeHTTP</code>方法会读取<code>Request</code>进行逻辑处理然后向<code>ResponseWriter</code>中写入响应的头部信息和响应内容。</p>\n<p>回到上面的<code>HandleFunc</code>函数，它调用了<code>*ServeMux.HandleFunc</code>将处理器注册到指定路由规则上：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">HandleFunc</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler <span class=\"keyword\">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: nil handler&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    mux.Handle(pattern, HandlerFunc(handler))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>注意一下这行代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mux.Handle(pattern, HandlerFunc(handler))</span><br></pre></td></tr></table></figure>\n<p>这里<code>HandlerFunc</code>实际上是将<code>handler</code>函数做了一个类型转换，将函数转换为了<code>http.HandlerFunc</code>类型（注意：注册路由时调用的是 <code>http.HandleFunc</code>，这里类型是<code>http.HandlerFunc</code>）。看一下<code>HandlerFunc</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> HandlerFunc <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(ResponseWriter, *Request)</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ServeHTTP calls f(w, r).</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(f HandlerFunc)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    f(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>HandlerFunc</code>类型表示的是一个具有<code>func(ResponseWriter, *Request)</code>签名的函数类型，并且这种类型实现了<code>ServeHTTP</code>方法（在其实现的<code>ServeHTTP</code>方法中又调用了被转换的函数自身）。也就是说这个类型的函数其实就是一个<code>Handler</code>类型的对象。利用这种类型转换，我们可以将将具有<code>func(ResponseWriter, *Request)</code>签名的普通函数转换为一个<code>Handler</code>对象，而不需要定义一个结构体，再让这个结构实现<code>ServeHTTP</code>方法。</p>\n<h3 id=\"ServeMux-服务复用器\"><a href=\"#ServeMux-服务复用器\" class=\"headerlink\" title=\"ServeMux(服务复用器)\"></a>ServeMux(服务复用器)</h3><p>上面的代码中可以看到不论是使用<code>http.HandleFunc</code>还是<code>http.Handle</code>注册路由的处理函数时最后都会用到<code>ServerMux</code>结构的<code>Handle</code>方法去注册路由处理函数。</p>\n<p>我们先来看一下<code>ServeMux</code>的定义：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> ServeMux <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    mu    sync.RWMutex</span><br><span class=\"line\">    m     <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry</span><br><span class=\"line\">    es    []muxEntry <span class=\"comment\">// slice of entries sorted from longest to shortest.</span></span><br><span class=\"line\">    hosts <span class=\"keyword\">bool</span>       <span class=\"comment\">// whether any patterns contain hostnames</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> muxEntry <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    h       Handler</span><br><span class=\"line\">    pattern <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>ServeMux</code>中的字段<code>m</code>，是一个<code>map</code>，<code>key</code>是路由表达式，<code>value</code>是一个<code>muxEntry</code>结构，<code>muxEntry</code>结构体存储了路由表达式和对应的<code>handler</code>。字段<code>m</code>对应的 <code>map</code>用于路由的精确匹配而<code>es</code>字段的<code>slice</code>会用于路由的部分匹配，这个到了路由匹配部分再细讲。</p>\n<p><code>ServeMux</code>也实现了<code>ServeHTTP</code>方法：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            w.Header().Set(<span class=\"string\">&quot;Connection&quot;</span>, <span class=\"string\">&quot;close&quot;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        w.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    h, _ := mux.Handler(r)</span><br><span class=\"line\">    h.ServeHTTP(w, r)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说<code>ServeMux</code>结构体也是<code>Handler</code>对象，只不过<code>ServeMux</code>的<code>ServeHTTP</code>方法不是用来处理具体的<code>request</code>和构建<code>response</code>，而是用来通过路由查找对应的路由处理器<code>Handler</code>对象，再去调用路由处理器的ServeHTTP 方法去处理<code>request</code>和构建<code>reponse</code>。</p>\n<h3 id=\"注册路由\"><a href=\"#注册路由\" class=\"headerlink\" title=\"注册路由\"></a>注册路由</h3><p>搞明白<code>Handler</code>和<code>ServeMux</code>之后，我们再回到之前的代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DefaultServeMux.Handle(pattern, handler)</span><br></pre></td></tr></table></figure>\n<p>这里的<code>DefaultServeMux</code>表示一个默认的<code>ServeMux</code>实例，在上面的例子中我们没有创建自定义的<code>ServeMux</code>，所以会自动使用<code>DefaultServeMux</code></p>\n<p>然后再看一下<code>ServeMux</code>的<code>Handle</code>方法是怎么注册路由的处理函数的：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handle</span><span class=\"params\">(pattern <span class=\"keyword\">string</span>, handler Handler)</span></span> &#123;</span><br><span class=\"line\">    mux.mu.Lock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.Unlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pattern == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: invalid pattern&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: nil handler&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 路由已经注册过处理器函数，直接panic</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> _, exist := mux.m[pattern]; exist &#123;</span><br><span class=\"line\">        <span class=\"built_in\">panic</span>(<span class=\"string\">&quot;http: multiple registrations for &quot;</span> + pattern)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> mux.m == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        mux.m = <span class=\"built_in\">make</span>(<span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]muxEntry)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 用路由的pattern和处理函数创建 muxEntry 对象</span></span><br><span class=\"line\">    e := muxEntry&#123;h: handler, pattern: pattern&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 向ServeMux的m 字段增加新的路由匹配规则</span></span><br><span class=\"line\">    mux.m[pattern] = e</span><br><span class=\"line\">    <span class=\"keyword\">if</span> pattern[<span class=\"built_in\">len</span>(pattern)<span class=\"number\">-1</span>] == <span class=\"string\">&#x27;/&#x27;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果路由patterm以&#x27;/&#x27;结尾，则将对应的muxEntry对象加入到[]muxEntry中，路由长的位于切片的前面</span></span><br><span class=\"line\">        mux.es = appendSorted(mux.es, e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> pattern[<span class=\"number\">0</span>] != <span class=\"string\">&#x27;/&#x27;</span> &#123;</span><br><span class=\"line\">        mux.hosts = <span class=\"literal\">true</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Handle</code>方法注册路由时主要做了两件事情：一个就是向<code>ServeMux</code>的<code>map[string]muxEntry</code>增加给定的路由匹配规则；然后如果路由表达式以<code>&#39;/&#39;</code>结尾，则将对应的<code>muxEntry</code>对象加入到<code>[]muxEntry</code>中，按照路由表达式长度倒序排列。前者用于路由精确匹配，后者用于部分匹配，具体怎么匹配的后面再看。</p>\n<h3 id=\"自定义-ServeMux\"><a href=\"#自定义-ServeMux\" class=\"headerlink\" title=\"自定义 ServeMux\"></a>自定义 ServeMux</h3><p>通过<code>http.NewServeMux()</code>可以创建一个<code>ServeMux</code>实例取代默认的<code>DefaultServeMux</code></p>\n<p>我们把上面输出<code>Hello World</code>的 <code>http server</code>再次改造一下，使用自定义的 <code>ServeMux</code>实例作为<code>ListenAndServe()</code>方法的第二个参数，并且增加一个<code>/welcome</code>路由（下面的代码主要是展示用<code>Handle </code>和 <code>HandleFunc </code>注册路由，实际使用的时候不必这么麻烦，选一种就好）：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">    <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> WelcomeHandlerStruct <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">HelloHandler</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*WelcomeHandlerStruct)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">    fmt.Fprintf(w, <span class=\"string\">&quot;Welcome&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span> <span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    mux := http.NewServeMux()</span><br><span class=\"line\">    mux.HandleFunc(<span class=\"string\">&quot;/&quot;</span>, HelloHandler)</span><br><span class=\"line\">    mux.Handle(<span class=\"string\">&quot;/welcome&quot;</span>, &amp;WelcomeHandlerStruct&#123;&#125;)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">&quot;:8080&quot;</span>, mux)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>之前提到<code>ServeMux</code>也实现了<code>ServeHTTP</code>方法，因此<code>mux</code>也是一个<code>Handler</code>对象。对于<code>ListenAndServe()</code>方法，如果第二个参数是自定义<code>ServeMux</code>实例，那么<code>Server</code>实例接收到的<code>ServeMux</code>服务复用器对象将不再是<code>DefaultServeMux</code>而是<code>mux</code>。</p>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><p>路由注册完成后，使用<code>http.ListenAndServe</code>方法就能启动服务器开始监听指定端口过来的请求。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">(addr <span class=\"keyword\">string</span>, handler Handler)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    server := &amp;Server&#123;Addr: addr, Handler: handler&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> server.ListenAndServe()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">ListenAndServe</span><span class=\"params\">()</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> srv.shuttingDown() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ErrServerClosed</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    addr := srv.Addr</span><br><span class=\"line\">    <span class=\"keyword\">if</span> addr == <span class=\"string\">&quot;&quot;</span> &#123;</span><br><span class=\"line\">        addr = <span class=\"string\">&quot;:http&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ln, err := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, addr)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> err</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> srv.Serve(tcpKeepAliveListener&#123;ln.(*net.TCPListener)&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这先创建了一个<code>Server</code>对象，传入了地址和<code>handler</code>参数（这里的<code>handler</code>参数时 <code>ServeMux </code>实例），然后调用<code>Server</code>对象<code>ListenAndServe()</code>方法。</p>\n<h3 id=\"Server（服务器对象）\"><a href=\"#Server（服务器对象）\" class=\"headerlink\" title=\"Server（服务器对象）\"></a>Server（服务器对象）</h3><p>先看一下<code>Server</code>这个结构体的定义，字段比较多，可以先大致了解一下：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> Server <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Addr    <span class=\"keyword\">string</span>  <span class=\"comment\">// TCP address to listen on, &quot;:http&quot; if empty</span></span><br><span class=\"line\">    Handler Handler <span class=\"comment\">// handler to invoke, http.DefaultServeMux if nil</span></span><br><span class=\"line\">    TLSConfig *tls.Config</span><br><span class=\"line\">    ReadTimeout time.Duration</span><br><span class=\"line\">    ReadHeaderTimeout time.Duration</span><br><span class=\"line\">    WriteTimeout time.Duration</span><br><span class=\"line\">    IdleTimeout time.Duration</span><br><span class=\"line\">    MaxHeaderBytes <span class=\"keyword\">int</span></span><br><span class=\"line\">    TLSNextProto <span class=\"keyword\">map</span>[<span class=\"keyword\">string</span>]<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*Server, *tls.Conn, Handler)</span></span></span><br><span class=\"line\">    ConnState <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(net.Conn, ConnState)</span></span></span><br><span class=\"line\">    ErrorLog *log.Logger</span><br><span class=\"line\"></span><br><span class=\"line\">    disableKeepAlives <span class=\"keyword\">int32</span>     <span class=\"comment\">// accessed atomically.</span></span><br><span class=\"line\">    inShutdown        <span class=\"keyword\">int32</span>     </span><br><span class=\"line\">    nextProtoOnce     sync.Once </span><br><span class=\"line\">    nextProtoErr      error     </span><br><span class=\"line\"></span><br><span class=\"line\">    mu         sync.Mutex</span><br><span class=\"line\">    listeners  <span class=\"keyword\">map</span>[*net.Listener]<span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">    activeConn <span class=\"keyword\">map</span>[*conn]<span class=\"keyword\">struct</span>&#123;&#125;<span class=\"comment\">// 活跃连接</span></span><br><span class=\"line\">    doneChan   <span class=\"keyword\">chan</span> <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\">    onShutdown []<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>Server</code>的<code>ListenAndServe</code>方法中，会初始化监听地址<code>Addr</code>，同时调用<code>Listen</code>方法设置监听。最后将监听的TCP对象传入其<code>Serve</code>方法。Server 对象的 Serve 方法会接收 Listener 中过来的连接，为每个连接创建一个<code>goroutine</code>，在<code>goroutine </code>中会用路由处理 <code>Handler</code> 对请求进行处理并构建响应。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(srv *Server)</span> <span class=\"title\">Serve</span><span class=\"params\">(l net.Listener)</span> <span class=\"title\">error</span></span> &#123;</span><br><span class=\"line\">......</span><br><span class=\"line\">   baseCtx := context.Background() <span class=\"comment\">// base is always background, per Issue 16220 </span></span><br><span class=\"line\">   ctx := context.WithValue(baseCtx, ServerContextKey, srv)</span><br><span class=\"line\">   <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">      rw, e := l.Accept()<span class=\"comment\">// 接收 listener 过来的网络连接请求</span></span><br><span class=\"line\">      ......</span><br><span class=\"line\">      c := srv.newConn(rw)</span><br><span class=\"line\">      c.setState(c.rwc, StateNew) <span class=\"comment\">// 将连接放在 Server.activeConn这个 map 中</span></span><br><span class=\"line\">      <span class=\"keyword\">go</span> c.serve(ctx)<span class=\"comment\">// 创建协程处理请求</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里隐去了一些细节，以便了解<code>Serve</code>方法的主要逻辑。首先创建一个上下文对象，然后调用<code>Listener</code>的<code>Accept()</code>接收监听到的网络连接；一旦有新的连接建立，则调用<code>Server</code>的<code>newConn()</code>创建新的连接对象，并将连接的状态标志为<code>StateNew</code>，然后开启一个<code>goroutine</code>处理连接请求。</p>\n<h2 id=\"处理连接\"><a href=\"#处理连接\" class=\"headerlink\" title=\"处理连接\"></a>处理连接</h2><p>在开启的 <code>goroutine</code>中<code>conn</code>的<code>serve()</code>会进行路由匹配找到路由处理函数然后调用处理函数。这个方法很长，我们保留关键逻辑。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(c *conn)</span> <span class=\"title\">serve</span><span class=\"params\">(ctx context.Context)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">        w, err := c.readRequest(ctx)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c.r.remain != c.server.initialReadLimitSize() &#123;</span><br><span class=\"line\">            <span class=\"comment\">// If we read any bytes off the wire, we&#x27;re active.</span></span><br><span class=\"line\">            c.setState(c.rwc, StateActive)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br><span class=\"line\">        w.cancelCtx()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> c.hijacked() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        w.finishRequest()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> !w.shouldReuseConnection() &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;</span><br><span class=\"line\">                c.closeWriteAndWait()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        c.setState(c.rwc, StateIdle)</span><br><span class=\"line\">        c.curReq.Store((*response)(<span class=\"literal\">nil</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当一个连接建立之后，该连接中所有的请求都将在这个协程中进行处理，直到连接被关闭。在<code>serve()</code>方法中会循环调用<code>readRequest()</code>方法读取下一个请求进行处理，其中最关键的逻辑是下面行代码：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)</span><br></pre></td></tr></table></figure>\n<p><code>serverHandler</code>是一个结构体类型，它会代理<code>Server</code>对象：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> serverHandler <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">   srv *Server</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(sh serverHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class=\"line\">    handler := sh.srv.Handler</span><br><span class=\"line\">    <span class=\"keyword\">if</span> handler == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        handler = DefaultServeMux</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> req.RequestURI == <span class=\"string\">&quot;*&quot;</span> &amp;&amp; req.Method == <span class=\"string\">&quot;OPTIONS&quot;</span> &#123;</span><br><span class=\"line\">        handler = globalOptionsHandler&#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    handler.ServeHTTP(rw, req)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>serverHandler</code>实现的<code>ServeHTTP()</code>方法里的<code>sh.srv.Handler</code>就是我们最初在<code>http.ListenAndServe()</code>中传入的<code>Handler</code>参数，也就是我们自定义的<code>ServeMux</code>对象。如果该<code>Handler</code>对象为<code>nil</code>，则会使用默认的<code>DefaultServeMux</code>。最后调用<code>ServeMux</code>的<code>ServeHTTP()</code>方法匹配当前路由对应的<code>handler</code>方法。</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> r.RequestURI == <span class=\"string\">&quot;*&quot;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> r.ProtoAtLeast(<span class=\"number\">1</span>, <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">         w.Header().Set(<span class=\"string\">&quot;Connection&quot;</span>, <span class=\"string\">&quot;close&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      w.WriteHeader(StatusBadRequest)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   h, _ := mux.Handler(r)</span><br><span class=\"line\">   h.ServeHTTP(w, r)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">Handler</span><span class=\"params\">(r *Request)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> r.Method == <span class=\"string\">&quot;CONNECT&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> mux.handler(r.Host, r.URL.Path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// All other requests have any port stripped and path cleaned</span></span><br><span class=\"line\">    <span class=\"comment\">// before passing to mux.handler.</span></span><br><span class=\"line\">    host := stripHostPort(r.Host)</span><br><span class=\"line\">    path := cleanPath(r.URL.Path)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// If the given path is /tree and its handler is not registered,</span></span><br><span class=\"line\">    <span class=\"comment\">// redirect for /tree/.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> u, ok := mux.redirectToPathSlash(host, path, r.URL); ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedirectHandler(u.String(), StatusMovedPermanently), u.Path</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> path != r.URL.Path &#123;</span><br><span class=\"line\">        _, pattern = mux.handler(host, path)</span><br><span class=\"line\">        url := *r.URL</span><br><span class=\"line\">        url.Path = path</span><br><span class=\"line\">        <span class=\"keyword\">return</span> RedirectHandler(url.String(), StatusMovedPermanently), pattern</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> mux.handler(host, r.URL.Path)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// handler is the main implementation of Handler.</span></span><br><span class=\"line\"><span class=\"comment\">// The path is known to be in canonical form, except for CONNECT methods.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">handler</span><span class=\"params\">(host, path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    mux.mu.RLock()</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> mux.mu.RUnlock()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Host-specific pattern takes precedence over generic ones</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> mux.hosts &#123;</span><br><span class=\"line\">        h, pattern = mux.match(host + path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = mux.match(path)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> h == <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        h, pattern = NotFoundHandler(), <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Find a handler on a handler map given a path string.</span></span><br><span class=\"line\"><span class=\"comment\">// Most-specific (longest) pattern wins.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(mux *ServeMux)</span> <span class=\"title\">match</span><span class=\"params\">(path <span class=\"keyword\">string</span>)</span> <span class=\"params\">(h Handler, pattern <span class=\"keyword\">string</span>)</span></span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Check for exact match first.</span></span><br><span class=\"line\">    v, ok := mux.m[path]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ok &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.h, v.pattern</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Check for longest valid match.  mux.es contains all patterns</span></span><br><span class=\"line\">    <span class=\"comment\">// that end in / sorted from longest to shortest.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, e := <span class=\"keyword\">range</span> mux.es &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> strings.HasPrefix(path, e.pattern) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.h, e.pattern</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">nil</span>, <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在<code>match</code>方法里我们看到之前提到的mux的<code>m</code>字段(类型为<code>map[string]muxEntry</code>)和<code>es</code>(类型为<code>[]muxEntry</code>)。这个方法里首先会利用进行精确匹配，在<code>map[string]muxEntry</code>中查找是否有对应的路由规则存在；如果没有匹配的路由规则，则会利用<code>es</code>进行近似匹配。</p>\n<p>之前提到在注册路由时会把以<code>&#39;/&#39;</code>结尾的路由（可称为<strong>节点路由</strong>）加入到<code>es</code>字段的<code>[]muxEntry</code>中。对于类似<code>/path1/path2/path3</code>这样的路由，如果不能找到精确匹配的路由规则，那么则会去匹配和当前路由最接近的已注册的父节点路由，所以如果路由<code>/path1/path2/</code>已注册，那么该路由会被匹配，否则继续匹配下一个父节点路由，直到根路由<code>/</code>。</p>\n<p>由于<code>[]muxEntry</code>中的<code>muxEntry</code>按照路由表达式从长到短排序，所以进行近似匹配时匹配到的节点路由一定是已注册父节点路由中最相近的。</p>\n<p>查找到路由实际的处理器<code>Handler</code>对象返回给调用者<code>ServerMux.ServeHTTP</code>方法后，最后在方法里就会调用处理器<code>Handler</code>的<code>ServeHTTP</code>方法处理请求、构建写入响应：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">h.ServeHTTP(w, r)</span><br></pre></td></tr></table></figure>\n<p>实际上如果根据路由查找不到处理器<code>Handler</code>那么也会返回<code>NotFoundHandler</code>:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotFound</span><span class=\"params\">(w ResponseWriter, r *Request)</span></span> &#123; Error(w, <span class=\"string\">&quot;404 page not found&quot;</span>, StatusNotFound) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">NotFoundHandler</span><span class=\"params\">()</span> <span class=\"title\">Handler</span></span> &#123; <span class=\"keyword\">return</span> HandlerFunc(NotFound) &#125;</span><br></pre></td></tr></table></figure>\n<p>这样标准统一，在调用<code> h.ServeHTTP(w, r)</code>后则会想响应中写入 404 的错误信息。</p>\n<h2 id=\"停止服务\"><a href=\"#停止服务\" class=\"headerlink\" title=\"停止服务\"></a>停止服务</h2><p>我们写的<code>http server</code>已经能监听网络连接、把请求路由到处理器函数处理请求并返回响应了，但是还需要能优雅的关停服务，在生产环境中，当需要更新服务端程序时需要重启服务，但此时可能有一部分请求进行到一半，如果强行中断这些请求可能会导致意外的结果。</p>\n<p>从 Go 1.8 版本开始，<code>net/http</code>原生支持使用<code>http.ShutDown</code>来优雅的关停HTTP 服务。这种方案同样要求用户创建自定义的 <code>http.Server</code> 对象，因为<code>Shutdown</code>方法无法通过其它途径调用。</p>\n<p>我们来看下面的代码，这段代码通过结合捕捉系统信号（Signal）、goroutine 和管道（Channel）来实现服务器的优雅停止：</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">   <span class=\"string\">&quot;context&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;log&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;net/http&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;os/signal&quot;</span></span><br><span class=\"line\">   <span class=\"string\">&quot;syscall&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">   mux := http.NewServeMux()</span><br><span class=\"line\">   mux.Handle(<span class=\"string\">&quot;/&quot;</span>, &amp;helloHandler&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">   server := &amp;http.Server&#123;</span><br><span class=\"line\">      Addr:    <span class=\"string\">&quot;:8081&quot;</span>,</span><br><span class=\"line\">      Handler: mux,</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 创建系统信号接收器</span></span><br><span class=\"line\">   done := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> os.Signal)</span><br><span class=\"line\">   signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)</span><br><span class=\"line\">   <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">      &lt;-done</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> err := server.Shutdown(context.Background()); err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">         log.Fatal(<span class=\"string\">&quot;Shutdown server:&quot;</span>, err)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;()</span><br><span class=\"line\"></span><br><span class=\"line\">   log.Println(<span class=\"string\">&quot;Starting HTTP server...&quot;</span>)</span><br><span class=\"line\">   err := server.ListenAndServe()</span><br><span class=\"line\">   <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> err == http.ErrServerClosed &#123;</span><br><span class=\"line\">         log.Print(<span class=\"string\">&quot;Server closed under request&quot;</span>)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         log.Fatal(<span class=\"string\">&quot;Server closed unexpected&quot;</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> helloHandler <span class=\"keyword\">struct</span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"params\">(*helloHandler)</span> <span class=\"title\">ServeHTTP</span><span class=\"params\">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class=\"line\">   fmt.Fprintf(w, <span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码通过捕捉 <code>os.Interrupt</code> 信号（Ctrl+C）和<code>syscall,SIGTERM</code>信号（kill 进程时传递给进程的信号）然后调用 <code>server.Shutdown</code> 方法告知服务器应停止接受新的请求并在处理完当前已接受的请求后关闭服务器。为了与普通错误相区别，标准库提供了一个特定的错误类型 <code>http.ErrServerClosed</code>，我们可以在代码中通过判断是否为该错误类型来确定服务器是正常关闭的还是意外关闭的。</p>\n<p>用Go 编写<code>http server</code>的流程就大致学习完了，当然要写出一个高性能的服务器还有很多要学习的地方，<code>net/http</code>标准库里还有很多结构和方法来完善<code>http server</code>，学会这些最基本的方法后再看其他Web 框架的代码时就清晰很多。甚至熟练了觉得框架用着太复杂也能自己封装一个HTTP 服务的脚手架（我用echo 和 gin 觉得还挺简单的，跟PHP 的Laravel框架比起来他们也就算个脚手架吧，没黑 PHP，关注我的用 Laravel 的小伙伴可别取关【哈哈哈…嗝】）。</p>\n<p>参考文章：</p>\n<p><a href=\"https://juejin.im/post/5dd11baff265da0c0c1fe813\">https://juejin.im/post/5dd11b…</a></p>\n<p><a href=\"https://github.com/unknwon/building-web-applications-in-go/blob/master/articles/01.md\">https://github.com/unknwon/bu…</a></p>\n<p><a href=\"https://medium.com/honestbee-tw-engineer/gracefully-shutdown-in-go-http-server-5f5e6b83da5a\">https://medium.com/honestbee-…</a></p>\n"},{"title":"Hello World Test","date":"2020-12-31T15:59:00.000Z","abbrlink":16002,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n## 1. 前言\n\npython除了丰富的第三方库外，本身也提供了一些内在的方法和底层的一些属性，大家比较常用的如dict、list、set、min、max、range、sorted等。笔者最近在做项目框架时涉及到一些不是很常用的方法和属性，在本文中和大家做下分享。\n\n## 2. 内置方法和函数介绍\n\n- enumerate\n\n    如果你需要遍历可迭代的对象，有需要获取它的序号，可以用`enumerate`, 每一个next返回的是一个tuple\n\n    ```python\n    list1 = [1, 2, 3, 4]\n    list2 = [4, 3, 2, 1]\n    for idx, value in enumerate(list1):\n        print(idx, value, list2[idx])\n    # 0 1 4\n    # 1 2 3\n    # 2 3 2\n    # 3 4 1\n    ```\n\n- zip zip从参数中的多个迭代器取元素组合成一个新的迭代器;\n\n    ```python\n    # 给list加上序号\n    b = [4, 3, 2, 1]\n    for i in zip(range(len(b)), b):\n        print(i)\n    # (0, 4)\n    # (1, 3)\n    # (2, 2)\n    # (3, 1)\n    ```\n\n- globals()：一个描述当前执行过程中全局符号表的字典，可以看出你执行的所有过程\n\n- id(object)：python对象的唯一标识\n\n- staticmethod 类静态函数注解\n\n    ```python\n    @staticmethod  \n    def test(): \n        print('this is static method')\n    \n    Foo.test = test\n    Foo.test()\n    ```\n\n- 类的属性 我们来看下一个类的申明，如下：\n\n    ```python\n    class Foo():\n        \"\"\"this is test class\"\"\"\n        def __init__(self, name):\n            self.name = name\n        \n        def run(self):\n            print('running')\n    ```\n\n    ```python\n    # 列出类的所有成员和属性\n    dir(Foo)\n    ['__class__',\n    '__delattr__',\n    '__dict__',\n    '__dir__',\n    '__doc__',\n    '__eq__',\n    '__format__',\n    '__ge__',\n    '__getattribute__',\n    '__gt__',\n    '__hash__',\n    '__init__',\n    '__init_subclass__',\n    '__le__',\n    '__lt__',\n    '__module__',\n    '__ne__',\n    '__new__',\n    '__reduce__',\n    '__reduce_ex__',\n    '__repr__',\n    '__setattr__',\n    '__sizeof__',\n    '__str__',\n    '__subclasshook__',\n    '__weakref__',\n    'run']\n    \n    \n    # 类的注释\n    Foo.__doc__\n    # 'this is test class'\n    \n    # 类自定义属性\n    Foo.__dict__\n    mappingproxy({'__module__': '__main__',\n              '__doc__': 'this is test class',\n              '__init__': <function __main__.Foo.__init__(self, name)>,\n              'run': <function __main__.Foo.run(self)>,\n              '__dict__': <attribute '__dict__' of 'Foo' objects>,\n              '__weakref__': <attribute '__weakref__' of 'Foo' objects>})\n    \n    # 类的父类\n    Foo.__base__\n    \n    # 类的名字\n    Foo.__name__\n    ```\n\n    **类的实例化和初始化**\n\n    ```python\n    # python类先通过__new__实例化，再调用__init__进行初始化类成员\n    foo = Foo('milk')\n    ```\n\n    **类的属性添加和访问**\n\n    ```python\n    # 类的访问\n    foo.name\n    foo.run()\n    \n    # 可以通过setattr 动态的添加属性\n    def method():\n        print(\"cow\")\n    \n    setattr(foo, \"type\", \"cow\")\n    setattr(foo, \"getcow\", method)\n    # cow\n    foo.type\n    foo.getcow()\n    \n    # 动态删除属性 delattr\n    delattr(foo, \"type\")\n    \n    # getattr 获取成员属性\n    if hasattr(foo, \"run\"): # 判断是否有属性\n        func = getattr(foo, \"run\")\n        func()\n    ```\n\n## 3. 单例模式应用\n\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。单例模式要求在类的使用过程中只实例化一次，所有对象都共享一个实例。创建的方法是在实例的时候判断下是否已经实例过了，有则返回实例化过的全局实例。python是如何实现的呢？关键是找到实例化的地方，对就是前面说的`__new__`\n\n```python\nclass Singleton(object):\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            cls._instance = object.__new__(cls)\n        return cls._instance\n    \n    def __init__(self, name):\n        self.name = name\n\n\na = Singleton('name1')\nb = Singleton('name2')\nprint(id(a), id(b))\nprint(a.name, b.name)\n# 1689352213112 1689352213112\n# name2 name2\n```\n\n## 4. 反射应用\n\n反射在许多框架中都有使用到，简单就是通过类的名称（字符串）来实例化类。一个典型的场景就是通过配置的方式来动态控制类的执行，比如定时任务的执行，通过维护每个定时任务类的执行时间，在执行时间到的时候，通过反射方式实例化类，执行任务，在java中也非常的常见。\n\npython的实现可以通过上面说的`getattr`获取模块中的类， 通过methodcaller来调用方法。我们来看一个简单的例子\n\n```python\nimport importlib\nfrom operator import methodcaller\n\nclass Foo():\n    \"\"\"this is test class\"\"\"\n    def __init__(self, name):\n        self.name = name\n    \n    def run(self, info):\n        print('running %s' % info)\n\n# 类所在的模块，默认情况__main__， 可以通过Foo.__dict__ 中'__module__'获取\napi_module = importlib.import_module('__main__') \n# getattr获取模块中的类， 这里Foo是字符串哦\nclazz = getattr(api_module, 'Foo')\n\n# 实例化\nparams = [\"milk\"]\ninstance = clazz(*params)\n\n# 方法调用， 方法也是字符串methodcaller(方法名， 方法参数)\ntask_result = methodcaller(\"run\", \"reflection\")(instance)\n\n# running reflection\n```\n\n## 5. 总结\n\n本文通过分享了python内置方法和属性， 并在单例模式和反射中进行应用。希望对你有帮助，欢迎交流@mintel 要点总结如下：\n\n- dir下类\n- 查看类自定义属性__dict__\n- __new__实例化类，__init__初始化类\n- getattr 获取属性\n- setattr 设置属性\n- 记住importlib和methodcaller","source":"_posts/python_md/Python内置方法和属性应用.md","raw":"---\ntitle: Hello World Test\ndate: '2020/12/31 23:59'\ntags:\n  - python\ncategories:\n  - 学习笔记\nabbrlink: 16002\ncover: \n---\n\n## 1. 前言\n\npython除了丰富的第三方库外，本身也提供了一些内在的方法和底层的一些属性，大家比较常用的如dict、list、set、min、max、range、sorted等。笔者最近在做项目框架时涉及到一些不是很常用的方法和属性，在本文中和大家做下分享。\n\n## 2. 内置方法和函数介绍\n\n- enumerate\n\n    如果你需要遍历可迭代的对象，有需要获取它的序号，可以用`enumerate`, 每一个next返回的是一个tuple\n\n    ```python\n    list1 = [1, 2, 3, 4]\n    list2 = [4, 3, 2, 1]\n    for idx, value in enumerate(list1):\n        print(idx, value, list2[idx])\n    # 0 1 4\n    # 1 2 3\n    # 2 3 2\n    # 3 4 1\n    ```\n\n- zip zip从参数中的多个迭代器取元素组合成一个新的迭代器;\n\n    ```python\n    # 给list加上序号\n    b = [4, 3, 2, 1]\n    for i in zip(range(len(b)), b):\n        print(i)\n    # (0, 4)\n    # (1, 3)\n    # (2, 2)\n    # (3, 1)\n    ```\n\n- globals()：一个描述当前执行过程中全局符号表的字典，可以看出你执行的所有过程\n\n- id(object)：python对象的唯一标识\n\n- staticmethod 类静态函数注解\n\n    ```python\n    @staticmethod  \n    def test(): \n        print('this is static method')\n    \n    Foo.test = test\n    Foo.test()\n    ```\n\n- 类的属性 我们来看下一个类的申明，如下：\n\n    ```python\n    class Foo():\n        \"\"\"this is test class\"\"\"\n        def __init__(self, name):\n            self.name = name\n        \n        def run(self):\n            print('running')\n    ```\n\n    ```python\n    # 列出类的所有成员和属性\n    dir(Foo)\n    ['__class__',\n    '__delattr__',\n    '__dict__',\n    '__dir__',\n    '__doc__',\n    '__eq__',\n    '__format__',\n    '__ge__',\n    '__getattribute__',\n    '__gt__',\n    '__hash__',\n    '__init__',\n    '__init_subclass__',\n    '__le__',\n    '__lt__',\n    '__module__',\n    '__ne__',\n    '__new__',\n    '__reduce__',\n    '__reduce_ex__',\n    '__repr__',\n    '__setattr__',\n    '__sizeof__',\n    '__str__',\n    '__subclasshook__',\n    '__weakref__',\n    'run']\n    \n    \n    # 类的注释\n    Foo.__doc__\n    # 'this is test class'\n    \n    # 类自定义属性\n    Foo.__dict__\n    mappingproxy({'__module__': '__main__',\n              '__doc__': 'this is test class',\n              '__init__': <function __main__.Foo.__init__(self, name)>,\n              'run': <function __main__.Foo.run(self)>,\n              '__dict__': <attribute '__dict__' of 'Foo' objects>,\n              '__weakref__': <attribute '__weakref__' of 'Foo' objects>})\n    \n    # 类的父类\n    Foo.__base__\n    \n    # 类的名字\n    Foo.__name__\n    ```\n\n    **类的实例化和初始化**\n\n    ```python\n    # python类先通过__new__实例化，再调用__init__进行初始化类成员\n    foo = Foo('milk')\n    ```\n\n    **类的属性添加和访问**\n\n    ```python\n    # 类的访问\n    foo.name\n    foo.run()\n    \n    # 可以通过setattr 动态的添加属性\n    def method():\n        print(\"cow\")\n    \n    setattr(foo, \"type\", \"cow\")\n    setattr(foo, \"getcow\", method)\n    # cow\n    foo.type\n    foo.getcow()\n    \n    # 动态删除属性 delattr\n    delattr(foo, \"type\")\n    \n    # getattr 获取成员属性\n    if hasattr(foo, \"run\"): # 判断是否有属性\n        func = getattr(foo, \"run\")\n        func()\n    ```\n\n## 3. 单例模式应用\n\n单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。单例模式要求在类的使用过程中只实例化一次，所有对象都共享一个实例。创建的方法是在实例的时候判断下是否已经实例过了，有则返回实例化过的全局实例。python是如何实现的呢？关键是找到实例化的地方，对就是前面说的`__new__`\n\n```python\nclass Singleton(object):\n    def __new__(cls, *args, **kwargs):\n        if not hasattr(cls, '_instance'):\n            cls._instance = object.__new__(cls)\n        return cls._instance\n    \n    def __init__(self, name):\n        self.name = name\n\n\na = Singleton('name1')\nb = Singleton('name2')\nprint(id(a), id(b))\nprint(a.name, b.name)\n# 1689352213112 1689352213112\n# name2 name2\n```\n\n## 4. 反射应用\n\n反射在许多框架中都有使用到，简单就是通过类的名称（字符串）来实例化类。一个典型的场景就是通过配置的方式来动态控制类的执行，比如定时任务的执行，通过维护每个定时任务类的执行时间，在执行时间到的时候，通过反射方式实例化类，执行任务，在java中也非常的常见。\n\npython的实现可以通过上面说的`getattr`获取模块中的类， 通过methodcaller来调用方法。我们来看一个简单的例子\n\n```python\nimport importlib\nfrom operator import methodcaller\n\nclass Foo():\n    \"\"\"this is test class\"\"\"\n    def __init__(self, name):\n        self.name = name\n    \n    def run(self, info):\n        print('running %s' % info)\n\n# 类所在的模块，默认情况__main__， 可以通过Foo.__dict__ 中'__module__'获取\napi_module = importlib.import_module('__main__') \n# getattr获取模块中的类， 这里Foo是字符串哦\nclazz = getattr(api_module, 'Foo')\n\n# 实例化\nparams = [\"milk\"]\ninstance = clazz(*params)\n\n# 方法调用， 方法也是字符串methodcaller(方法名， 方法参数)\ntask_result = methodcaller(\"run\", \"reflection\")(instance)\n\n# running reflection\n```\n\n## 5. 总结\n\n本文通过分享了python内置方法和属性， 并在单例模式和反射中进行应用。希望对你有帮助，欢迎交流@mintel 要点总结如下：\n\n- dir下类\n- 查看类自定义属性__dict__\n- __new__实例化类，__init__初始化类\n- getattr 获取属性\n- setattr 设置属性\n- 记住importlib和methodcaller","slug":"python_md/Python内置方法和属性应用","published":1,"updated":"2021-04-08T14:09:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5u000qw9q934ly1oyy","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>python除了丰富的第三方库外，本身也提供了一些内在的方法和底层的一些属性，大家比较常用的如dict、list、set、min、max、range、sorted等。笔者最近在做项目框架时涉及到一些不是很常用的方法和属性，在本文中和大家做下分享。</p>\n<h2 id=\"2-内置方法和函数介绍\"><a href=\"#2-内置方法和函数介绍\" class=\"headerlink\" title=\"2. 内置方法和函数介绍\"></a>2. 内置方法和函数介绍</h2><ul>\n<li><p>enumerate</p>\n<p>  如果你需要遍历可迭代的对象，有需要获取它的序号，可以用<code>enumerate</code>, 每一个next返回的是一个tuple</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">list2 = [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> idx, value <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(list1):</span><br><span class=\"line\">    print(idx, value, list2[idx])</span><br><span class=\"line\"><span class=\"comment\"># 0 1 4</span></span><br><span class=\"line\"><span class=\"comment\"># 1 2 3</span></span><br><span class=\"line\"><span class=\"comment\"># 2 3 2</span></span><br><span class=\"line\"><span class=\"comment\"># 3 4 1</span></span><br></pre></td></tr></table></figure></li>\n<li><p>zip zip从参数中的多个迭代器取元素组合成一个新的迭代器;</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给list加上序号</span></span><br><span class=\"line\">b = [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(<span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(b)), b):</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"><span class=\"comment\"># (0, 4)</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># (2, 2)</span></span><br><span class=\"line\"><span class=\"comment\"># (3, 1)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>globals()：一个描述当前执行过程中全局符号表的字典，可以看出你执行的所有过程</p>\n</li>\n<li><p>id(object)：python对象的唯一标识</p>\n</li>\n<li><p>staticmethod 类静态函数注解</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@staticmethod  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span>():</span> </span><br><span class=\"line\">    print(<span class=\"string\">&#x27;this is static method&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.test = test</span><br><span class=\"line\">Foo.test()</span><br></pre></td></tr></table></figure></li>\n<li><p>类的属性 我们来看下一个类的申明，如下：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;this is test class&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running&#x27;</span>)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出类的所有成员和属性</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span>(Foo)</span><br><span class=\"line\">[<span class=\"string\">&#x27;__class__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__delattr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__dict__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__dir__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__doc__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__eq__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__format__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ge__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__getattribute__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__gt__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__hash__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init_subclass__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__le__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__lt__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__module__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ne__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__new__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__reduce__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__repr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__setattr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__sizeof__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__str__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__subclasshook__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__weakref__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;run&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类的注释</span></span><br><span class=\"line\">Foo.__doc__</span><br><span class=\"line\"><span class=\"comment\"># &#x27;this is test class&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类自定义属性</span></span><br><span class=\"line\">Foo.__dict__</span><br><span class=\"line\">mappingproxy(&#123;<span class=\"string\">&#x27;__module__&#x27;</span>: <span class=\"string\">&#x27;__main__&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__doc__&#x27;</span>: <span class=\"string\">&#x27;this is test class&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__init__&#x27;</span>: &lt;function __main__.Foo.__init__(self, name)&gt;,</span><br><span class=\"line\">          <span class=\"string\">&#x27;run&#x27;</span>: &lt;function __main__.Foo.run(self)&gt;,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__dict__&#x27;</span>: &lt;attribute <span class=\"string\">&#x27;__dict__&#x27;</span> of <span class=\"string\">&#x27;Foo&#x27;</span> objects&gt;,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class=\"string\">&#x27;__weakref__&#x27;</span> of <span class=\"string\">&#x27;Foo&#x27;</span> objects&gt;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类的父类</span></span><br><span class=\"line\">Foo.__base__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类的名字</span></span><br><span class=\"line\">Foo.__name__</span><br></pre></td></tr></table></figure>\n<p>  <strong>类的实例化和初始化</strong></p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python类先通过__new__实例化，再调用__init__进行初始化类成员</span></span><br><span class=\"line\">foo = Foo(<span class=\"string\">&#x27;milk&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>  <strong>类的属性添加和访问</strong></p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 类的访问</span></span><br><span class=\"line\">foo.name</span><br><span class=\"line\">foo.run()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以通过setattr 动态的添加属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">method</span>():</span></span><br><span class=\"line\">    print(<span class=\"string\">&quot;cow&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setattr</span>(foo, <span class=\"string\">&quot;type&quot;</span>, <span class=\"string\">&quot;cow&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">setattr</span>(foo, <span class=\"string\">&quot;getcow&quot;</span>, method)</span><br><span class=\"line\"><span class=\"comment\"># cow</span></span><br><span class=\"line\">foo.<span class=\"built_in\">type</span></span><br><span class=\"line\">foo.getcow()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 动态删除属性 delattr</span></span><br><span class=\"line\"><span class=\"built_in\">delattr</span>(foo, <span class=\"string\">&quot;type&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># getattr 获取成员属性</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">hasattr</span>(foo, <span class=\"string\">&quot;run&quot;</span>): <span class=\"comment\"># 判断是否有属性</span></span><br><span class=\"line\">    func = <span class=\"built_in\">getattr</span>(foo, <span class=\"string\">&quot;run&quot;</span>)</span><br><span class=\"line\">    func()</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-单例模式应用\"><a href=\"#3-单例模式应用\" class=\"headerlink\" title=\"3. 单例模式应用\"></a>3. 单例模式应用</h2></li>\n</ul>\n<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。单例模式要求在类的使用过程中只实例化一次，所有对象都共享一个实例。创建的方法是在实例的时候判断下是否已经实例过了，有则返回实例化过的全局实例。python是如何实现的呢？关键是找到实例化的地方，对就是前面说的<code>__new__</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(cls, <span class=\"string\">&#x27;_instance&#x27;</span>):</span><br><span class=\"line\">            cls._instance = <span class=\"built_in\">object</span>.__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = Singleton(<span class=\"string\">&#x27;name1&#x27;</span>)</span><br><span class=\"line\">b = Singleton(<span class=\"string\">&#x27;name2&#x27;</span>)</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(a), <span class=\"built_in\">id</span>(b))</span><br><span class=\"line\">print(a.name, b.name)</span><br><span class=\"line\"><span class=\"comment\"># 1689352213112 1689352213112</span></span><br><span class=\"line\"><span class=\"comment\"># name2 name2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-反射应用\"><a href=\"#4-反射应用\" class=\"headerlink\" title=\"4. 反射应用\"></a>4. 反射应用</h2><p>反射在许多框架中都有使用到，简单就是通过类的名称（字符串）来实例化类。一个典型的场景就是通过配置的方式来动态控制类的执行，比如定时任务的执行，通过维护每个定时任务类的执行时间，在执行时间到的时候，通过反射方式实例化类，执行任务，在java中也非常的常见。</p>\n<p>python的实现可以通过上面说的<code>getattr</code>获取模块中的类， 通过methodcaller来调用方法。我们来看一个简单的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> importlib</span><br><span class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> methodcaller</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;this is test class&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self, info</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running %s&#x27;</span> % info)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类所在的模块，默认情况__main__， 可以通过Foo.__dict__ 中&#x27;__module__&#x27;获取</span></span><br><span class=\"line\">api_module = importlib.import_module(<span class=\"string\">&#x27;__main__&#x27;</span>) </span><br><span class=\"line\"><span class=\"comment\"># getattr获取模块中的类， 这里Foo是字符串哦</span></span><br><span class=\"line\">clazz = <span class=\"built_in\">getattr</span>(api_module, <span class=\"string\">&#x27;Foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实例化</span></span><br><span class=\"line\">params = [<span class=\"string\">&quot;milk&quot;</span>]</span><br><span class=\"line\">instance = clazz(*params)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法调用， 方法也是字符串methodcaller(方法名， 方法参数)</span></span><br><span class=\"line\">task_result = methodcaller(<span class=\"string\">&quot;run&quot;</span>, <span class=\"string\">&quot;reflection&quot;</span>)(instance)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># running reflection</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><p>本文通过分享了python内置方法和属性， 并在单例模式和反射中进行应用。希望对你有帮助，欢迎交流@mintel 要点总结如下：</p>\n<ul>\n<li>dir下类</li>\n<li>查看类自定义属性<strong>dict</strong></li>\n<li>__new__实例化类，__init__初始化类</li>\n<li>getattr 获取属性</li>\n<li>setattr 设置属性</li>\n<li>记住importlib和methodcaller</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><p>python除了丰富的第三方库外，本身也提供了一些内在的方法和底层的一些属性，大家比较常用的如dict、list、set、min、max、range、sorted等。笔者最近在做项目框架时涉及到一些不是很常用的方法和属性，在本文中和大家做下分享。</p>\n<h2 id=\"2-内置方法和函数介绍\"><a href=\"#2-内置方法和函数介绍\" class=\"headerlink\" title=\"2. 内置方法和函数介绍\"></a>2. 内置方法和函数介绍</h2><ul>\n<li><p>enumerate</p>\n<p>  如果你需要遍历可迭代的对象，有需要获取它的序号，可以用<code>enumerate</code>, 每一个next返回的是一个tuple</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list1 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\">list2 = [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> idx, value <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(list1):</span><br><span class=\"line\">    print(idx, value, list2[idx])</span><br><span class=\"line\"><span class=\"comment\"># 0 1 4</span></span><br><span class=\"line\"><span class=\"comment\"># 1 2 3</span></span><br><span class=\"line\"><span class=\"comment\"># 2 3 2</span></span><br><span class=\"line\"><span class=\"comment\"># 3 4 1</span></span><br></pre></td></tr></table></figure></li>\n<li><p>zip zip从参数中的多个迭代器取元素组合成一个新的迭代器;</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 给list加上序号</span></span><br><span class=\"line\">b = [<span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">zip</span>(<span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(b)), b):</span><br><span class=\"line\">    print(i)</span><br><span class=\"line\"><span class=\"comment\"># (0, 4)</span></span><br><span class=\"line\"><span class=\"comment\"># (1, 3)</span></span><br><span class=\"line\"><span class=\"comment\"># (2, 2)</span></span><br><span class=\"line\"><span class=\"comment\"># (3, 1)</span></span><br></pre></td></tr></table></figure></li>\n<li><p>globals()：一个描述当前执行过程中全局符号表的字典，可以看出你执行的所有过程</p>\n</li>\n<li><p>id(object)：python对象的唯一标识</p>\n</li>\n<li><p>staticmethod 类静态函数注解</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@staticmethod  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test</span>():</span> </span><br><span class=\"line\">    print(<span class=\"string\">&#x27;this is static method&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Foo.test = test</span><br><span class=\"line\">Foo.test()</span><br></pre></td></tr></table></figure></li>\n<li><p>类的属性 我们来看下一个类的申明，如下：</p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;this is test class&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running&#x27;</span>)</span><br></pre></td></tr></table></figure>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 列出类的所有成员和属性</span></span><br><span class=\"line\"><span class=\"built_in\">dir</span>(Foo)</span><br><span class=\"line\">[<span class=\"string\">&#x27;__class__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__delattr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__dict__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__dir__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__doc__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__eq__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__format__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ge__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__getattribute__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__gt__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__hash__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__init_subclass__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__le__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__lt__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__module__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__ne__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__new__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__reduce__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__reduce_ex__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__repr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__setattr__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__sizeof__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__str__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__subclasshook__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;__weakref__&#x27;</span>,</span><br><span class=\"line\"><span class=\"string\">&#x27;run&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类的注释</span></span><br><span class=\"line\">Foo.__doc__</span><br><span class=\"line\"><span class=\"comment\"># &#x27;this is test class&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类自定义属性</span></span><br><span class=\"line\">Foo.__dict__</span><br><span class=\"line\">mappingproxy(&#123;<span class=\"string\">&#x27;__module__&#x27;</span>: <span class=\"string\">&#x27;__main__&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__doc__&#x27;</span>: <span class=\"string\">&#x27;this is test class&#x27;</span>,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__init__&#x27;</span>: &lt;function __main__.Foo.__init__(self, name)&gt;,</span><br><span class=\"line\">          <span class=\"string\">&#x27;run&#x27;</span>: &lt;function __main__.Foo.run(self)&gt;,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__dict__&#x27;</span>: &lt;attribute <span class=\"string\">&#x27;__dict__&#x27;</span> of <span class=\"string\">&#x27;Foo&#x27;</span> objects&gt;,</span><br><span class=\"line\">          <span class=\"string\">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class=\"string\">&#x27;__weakref__&#x27;</span> of <span class=\"string\">&#x27;Foo&#x27;</span> objects&gt;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类的父类</span></span><br><span class=\"line\">Foo.__base__</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类的名字</span></span><br><span class=\"line\">Foo.__name__</span><br></pre></td></tr></table></figure>\n<p>  <strong>类的实例化和初始化</strong></p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># python类先通过__new__实例化，再调用__init__进行初始化类成员</span></span><br><span class=\"line\">foo = Foo(<span class=\"string\">&#x27;milk&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<p>  <strong>类的属性添加和访问</strong></p>\n  <figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 类的访问</span></span><br><span class=\"line\">foo.name</span><br><span class=\"line\">foo.run()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可以通过setattr 动态的添加属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">method</span>():</span></span><br><span class=\"line\">    print(<span class=\"string\">&quot;cow&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setattr</span>(foo, <span class=\"string\">&quot;type&quot;</span>, <span class=\"string\">&quot;cow&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">setattr</span>(foo, <span class=\"string\">&quot;getcow&quot;</span>, method)</span><br><span class=\"line\"><span class=\"comment\"># cow</span></span><br><span class=\"line\">foo.<span class=\"built_in\">type</span></span><br><span class=\"line\">foo.getcow()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 动态删除属性 delattr</span></span><br><span class=\"line\"><span class=\"built_in\">delattr</span>(foo, <span class=\"string\">&quot;type&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># getattr 获取成员属性</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"built_in\">hasattr</span>(foo, <span class=\"string\">&quot;run&quot;</span>): <span class=\"comment\"># 判断是否有属性</span></span><br><span class=\"line\">    func = <span class=\"built_in\">getattr</span>(foo, <span class=\"string\">&quot;run&quot;</span>)</span><br><span class=\"line\">    func()</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-单例模式应用\"><a href=\"#3-单例模式应用\" class=\"headerlink\" title=\"3. 单例模式应用\"></a>3. 单例模式应用</h2></li>\n</ul>\n<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。单例模式要求在类的使用过程中只实例化一次，所有对象都共享一个实例。创建的方法是在实例的时候判断下是否已经实例过了，有则返回实例化过的全局实例。python是如何实现的呢？关键是找到实例化的地方，对就是前面说的<code>__new__</code></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span>(<span class=\"params\"><span class=\"built_in\">object</span></span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span>(<span class=\"params\">cls, *args, **kwargs</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> <span class=\"built_in\">hasattr</span>(cls, <span class=\"string\">&#x27;_instance&#x27;</span>):</span><br><span class=\"line\">            cls._instance = <span class=\"built_in\">object</span>.__new__(cls)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cls._instance</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">a = Singleton(<span class=\"string\">&#x27;name1&#x27;</span>)</span><br><span class=\"line\">b = Singleton(<span class=\"string\">&#x27;name2&#x27;</span>)</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(a), <span class=\"built_in\">id</span>(b))</span><br><span class=\"line\">print(a.name, b.name)</span><br><span class=\"line\"><span class=\"comment\"># 1689352213112 1689352213112</span></span><br><span class=\"line\"><span class=\"comment\"># name2 name2</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-反射应用\"><a href=\"#4-反射应用\" class=\"headerlink\" title=\"4. 反射应用\"></a>4. 反射应用</h2><p>反射在许多框架中都有使用到，简单就是通过类的名称（字符串）来实例化类。一个典型的场景就是通过配置的方式来动态控制类的执行，比如定时任务的执行，通过维护每个定时任务类的执行时间，在执行时间到的时候，通过反射方式实例化类，执行任务，在java中也非常的常见。</p>\n<p>python的实现可以通过上面说的<code>getattr</code>获取模块中的类， 通过methodcaller来调用方法。我们来看一个简单的例子</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> importlib</span><br><span class=\"line\"><span class=\"keyword\">from</span> operator <span class=\"keyword\">import</span> methodcaller</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span>():</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;this is test class&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, name</span>):</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span>(<span class=\"params\">self, info</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running %s&#x27;</span> % info)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 类所在的模块，默认情况__main__， 可以通过Foo.__dict__ 中&#x27;__module__&#x27;获取</span></span><br><span class=\"line\">api_module = importlib.import_module(<span class=\"string\">&#x27;__main__&#x27;</span>) </span><br><span class=\"line\"><span class=\"comment\"># getattr获取模块中的类， 这里Foo是字符串哦</span></span><br><span class=\"line\">clazz = <span class=\"built_in\">getattr</span>(api_module, <span class=\"string\">&#x27;Foo&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 实例化</span></span><br><span class=\"line\">params = [<span class=\"string\">&quot;milk&quot;</span>]</span><br><span class=\"line\">instance = clazz(*params)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 方法调用， 方法也是字符串methodcaller(方法名， 方法参数)</span></span><br><span class=\"line\">task_result = methodcaller(<span class=\"string\">&quot;run&quot;</span>, <span class=\"string\">&quot;reflection&quot;</span>)(instance)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># running reflection</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. 总结</h2><p>本文通过分享了python内置方法和属性， 并在单例模式和反射中进行应用。希望对你有帮助，欢迎交流@mintel 要点总结如下：</p>\n<ul>\n<li>dir下类</li>\n<li>查看类自定义属性<strong>dict</strong></li>\n<li>__new__实例化类，__init__初始化类</li>\n<li>getattr 获取属性</li>\n<li>setattr 设置属性</li>\n<li>记住importlib和methodcaller</li>\n</ul>\n"},{"title":"Golang net包简介","date":"2020-12-31T15:59:00.000Z","abbrlink":14003,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# Golang net 包简介\n\n> golang 的 net 包，相关接口和结构比较多，今天做个简单的梳理。\n\n## 网络模型\n\n在总结 net 包之前，还需要温习模糊的网络模型知识。下图是大学课本上的网络模型图：\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160629256.png\" alt=\"image-20210330160629256\" style=\"zoom:67%;\" />\n\n模型图中可以看到，OSI 的七层模型，每一层实现的是与对端相应层的通信接口。但是实际应用中，我们把会话层、表示层、应用层统称为应用层。因此，就变成了TCP/IP 的五层模型。 其中网络层包含了 ip,arp,icmp 等协议，传输层包含了 TCP， UDP 等协议，应用层，比如 SMTP，DNS，HTTP 等协议。\n在 net 包中，主要涉及网络层和传输层的协议。支持如下：\n网络层：\n\n- ICMP\n- IGMP\n- IVP6-ICMP\n\n传输层：\n\n- TCP\n- UDP\n\n## Socket 编程\n\n在讲代码结构前，还需要回忆（学习）几个 Socket 编程(套接字编程)的知识点。\n\n1. 在 Linux 上一切皆文件。所以各端口的读写服务可以认为是读取/写入文件, 一般使用文件描述符 fd (file descriptor) 表示。在Windows上，各端口的读写服务是一个通信链的句柄操作，通过句柄实现网络发出请求和读取数据。在 go 中为了统一，采用 linux 的 fd 代表一个链接节点。\n2. TCP 是面向连接的、可靠的流协议，可以理解为不断从文件中读取数据（STREAM）。UDP 是无链接的、面向报文的协议，是无序，不可靠的（DGRAM）（目前很多可靠的协议都是基于UDP 开发的）。\n3. UNIXDomain Socket 是一种 进程间通信的协议，之前仅在*nix上使用，17年 17063 版本后支持了该协议。虽然是一个 IPC 协议，但是在实现上是基于套接字 (socket) 实现的。因此，UNIXDomain Socket 也放在了net 包中。\n4. unixDomain Socket 也可以选择采用比特流的方式，或者无序的，不可靠的通讯方式，有序数据包的方式（SEQPACKET, Linux 2.6 内核才支持）\n\n## 代码结构\n\n下面我们看看 net 包中一些接口，以及一些接口的实现。\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160649541.png\" alt=\"image-20210330160649541\"  />\n\n从图中可以看出，基于 TCP、UDP、IP、Unix （Stream 方式）的链接抽象出来都是 Conn 接口。基于包传递的 UDP、IP、UnixConn （DGRAM 包方式） 都实现了 PacketConn 接口。对于面向流的监听器，比如： TCPListener、 UnixListener 都实现了 Listener 接口。\n\n整体上可以看出，net 包对网络链接是基于我们复习的网络知识实现的。对于代码的底层实现，也是比较简单的。正对不同的平台，调用不同平台套接字的系统调用即可。直观上看，对于不同的链接，我们都是可以通过Conn 的接口来做网络io的交互。\n\n## 如何使用\n\n在了解了包的构成后，我们基于不同的网络协议分两类来学习如何调用网络包提供的方法。\n\n### 基于流的协议\n\n基于流的协议，net 包中支持了常见的 TCP，Unix （Stream 方式） 两种。基于流的协议需要先于对端建立链接，然后再发送消息。下面是 Unix 套接字编程的一个流程：\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160708936.png\" alt=\"image-20210330160708936\" style=\"zoom:67%;\" />\n\n首先，服务端需要绑定并监听端口，然后等待客户端与其建立链接，通过 Accept 接收到客户端的连接后，开始读写消息。最后，当服务端收到EOF标识后，关闭链接即可。 HTTP, SMTP 等应用层协议都是使用的 TCP 传输层协议。\n\n### 基于包的协议\n\n基于包的协议，net 包中支持了常见的 UDP，Unix （DGRAM 包方式，PacketConn 方式），Ip (网络层协议，支持了icmp, igmp) 几种。基于包的协议在bind 端口后，无需建立连接，是一种即发即收的模式。\n\n基于包的协议，例如基于UDP 的 DNS解析， 文件传输（TFTP协议）等协议，在网络层应该都是基于包的协议。 下面是基于包请求的Server 端和Client端：\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160725275.png\" alt=\"image-20210330160725275\" style=\"zoom:67%;\" />\n\n可以看到，在Socket 编程里， 基于包的协议是不需要 Listen 和 Accept 的。在 net 包中，使用ListenPacket，实际上仅是构造了一个UDP连接，做了端口绑定而已。端口绑定后，Server 端开始阻塞读取包数据，之后二者开始通信。由于基于包协议，因此，我们也可以采用PacketConn 接口（看第一个实现接口的图）构造UDP包。\n\n## 一个简单的例子\n\n下面，我们构造一个简单的 Redis Server （支持多线程），实现了支持Redis协议的简易Key-Value操作（可以使用Redis-cli直接验证）:\n\n```go\npackage main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"io\"\n  \"net\"\n  \"strconv\"\n  \"strings\"\n  \"sync\"\n)\n\nvar KVMap sync.Map\nfunc main() {\n  // 构造一个listener\n  listener, _ := net.Listen(\"tcp\", \"127.0.0.1:6379\")\n  defer func() { _ = listener.Close() }()\n  for {\n    // 接收请求\n    conn, _ := listener.Accept()\n\n    // 连接的处理\n    go FakeRedis(conn)\n  }\n}\n\n// 这里做了io 读写操作，并解析了 Redis 的协议\nfunc FakeRedis(conn net.Conn) {\n  defer conn.Close()\n  reader := bufio.NewReader(conn)\n  for {\n    data, _, err := reader.ReadLine()\n    if err == io.EOF {\n      return\n    }\n\n    paramCount, _ := strconv.Atoi(string(data[1:]))\n    var params []string\n    for i := 0; i < paramCount; i++ {\n      _, _, _ = reader.ReadLine() // 每个参数的长度，这里忽略了\n      sParam, _, _ := reader.ReadLine()\n      params = append(params, string(sParam))\n    }\n\n    switch strings.ToUpper(params[0]) {\n    case \"GET\":\n      if v, ok := KVMap.Load(params[1]); !ok {\n        conn.Write([]byte(\"$-1\\r\\n\"))\n      } else {\n        conn.Write([]byte(fmt.Sprintf(\"$%d\\r\\n%v\\r\\n\", len(v.(string)), v)))\n      }\n    case \"SET\":\n      KVMap.Store(params[1], params[2])\n      conn.Write([]byte(\"+OK\\r\\n\"))\n    case \"COMMAND\":\n      conn.Write([]byte(\"+OK\\r\\n\"))\n    }\n  }\n\n}\n```\n\n*上述代码没有任何的异常处理，仅作为网络连接的一个简单例子。*\n从代码中可以看出，我们的数据流式的网络协议，在建立连接后，可以和文件IO服务一样，可以任意的读写操作。\n正常情况下，流处理的请求，都会开启一个协程来做连接处理，主协程仅用来接收连接请求。(基于包的网络协议则可以不用开启协程处理)\n\n## 总结\n\n1. 基于 Conn 的消息都是有三种过期时间，这其实是在底层epoll_wait中设置的超时时间。 Deadline 设置了Dail中建立连接的超时时间， ReadDeadline 是 Read 操作的超时时间， WriteDeadline 为 Write 操作的超时时间。\n2. net 包作为基础包，基于net开发应用层协议比较多，例如 net/http, net/rpc/smtp 等。\n3. 网络的io操作底层是基于epoll来实现的, unixDomain 基于文件来实现的。\n4. net 包实现的套接字编程仅是我们日常生活中用的比较多的一些方法，还有很多未实现的配置待我们去探索。\n5. 网络模型比较简单，实际用起来，还是需要分门别类的。","source":"_posts/go_md/Golang net包简介.md","raw":"---\ntitle: Golang net包简介\ndate: '2020/12/31 23:59'\ntags:\n - go\ncategories:\n - 学习笔记\nabbrlink: 14003\ncover: \n---\n\n# Golang net 包简介\n\n> golang 的 net 包，相关接口和结构比较多，今天做个简单的梳理。\n\n## 网络模型\n\n在总结 net 包之前，还需要温习模糊的网络模型知识。下图是大学课本上的网络模型图：\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160629256.png\" alt=\"image-20210330160629256\" style=\"zoom:67%;\" />\n\n模型图中可以看到，OSI 的七层模型，每一层实现的是与对端相应层的通信接口。但是实际应用中，我们把会话层、表示层、应用层统称为应用层。因此，就变成了TCP/IP 的五层模型。 其中网络层包含了 ip,arp,icmp 等协议，传输层包含了 TCP， UDP 等协议，应用层，比如 SMTP，DNS，HTTP 等协议。\n在 net 包中，主要涉及网络层和传输层的协议。支持如下：\n网络层：\n\n- ICMP\n- IGMP\n- IVP6-ICMP\n\n传输层：\n\n- TCP\n- UDP\n\n## Socket 编程\n\n在讲代码结构前，还需要回忆（学习）几个 Socket 编程(套接字编程)的知识点。\n\n1. 在 Linux 上一切皆文件。所以各端口的读写服务可以认为是读取/写入文件, 一般使用文件描述符 fd (file descriptor) 表示。在Windows上，各端口的读写服务是一个通信链的句柄操作，通过句柄实现网络发出请求和读取数据。在 go 中为了统一，采用 linux 的 fd 代表一个链接节点。\n2. TCP 是面向连接的、可靠的流协议，可以理解为不断从文件中读取数据（STREAM）。UDP 是无链接的、面向报文的协议，是无序，不可靠的（DGRAM）（目前很多可靠的协议都是基于UDP 开发的）。\n3. UNIXDomain Socket 是一种 进程间通信的协议，之前仅在*nix上使用，17年 17063 版本后支持了该协议。虽然是一个 IPC 协议，但是在实现上是基于套接字 (socket) 实现的。因此，UNIXDomain Socket 也放在了net 包中。\n4. unixDomain Socket 也可以选择采用比特流的方式，或者无序的，不可靠的通讯方式，有序数据包的方式（SEQPACKET, Linux 2.6 内核才支持）\n\n## 代码结构\n\n下面我们看看 net 包中一些接口，以及一些接口的实现。\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160649541.png\" alt=\"image-20210330160649541\"  />\n\n从图中可以看出，基于 TCP、UDP、IP、Unix （Stream 方式）的链接抽象出来都是 Conn 接口。基于包传递的 UDP、IP、UnixConn （DGRAM 包方式） 都实现了 PacketConn 接口。对于面向流的监听器，比如： TCPListener、 UnixListener 都实现了 Listener 接口。\n\n整体上可以看出，net 包对网络链接是基于我们复习的网络知识实现的。对于代码的底层实现，也是比较简单的。正对不同的平台，调用不同平台套接字的系统调用即可。直观上看，对于不同的链接，我们都是可以通过Conn 的接口来做网络io的交互。\n\n## 如何使用\n\n在了解了包的构成后，我们基于不同的网络协议分两类来学习如何调用网络包提供的方法。\n\n### 基于流的协议\n\n基于流的协议，net 包中支持了常见的 TCP，Unix （Stream 方式） 两种。基于流的协议需要先于对端建立链接，然后再发送消息。下面是 Unix 套接字编程的一个流程：\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160708936.png\" alt=\"image-20210330160708936\" style=\"zoom:67%;\" />\n\n首先，服务端需要绑定并监听端口，然后等待客户端与其建立链接，通过 Accept 接收到客户端的连接后，开始读写消息。最后，当服务端收到EOF标识后，关闭链接即可。 HTTP, SMTP 等应用层协议都是使用的 TCP 传输层协议。\n\n### 基于包的协议\n\n基于包的协议，net 包中支持了常见的 UDP，Unix （DGRAM 包方式，PacketConn 方式），Ip (网络层协议，支持了icmp, igmp) 几种。基于包的协议在bind 端口后，无需建立连接，是一种即发即收的模式。\n\n基于包的协议，例如基于UDP 的 DNS解析， 文件传输（TFTP协议）等协议，在网络层应该都是基于包的协议。 下面是基于包请求的Server 端和Client端：\n\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160725275.png\" alt=\"image-20210330160725275\" style=\"zoom:67%;\" />\n\n可以看到，在Socket 编程里， 基于包的协议是不需要 Listen 和 Accept 的。在 net 包中，使用ListenPacket，实际上仅是构造了一个UDP连接，做了端口绑定而已。端口绑定后，Server 端开始阻塞读取包数据，之后二者开始通信。由于基于包协议，因此，我们也可以采用PacketConn 接口（看第一个实现接口的图）构造UDP包。\n\n## 一个简单的例子\n\n下面，我们构造一个简单的 Redis Server （支持多线程），实现了支持Redis协议的简易Key-Value操作（可以使用Redis-cli直接验证）:\n\n```go\npackage main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"io\"\n  \"net\"\n  \"strconv\"\n  \"strings\"\n  \"sync\"\n)\n\nvar KVMap sync.Map\nfunc main() {\n  // 构造一个listener\n  listener, _ := net.Listen(\"tcp\", \"127.0.0.1:6379\")\n  defer func() { _ = listener.Close() }()\n  for {\n    // 接收请求\n    conn, _ := listener.Accept()\n\n    // 连接的处理\n    go FakeRedis(conn)\n  }\n}\n\n// 这里做了io 读写操作，并解析了 Redis 的协议\nfunc FakeRedis(conn net.Conn) {\n  defer conn.Close()\n  reader := bufio.NewReader(conn)\n  for {\n    data, _, err := reader.ReadLine()\n    if err == io.EOF {\n      return\n    }\n\n    paramCount, _ := strconv.Atoi(string(data[1:]))\n    var params []string\n    for i := 0; i < paramCount; i++ {\n      _, _, _ = reader.ReadLine() // 每个参数的长度，这里忽略了\n      sParam, _, _ := reader.ReadLine()\n      params = append(params, string(sParam))\n    }\n\n    switch strings.ToUpper(params[0]) {\n    case \"GET\":\n      if v, ok := KVMap.Load(params[1]); !ok {\n        conn.Write([]byte(\"$-1\\r\\n\"))\n      } else {\n        conn.Write([]byte(fmt.Sprintf(\"$%d\\r\\n%v\\r\\n\", len(v.(string)), v)))\n      }\n    case \"SET\":\n      KVMap.Store(params[1], params[2])\n      conn.Write([]byte(\"+OK\\r\\n\"))\n    case \"COMMAND\":\n      conn.Write([]byte(\"+OK\\r\\n\"))\n    }\n  }\n\n}\n```\n\n*上述代码没有任何的异常处理，仅作为网络连接的一个简单例子。*\n从代码中可以看出，我们的数据流式的网络协议，在建立连接后，可以和文件IO服务一样，可以任意的读写操作。\n正常情况下，流处理的请求，都会开启一个协程来做连接处理，主协程仅用来接收连接请求。(基于包的网络协议则可以不用开启协程处理)\n\n## 总结\n\n1. 基于 Conn 的消息都是有三种过期时间，这其实是在底层epoll_wait中设置的超时时间。 Deadline 设置了Dail中建立连接的超时时间， ReadDeadline 是 Read 操作的超时时间， WriteDeadline 为 Write 操作的超时时间。\n2. net 包作为基础包，基于net开发应用层协议比较多，例如 net/http, net/rpc/smtp 等。\n3. 网络的io操作底层是基于epoll来实现的, unixDomain 基于文件来实现的。\n4. net 包实现的套接字编程仅是我们日常生活中用的比较多的一些方法，还有很多未实现的配置待我们去探索。\n5. 网络模型比较简单，实际用起来，还是需要分门别类的。","slug":"go_md/Golang net包简介","published":1,"updated":"2021-04-09T12:48:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5v000uw9q9ant8barb","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Golang-net-包简介\"><a href=\"#Golang-net-包简介\" class=\"headerlink\" title=\"Golang net 包简介\"></a>Golang net 包简介</h1><blockquote>\n<p>golang 的 net 包，相关接口和结构比较多，今天做个简单的梳理。</p>\n</blockquote>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><p>在总结 net 包之前，还需要温习模糊的网络模型知识。下图是大学课本上的网络模型图：</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160629256.png\" alt=\"image-20210330160629256\" style=\"zoom:67%;\" />\n\n<p>模型图中可以看到，OSI 的七层模型，每一层实现的是与对端相应层的通信接口。但是实际应用中，我们把会话层、表示层、应用层统称为应用层。因此，就变成了TCP/IP 的五层模型。 其中网络层包含了 ip,arp,icmp 等协议，传输层包含了 TCP， UDP 等协议，应用层，比如 SMTP，DNS，HTTP 等协议。<br>在 net 包中，主要涉及网络层和传输层的协议。支持如下：<br>网络层：</p>\n<ul>\n<li>ICMP</li>\n<li>IGMP</li>\n<li>IVP6-ICMP</li>\n</ul>\n<p>传输层：</p>\n<ul>\n<li>TCP</li>\n<li>UDP</li>\n</ul>\n<h2 id=\"Socket-编程\"><a href=\"#Socket-编程\" class=\"headerlink\" title=\"Socket 编程\"></a>Socket 编程</h2><p>在讲代码结构前，还需要回忆（学习）几个 Socket 编程(套接字编程)的知识点。</p>\n<ol>\n<li>在 Linux 上一切皆文件。所以各端口的读写服务可以认为是读取/写入文件, 一般使用文件描述符 fd (file descriptor) 表示。在Windows上，各端口的读写服务是一个通信链的句柄操作，通过句柄实现网络发出请求和读取数据。在 go 中为了统一，采用 linux 的 fd 代表一个链接节点。</li>\n<li>TCP 是面向连接的、可靠的流协议，可以理解为不断从文件中读取数据（STREAM）。UDP 是无链接的、面向报文的协议，是无序，不可靠的（DGRAM）（目前很多可靠的协议都是基于UDP 开发的）。</li>\n<li>UNIXDomain Socket 是一种 进程间通信的协议，之前仅在*nix上使用，17年 17063 版本后支持了该协议。虽然是一个 IPC 协议，但是在实现上是基于套接字 (socket) 实现的。因此，UNIXDomain Socket 也放在了net 包中。</li>\n<li>unixDomain Socket 也可以选择采用比特流的方式，或者无序的，不可靠的通讯方式，有序数据包的方式（SEQPACKET, Linux 2.6 内核才支持）</li>\n</ol>\n<h2 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h2><p>下面我们看看 net 包中一些接口，以及一些接口的实现。</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160649541.png\" alt=\"image-20210330160649541\"  />\n\n<p>从图中可以看出，基于 TCP、UDP、IP、Unix （Stream 方式）的链接抽象出来都是 Conn 接口。基于包传递的 UDP、IP、UnixConn （DGRAM 包方式） 都实现了 PacketConn 接口。对于面向流的监听器，比如： TCPListener、 UnixListener 都实现了 Listener 接口。</p>\n<p>整体上可以看出，net 包对网络链接是基于我们复习的网络知识实现的。对于代码的底层实现，也是比较简单的。正对不同的平台，调用不同平台套接字的系统调用即可。直观上看，对于不同的链接，我们都是可以通过Conn 的接口来做网络io的交互。</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>在了解了包的构成后，我们基于不同的网络协议分两类来学习如何调用网络包提供的方法。</p>\n<h3 id=\"基于流的协议\"><a href=\"#基于流的协议\" class=\"headerlink\" title=\"基于流的协议\"></a>基于流的协议</h3><p>基于流的协议，net 包中支持了常见的 TCP，Unix （Stream 方式） 两种。基于流的协议需要先于对端建立链接，然后再发送消息。下面是 Unix 套接字编程的一个流程：</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160708936.png\" alt=\"image-20210330160708936\" style=\"zoom:67%;\" />\n\n<p>首先，服务端需要绑定并监听端口，然后等待客户端与其建立链接，通过 Accept 接收到客户端的连接后，开始读写消息。最后，当服务端收到EOF标识后，关闭链接即可。 HTTP, SMTP 等应用层协议都是使用的 TCP 传输层协议。</p>\n<h3 id=\"基于包的协议\"><a href=\"#基于包的协议\" class=\"headerlink\" title=\"基于包的协议\"></a>基于包的协议</h3><p>基于包的协议，net 包中支持了常见的 UDP，Unix （DGRAM 包方式，PacketConn 方式），Ip (网络层协议，支持了icmp, igmp) 几种。基于包的协议在bind 端口后，无需建立连接，是一种即发即收的模式。</p>\n<p>基于包的协议，例如基于UDP 的 DNS解析， 文件传输（TFTP协议）等协议，在网络层应该都是基于包的协议。 下面是基于包请求的Server 端和Client端：</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160725275.png\" alt=\"image-20210330160725275\" style=\"zoom:67%;\" />\n\n<p>可以看到，在Socket 编程里， 基于包的协议是不需要 Listen 和 Accept 的。在 net 包中，使用ListenPacket，实际上仅是构造了一个UDP连接，做了端口绑定而已。端口绑定后，Server 端开始阻塞读取包数据，之后二者开始通信。由于基于包协议，因此，我们也可以采用PacketConn 接口（看第一个实现接口的图）构造UDP包。</p>\n<h2 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h2><p>下面，我们构造一个简单的 Redis Server （支持多线程），实现了支持Redis协议的简易Key-Value操作（可以使用Redis-cli直接验证）:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;net&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> KVMap sync.Map</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 构造一个listener</span></span><br><span class=\"line\">  listener, _ := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; _ = listener.Close() &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收请求</span></span><br><span class=\"line\">    conn, _ := listener.Accept()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> FakeRedis(conn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里做了io 读写操作，并解析了 Redis 的协议</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FakeRedis</span><span class=\"params\">(conn net.Conn)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">  reader := bufio.NewReader(conn)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    data, _, err := reader.ReadLine()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    paramCount, _ := strconv.Atoi(<span class=\"keyword\">string</span>(data[<span class=\"number\">1</span>:]))</span><br><span class=\"line\">    <span class=\"keyword\">var</span> params []<span class=\"keyword\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; paramCount; i++ &#123;</span><br><span class=\"line\">      _, _, _ = reader.ReadLine() <span class=\"comment\">// 每个参数的长度，这里忽略了</span></span><br><span class=\"line\">      sParam, _, _ := reader.ReadLine()</span><br><span class=\"line\">      params = <span class=\"built_in\">append</span>(params, <span class=\"keyword\">string</span>(sParam))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> strings.ToUpper(params[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;GET&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> v, ok := KVMap.Load(params[<span class=\"number\">1</span>]); !ok &#123;</span><br><span class=\"line\">        conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;$-1\\r\\n&quot;</span>))</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        conn.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(<span class=\"string\">&quot;$%d\\r\\n%v\\r\\n&quot;</span>, <span class=\"built_in\">len</span>(v.(<span class=\"keyword\">string</span>)), v)))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;SET&quot;</span>:</span><br><span class=\"line\">      KVMap.Store(params[<span class=\"number\">1</span>], params[<span class=\"number\">2</span>])</span><br><span class=\"line\">      conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;+OK\\r\\n&quot;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;COMMAND&quot;</span>:</span><br><span class=\"line\">      conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;+OK\\r\\n&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>上述代码没有任何的异常处理，仅作为网络连接的一个简单例子。</em><br>从代码中可以看出，我们的数据流式的网络协议，在建立连接后，可以和文件IO服务一样，可以任意的读写操作。<br>正常情况下，流处理的请求，都会开启一个协程来做连接处理，主协程仅用来接收连接请求。(基于包的网络协议则可以不用开启协程处理)</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>基于 Conn 的消息都是有三种过期时间，这其实是在底层epoll_wait中设置的超时时间。 Deadline 设置了Dail中建立连接的超时时间， ReadDeadline 是 Read 操作的超时时间， WriteDeadline 为 Write 操作的超时时间。</li>\n<li>net 包作为基础包，基于net开发应用层协议比较多，例如 net/http, net/rpc/smtp 等。</li>\n<li>网络的io操作底层是基于epoll来实现的, unixDomain 基于文件来实现的。</li>\n<li>net 包实现的套接字编程仅是我们日常生活中用的比较多的一些方法，还有很多未实现的配置待我们去探索。</li>\n<li>网络模型比较简单，实际用起来，还是需要分门别类的。</li>\n</ol>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Golang-net-包简介\"><a href=\"#Golang-net-包简介\" class=\"headerlink\" title=\"Golang net 包简介\"></a>Golang net 包简介</h1><blockquote>\n<p>golang 的 net 包，相关接口和结构比较多，今天做个简单的梳理。</p>\n</blockquote>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><p>在总结 net 包之前，还需要温习模糊的网络模型知识。下图是大学课本上的网络模型图：</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160629256.png\" alt=\"image-20210330160629256\" style=\"zoom:67%;\" />\n\n<p>模型图中可以看到，OSI 的七层模型，每一层实现的是与对端相应层的通信接口。但是实际应用中，我们把会话层、表示层、应用层统称为应用层。因此，就变成了TCP/IP 的五层模型。 其中网络层包含了 ip,arp,icmp 等协议，传输层包含了 TCP， UDP 等协议，应用层，比如 SMTP，DNS，HTTP 等协议。<br>在 net 包中，主要涉及网络层和传输层的协议。支持如下：<br>网络层：</p>\n<ul>\n<li>ICMP</li>\n<li>IGMP</li>\n<li>IVP6-ICMP</li>\n</ul>\n<p>传输层：</p>\n<ul>\n<li>TCP</li>\n<li>UDP</li>\n</ul>\n<h2 id=\"Socket-编程\"><a href=\"#Socket-编程\" class=\"headerlink\" title=\"Socket 编程\"></a>Socket 编程</h2><p>在讲代码结构前，还需要回忆（学习）几个 Socket 编程(套接字编程)的知识点。</p>\n<ol>\n<li>在 Linux 上一切皆文件。所以各端口的读写服务可以认为是读取/写入文件, 一般使用文件描述符 fd (file descriptor) 表示。在Windows上，各端口的读写服务是一个通信链的句柄操作，通过句柄实现网络发出请求和读取数据。在 go 中为了统一，采用 linux 的 fd 代表一个链接节点。</li>\n<li>TCP 是面向连接的、可靠的流协议，可以理解为不断从文件中读取数据（STREAM）。UDP 是无链接的、面向报文的协议，是无序，不可靠的（DGRAM）（目前很多可靠的协议都是基于UDP 开发的）。</li>\n<li>UNIXDomain Socket 是一种 进程间通信的协议，之前仅在*nix上使用，17年 17063 版本后支持了该协议。虽然是一个 IPC 协议，但是在实现上是基于套接字 (socket) 实现的。因此，UNIXDomain Socket 也放在了net 包中。</li>\n<li>unixDomain Socket 也可以选择采用比特流的方式，或者无序的，不可靠的通讯方式，有序数据包的方式（SEQPACKET, Linux 2.6 内核才支持）</li>\n</ol>\n<h2 id=\"代码结构\"><a href=\"#代码结构\" class=\"headerlink\" title=\"代码结构\"></a>代码结构</h2><p>下面我们看看 net 包中一些接口，以及一些接口的实现。</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160649541.png\" alt=\"image-20210330160649541\"  />\n\n<p>从图中可以看出，基于 TCP、UDP、IP、Unix （Stream 方式）的链接抽象出来都是 Conn 接口。基于包传递的 UDP、IP、UnixConn （DGRAM 包方式） 都实现了 PacketConn 接口。对于面向流的监听器，比如： TCPListener、 UnixListener 都实现了 Listener 接口。</p>\n<p>整体上可以看出，net 包对网络链接是基于我们复习的网络知识实现的。对于代码的底层实现，也是比较简单的。正对不同的平台，调用不同平台套接字的系统调用即可。直观上看，对于不同的链接，我们都是可以通过Conn 的接口来做网络io的交互。</p>\n<h2 id=\"如何使用\"><a href=\"#如何使用\" class=\"headerlink\" title=\"如何使用\"></a>如何使用</h2><p>在了解了包的构成后，我们基于不同的网络协议分两类来学习如何调用网络包提供的方法。</p>\n<h3 id=\"基于流的协议\"><a href=\"#基于流的协议\" class=\"headerlink\" title=\"基于流的协议\"></a>基于流的协议</h3><p>基于流的协议，net 包中支持了常见的 TCP，Unix （Stream 方式） 两种。基于流的协议需要先于对端建立链接，然后再发送消息。下面是 Unix 套接字编程的一个流程：</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160708936.png\" alt=\"image-20210330160708936\" style=\"zoom:67%;\" />\n\n<p>首先，服务端需要绑定并监听端口，然后等待客户端与其建立链接，通过 Accept 接收到客户端的连接后，开始读写消息。最后，当服务端收到EOF标识后，关闭链接即可。 HTTP, SMTP 等应用层协议都是使用的 TCP 传输层协议。</p>\n<h3 id=\"基于包的协议\"><a href=\"#基于包的协议\" class=\"headerlink\" title=\"基于包的协议\"></a>基于包的协议</h3><p>基于包的协议，net 包中支持了常见的 UDP，Unix （DGRAM 包方式，PacketConn 方式），Ip (网络层协议，支持了icmp, igmp) 几种。基于包的协议在bind 端口后，无需建立连接，是一种即发即收的模式。</p>\n<p>基于包的协议，例如基于UDP 的 DNS解析， 文件传输（TFTP协议）等协议，在网络层应该都是基于包的协议。 下面是基于包请求的Server 端和Client端：</p>\n<img src=\"Golang%20net%E5%8C%85%E7%AE%80%E4%BB%8B/image-20210330160725275.png\" alt=\"image-20210330160725275\" style=\"zoom:67%;\" />\n\n<p>可以看到，在Socket 编程里， 基于包的协议是不需要 Listen 和 Accept 的。在 net 包中，使用ListenPacket，实际上仅是构造了一个UDP连接，做了端口绑定而已。端口绑定后，Server 端开始阻塞读取包数据，之后二者开始通信。由于基于包协议，因此，我们也可以采用PacketConn 接口（看第一个实现接口的图）构造UDP包。</p>\n<h2 id=\"一个简单的例子\"><a href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"></a>一个简单的例子</h2><p>下面，我们构造一个简单的 Redis Server （支持多线程），实现了支持Redis协议的简易Key-Value操作（可以使用Redis-cli直接验证）:</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">  <span class=\"string\">&quot;bufio&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;io&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;net&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;strconv&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;strings&quot;</span></span><br><span class=\"line\">  <span class=\"string\">&quot;sync&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> KVMap sync.Map</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 构造一个listener</span></span><br><span class=\"line\">  listener, _ := net.Listen(<span class=\"string\">&quot;tcp&quot;</span>, <span class=\"string\">&quot;127.0.0.1:6379&quot;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123; _ = listener.Close() &#125;()</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收请求</span></span><br><span class=\"line\">    conn, _ := listener.Accept()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 连接的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">go</span> FakeRedis(conn)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里做了io 读写操作，并解析了 Redis 的协议</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">FakeRedis</span><span class=\"params\">(conn net.Conn)</span></span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">defer</span> conn.Close()</span><br><span class=\"line\">  reader := bufio.NewReader(conn)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> &#123;</span><br><span class=\"line\">    data, _, err := reader.ReadLine()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err == io.EOF &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    paramCount, _ := strconv.Atoi(<span class=\"keyword\">string</span>(data[<span class=\"number\">1</span>:]))</span><br><span class=\"line\">    <span class=\"keyword\">var</span> params []<span class=\"keyword\">string</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i := <span class=\"number\">0</span>; i &lt; paramCount; i++ &#123;</span><br><span class=\"line\">      _, _, _ = reader.ReadLine() <span class=\"comment\">// 每个参数的长度，这里忽略了</span></span><br><span class=\"line\">      sParam, _, _ := reader.ReadLine()</span><br><span class=\"line\">      params = <span class=\"built_in\">append</span>(params, <span class=\"keyword\">string</span>(sParam))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> strings.ToUpper(params[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;GET&quot;</span>:</span><br><span class=\"line\">      <span class=\"keyword\">if</span> v, ok := KVMap.Load(params[<span class=\"number\">1</span>]); !ok &#123;</span><br><span class=\"line\">        conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;$-1\\r\\n&quot;</span>))</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        conn.Write([]<span class=\"keyword\">byte</span>(fmt.Sprintf(<span class=\"string\">&quot;$%d\\r\\n%v\\r\\n&quot;</span>, <span class=\"built_in\">len</span>(v.(<span class=\"keyword\">string</span>)), v)))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;SET&quot;</span>:</span><br><span class=\"line\">      KVMap.Store(params[<span class=\"number\">1</span>], params[<span class=\"number\">2</span>])</span><br><span class=\"line\">      conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;+OK\\r\\n&quot;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&quot;COMMAND&quot;</span>:</span><br><span class=\"line\">      conn.Write([]<span class=\"keyword\">byte</span>(<span class=\"string\">&quot;+OK\\r\\n&quot;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>上述代码没有任何的异常处理，仅作为网络连接的一个简单例子。</em><br>从代码中可以看出，我们的数据流式的网络协议，在建立连接后，可以和文件IO服务一样，可以任意的读写操作。<br>正常情况下，流处理的请求，都会开启一个协程来做连接处理，主协程仅用来接收连接请求。(基于包的网络协议则可以不用开启协程处理)</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ol>\n<li>基于 Conn 的消息都是有三种过期时间，这其实是在底层epoll_wait中设置的超时时间。 Deadline 设置了Dail中建立连接的超时时间， ReadDeadline 是 Read 操作的超时时间， WriteDeadline 为 Write 操作的超时时间。</li>\n<li>net 包作为基础包，基于net开发应用层协议比较多，例如 net/http, net/rpc/smtp 等。</li>\n<li>网络的io操作底层是基于epoll来实现的, unixDomain 基于文件来实现的。</li>\n<li>net 包实现的套接字编程仅是我们日常生活中用的比较多的一些方法，还有很多未实现的配置待我们去探索。</li>\n<li>网络模型比较简单，实际用起来，还是需要分门别类的。</li>\n</ol>\n"},{"title":"Python中的“*”总结","date":"2020-12-31T15:59:00.000Z","abbrlink":16001,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n## Python中的“*”总结\n\n对于一般的Python使用者来说，清楚Python中的“*”号是作为乘法运算符就足够了，但是如果你想要更进一步，想要在Python领域中更进一步的话，就需要了解Python中“星号”的五个强大的用途。\n\n### **1.作为乘法或者是乘幂运算符**\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmP6gnlib8DyoYJfjjogscYBQiaMbQoKvrcDK8ibgiaTT3Zic3zUzuhHXX2NA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n作为基础的Python应用，乘法运算和乘幂运算是大家最容易想到的星号作用。上述程序中，单个星号运算符起到了乘法运算的目的，而连续的两个乘号起到了乘幂运算的目的。从结果可以看出，3*3的结果是9，而3的3次方是27。\n\n\n\n### **2.接收多个参数**\n\n当我们在编写函数时，有时候函数的参数数量太多，所以我们想尽量的缩短程序，让程序看起来简介，除此之外，我们可能不知道函数有多少个具体的参数，这个时候，就可以用星号来发挥作用。\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm0jwvh8XeMdSQxV9bSXacBlUgv3RemyH8ORoSicAG3ZSkj5yHxOXF0KQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n上述程序中，单个星号起到的作用是帮助我们捕获多个位置参数，然后将其放入到字典中，需要注意的是，在传入参数时，它的顺序位置需要明确，以方便在函数调用中使用。\n\n\n\n而对于双星号的参数，可以帮助我们捕获多个带关键字名字的参数，并放入到字典中去，这样的话，我们在程序内使用的时候，可以根据关键字名字来调用，而无需过多关注参数的顺序位置。\n\n\n\n### **3.函数使用时必须带有形参名称**\n\n星号的一个作用是在函数调用时，必须要指定函数的形参名称，如下图程序:\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibme58q0hXtt6ib4cgzCrwx2dRzv0MR5a1ccfGelT7VZ98ibDJpaDSA7mQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n上述的程序中，func3的第一个参数是星号，它的作用是星号之后的形参在函数调用时都必须要显示的指定；\n\n通过函数的调用就可以看出，我们在前两次的函数调用都指明了星号之后的函数的形参名称；\n\n而第二次的调用没有指定函数的形参名称，结果显示，没有明确形参指定的函数会报错误，从而提示我们必须指定函数的形参。\n\n\n\n### **4.可迭代对象的组合**\n\n对于Python中的可迭代对象，是指实现了__iter__()方法的对象，通常大家使用的列表、元组、字典、字符串等等，都是可迭代对象。对于可迭代对象的组合，如下图所示：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm068JNmTicYgmFiam67v6rOM3KX8FwDhdrjp7QJsskJO5PD4WmQ5QYpww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n可以看到，我们日常所使用的可迭代对象的组合方式，是通过两个for循环来实现，但是这样的方法简单，却并不能展示出Python的简洁性的优势。\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmbOZMI7Bhgn1Yzia70RASMyicm6KUichr03VG2TvZmnZGI4hl8lX91LiaRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n上图中，可以利用星号来实现可迭代对象的解压。一行代码即可搞定可迭代对象的组合。\n\n\n\n### **5.压缩可迭代对象的一部分**\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmGpql7eYUCY4yOJphnNULZpXD8dqt8ANy9aYQWKmH5ibx1llSWf3iba9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n当我们从可迭代对象中取值，例如上例中，a，b，c，d与mylist中的元素是一一对应的关系，既不能多也不能少，而当我们只想取出某一部分的元素时，就可以利用星号来进行剩余部分元素的一个压缩。\n\n\n\n如上述程序中，可以利用星号前缀的c元素来代替后面的可迭代对象的内容，对象c也是一个可迭代对象。\n\n\n\n### **总结**\n\n星号运算符在Python的程序中，除了用作乘法运算符外，还有一些非常强大而且高效的使用方法，我们要在日常的程序中学会使用这些方法，让我们的程序变得更加简洁高效。","source":"_posts/python_md/Python中的star总结.md","raw":"---\ntitle: Python中的“*”总结\ndate: '2020/12/31 23:59'\ntags:\n  - python\ncategories:\n  - 学习笔记\nabbrlink: 16001\ncover: \n---\n\n## Python中的“*”总结\n\n对于一般的Python使用者来说，清楚Python中的“*”号是作为乘法运算符就足够了，但是如果你想要更进一步，想要在Python领域中更进一步的话，就需要了解Python中“星号”的五个强大的用途。\n\n### **1.作为乘法或者是乘幂运算符**\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmP6gnlib8DyoYJfjjogscYBQiaMbQoKvrcDK8ibgiaTT3Zic3zUzuhHXX2NA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n\n\n作为基础的Python应用，乘法运算和乘幂运算是大家最容易想到的星号作用。上述程序中，单个星号运算符起到了乘法运算的目的，而连续的两个乘号起到了乘幂运算的目的。从结果可以看出，3*3的结果是9，而3的3次方是27。\n\n\n\n### **2.接收多个参数**\n\n当我们在编写函数时，有时候函数的参数数量太多，所以我们想尽量的缩短程序，让程序看起来简介，除此之外，我们可能不知道函数有多少个具体的参数，这个时候，就可以用星号来发挥作用。\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm0jwvh8XeMdSQxV9bSXacBlUgv3RemyH8ORoSicAG3ZSkj5yHxOXF0KQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n上述程序中，单个星号起到的作用是帮助我们捕获多个位置参数，然后将其放入到字典中，需要注意的是，在传入参数时，它的顺序位置需要明确，以方便在函数调用中使用。\n\n\n\n而对于双星号的参数，可以帮助我们捕获多个带关键字名字的参数，并放入到字典中去，这样的话，我们在程序内使用的时候，可以根据关键字名字来调用，而无需过多关注参数的顺序位置。\n\n\n\n### **3.函数使用时必须带有形参名称**\n\n星号的一个作用是在函数调用时，必须要指定函数的形参名称，如下图程序:\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibme58q0hXtt6ib4cgzCrwx2dRzv0MR5a1ccfGelT7VZ98ibDJpaDSA7mQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n上述的程序中，func3的第一个参数是星号，它的作用是星号之后的形参在函数调用时都必须要显示的指定；\n\n通过函数的调用就可以看出，我们在前两次的函数调用都指明了星号之后的函数的形参名称；\n\n而第二次的调用没有指定函数的形参名称，结果显示，没有明确形参指定的函数会报错误，从而提示我们必须指定函数的形参。\n\n\n\n### **4.可迭代对象的组合**\n\n对于Python中的可迭代对象，是指实现了__iter__()方法的对象，通常大家使用的列表、元组、字典、字符串等等，都是可迭代对象。对于可迭代对象的组合，如下图所示：\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm068JNmTicYgmFiam67v6rOM3KX8FwDhdrjp7QJsskJO5PD4WmQ5QYpww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n可以看到，我们日常所使用的可迭代对象的组合方式，是通过两个for循环来实现，但是这样的方法简单，却并不能展示出Python的简洁性的优势。\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmbOZMI7Bhgn1Yzia70RASMyicm6KUichr03VG2TvZmnZGI4hl8lX91LiaRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n上图中，可以利用星号来实现可迭代对象的解压。一行代码即可搞定可迭代对象的组合。\n\n\n\n### **5.压缩可迭代对象的一部分**\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmGpql7eYUCY4yOJphnNULZpXD8dqt8ANy9aYQWKmH5ibx1llSWf3iba9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n当我们从可迭代对象中取值，例如上例中，a，b，c，d与mylist中的元素是一一对应的关系，既不能多也不能少，而当我们只想取出某一部分的元素时，就可以利用星号来进行剩余部分元素的一个压缩。\n\n\n\n如上述程序中，可以利用星号前缀的c元素来代替后面的可迭代对象的内容，对象c也是一个可迭代对象。\n\n\n\n### **总结**\n\n星号运算符在Python的程序中，除了用作乘法运算符外，还有一些非常强大而且高效的使用方法，我们要在日常的程序中学会使用这些方法，让我们的程序变得更加简洁高效。","slug":"python_md/Python中的star总结","published":1,"updated":"2021-04-08T14:09:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5w000xw9q9abgm952h","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h2 id=\"Python中的“-”总结\"><a href=\"#Python中的“-”总结\" class=\"headerlink\" title=\"Python中的“*”总结\"></a>Python中的“*”总结</h2><p>对于一般的Python使用者来说，清楚Python中的“*”号是作为乘法运算符就足够了，但是如果你想要更进一步，想要在Python领域中更进一步的话，就需要了解Python中“星号”的五个强大的用途。</p>\n<h3 id=\"1-作为乘法或者是乘幂运算符\"><a href=\"#1-作为乘法或者是乘幂运算符\" class=\"headerlink\" title=\"1.作为乘法或者是乘幂运算符\"></a><strong>1.作为乘法或者是乘幂运算符</strong></h3><p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmP6gnlib8DyoYJfjjogscYBQiaMbQoKvrcDK8ibgiaTT3Zic3zUzuhHXX2NA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>作为基础的Python应用，乘法运算和乘幂运算是大家最容易想到的星号作用。上述程序中，单个星号运算符起到了乘法运算的目的，而连续的两个乘号起到了乘幂运算的目的。从结果可以看出，3*3的结果是9，而3的3次方是27。</p>\n<h3 id=\"2-接收多个参数\"><a href=\"#2-接收多个参数\" class=\"headerlink\" title=\"2.接收多个参数\"></a><strong>2.接收多个参数</strong></h3><p>当我们在编写函数时，有时候函数的参数数量太多，所以我们想尽量的缩短程序，让程序看起来简介，除此之外，我们可能不知道函数有多少个具体的参数，这个时候，就可以用星号来发挥作用。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm0jwvh8XeMdSQxV9bSXacBlUgv3RemyH8ORoSicAG3ZSkj5yHxOXF0KQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>上述程序中，单个星号起到的作用是帮助我们捕获多个位置参数，然后将其放入到字典中，需要注意的是，在传入参数时，它的顺序位置需要明确，以方便在函数调用中使用。</p>\n<p>而对于双星号的参数，可以帮助我们捕获多个带关键字名字的参数，并放入到字典中去，这样的话，我们在程序内使用的时候，可以根据关键字名字来调用，而无需过多关注参数的顺序位置。</p>\n<h3 id=\"3-函数使用时必须带有形参名称\"><a href=\"#3-函数使用时必须带有形参名称\" class=\"headerlink\" title=\"3.函数使用时必须带有形参名称\"></a><strong>3.函数使用时必须带有形参名称</strong></h3><p>星号的一个作用是在函数调用时，必须要指定函数的形参名称，如下图程序:</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibme58q0hXtt6ib4cgzCrwx2dRzv0MR5a1ccfGelT7VZ98ibDJpaDSA7mQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>上述的程序中，func3的第一个参数是星号，它的作用是星号之后的形参在函数调用时都必须要显示的指定；</p>\n<p>通过函数的调用就可以看出，我们在前两次的函数调用都指明了星号之后的函数的形参名称；</p>\n<p>而第二次的调用没有指定函数的形参名称，结果显示，没有明确形参指定的函数会报错误，从而提示我们必须指定函数的形参。</p>\n<h3 id=\"4-可迭代对象的组合\"><a href=\"#4-可迭代对象的组合\" class=\"headerlink\" title=\"4.可迭代对象的组合\"></a><strong>4.可迭代对象的组合</strong></h3><p>对于Python中的可迭代对象，是指实现了<strong>iter</strong>()方法的对象，通常大家使用的列表、元组、字典、字符串等等，都是可迭代对象。对于可迭代对象的组合，如下图所示：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm068JNmTicYgmFiam67v6rOM3KX8FwDhdrjp7QJsskJO5PD4WmQ5QYpww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>可以看到，我们日常所使用的可迭代对象的组合方式，是通过两个for循环来实现，但是这样的方法简单，却并不能展示出Python的简洁性的优势。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmbOZMI7Bhgn1Yzia70RASMyicm6KUichr03VG2TvZmnZGI4hl8lX91LiaRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>上图中，可以利用星号来实现可迭代对象的解压。一行代码即可搞定可迭代对象的组合。</p>\n<h3 id=\"5-压缩可迭代对象的一部分\"><a href=\"#5-压缩可迭代对象的一部分\" class=\"headerlink\" title=\"5.压缩可迭代对象的一部分\"></a><strong>5.压缩可迭代对象的一部分</strong></h3><p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmGpql7eYUCY4yOJphnNULZpXD8dqt8ANy9aYQWKmH5ibx1llSWf3iba9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>当我们从可迭代对象中取值，例如上例中，a，b，c，d与mylist中的元素是一一对应的关系，既不能多也不能少，而当我们只想取出某一部分的元素时，就可以利用星号来进行剩余部分元素的一个压缩。</p>\n<p>如上述程序中，可以利用星号前缀的c元素来代替后面的可迭代对象的内容，对象c也是一个可迭代对象。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>星号运算符在Python的程序中，除了用作乘法运算符外，还有一些非常强大而且高效的使用方法，我们要在日常的程序中学会使用这些方法，让我们的程序变得更加简洁高效。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"Python中的“-”总结\"><a href=\"#Python中的“-”总结\" class=\"headerlink\" title=\"Python中的“*”总结\"></a>Python中的“*”总结</h2><p>对于一般的Python使用者来说，清楚Python中的“*”号是作为乘法运算符就足够了，但是如果你想要更进一步，想要在Python领域中更进一步的话，就需要了解Python中“星号”的五个强大的用途。</p>\n<h3 id=\"1-作为乘法或者是乘幂运算符\"><a href=\"#1-作为乘法或者是乘幂运算符\" class=\"headerlink\" title=\"1.作为乘法或者是乘幂运算符\"></a><strong>1.作为乘法或者是乘幂运算符</strong></h3><p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmP6gnlib8DyoYJfjjogscYBQiaMbQoKvrcDK8ibgiaTT3Zic3zUzuhHXX2NA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>作为基础的Python应用，乘法运算和乘幂运算是大家最容易想到的星号作用。上述程序中，单个星号运算符起到了乘法运算的目的，而连续的两个乘号起到了乘幂运算的目的。从结果可以看出，3*3的结果是9，而3的3次方是27。</p>\n<h3 id=\"2-接收多个参数\"><a href=\"#2-接收多个参数\" class=\"headerlink\" title=\"2.接收多个参数\"></a><strong>2.接收多个参数</strong></h3><p>当我们在编写函数时，有时候函数的参数数量太多，所以我们想尽量的缩短程序，让程序看起来简介，除此之外，我们可能不知道函数有多少个具体的参数，这个时候，就可以用星号来发挥作用。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm0jwvh8XeMdSQxV9bSXacBlUgv3RemyH8ORoSicAG3ZSkj5yHxOXF0KQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>上述程序中，单个星号起到的作用是帮助我们捕获多个位置参数，然后将其放入到字典中，需要注意的是，在传入参数时，它的顺序位置需要明确，以方便在函数调用中使用。</p>\n<p>而对于双星号的参数，可以帮助我们捕获多个带关键字名字的参数，并放入到字典中去，这样的话，我们在程序内使用的时候，可以根据关键字名字来调用，而无需过多关注参数的顺序位置。</p>\n<h3 id=\"3-函数使用时必须带有形参名称\"><a href=\"#3-函数使用时必须带有形参名称\" class=\"headerlink\" title=\"3.函数使用时必须带有形参名称\"></a><strong>3.函数使用时必须带有形参名称</strong></h3><p>星号的一个作用是在函数调用时，必须要指定函数的形参名称，如下图程序:</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibme58q0hXtt6ib4cgzCrwx2dRzv0MR5a1ccfGelT7VZ98ibDJpaDSA7mQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>上述的程序中，func3的第一个参数是星号，它的作用是星号之后的形参在函数调用时都必须要显示的指定；</p>\n<p>通过函数的调用就可以看出，我们在前两次的函数调用都指明了星号之后的函数的形参名称；</p>\n<p>而第二次的调用没有指定函数的形参名称，结果显示，没有明确形参指定的函数会报错误，从而提示我们必须指定函数的形参。</p>\n<h3 id=\"4-可迭代对象的组合\"><a href=\"#4-可迭代对象的组合\" class=\"headerlink\" title=\"4.可迭代对象的组合\"></a><strong>4.可迭代对象的组合</strong></h3><p>对于Python中的可迭代对象，是指实现了<strong>iter</strong>()方法的对象，通常大家使用的列表、元组、字典、字符串等等，都是可迭代对象。对于可迭代对象的组合，如下图所示：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibm068JNmTicYgmFiam67v6rOM3KX8FwDhdrjp7QJsskJO5PD4WmQ5QYpww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>可以看到，我们日常所使用的可迭代对象的组合方式，是通过两个for循环来实现，但是这样的方法简单，却并不能展示出Python的简洁性的优势。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmbOZMI7Bhgn1Yzia70RASMyicm6KUichr03VG2TvZmnZGI4hl8lX91LiaRQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>上图中，可以利用星号来实现可迭代对象的解压。一行代码即可搞定可迭代对象的组合。</p>\n<h3 id=\"5-压缩可迭代对象的一部分\"><a href=\"#5-压缩可迭代对象的一部分\" class=\"headerlink\" title=\"5.压缩可迭代对象的一部分\"></a><strong>5.压缩可迭代对象的一部分</strong></h3><p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/H4U1sS0fpI6paSHxlqkGz3roPyaNyYibmGpql7eYUCY4yOJphnNULZpXD8dqt8ANy9aYQWKmH5ibx1llSWf3iba9A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>当我们从可迭代对象中取值，例如上例中，a，b，c，d与mylist中的元素是一一对应的关系，既不能多也不能少，而当我们只想取出某一部分的元素时，就可以利用星号来进行剩余部分元素的一个压缩。</p>\n<p>如上述程序中，可以利用星号前缀的c元素来代替后面的可迭代对象的内容，对象c也是一个可迭代对象。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>星号运算符在Python的程序中，除了用作乘法运算符外，还有一些非常强大而且高效的使用方法，我们要在日常的程序中学会使用这些方法，让我们的程序变得更加简洁高效。</p>\n"},{"title":"Python 面向对象编程","date":"2020-12-31T15:59:00.000Z","abbrlink":16004,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n## **Python 面向对象编程** \n\n面向对象程序设计思想，首先思考的不是程序执行流程，它的核心是抽象出一个对象，然后构思此对象包括的数据，以及操作数据的行为方法。\n\n本专题主要讨论面向对象编程(OOP)的基础和进阶知识，实际开发模型中OOP的主要实践，尽量使用最贴切的例子。\n\n## **基础专题**\n\n### 1 类定义\n\n动物是自然界一个庞大的群体，以建模动物类为主要案例论述OOP编程。\n\nPython语言创建动物类的基本语法如下，使用`class`关键字定义一个动物类：\n\n```python\nclass Animal():\n    pass\n```\n\n类里面可包括数据，如下所示的`Animal`类包括两个数据：`self.name`和`self.speed`：\n\n```python\nclass Animal():\n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.speed = speed # 动物行走或飞行速度\n```\n\n注意到类里面通过系统函数`__init__`为类的2个数据赋值，数据前使用`self`保留字。\n\n`self`的作用是指名这两个数据是实例上的，而非类上的。\n\n同时注意到`__init__`方法的第一个参数也带有`self`，所以也表明此方法是实例上的方法。\n\n### 2 实例\n\n理解什么是实例上的数据或方法，什么是类上的数据，需要先建立`实例`的概念，`类`的概念，如下：\n\n```python\n# 生成一个名字叫加菲猫、行走速度8km/h的cat对象\ncat = Animal('加菲猫',8) \n```\n\n`cat`就是`Animal`的实例，也可以一次创建成千上百个实例，如下创建1000只蜜蜂：\n\n```python\nbees = [Animal('bee'+str(i),5) for i in range(1000)]\n```\n\n总结：自始至终只使用一个类`Animal`，但却可以创建出许多个它的实例，因此是一对多的关系。\n\n实例创建完成后，下一步打印它看看：\n\n```python\nIn [1]: print(cat)                                                           \n<__main__.Animal object at 0x7fce3a596ad0>\n```\n\n结果显示它是`Animal`对象，其实打印结果显示实例属性信息会更友好，那么怎么实现呢？\n\n### 3 打印实例\n\n只需重新定义一个系统(又称为魔法)函数`__str__` ，就能让打印实例显示的更加友好：\n\n```python\nclass Animal():\n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0.speed}) is printed\n                name={0.name}\n                speed={0.speed}'''.format(self)\n```\n\n使用`0.数据名称`的格式，这是类专有的打印格式。\n\n现在再打印:\n\n```python\ncat = Animal('加菲猫',8)\nprint(cat)\n```\n\n打印信息如下:\n\n```python\nAnimal(加菲猫,8) is printed\n                name=加菲猫\n                speed=8\n```\n\n以上就是想要的打印格式，看到实例的数据值都正确。\n\n### 4 属性\n\n至此，我们都称类里的`name`和`speed`称为数据，其实它们有一个专业名称：属性。\n\n同时，上面还有一个问题我们没有回答完全，什么是类上的属性？\n\n如下，在最新`Animal`类定义基础上，再添加一个`cprop`属性，它前面没有`self`保留字：\n\n```python\nclass Animal():\n   cprop = \"我是类上的属性cprop\"\n   \n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0.speed}) is printed\n                name={0.name}\n                speed={0.speed}'''.format(self)\n```\n\n类上的属性直接使用类便可引用：\n\n```python\nIn [1]: Animal.cprop                                                           \nOut[1]: '我是类上的属性cprop'\n```\n\n类上的属性，实例同样可以引用，并且所有的实例都共用此属性值：\n\n```python\nIn [1]: cat = Animal('加菲猫',8)\nIn [2]: cat.cprop                                                              \nOut[2]: '我是类上的属性cprop'\n```\n\nPython作为一门动态语言，支持属性的动态添加和删除。\n\n如下`cat`实例原来不存在`color`属性，但是赋值时不光不会报错，相反会直接将属性添加到`cat`上：\n\n```python\ncat.color = 'grap'\n```\n\n那么，如何验证`cat`是否有`color`属性呢？使用内置函数`hasattr`：\n\n```python\nIn [24]: hasattr(cat,'color') # cat 已经有`color`属性                          \nOut[24]: True\n```\n\n但是注意：以上添加属性方法仅仅为`cat`实例本身添加，而不会为其他实例添加：\n\n```python\nIn [26]: monkey = Animal('大猩猩',2)                                            \nIn [27]: hasattr(monkey,'color')                                             \nOut[27]: False\n```\n\n`monkey`实例并没有`color`属性，注意与`__init__`创建属性方法的区别。\n\n### 5 private,protected,public\n\n像`name`和`speed`属性，引用此实例的对象都能访问到它们，如下：\n\n```python\n# 模块名称：manager.py\n\nimport time\n\nclass Manager():\n    def __init__(self,animal):\n        self.animal = animal\n        \n    def recordTime(self):\n        self.__t = time.time()\n        print('feeding time for %s（行走速度为:%s） is %.0f'%(self.animal.name,self.animal.speed,self.__t))\n    \n    def getFeedingTime(self):\n        return '%0.f'%(self.__t,) \n```\n\n使用以上`Manager`类，创建一个`cat`实例，`xiaoming`实例引用`cat`:\n\n```python\ncat = Animal('加菲猫',8)\nxiaoming =  Manager(cat) \n```\n\n`xiaoming`的`recordTime`方法引用里，引用了animal的两个属性`name`和`speed`:\n\n```python\nIn[1]: xiaoming.recordTime()\n\nOut[1]: feeding time for 加菲猫（行走速度为:8） is 1595681304\n```\n\n注意看到`self.__t`属性，它就是一个私有属性，只能被`Manager`类内的所有方法引用，如被方法`getFeedingTime`方法引用。但是，不能被其他类引用。\n\n如果我们连`speed`这个属性也不想被其他类访问，那么只需将`self.speed`修改为`self.__speed`:\n\n同时`Manager`类的`self.animal.speed`修改为`self.animal.__speed`，再次调用下面方法时：\n\n```python\nxiaoming.recordTime()\n```\n\n就会报没有`__speed`属性的异常，从而验证了`__speed`属性已经变为类内私有，不会暴露在外面。\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN27U75xiaIHaCmh1hoTcHHAeKTUhyWWyR57DF1T4rsSuR9USGFHYn5mVmfaQxS22uGxNe1DICoVic9icA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n总结：`name`属性相当于java的public属性，而`__speed`相当于java的private属性。\n\n下面在说继承时，讲解`protected`属性，实际上它就是带有1个`_`的属性，它只能被继承的类所引用。\n\n### 6 继承\n\n上面已经讲完了OOP三大特性中的封装性，而继承是它的第二大特性。子类继承父类的所有`public`和`protected`数据和方法，极大提高了代码的重用性。\n\n如上创建的`Animal`类最新版本为：\n\n```python\nclass Animal():\n   cprop = \"我是类上的属性cprop\"\n   \n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.__speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0.__speed}) is printed\n                name={0.name}\n                speed={0.__speed}'''.format(self)\n```\n\n现在有个新的需求，要重新定义一个`Cat`猫类，它也有`name`和`speed`两个属性，同时还有`color`和`genre`两个属性，打印时只需要打印`name`和`speed`两个属性就行。\n\n因此，基本可以复用基类`Animal`，但需要修改`__speed`属性为受保护(`protected`)的`_speed`属性，这样子类都可以使用此属性，而外部还是访问不到它。\n\n综合以上，`Cat`类的定义如下：\n\n```python\nclass Cat(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n```\n\n首先使用`super()`方法找到`Cat`的基类`Animal`，然后引用基类的`__init__`方法，这样复用基类的方法。\n\n使用`Cat`类，打印时，又复用了基类的 `__str__`方法：\n\n```python\njiafeimao = Cat('加菲猫',8,'gray','CatGenre')\nprint(jiafeimao)\n```\n\n打印结果：\n\n```python\nAnimal(加菲猫,8) is printed\n                name=加菲猫\n                speed=8\n```\n\n以上就是基本的继承使用案例，继承要求基类定义的数据和行为尽量标准、尽量精简，以此提高代码复用性。\n\n### 7 多态\n\n如果说OOP的封装和继承使用起来更加直观易用，那么作为第三大特性的多态，在实践中真正运用起来就不那么容易。有的读者OOP编程初期，可能对多态的价值体会不深刻，甚至都已经淡忘它的存在。\n\n那么问题就在：多态到底真的有用吗？到底使用在哪些场景？\n\n多态价值很大，使用场景很多，几乎所有的系统或软件，都能看到它的应用。这篇文章尽可能通过一个精简的例子说明它的价值和使用方法。如果不用多态，方法怎么写；使用多态，又是怎么写。\n\n为了一脉相承，做到一致性，仍然基于上面的案例，已经创建好的`Cat`类要有一个方法打印和返回它的爬行速度。同时需要再创建一个类`Bird`，要有一个方法打印和返回它的飞行速度；\n\n如果不使用多态，为`Cat`类新增一个方法：\n\n```python\nclass Cat(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n    # 添加方法\n    def getRunningSpeed(self):\n        print('running speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n```\n\n重新创建一个`Bird`类：\n\n```python\nclass Bird(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n    # 添加方法\n    def getFlyingSpeed(self):\n        print('flying speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n```\n\n最后，上面创建的`Manager`类会引用`Cat`和`Bird`类，但是需要修改`recordTime`方法，因为Cat它是爬行的，Bird它是飞行的，所以要根据对象类型的不同做逻辑区分，如下所示：\n\n```python\n# 模块名称：manager.py\n\nimport time\nfrom animal import (Animal,Cat,Bird)\n\nclass Manager():\n    def __init__(self,animal):\n        self.animal = animal\n        \n    def recordTime(self):\n        self.__t = time.time()\n        if isinstance(self.animal, Cat):\n            print('feeding time for %s is %.0f'%(self.animal.name,self.__t))\n            self.animal.getRunningSpeed()\n        if isinstance(self.animal,Bird):\n            print('feeding time for %s is %.0f'%(self.animal.name,self.__t))\n            self.animal.getFlyingSpeed()\n\n    def getFeedingTime(self):\n        return '%0.f'%(self.__t,) \n```\n\n如果再来一个类，我们又得需要修改`recordTime`，再增加一个`if`分支，从软件设计角度讲，这种不断破坏封装的行为不可取。\n\n**但是，使用多态，就可以保证`recordTime`不被修改，不必写很多if分支。**怎么来实现呢？\n\n首先，在基类`Animal`中创建一个基类方法，然后`Cat`和`Bird`分别重写此方法，最后传入到`Manager`类的`animal`参数是什么类型，在`recordTime`方法中就会对应调用这个`animal`实例的方法，这就是**多态**。\n\n代码如下：\n\nanimal2.py 模块如下：\n\n```python\n# animal2.py 模块\n\nclass Animal():\n   cprop = \"我是类上的属性cprop\"\n   \n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self._speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0._speed}) is printed\n                name={0.name}\n                speed={0._speed}'''.format(self)\n\n   def getSpeedBehavior(self):\n       pass \n\nclass Cat(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n        \n    # 重写方法\n    def getSpeedBehavior(self):\n        print('running speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n        \n\nclass Bird(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n\n    # 重写方法\n    def getSpeedBehavior(self):\n        print('flying speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n```\n\nmanager2.py 模块如下：\n\n```python\n# manager2.py 模块\n\nimport time\nfrom animal2 import (Animal,Cat,Bird)\n\nclass Manager():\n    def __init__(self,animal):\n        self.animal = animal\n        \n    def recordTime(self):\n        self.__t = time.time()\n        print('feeding time for %s is %.0f'%(self.animal.name,self.__t))\n        self.animal.getSpeedBehavior()\n\n    def getFeedingTime(self):\n        return '%0.f'%(self.__t,)  \n```\n\n`recordTime`方法非常清爽，不需要任何if逻辑，只需要调用我们定义的`Animal`类的基方法`getSpeedBehavior`即可。\n\n在使用上面所有类时，`Manager(jiafeimao)`传入`Cat`类实例时，`recordTime`方法调用就被自动指向`Cat`实例的`getSpeedBehavior`方法；\n\n`Manager(haiying)`传入`Bird`类实例时，自动指向`Bird`实例的`getSpeedBehavior`方法，这就是多态和它的价值，Manager类的方法不必每次都修改，保证了类的封装性。\n\n```python\nif __name__ == \"__main__\":\n    jiafeimao = Cat('jiafeimao',2,'gray','CatGenre')\n    haiying = Bird('haiying',40,'blue','BirdGenre')\n\n    Manager(jiafeimao).recordTime()\n    print('#'*30)\n    Manager(haiying).recordTime()  \n```\n\n## **总结**\n\n以上就是面向对象编程专题的基础部分，大纲如下：\n\n- Python 面向对象编程\n\n- 基础专题\n\n- - 1 类定义\n    - 2 实例\n    - 3 打印实例\n    - 4 属性\n    - 5 private,protected,public\n    - 6 继承\n    - 7 多态\n\n- 总结","source":"_posts/python_md/Python面向对象编程.md","raw":"---\ntitle: Python 面向对象编程\ndate: '2020/12/31 23:59'\ntags:\n  - python\ncategories:\n  - 学习笔记\nabbrlink: 16004\ncover: \n---\n\n## **Python 面向对象编程** \n\n面向对象程序设计思想，首先思考的不是程序执行流程，它的核心是抽象出一个对象，然后构思此对象包括的数据，以及操作数据的行为方法。\n\n本专题主要讨论面向对象编程(OOP)的基础和进阶知识，实际开发模型中OOP的主要实践，尽量使用最贴切的例子。\n\n## **基础专题**\n\n### 1 类定义\n\n动物是自然界一个庞大的群体，以建模动物类为主要案例论述OOP编程。\n\nPython语言创建动物类的基本语法如下，使用`class`关键字定义一个动物类：\n\n```python\nclass Animal():\n    pass\n```\n\n类里面可包括数据，如下所示的`Animal`类包括两个数据：`self.name`和`self.speed`：\n\n```python\nclass Animal():\n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.speed = speed # 动物行走或飞行速度\n```\n\n注意到类里面通过系统函数`__init__`为类的2个数据赋值，数据前使用`self`保留字。\n\n`self`的作用是指名这两个数据是实例上的，而非类上的。\n\n同时注意到`__init__`方法的第一个参数也带有`self`，所以也表明此方法是实例上的方法。\n\n### 2 实例\n\n理解什么是实例上的数据或方法，什么是类上的数据，需要先建立`实例`的概念，`类`的概念，如下：\n\n```python\n# 生成一个名字叫加菲猫、行走速度8km/h的cat对象\ncat = Animal('加菲猫',8) \n```\n\n`cat`就是`Animal`的实例，也可以一次创建成千上百个实例，如下创建1000只蜜蜂：\n\n```python\nbees = [Animal('bee'+str(i),5) for i in range(1000)]\n```\n\n总结：自始至终只使用一个类`Animal`，但却可以创建出许多个它的实例，因此是一对多的关系。\n\n实例创建完成后，下一步打印它看看：\n\n```python\nIn [1]: print(cat)                                                           \n<__main__.Animal object at 0x7fce3a596ad0>\n```\n\n结果显示它是`Animal`对象，其实打印结果显示实例属性信息会更友好，那么怎么实现呢？\n\n### 3 打印实例\n\n只需重新定义一个系统(又称为魔法)函数`__str__` ，就能让打印实例显示的更加友好：\n\n```python\nclass Animal():\n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0.speed}) is printed\n                name={0.name}\n                speed={0.speed}'''.format(self)\n```\n\n使用`0.数据名称`的格式，这是类专有的打印格式。\n\n现在再打印:\n\n```python\ncat = Animal('加菲猫',8)\nprint(cat)\n```\n\n打印信息如下:\n\n```python\nAnimal(加菲猫,8) is printed\n                name=加菲猫\n                speed=8\n```\n\n以上就是想要的打印格式，看到实例的数据值都正确。\n\n### 4 属性\n\n至此，我们都称类里的`name`和`speed`称为数据，其实它们有一个专业名称：属性。\n\n同时，上面还有一个问题我们没有回答完全，什么是类上的属性？\n\n如下，在最新`Animal`类定义基础上，再添加一个`cprop`属性，它前面没有`self`保留字：\n\n```python\nclass Animal():\n   cprop = \"我是类上的属性cprop\"\n   \n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0.speed}) is printed\n                name={0.name}\n                speed={0.speed}'''.format(self)\n```\n\n类上的属性直接使用类便可引用：\n\n```python\nIn [1]: Animal.cprop                                                           \nOut[1]: '我是类上的属性cprop'\n```\n\n类上的属性，实例同样可以引用，并且所有的实例都共用此属性值：\n\n```python\nIn [1]: cat = Animal('加菲猫',8)\nIn [2]: cat.cprop                                                              \nOut[2]: '我是类上的属性cprop'\n```\n\nPython作为一门动态语言，支持属性的动态添加和删除。\n\n如下`cat`实例原来不存在`color`属性，但是赋值时不光不会报错，相反会直接将属性添加到`cat`上：\n\n```python\ncat.color = 'grap'\n```\n\n那么，如何验证`cat`是否有`color`属性呢？使用内置函数`hasattr`：\n\n```python\nIn [24]: hasattr(cat,'color') # cat 已经有`color`属性                          \nOut[24]: True\n```\n\n但是注意：以上添加属性方法仅仅为`cat`实例本身添加，而不会为其他实例添加：\n\n```python\nIn [26]: monkey = Animal('大猩猩',2)                                            \nIn [27]: hasattr(monkey,'color')                                             \nOut[27]: False\n```\n\n`monkey`实例并没有`color`属性，注意与`__init__`创建属性方法的区别。\n\n### 5 private,protected,public\n\n像`name`和`speed`属性，引用此实例的对象都能访问到它们，如下：\n\n```python\n# 模块名称：manager.py\n\nimport time\n\nclass Manager():\n    def __init__(self,animal):\n        self.animal = animal\n        \n    def recordTime(self):\n        self.__t = time.time()\n        print('feeding time for %s（行走速度为:%s） is %.0f'%(self.animal.name,self.animal.speed,self.__t))\n    \n    def getFeedingTime(self):\n        return '%0.f'%(self.__t,) \n```\n\n使用以上`Manager`类，创建一个`cat`实例，`xiaoming`实例引用`cat`:\n\n```python\ncat = Animal('加菲猫',8)\nxiaoming =  Manager(cat) \n```\n\n`xiaoming`的`recordTime`方法引用里，引用了animal的两个属性`name`和`speed`:\n\n```python\nIn[1]: xiaoming.recordTime()\n\nOut[1]: feeding time for 加菲猫（行走速度为:8） is 1595681304\n```\n\n注意看到`self.__t`属性，它就是一个私有属性，只能被`Manager`类内的所有方法引用，如被方法`getFeedingTime`方法引用。但是，不能被其他类引用。\n\n如果我们连`speed`这个属性也不想被其他类访问，那么只需将`self.speed`修改为`self.__speed`:\n\n同时`Manager`类的`self.animal.speed`修改为`self.animal.__speed`，再次调用下面方法时：\n\n```python\nxiaoming.recordTime()\n```\n\n就会报没有`__speed`属性的异常，从而验证了`__speed`属性已经变为类内私有，不会暴露在外面。\n\n![img](https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN27U75xiaIHaCmh1hoTcHHAeKTUhyWWyR57DF1T4rsSuR9USGFHYn5mVmfaQxS22uGxNe1DICoVic9icA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)\n\n总结：`name`属性相当于java的public属性，而`__speed`相当于java的private属性。\n\n下面在说继承时，讲解`protected`属性，实际上它就是带有1个`_`的属性，它只能被继承的类所引用。\n\n### 6 继承\n\n上面已经讲完了OOP三大特性中的封装性，而继承是它的第二大特性。子类继承父类的所有`public`和`protected`数据和方法，极大提高了代码的重用性。\n\n如上创建的`Animal`类最新版本为：\n\n```python\nclass Animal():\n   cprop = \"我是类上的属性cprop\"\n   \n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self.__speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0.__speed}) is printed\n                name={0.name}\n                speed={0.__speed}'''.format(self)\n```\n\n现在有个新的需求，要重新定义一个`Cat`猫类，它也有`name`和`speed`两个属性，同时还有`color`和`genre`两个属性，打印时只需要打印`name`和`speed`两个属性就行。\n\n因此，基本可以复用基类`Animal`，但需要修改`__speed`属性为受保护(`protected`)的`_speed`属性，这样子类都可以使用此属性，而外部还是访问不到它。\n\n综合以上，`Cat`类的定义如下：\n\n```python\nclass Cat(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n```\n\n首先使用`super()`方法找到`Cat`的基类`Animal`，然后引用基类的`__init__`方法，这样复用基类的方法。\n\n使用`Cat`类，打印时，又复用了基类的 `__str__`方法：\n\n```python\njiafeimao = Cat('加菲猫',8,'gray','CatGenre')\nprint(jiafeimao)\n```\n\n打印结果：\n\n```python\nAnimal(加菲猫,8) is printed\n                name=加菲猫\n                speed=8\n```\n\n以上就是基本的继承使用案例，继承要求基类定义的数据和行为尽量标准、尽量精简，以此提高代码复用性。\n\n### 7 多态\n\n如果说OOP的封装和继承使用起来更加直观易用，那么作为第三大特性的多态，在实践中真正运用起来就不那么容易。有的读者OOP编程初期，可能对多态的价值体会不深刻，甚至都已经淡忘它的存在。\n\n那么问题就在：多态到底真的有用吗？到底使用在哪些场景？\n\n多态价值很大，使用场景很多，几乎所有的系统或软件，都能看到它的应用。这篇文章尽可能通过一个精简的例子说明它的价值和使用方法。如果不用多态，方法怎么写；使用多态，又是怎么写。\n\n为了一脉相承，做到一致性，仍然基于上面的案例，已经创建好的`Cat`类要有一个方法打印和返回它的爬行速度。同时需要再创建一个类`Bird`，要有一个方法打印和返回它的飞行速度；\n\n如果不使用多态，为`Cat`类新增一个方法：\n\n```python\nclass Cat(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n    # 添加方法\n    def getRunningSpeed(self):\n        print('running speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n```\n\n重新创建一个`Bird`类：\n\n```python\nclass Bird(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n    # 添加方法\n    def getFlyingSpeed(self):\n        print('flying speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n```\n\n最后，上面创建的`Manager`类会引用`Cat`和`Bird`类，但是需要修改`recordTime`方法，因为Cat它是爬行的，Bird它是飞行的，所以要根据对象类型的不同做逻辑区分，如下所示：\n\n```python\n# 模块名称：manager.py\n\nimport time\nfrom animal import (Animal,Cat,Bird)\n\nclass Manager():\n    def __init__(self,animal):\n        self.animal = animal\n        \n    def recordTime(self):\n        self.__t = time.time()\n        if isinstance(self.animal, Cat):\n            print('feeding time for %s is %.0f'%(self.animal.name,self.__t))\n            self.animal.getRunningSpeed()\n        if isinstance(self.animal,Bird):\n            print('feeding time for %s is %.0f'%(self.animal.name,self.__t))\n            self.animal.getFlyingSpeed()\n\n    def getFeedingTime(self):\n        return '%0.f'%(self.__t,) \n```\n\n如果再来一个类，我们又得需要修改`recordTime`，再增加一个`if`分支，从软件设计角度讲，这种不断破坏封装的行为不可取。\n\n**但是，使用多态，就可以保证`recordTime`不被修改，不必写很多if分支。**怎么来实现呢？\n\n首先，在基类`Animal`中创建一个基类方法，然后`Cat`和`Bird`分别重写此方法，最后传入到`Manager`类的`animal`参数是什么类型，在`recordTime`方法中就会对应调用这个`animal`实例的方法，这就是**多态**。\n\n代码如下：\n\nanimal2.py 模块如下：\n\n```python\n# animal2.py 模块\n\nclass Animal():\n   cprop = \"我是类上的属性cprop\"\n   \n   def __init__(self,name,speed):\n       self.name = name # 动物名字\n       self._speed = speed # 动物行走或飞行速度\n  \n   def __str__(self):\n        return '''Animal({0.name},{0._speed}) is printed\n                name={0.name}\n                speed={0._speed}'''.format(self)\n\n   def getSpeedBehavior(self):\n       pass \n\nclass Cat(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n        \n    # 重写方法\n    def getSpeedBehavior(self):\n        print('running speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n        \n\nclass Bird(Animal):\n    def __init__(self,name,speed,color,genre):\n        super().__init__(name,speed)\n        self.color = color \n        self.genre = genre\n\n    # 重写方法\n    def getSpeedBehavior(self):\n        print('flying speed of %s is %s' %(self.name, self._speed))\n        return self._speed\n```\n\nmanager2.py 模块如下：\n\n```python\n# manager2.py 模块\n\nimport time\nfrom animal2 import (Animal,Cat,Bird)\n\nclass Manager():\n    def __init__(self,animal):\n        self.animal = animal\n        \n    def recordTime(self):\n        self.__t = time.time()\n        print('feeding time for %s is %.0f'%(self.animal.name,self.__t))\n        self.animal.getSpeedBehavior()\n\n    def getFeedingTime(self):\n        return '%0.f'%(self.__t,)  \n```\n\n`recordTime`方法非常清爽，不需要任何if逻辑，只需要调用我们定义的`Animal`类的基方法`getSpeedBehavior`即可。\n\n在使用上面所有类时，`Manager(jiafeimao)`传入`Cat`类实例时，`recordTime`方法调用就被自动指向`Cat`实例的`getSpeedBehavior`方法；\n\n`Manager(haiying)`传入`Bird`类实例时，自动指向`Bird`实例的`getSpeedBehavior`方法，这就是多态和它的价值，Manager类的方法不必每次都修改，保证了类的封装性。\n\n```python\nif __name__ == \"__main__\":\n    jiafeimao = Cat('jiafeimao',2,'gray','CatGenre')\n    haiying = Bird('haiying',40,'blue','BirdGenre')\n\n    Manager(jiafeimao).recordTime()\n    print('#'*30)\n    Manager(haiying).recordTime()  \n```\n\n## **总结**\n\n以上就是面向对象编程专题的基础部分，大纲如下：\n\n- Python 面向对象编程\n\n- 基础专题\n\n- - 1 类定义\n    - 2 实例\n    - 3 打印实例\n    - 4 属性\n    - 5 private,protected,public\n    - 6 继承\n    - 7 多态\n\n- 总结","slug":"python_md/Python面向对象编程","published":1,"updated":"2021-04-08T14:09:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5x0010w9q9hziu8uzg","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h2 id=\"Python-面向对象编程\"><a href=\"#Python-面向对象编程\" class=\"headerlink\" title=\"Python 面向对象编程\"></a><strong>Python 面向对象编程</strong></h2><p>面向对象程序设计思想，首先思考的不是程序执行流程，它的核心是抽象出一个对象，然后构思此对象包括的数据，以及操作数据的行为方法。</p>\n<p>本专题主要讨论面向对象编程(OOP)的基础和进阶知识，实际开发模型中OOP的主要实践，尽量使用最贴切的例子。</p>\n<h2 id=\"基础专题\"><a href=\"#基础专题\" class=\"headerlink\" title=\"基础专题\"></a><strong>基础专题</strong></h2><h3 id=\"1-类定义\"><a href=\"#1-类定义\" class=\"headerlink\" title=\"1 类定义\"></a>1 类定义</h3><p>动物是自然界一个庞大的群体，以建模动物类为主要案例论述OOP编程。</p>\n<p>Python语言创建动物类的基本语法如下，使用<code>class</code>关键字定义一个动物类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>类里面可包括数据，如下所示的<code>Animal</code>类包括两个数据：<code>self.name</code>和<code>self.speed</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br></pre></td></tr></table></figure>\n<p>注意到类里面通过系统函数<code>__init__</code>为类的2个数据赋值，数据前使用<code>self</code>保留字。</p>\n<p><code>self</code>的作用是指名这两个数据是实例上的，而非类上的。</p>\n<p>同时注意到<code>__init__</code>方法的第一个参数也带有<code>self</code>，所以也表明此方法是实例上的方法。</p>\n<h3 id=\"2-实例\"><a href=\"#2-实例\" class=\"headerlink\" title=\"2 实例\"></a>2 实例</h3><p>理解什么是实例上的数据或方法，什么是类上的数据，需要先建立<code>实例</code>的概念，<code>类</code>的概念，如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成一个名字叫加菲猫、行走速度8km/h的cat对象</span></span><br><span class=\"line\">cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>) </span><br></pre></td></tr></table></figure>\n<p><code>cat</code>就是<code>Animal</code>的实例，也可以一次创建成千上百个实例，如下创建1000只蜜蜂：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bees = [Animal(<span class=\"string\">&#x27;bee&#x27;</span>+<span class=\"built_in\">str</span>(i),<span class=\"number\">5</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1000</span>)]</span><br></pre></td></tr></table></figure>\n<p>总结：自始至终只使用一个类<code>Animal</code>，但却可以创建出许多个它的实例，因此是一对多的关系。</p>\n<p>实例创建完成后，下一步打印它看看：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: print(cat)                                                           </span><br><span class=\"line\">&lt;__main__.Animal <span class=\"built_in\">object</span> at <span class=\"number\">0x7fce3a596ad0</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>结果显示它是<code>Animal</code>对象，其实打印结果显示实例属性信息会更友好，那么怎么实现呢？</p>\n<h3 id=\"3-打印实例\"><a href=\"#3-打印实例\" class=\"headerlink\" title=\"3 打印实例\"></a>3 打印实例</h3><p>只需重新定义一个系统(又称为魔法)函数<code>__str__</code> ，就能让打印实例显示的更加友好：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0.speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0.speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br></pre></td></tr></table></figure>\n<p>使用<code>0.数据名称</code>的格式，这是类专有的打印格式。</p>\n<p>现在再打印:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">print(cat)</span><br></pre></td></tr></table></figure>\n<p>打印信息如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal(加菲猫,<span class=\"number\">8</span>) <span class=\"keyword\">is</span> printed</span><br><span class=\"line\">                name=加菲猫</span><br><span class=\"line\">                speed=<span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>以上就是想要的打印格式，看到实例的数据值都正确。</p>\n<h3 id=\"4-属性\"><a href=\"#4-属性\" class=\"headerlink\" title=\"4 属性\"></a>4 属性</h3><p>至此，我们都称类里的<code>name</code>和<code>speed</code>称为数据，其实它们有一个专业名称：属性。</p>\n<p>同时，上面还有一个问题我们没有回答完全，什么是类上的属性？</p>\n<p>如下，在最新<code>Animal</code>类定义基础上，再添加一个<code>cprop</code>属性，它前面没有<code>self</code>保留字：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   cprop = <span class=\"string\">&quot;我是类上的属性cprop&quot;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0.speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0.speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br></pre></td></tr></table></figure>\n<p>类上的属性直接使用类便可引用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: Animal.cprop                                                           </span><br><span class=\"line\">Out[<span class=\"number\">1</span>]: <span class=\"string\">&#x27;我是类上的属性cprop&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>类上的属性，实例同样可以引用，并且所有的实例都共用此属性值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">In [<span class=\"number\">2</span>]: cat.cprop                                                              </span><br><span class=\"line\">Out[<span class=\"number\">2</span>]: <span class=\"string\">&#x27;我是类上的属性cprop&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>Python作为一门动态语言，支持属性的动态添加和删除。</p>\n<p>如下<code>cat</code>实例原来不存在<code>color</code>属性，但是赋值时不光不会报错，相反会直接将属性添加到<code>cat</code>上：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat.color = <span class=\"string\">&#x27;grap&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>那么，如何验证<code>cat</code>是否有<code>color</code>属性呢？使用内置函数<code>hasattr</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">24</span>]: <span class=\"built_in\">hasattr</span>(cat,<span class=\"string\">&#x27;color&#x27;</span>) <span class=\"comment\"># cat 已经有`color`属性                          </span></span><br><span class=\"line\">Out[<span class=\"number\">24</span>]: <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>但是注意：以上添加属性方法仅仅为<code>cat</code>实例本身添加，而不会为其他实例添加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">26</span>]: monkey = Animal(<span class=\"string\">&#x27;大猩猩&#x27;</span>,<span class=\"number\">2</span>)                                            </span><br><span class=\"line\">In [<span class=\"number\">27</span>]: <span class=\"built_in\">hasattr</span>(monkey,<span class=\"string\">&#x27;color&#x27;</span>)                                             </span><br><span class=\"line\">Out[<span class=\"number\">27</span>]: <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p><code>monkey</code>实例并没有<code>color</code>属性，注意与<code>__init__</code>创建属性方法的区别。</p>\n<h3 id=\"5-private-protected-public\"><a href=\"#5-private-protected-public\" class=\"headerlink\" title=\"5 private,protected,public\"></a>5 private,protected,public</h3><p>像<code>name</code>和<code>speed</code>属性，引用此实例的对象都能访问到它们，如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模块名称：manager.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span>():</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,animal</span>):</span></span><br><span class=\"line\">        self.animal = animal</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recordTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__t = time.time()</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;feeding time for %s（行走速度为:%s） is %.0f&#x27;</span>%(self.animal.name,self.animal.speed,self.__t))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFeedingTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%0.f&#x27;</span>%(self.__t,) </span><br></pre></td></tr></table></figure>\n<p>使用以上<code>Manager</code>类，创建一个<code>cat</code>实例，<code>xiaoming</code>实例引用<code>cat</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">xiaoming =  Manager(cat) </span><br></pre></td></tr></table></figure>\n<p><code>xiaoming</code>的<code>recordTime</code>方法引用里，引用了animal的两个属性<code>name</code>和<code>speed</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In[<span class=\"number\">1</span>]: xiaoming.recordTime()</span><br><span class=\"line\"></span><br><span class=\"line\">Out[<span class=\"number\">1</span>]: feeding time <span class=\"keyword\">for</span> 加菲猫（行走速度为:<span class=\"number\">8</span>） <span class=\"keyword\">is</span> <span class=\"number\">1595681304</span></span><br></pre></td></tr></table></figure>\n<p>注意看到<code>self.__t</code>属性，它就是一个私有属性，只能被<code>Manager</code>类内的所有方法引用，如被方法<code>getFeedingTime</code>方法引用。但是，不能被其他类引用。</p>\n<p>如果我们连<code>speed</code>这个属性也不想被其他类访问，那么只需将<code>self.speed</code>修改为<code>self.__speed</code>:</p>\n<p>同时<code>Manager</code>类的<code>self.animal.speed</code>修改为<code>self.animal.__speed</code>，再次调用下面方法时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xiaoming.recordTime()</span><br></pre></td></tr></table></figure>\n<p>就会报没有<code>__speed</code>属性的异常，从而验证了<code>__speed</code>属性已经变为类内私有，不会暴露在外面。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN27U75xiaIHaCmh1hoTcHHAeKTUhyWWyR57DF1T4rsSuR9USGFHYn5mVmfaQxS22uGxNe1DICoVic9icA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>总结：<code>name</code>属性相当于java的public属性，而<code>__speed</code>相当于java的private属性。</p>\n<p>下面在说继承时，讲解<code>protected</code>属性，实际上它就是带有1个<code>_</code>的属性，它只能被继承的类所引用。</p>\n<h3 id=\"6-继承\"><a href=\"#6-继承\" class=\"headerlink\" title=\"6 继承\"></a>6 继承</h3><p>上面已经讲完了OOP三大特性中的封装性，而继承是它的第二大特性。子类继承父类的所有<code>public</code>和<code>protected</code>数据和方法，极大提高了代码的重用性。</p>\n<p>如上创建的<code>Animal</code>类最新版本为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   cprop = <span class=\"string\">&quot;我是类上的属性cprop&quot;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.__speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0.__speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0.__speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br></pre></td></tr></table></figure>\n<p>现在有个新的需求，要重新定义一个<code>Cat</code>猫类，它也有<code>name</code>和<code>speed</code>两个属性，同时还有<code>color</code>和<code>genre</code>两个属性，打印时只需要打印<code>name</code>和<code>speed</code>两个属性就行。</p>\n<p>因此，基本可以复用基类<code>Animal</code>，但需要修改<code>__speed</code>属性为受保护(<code>protected</code>)的<code>_speed</code>属性，这样子类都可以使用此属性，而外部还是访问不到它。</p>\n<p>综合以上，<code>Cat</code>类的定义如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br></pre></td></tr></table></figure>\n<p>首先使用<code>super()</code>方法找到<code>Cat</code>的基类<code>Animal</code>，然后引用基类的<code>__init__</code>方法，这样复用基类的方法。</p>\n<p>使用<code>Cat</code>类，打印时，又复用了基类的 <code>__str__</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jiafeimao = Cat(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>,<span class=\"string\">&#x27;gray&#x27;</span>,<span class=\"string\">&#x27;CatGenre&#x27;</span>)</span><br><span class=\"line\">print(jiafeimao)</span><br></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal(加菲猫,<span class=\"number\">8</span>) <span class=\"keyword\">is</span> printed</span><br><span class=\"line\">                name=加菲猫</span><br><span class=\"line\">                speed=<span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>以上就是基本的继承使用案例，继承要求基类定义的数据和行为尽量标准、尽量精简，以此提高代码复用性。</p>\n<h3 id=\"7-多态\"><a href=\"#7-多态\" class=\"headerlink\" title=\"7 多态\"></a>7 多态</h3><p>如果说OOP的封装和继承使用起来更加直观易用，那么作为第三大特性的多态，在实践中真正运用起来就不那么容易。有的读者OOP编程初期，可能对多态的价值体会不深刻，甚至都已经淡忘它的存在。</p>\n<p>那么问题就在：多态到底真的有用吗？到底使用在哪些场景？</p>\n<p>多态价值很大，使用场景很多，几乎所有的系统或软件，都能看到它的应用。这篇文章尽可能通过一个精简的例子说明它的价值和使用方法。如果不用多态，方法怎么写；使用多态，又是怎么写。</p>\n<p>为了一脉相承，做到一致性，仍然基于上面的案例，已经创建好的<code>Cat</code>类要有一个方法打印和返回它的爬行速度。同时需要再创建一个类<code>Bird</code>，要有一个方法打印和返回它的飞行速度；</p>\n<p>如果不使用多态，为<code>Cat</code>类新增一个方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\">    <span class=\"comment\"># 添加方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getRunningSpeed</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br></pre></td></tr></table></figure>\n<p>重新创建一个<code>Bird</code>类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\">    <span class=\"comment\"># 添加方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFlyingSpeed</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;flying speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br></pre></td></tr></table></figure>\n<p>最后，上面创建的<code>Manager</code>类会引用<code>Cat</code>和<code>Bird</code>类，但是需要修改<code>recordTime</code>方法，因为Cat它是爬行的，Bird它是飞行的，所以要根据对象类型的不同做逻辑区分，如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模块名称：manager.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> animal <span class=\"keyword\">import</span> (Animal,Cat,Bird)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span>():</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,animal</span>):</span></span><br><span class=\"line\">        self.animal = animal</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recordTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__t = time.time()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(self.animal, Cat):</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;feeding time for %s is %.0f&#x27;</span>%(self.animal.name,self.__t))</span><br><span class=\"line\">            self.animal.getRunningSpeed()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(self.animal,Bird):</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;feeding time for %s is %.0f&#x27;</span>%(self.animal.name,self.__t))</span><br><span class=\"line\">            self.animal.getFlyingSpeed()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFeedingTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%0.f&#x27;</span>%(self.__t,) </span><br></pre></td></tr></table></figure>\n<p>如果再来一个类，我们又得需要修改<code>recordTime</code>，再增加一个<code>if</code>分支，从软件设计角度讲，这种不断破坏封装的行为不可取。</p>\n<p><strong>但是，使用多态，就可以保证<code>recordTime</code>不被修改，不必写很多if分支。</strong>怎么来实现呢？</p>\n<p>首先，在基类<code>Animal</code>中创建一个基类方法，然后<code>Cat</code>和<code>Bird</code>分别重写此方法，最后传入到<code>Manager</code>类的<code>animal</code>参数是什么类型，在<code>recordTime</code>方法中就会对应调用这个<code>animal</code>实例的方法，这就是<strong>多态</strong>。</p>\n<p>代码如下：</p>\n<p>animal2.py 模块如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># animal2.py 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   cprop = <span class=\"string\">&quot;我是类上的属性cprop&quot;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self._speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0._speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0._speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSpeedBehavior</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">       <span class=\"keyword\">pass</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\"># 重写方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSpeedBehavior</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 重写方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSpeedBehavior</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;flying speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br></pre></td></tr></table></figure>\n<p>manager2.py 模块如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># manager2.py 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> animal2 <span class=\"keyword\">import</span> (Animal,Cat,Bird)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span>():</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,animal</span>):</span></span><br><span class=\"line\">        self.animal = animal</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recordTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__t = time.time()</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;feeding time for %s is %.0f&#x27;</span>%(self.animal.name,self.__t))</span><br><span class=\"line\">        self.animal.getSpeedBehavior()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFeedingTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%0.f&#x27;</span>%(self.__t,)  </span><br></pre></td></tr></table></figure>\n<p><code>recordTime</code>方法非常清爽，不需要任何if逻辑，只需要调用我们定义的<code>Animal</code>类的基方法<code>getSpeedBehavior</code>即可。</p>\n<p>在使用上面所有类时，<code>Manager(jiafeimao)</code>传入<code>Cat</code>类实例时，<code>recordTime</code>方法调用就被自动指向<code>Cat</code>实例的<code>getSpeedBehavior</code>方法；</p>\n<p><code>Manager(haiying)</code>传入<code>Bird</code>类实例时，自动指向<code>Bird</code>实例的<code>getSpeedBehavior</code>方法，这就是多态和它的价值，Manager类的方法不必每次都修改，保证了类的封装性。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    jiafeimao = Cat(<span class=\"string\">&#x27;jiafeimao&#x27;</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;gray&#x27;</span>,<span class=\"string\">&#x27;CatGenre&#x27;</span>)</span><br><span class=\"line\">    haiying = Bird(<span class=\"string\">&#x27;haiying&#x27;</span>,<span class=\"number\">40</span>,<span class=\"string\">&#x27;blue&#x27;</span>,<span class=\"string\">&#x27;BirdGenre&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    Manager(jiafeimao).recordTime()</span><br><span class=\"line\">    print(<span class=\"string\">&#x27;#&#x27;</span>*<span class=\"number\">30</span>)</span><br><span class=\"line\">    Manager(haiying).recordTime()  </span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>以上就是面向对象编程专题的基础部分，大纲如下：</p>\n<ul>\n<li><p>Python 面向对象编程</p>\n</li>\n<li><p>基础专题</p>\n</li>\n<li><ul>\n<li>1 类定义<ul>\n<li>2 实例</li>\n<li>3 打印实例</li>\n<li>4 属性</li>\n<li>5 private,protected,public</li>\n<li>6 继承</li>\n<li>7 多态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>总结</p>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"Python-面向对象编程\"><a href=\"#Python-面向对象编程\" class=\"headerlink\" title=\"Python 面向对象编程\"></a><strong>Python 面向对象编程</strong></h2><p>面向对象程序设计思想，首先思考的不是程序执行流程，它的核心是抽象出一个对象，然后构思此对象包括的数据，以及操作数据的行为方法。</p>\n<p>本专题主要讨论面向对象编程(OOP)的基础和进阶知识，实际开发模型中OOP的主要实践，尽量使用最贴切的例子。</p>\n<h2 id=\"基础专题\"><a href=\"#基础专题\" class=\"headerlink\" title=\"基础专题\"></a><strong>基础专题</strong></h2><h3 id=\"1-类定义\"><a href=\"#1-类定义\" class=\"headerlink\" title=\"1 类定义\"></a>1 类定义</h3><p>动物是自然界一个庞大的群体，以建模动物类为主要案例论述OOP编程。</p>\n<p>Python语言创建动物类的基本语法如下，使用<code>class</code>关键字定义一个动物类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>类里面可包括数据，如下所示的<code>Animal</code>类包括两个数据：<code>self.name</code>和<code>self.speed</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br></pre></td></tr></table></figure>\n<p>注意到类里面通过系统函数<code>__init__</code>为类的2个数据赋值，数据前使用<code>self</code>保留字。</p>\n<p><code>self</code>的作用是指名这两个数据是实例上的，而非类上的。</p>\n<p>同时注意到<code>__init__</code>方法的第一个参数也带有<code>self</code>，所以也表明此方法是实例上的方法。</p>\n<h3 id=\"2-实例\"><a href=\"#2-实例\" class=\"headerlink\" title=\"2 实例\"></a>2 实例</h3><p>理解什么是实例上的数据或方法，什么是类上的数据，需要先建立<code>实例</code>的概念，<code>类</code>的概念，如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 生成一个名字叫加菲猫、行走速度8km/h的cat对象</span></span><br><span class=\"line\">cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>) </span><br></pre></td></tr></table></figure>\n<p><code>cat</code>就是<code>Animal</code>的实例，也可以一次创建成千上百个实例，如下创建1000只蜜蜂：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bees = [Animal(<span class=\"string\">&#x27;bee&#x27;</span>+<span class=\"built_in\">str</span>(i),<span class=\"number\">5</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1000</span>)]</span><br></pre></td></tr></table></figure>\n<p>总结：自始至终只使用一个类<code>Animal</code>，但却可以创建出许多个它的实例，因此是一对多的关系。</p>\n<p>实例创建完成后，下一步打印它看看：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: print(cat)                                                           </span><br><span class=\"line\">&lt;__main__.Animal <span class=\"built_in\">object</span> at <span class=\"number\">0x7fce3a596ad0</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>结果显示它是<code>Animal</code>对象，其实打印结果显示实例属性信息会更友好，那么怎么实现呢？</p>\n<h3 id=\"3-打印实例\"><a href=\"#3-打印实例\" class=\"headerlink\" title=\"3 打印实例\"></a>3 打印实例</h3><p>只需重新定义一个系统(又称为魔法)函数<code>__str__</code> ，就能让打印实例显示的更加友好：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0.speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0.speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br></pre></td></tr></table></figure>\n<p>使用<code>0.数据名称</code>的格式，这是类专有的打印格式。</p>\n<p>现在再打印:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">print(cat)</span><br></pre></td></tr></table></figure>\n<p>打印信息如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal(加菲猫,<span class=\"number\">8</span>) <span class=\"keyword\">is</span> printed</span><br><span class=\"line\">                name=加菲猫</span><br><span class=\"line\">                speed=<span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>以上就是想要的打印格式，看到实例的数据值都正确。</p>\n<h3 id=\"4-属性\"><a href=\"#4-属性\" class=\"headerlink\" title=\"4 属性\"></a>4 属性</h3><p>至此，我们都称类里的<code>name</code>和<code>speed</code>称为数据，其实它们有一个专业名称：属性。</p>\n<p>同时，上面还有一个问题我们没有回答完全，什么是类上的属性？</p>\n<p>如下，在最新<code>Animal</code>类定义基础上，再添加一个<code>cprop</code>属性，它前面没有<code>self</code>保留字：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   cprop = <span class=\"string\">&quot;我是类上的属性cprop&quot;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0.speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0.speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br></pre></td></tr></table></figure>\n<p>类上的属性直接使用类便可引用：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: Animal.cprop                                                           </span><br><span class=\"line\">Out[<span class=\"number\">1</span>]: <span class=\"string\">&#x27;我是类上的属性cprop&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>类上的属性，实例同样可以引用，并且所有的实例都共用此属性值：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">1</span>]: cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">In [<span class=\"number\">2</span>]: cat.cprop                                                              </span><br><span class=\"line\">Out[<span class=\"number\">2</span>]: <span class=\"string\">&#x27;我是类上的属性cprop&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>Python作为一门动态语言，支持属性的动态添加和删除。</p>\n<p>如下<code>cat</code>实例原来不存在<code>color</code>属性，但是赋值时不光不会报错，相反会直接将属性添加到<code>cat</code>上：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat.color = <span class=\"string\">&#x27;grap&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>那么，如何验证<code>cat</code>是否有<code>color</code>属性呢？使用内置函数<code>hasattr</code>：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">24</span>]: <span class=\"built_in\">hasattr</span>(cat,<span class=\"string\">&#x27;color&#x27;</span>) <span class=\"comment\"># cat 已经有`color`属性                          </span></span><br><span class=\"line\">Out[<span class=\"number\">24</span>]: <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<p>但是注意：以上添加属性方法仅仅为<code>cat</code>实例本身添加，而不会为其他实例添加：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In [<span class=\"number\">26</span>]: monkey = Animal(<span class=\"string\">&#x27;大猩猩&#x27;</span>,<span class=\"number\">2</span>)                                            </span><br><span class=\"line\">In [<span class=\"number\">27</span>]: <span class=\"built_in\">hasattr</span>(monkey,<span class=\"string\">&#x27;color&#x27;</span>)                                             </span><br><span class=\"line\">Out[<span class=\"number\">27</span>]: <span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p><code>monkey</code>实例并没有<code>color</code>属性，注意与<code>__init__</code>创建属性方法的区别。</p>\n<h3 id=\"5-private-protected-public\"><a href=\"#5-private-protected-public\" class=\"headerlink\" title=\"5 private,protected,public\"></a>5 private,protected,public</h3><p>像<code>name</code>和<code>speed</code>属性，引用此实例的对象都能访问到它们，如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模块名称：manager.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span>():</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,animal</span>):</span></span><br><span class=\"line\">        self.animal = animal</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recordTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__t = time.time()</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;feeding time for %s（行走速度为:%s） is %.0f&#x27;</span>%(self.animal.name,self.animal.speed,self.__t))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFeedingTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%0.f&#x27;</span>%(self.__t,) </span><br></pre></td></tr></table></figure>\n<p>使用以上<code>Manager</code>类，创建一个<code>cat</code>实例，<code>xiaoming</code>实例引用<code>cat</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat = Animal(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>)</span><br><span class=\"line\">xiaoming =  Manager(cat) </span><br></pre></td></tr></table></figure>\n<p><code>xiaoming</code>的<code>recordTime</code>方法引用里，引用了animal的两个属性<code>name</code>和<code>speed</code>:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">In[<span class=\"number\">1</span>]: xiaoming.recordTime()</span><br><span class=\"line\"></span><br><span class=\"line\">Out[<span class=\"number\">1</span>]: feeding time <span class=\"keyword\">for</span> 加菲猫（行走速度为:<span class=\"number\">8</span>） <span class=\"keyword\">is</span> <span class=\"number\">1595681304</span></span><br></pre></td></tr></table></figure>\n<p>注意看到<code>self.__t</code>属性，它就是一个私有属性，只能被<code>Manager</code>类内的所有方法引用，如被方法<code>getFeedingTime</code>方法引用。但是，不能被其他类引用。</p>\n<p>如果我们连<code>speed</code>这个属性也不想被其他类访问，那么只需将<code>self.speed</code>修改为<code>self.__speed</code>:</p>\n<p>同时<code>Manager</code>类的<code>self.animal.speed</code>修改为<code>self.animal.__speed</code>，再次调用下面方法时：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">xiaoming.recordTime()</span><br></pre></td></tr></table></figure>\n<p>就会报没有<code>__speed</code>属性的异常，从而验证了<code>__speed</code>属性已经变为类内私有，不会暴露在外面。</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/FQd8gQcyN27U75xiaIHaCmh1hoTcHHAeKTUhyWWyR57DF1T4rsSuR9USGFHYn5mVmfaQxS22uGxNe1DICoVic9icA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"img\"></p>\n<p>总结：<code>name</code>属性相当于java的public属性，而<code>__speed</code>相当于java的private属性。</p>\n<p>下面在说继承时，讲解<code>protected</code>属性，实际上它就是带有1个<code>_</code>的属性，它只能被继承的类所引用。</p>\n<h3 id=\"6-继承\"><a href=\"#6-继承\" class=\"headerlink\" title=\"6 继承\"></a>6 继承</h3><p>上面已经讲完了OOP三大特性中的封装性，而继承是它的第二大特性。子类继承父类的所有<code>public</code>和<code>protected</code>数据和方法，极大提高了代码的重用性。</p>\n<p>如上创建的<code>Animal</code>类最新版本为：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   cprop = <span class=\"string\">&quot;我是类上的属性cprop&quot;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self.__speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0.__speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0.__speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br></pre></td></tr></table></figure>\n<p>现在有个新的需求，要重新定义一个<code>Cat</code>猫类，它也有<code>name</code>和<code>speed</code>两个属性，同时还有<code>color</code>和<code>genre</code>两个属性，打印时只需要打印<code>name</code>和<code>speed</code>两个属性就行。</p>\n<p>因此，基本可以复用基类<code>Animal</code>，但需要修改<code>__speed</code>属性为受保护(<code>protected</code>)的<code>_speed</code>属性，这样子类都可以使用此属性，而外部还是访问不到它。</p>\n<p>综合以上，<code>Cat</code>类的定义如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br></pre></td></tr></table></figure>\n<p>首先使用<code>super()</code>方法找到<code>Cat</code>的基类<code>Animal</code>，然后引用基类的<code>__init__</code>方法，这样复用基类的方法。</p>\n<p>使用<code>Cat</code>类，打印时，又复用了基类的 <code>__str__</code>方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jiafeimao = Cat(<span class=\"string\">&#x27;加菲猫&#x27;</span>,<span class=\"number\">8</span>,<span class=\"string\">&#x27;gray&#x27;</span>,<span class=\"string\">&#x27;CatGenre&#x27;</span>)</span><br><span class=\"line\">print(jiafeimao)</span><br></pre></td></tr></table></figure>\n<p>打印结果：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal(加菲猫,<span class=\"number\">8</span>) <span class=\"keyword\">is</span> printed</span><br><span class=\"line\">                name=加菲猫</span><br><span class=\"line\">                speed=<span class=\"number\">8</span></span><br></pre></td></tr></table></figure>\n<p>以上就是基本的继承使用案例，继承要求基类定义的数据和行为尽量标准、尽量精简，以此提高代码复用性。</p>\n<h3 id=\"7-多态\"><a href=\"#7-多态\" class=\"headerlink\" title=\"7 多态\"></a>7 多态</h3><p>如果说OOP的封装和继承使用起来更加直观易用，那么作为第三大特性的多态，在实践中真正运用起来就不那么容易。有的读者OOP编程初期，可能对多态的价值体会不深刻，甚至都已经淡忘它的存在。</p>\n<p>那么问题就在：多态到底真的有用吗？到底使用在哪些场景？</p>\n<p>多态价值很大，使用场景很多，几乎所有的系统或软件，都能看到它的应用。这篇文章尽可能通过一个精简的例子说明它的价值和使用方法。如果不用多态，方法怎么写；使用多态，又是怎么写。</p>\n<p>为了一脉相承，做到一致性，仍然基于上面的案例，已经创建好的<code>Cat</code>类要有一个方法打印和返回它的爬行速度。同时需要再创建一个类<code>Bird</code>，要有一个方法打印和返回它的飞行速度；</p>\n<p>如果不使用多态，为<code>Cat</code>类新增一个方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\">    <span class=\"comment\"># 添加方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getRunningSpeed</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br></pre></td></tr></table></figure>\n<p>重新创建一个<code>Bird</code>类：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\">    <span class=\"comment\"># 添加方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFlyingSpeed</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;flying speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br></pre></td></tr></table></figure>\n<p>最后，上面创建的<code>Manager</code>类会引用<code>Cat</code>和<code>Bird</code>类，但是需要修改<code>recordTime</code>方法，因为Cat它是爬行的，Bird它是飞行的，所以要根据对象类型的不同做逻辑区分，如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 模块名称：manager.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> animal <span class=\"keyword\">import</span> (Animal,Cat,Bird)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span>():</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,animal</span>):</span></span><br><span class=\"line\">        self.animal = animal</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recordTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__t = time.time()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(self.animal, Cat):</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;feeding time for %s is %.0f&#x27;</span>%(self.animal.name,self.__t))</span><br><span class=\"line\">            self.animal.getRunningSpeed()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(self.animal,Bird):</span><br><span class=\"line\">            print(<span class=\"string\">&#x27;feeding time for %s is %.0f&#x27;</span>%(self.animal.name,self.__t))</span><br><span class=\"line\">            self.animal.getFlyingSpeed()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFeedingTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%0.f&#x27;</span>%(self.__t,) </span><br></pre></td></tr></table></figure>\n<p>如果再来一个类，我们又得需要修改<code>recordTime</code>，再增加一个<code>if</code>分支，从软件设计角度讲，这种不断破坏封装的行为不可取。</p>\n<p><strong>但是，使用多态，就可以保证<code>recordTime</code>不被修改，不必写很多if分支。</strong>怎么来实现呢？</p>\n<p>首先，在基类<code>Animal</code>中创建一个基类方法，然后<code>Cat</code>和<code>Bird</code>分别重写此方法，最后传入到<code>Manager</code>类的<code>animal</code>参数是什么类型，在<code>recordTime</code>方法中就会对应调用这个<code>animal</code>实例的方法，这就是<strong>多态</strong>。</p>\n<p>代码如下：</p>\n<p>animal2.py 模块如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># animal2.py 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>():</span></span><br><span class=\"line\">   cprop = <span class=\"string\">&quot;我是类上的属性cprop&quot;</span></span><br><span class=\"line\">   </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed</span>):</span></span><br><span class=\"line\">       self.name = name <span class=\"comment\"># 动物名字</span></span><br><span class=\"line\">       self._speed = speed <span class=\"comment\"># 动物行走或飞行速度</span></span><br><span class=\"line\">  </span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;&#x27;&#x27;Animal(&#123;0.name&#125;,&#123;0._speed&#125;) is printed</span></span><br><span class=\"line\"><span class=\"string\">                name=&#123;0.name&#125;</span></span><br><span class=\"line\"><span class=\"string\">                speed=&#123;0._speed&#125;&#x27;&#x27;&#x27;</span>.<span class=\"built_in\">format</span>(self)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSpeedBehavior</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">       <span class=\"keyword\">pass</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Cat</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\"># 重写方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSpeedBehavior</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;running speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br><span class=\"line\">        </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bird</span>(<span class=\"params\">Animal</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,name,speed,color,genre</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(name,speed)</span><br><span class=\"line\">        self.color = color </span><br><span class=\"line\">        self.genre = genre</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 重写方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getSpeedBehavior</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        print(<span class=\"string\">&#x27;flying speed of %s is %s&#x27;</span> %(self.name, self._speed))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._speed</span><br></pre></td></tr></table></figure>\n<p>manager2.py 模块如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># manager2.py 模块</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> animal2 <span class=\"keyword\">import</span> (Animal,Cat,Bird)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Manager</span>():</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,animal</span>):</span></span><br><span class=\"line\">        self.animal = animal</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">recordTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        self.__t = time.time()</span><br><span class=\"line\">        print(<span class=\"string\">&#x27;feeding time for %s is %.0f&#x27;</span>%(self.animal.name,self.__t))</span><br><span class=\"line\">        self.animal.getSpeedBehavior()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getFeedingTime</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;%0.f&#x27;</span>%(self.__t,)  </span><br></pre></td></tr></table></figure>\n<p><code>recordTime</code>方法非常清爽，不需要任何if逻辑，只需要调用我们定义的<code>Animal</code>类的基方法<code>getSpeedBehavior</code>即可。</p>\n<p>在使用上面所有类时，<code>Manager(jiafeimao)</code>传入<code>Cat</code>类实例时，<code>recordTime</code>方法调用就被自动指向<code>Cat</code>实例的<code>getSpeedBehavior</code>方法；</p>\n<p><code>Manager(haiying)</code>传入<code>Bird</code>类实例时，自动指向<code>Bird</code>实例的<code>getSpeedBehavior</code>方法，这就是多态和它的价值，Manager类的方法不必每次都修改，保证了类的封装性。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    jiafeimao = Cat(<span class=\"string\">&#x27;jiafeimao&#x27;</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;gray&#x27;</span>,<span class=\"string\">&#x27;CatGenre&#x27;</span>)</span><br><span class=\"line\">    haiying = Bird(<span class=\"string\">&#x27;haiying&#x27;</span>,<span class=\"number\">40</span>,<span class=\"string\">&#x27;blue&#x27;</span>,<span class=\"string\">&#x27;BirdGenre&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    Manager(jiafeimao).recordTime()</span><br><span class=\"line\">    print(<span class=\"string\">&#x27;#&#x27;</span>*<span class=\"number\">30</span>)</span><br><span class=\"line\">    Manager(haiying).recordTime()  </span><br></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h2><p>以上就是面向对象编程专题的基础部分，大纲如下：</p>\n<ul>\n<li><p>Python 面向对象编程</p>\n</li>\n<li><p>基础专题</p>\n</li>\n<li><ul>\n<li>1 类定义<ul>\n<li>2 实例</li>\n<li>3 打印实例</li>\n<li>4 属性</li>\n<li>5 private,protected,public</li>\n<li>6 继承</li>\n<li>7 多态</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>总结</p>\n</li>\n</ul>\n"},{"title":"Python模块学习<一>","date":"2021-04-13T09:32:24.000Z","abbrlink":16108,"cover":"img/python.png","_content":"","source":"_posts/python_md/Python模块学习.md","raw":"---\ntitle: Python模块学习<一>\ndate:\ntags:\n  - python\ncategories:\n  - 学习笔记\nabbrlink: 16108\ncover: img/python.png\n---\n","slug":"python_md/Python模块学习","published":1,"updated":"2021-04-09T13:53:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5x0013w9q90ddsbhgi","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":""},{"title":"Python学习之整数比较","date":"2020-12-31T15:59:00.000Z","abbrlink":16003,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n最近学习python，发现整数比较时一个有趣的现象：\n\n```python\na = 256\nb = 256\nprint id(a)\nprint id(b)\nprint(a == b)\nprint(a is b)\nprint(id(a) == id(b))\nprint(id(a) is id(b))\nc = 257\nd = 257\nprint id(c)\nprint id(d)\nprint(c == d)\nprint(c is d)\nprint(id(c) == id(d))\nprint(id(c) is id(d))\n```\n在pycharm中运行的结果是：\n\n```python\n32019104\n32019104\nTrue\nTrue\nTrue\nFalse\n40550424\n40550424\nTrue\nTrue\nTrue\nFalse\n```\n而在Python IDE中运行：\n\n```python\n>>> a = 256\n>>> b = 256\n>>> a == b\nTrue\n>>> a is b\nTrue\n>>> id(a)\n32346576L\n>>> id(b)\n32346576L\n>>> c = 257\n>>> d = 257\n>>> c == d\nTrue\n>>> c is d\nFalse\n>>> id(c)\n39891736L\n>>> id(d)\n39891712L\n```\n为什么同样是Python2.7.14，得出的结果迥然不同呢？\n在Python中一切都是对象，因此整数也是对象。对象之间比较是否相等可以用==，也可以用is，两者的区别主要是：\n\n* is比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象，是否指向同一个内存地址。\n* ==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。\n\n因此，代码段中`a == b`很好理解，因为两个对象的值都是256， 而`a is b`返回True， 说明a和b都是指向同一对象的。但是当值为257时，为什么指向的不是同一个对象呢？\n\n**问题一：256和257，差别在哪里？**\n\n出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256)之间的小对象放在small_ints中，注意左闭右开。但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。\n\n源码位置： `Include/intobject.h | Objects/intobject.c`\n\n**小整数对象池：**\n小整数对象池就是一个**PyIntObject指针数组**\n\n```C\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n \n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif\n \n#if NSMALLNEGINTS + NSMALLPOSINTS > 0\n/* References to small integers are saved in this array\n   so that they can be shared.\n   The integers that are saved are those in the range\n   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).\n*/\n \nstatic PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];\n#endif\n\n```\n其结构如下(注意要以以下的格式插入)：\n{% asset_img int.png This is an example image %}\n\n**问题二：都是257，is结局为啥不一样？**\n\n其实答案就是如此简单：\n对于Python而言，存储好的脚本文件（Script file）和在Console中的交互式（interactive）命令，执行方式不同。对于脚本文件，解释器将其当作整个代码块执行，而对于交互性命令行中的每一条命令，解释器将其当作单独的代码块执行。而Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用（这句话不够严谨，后面会详谈）。所以在给出的例子中，文件执行时（同一个代码块）会把a、b两个变量指向同一个对象；而在命令行执行时，a、b赋值语句分别被当作两个代码块执行，所以会得到两个不同的对象，因而is判断返回False。","source":"_posts/python_md/Python学习之整数比较.md","raw":"---\ntitle: Python学习之整数比较\ndate: '2020/12/31 23:59'\ntags:\n - python\ncategories:\n - 学习笔记\nabbrlink: 16003\ncover: \n---\n\n最近学习python，发现整数比较时一个有趣的现象：\n\n```python\na = 256\nb = 256\nprint id(a)\nprint id(b)\nprint(a == b)\nprint(a is b)\nprint(id(a) == id(b))\nprint(id(a) is id(b))\nc = 257\nd = 257\nprint id(c)\nprint id(d)\nprint(c == d)\nprint(c is d)\nprint(id(c) == id(d))\nprint(id(c) is id(d))\n```\n在pycharm中运行的结果是：\n\n```python\n32019104\n32019104\nTrue\nTrue\nTrue\nFalse\n40550424\n40550424\nTrue\nTrue\nTrue\nFalse\n```\n而在Python IDE中运行：\n\n```python\n>>> a = 256\n>>> b = 256\n>>> a == b\nTrue\n>>> a is b\nTrue\n>>> id(a)\n32346576L\n>>> id(b)\n32346576L\n>>> c = 257\n>>> d = 257\n>>> c == d\nTrue\n>>> c is d\nFalse\n>>> id(c)\n39891736L\n>>> id(d)\n39891712L\n```\n为什么同样是Python2.7.14，得出的结果迥然不同呢？\n在Python中一切都是对象，因此整数也是对象。对象之间比较是否相等可以用==，也可以用is，两者的区别主要是：\n\n* is比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象，是否指向同一个内存地址。\n* ==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。\n\n因此，代码段中`a == b`很好理解，因为两个对象的值都是256， 而`a is b`返回True， 说明a和b都是指向同一对象的。但是当值为257时，为什么指向的不是同一个对象呢？\n\n**问题一：256和257，差别在哪里？**\n\n出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256)之间的小对象放在small_ints中，注意左闭右开。但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。\n\n源码位置： `Include/intobject.h | Objects/intobject.c`\n\n**小整数对象池：**\n小整数对象池就是一个**PyIntObject指针数组**\n\n```C\n#ifndef NSMALLPOSINTS\n#define NSMALLPOSINTS           257\n#endif\n \n#ifndef NSMALLNEGINTS\n#define NSMALLNEGINTS           5\n#endif\n \n#if NSMALLNEGINTS + NSMALLPOSINTS > 0\n/* References to small integers are saved in this array\n   so that they can be shared.\n   The integers that are saved are those in the range\n   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).\n*/\n \nstatic PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];\n#endif\n\n```\n其结构如下(注意要以以下的格式插入)：\n{% asset_img int.png This is an example image %}\n\n**问题二：都是257，is结局为啥不一样？**\n\n其实答案就是如此简单：\n对于Python而言，存储好的脚本文件（Script file）和在Console中的交互式（interactive）命令，执行方式不同。对于脚本文件，解释器将其当作整个代码块执行，而对于交互性命令行中的每一条命令，解释器将其当作单独的代码块执行。而Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用（这句话不够严谨，后面会详谈）。所以在给出的例子中，文件执行时（同一个代码块）会把a、b两个变量指向同一个对象；而在命令行执行时，a、b赋值语句分别被当作两个代码块执行，所以会得到两个不同的对象，因而is判断返回False。","slug":"python_md/Python学习之整数比较","published":1,"updated":"2021-04-08T14:09:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5x0016w9q9g031b257","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><p>最近学习python，发现整数比较时一个有趣的现象：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">256</span></span><br><span class=\"line\">b = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(b)</span><br><span class=\"line\">print(a == b)</span><br><span class=\"line\">print(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(a) == <span class=\"built_in\">id</span>(b))</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(a) <span class=\"keyword\">is</span> <span class=\"built_in\">id</span>(b))</span><br><span class=\"line\">c = <span class=\"number\">257</span></span><br><span class=\"line\">d = <span class=\"number\">257</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(d)</span><br><span class=\"line\">print(c == d)</span><br><span class=\"line\">print(c <span class=\"keyword\">is</span> d)</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(c) == <span class=\"built_in\">id</span>(d))</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(c) <span class=\"keyword\">is</span> <span class=\"built_in\">id</span>(d))</span><br></pre></td></tr></table></figure>\n<p>在pycharm中运行的结果是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">32019104</span></span><br><span class=\"line\"><span class=\"number\">32019104</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"number\">40550424</span></span><br><span class=\"line\"><span class=\"number\">40550424</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>而在Python IDE中运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a == b</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(a)</span><br><span class=\"line\"><span class=\"number\">32346576L</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(b)</span><br><span class=\"line\"><span class=\"number\">32346576L</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = <span class=\"number\">257</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = <span class=\"number\">257</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c == d</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c <span class=\"keyword\">is</span> d</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(c)</span><br><span class=\"line\"><span class=\"number\">39891736L</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(d)</span><br><span class=\"line\"><span class=\"number\">39891712L</span></span><br></pre></td></tr></table></figure>\n<p>为什么同样是Python2.7.14，得出的结果迥然不同呢？<br>在Python中一切都是对象，因此整数也是对象。对象之间比较是否相等可以用==，也可以用is，两者的区别主要是：</p>\n<ul>\n<li>is比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象，是否指向同一个内存地址。</li>\n<li>==比较的是两个对象的内容是否相等，默认会调用对象的<strong>eq</strong>()方法。</li>\n</ul>\n<p>因此，代码段中<code>a == b</code>很好理解，因为两个对象的值都是256， 而<code>a is b</code>返回True， 说明a和b都是指向同一对象的。但是当值为257时，为什么指向的不是同一个对象呢？</p>\n<p><strong>问题一：256和257，差别在哪里？</strong></p>\n<p>出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256)之间的小对象放在small_ints中，注意左闭右开。但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。</p>\n<p>源码位置： <code>Include/intobject.h | Objects/intobject.c</code></p>\n<p><strong>小整数对象池：</strong><br>小整数对象池就是一个<strong>PyIntObject指针数组</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NSMALLPOSINTS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NSMALLPOSINTS           257</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NSMALLNEGINTS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NSMALLNEGINTS           5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">/* References to small integers are saved in this array</span></span><br><span class=\"line\"><span class=\"comment\">   so that they can be shared.</span></span><br><span class=\"line\"><span class=\"comment\">   The integers that are saved are those in the range</span></span><br><span class=\"line\"><span class=\"comment\">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">static</span> PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>其结构如下(注意要以以下的格式插入)：</p>\n<img src=\"/Blog/posts/16003/int.png\" class=\"\" title=\"This is an example image\">\n\n<p><strong>问题二：都是257，is结局为啥不一样？</strong></p>\n<p>其实答案就是如此简单：<br>对于Python而言，存储好的脚本文件（Script file）和在Console中的交互式（interactive）命令，执行方式不同。对于脚本文件，解释器将其当作整个代码块执行，而对于交互性命令行中的每一条命令，解释器将其当作单独的代码块执行。而Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用（这句话不够严谨，后面会详谈）。所以在给出的例子中，文件执行时（同一个代码块）会把a、b两个变量指向同一个对象；而在命令行执行时，a、b赋值语句分别被当作两个代码块执行，所以会得到两个不同的对象，因而is判断返回False。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>最近学习python，发现整数比较时一个有趣的现象：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">256</span></span><br><span class=\"line\">b = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(a)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(b)</span><br><span class=\"line\">print(a == b)</span><br><span class=\"line\">print(a <span class=\"keyword\">is</span> b)</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(a) == <span class=\"built_in\">id</span>(b))</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(a) <span class=\"keyword\">is</span> <span class=\"built_in\">id</span>(b))</span><br><span class=\"line\">c = <span class=\"number\">257</span></span><br><span class=\"line\">d = <span class=\"number\">257</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(c)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">id</span>(d)</span><br><span class=\"line\">print(c == d)</span><br><span class=\"line\">print(c <span class=\"keyword\">is</span> d)</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(c) == <span class=\"built_in\">id</span>(d))</span><br><span class=\"line\">print(<span class=\"built_in\">id</span>(c) <span class=\"keyword\">is</span> <span class=\"built_in\">id</span>(d))</span><br></pre></td></tr></table></figure>\n<p>在pycharm中运行的结果是：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">32019104</span></span><br><span class=\"line\"><span class=\"number\">32019104</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"number\">40550424</span></span><br><span class=\"line\"><span class=\"number\">40550424</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"literal\">False</span></span><br></pre></td></tr></table></figure>\n<p>而在Python IDE中运行：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>b = <span class=\"number\">256</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a == b</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>a <span class=\"keyword\">is</span> b</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(a)</span><br><span class=\"line\"><span class=\"number\">32346576L</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(b)</span><br><span class=\"line\"><span class=\"number\">32346576L</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c = <span class=\"number\">257</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d = <span class=\"number\">257</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c == d</span><br><span class=\"line\"><span class=\"literal\">True</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>c <span class=\"keyword\">is</span> d</span><br><span class=\"line\"><span class=\"literal\">False</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(c)</span><br><span class=\"line\"><span class=\"number\">39891736L</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">id</span>(d)</span><br><span class=\"line\"><span class=\"number\">39891712L</span></span><br></pre></td></tr></table></figure>\n<p>为什么同样是Python2.7.14，得出的结果迥然不同呢？<br>在Python中一切都是对象，因此整数也是对象。对象之间比较是否相等可以用==，也可以用is，两者的区别主要是：</p>\n<ul>\n<li>is比较的是两个对象的id值是否相等，也就是比较俩对象是否为同一个实例对象，是否指向同一个内存地址。</li>\n<li>==比较的是两个对象的内容是否相等，默认会调用对象的<strong>eq</strong>()方法。</li>\n</ul>\n<p>因此，代码段中<code>a == b</code>很好理解，因为两个对象的值都是256， 而<code>a is b</code>返回True， 说明a和b都是指向同一对象的。但是当值为257时，为什么指向的不是同一个对象呢？</p>\n<p><strong>问题一：256和257，差别在哪里？</strong></p>\n<p>出于对性能的考虑，Python内部做了很多的优化工作，对于整数对象，Python把一些频繁使用的整数对象缓存起来，保存到一个叫small_ints的链表中，在Python的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python把这些可能频繁使用的整数对象规定在范围[-5, 256)之间的小对象放在small_ints中，注意左闭右开。但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为257不再小整数范围内，因此尽管a和b的值是一样，但是他们在Python内部却是以两个独立的对象存在的，各自为政，互不干涉。</p>\n<p>源码位置： <code>Include/intobject.h | Objects/intobject.c</code></p>\n<p><strong>小整数对象池：</strong><br>小整数对象池就是一个<strong>PyIntObject指针数组</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NSMALLPOSINTS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NSMALLPOSINTS           257</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> NSMALLNEGINTS</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NSMALLNEGINTS           5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> NSMALLNEGINTS + NSMALLPOSINTS &gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">/* References to small integers are saved in this array</span></span><br><span class=\"line\"><span class=\"comment\">   so that they can be shared.</span></span><br><span class=\"line\"><span class=\"comment\">   The integers that are saved are those in the range</span></span><br><span class=\"line\"><span class=\"comment\">   -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive).</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">static</span> PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>其结构如下(注意要以以下的格式插入)：</p>\n<img src=\"/Blog/posts/16003/int.png\" class=\"\" title=\"This is an example image\">\n\n<p><strong>问题二：都是257，is结局为啥不一样？</strong></p>\n<p>其实答案就是如此简单：<br>对于Python而言，存储好的脚本文件（Script file）和在Console中的交互式（interactive）命令，执行方式不同。对于脚本文件，解释器将其当作整个代码块执行，而对于交互性命令行中的每一条命令，解释器将其当作单独的代码块执行。而Python在执行同一个代码块的初始化对象的命令时，会检查是否其值是否已经存在，如果存在，会将其重用（这句话不够严谨，后面会详谈）。所以在给出的例子中，文件执行时（同一个代码块）会把a、b两个变量指向同一个对象；而在命令行执行时，a、b赋值语句分别被当作两个代码块执行，所以会得到两个不同的对象，因而is判断返回False。</p>\n"},{"title":"Test with Coverage","date":"2020-12-31T15:59:00.000Z","abbrlink":16005,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n前几天，听了公司某位大佬关于编程心得的体会，其中讲到了“测试驱动开发”，感觉自己的测试技能薄弱，因此，写下这篇文章，希望对测试能有个入门。这段时间，笔者也体会到了测试的价值，一句话，学会测试，能够让你的开发更加高效。\n\n本文将介绍以下两个方面的内容：\n\n- Test with Coverage\n- Mock\n\n### Test with Coverage\n\n`测试覆盖率`通常被用来衡量测试的充分性和完整性。从广义的角度讲，主要分为两大类：面向项目的`需求覆盖率`和更偏向技术的`代码覆盖率`。对于开发人员来说，我们更注重代码覆盖率。\n\n`代码覆盖率`指的是至少执行了一次的条目数占整个条目数的百分比。如果条目数是语句，对应的就是`代码行覆盖率`；如果条目数是函数，对应的就是`函数覆盖率`；如果条目数是路径，对应的就是`路径覆盖率`，等等。统计代码覆盖率的根本目的是找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的废弃代码。通常我们希望代码覆盖率越高越好，代码覆盖率越高越能说明你的测试用例设计是充分且完备的，但测试的成本会随着代码覆盖率的提高而增加。\n\n在Python中，`coverage`模块帮助我们实现了`代码行覆盖率`，我们可以方便地使用它来完整测试的代码行覆盖率。\n\n我们通过一个例子来介绍`coverage`模块的使用。\n\n首先，我们有脚本`func_add.py`，实现了add函数，代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n\ndef add(a, b):\n    if isinstance(a, str) and isinstance(b, str):\n        return a + '+' + b\n    elif isinstance(a, list) and isinstance(b, list):\n        return a + b\n    elif isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return a + b\n    else:\n        return None\n```\n\n在add函数中，分四种情况实现了加法，分别是字符串，列表，属性值，以及其它情况。\n\n接着，我们用unittest模块来进行单元测试，代码脚本（`test_func_add.py`）如下：\n\n```python\nimport unittest\nfrom func_add import add\n\n\nclass Test_Add(unittest.TestCase):\n\n    def setUp(self):\n        pass\n\n    def test_add_case1(self):\n        a = \"Hello\"\n        b = \"World\"\n        res = add(a, b)\n        print(res)\n        self.assertEqual(res, \"Hello+World\")\n\n    def test_add_case2(self):\n        a = 1\n        b = 2\n        res = add(a, b)\n        print(res)\n        self.assertEqual(res, 3)\n\n    def test_add_case3(self):\n        a = [1, 2]\n        b = [3]\n        res = add(a, b)\n        print(res)\n        self.assertEqual(res, [1, 2, 3])\n\n    def test_add_case4(self):\n        a = 2\n        b = \"3\"\n        res = add(a, b)\n        print(None)\n        self.assertEqual(res, None)\n\n\nif __name__ == '__main__':\n\n    # 部分用例测试\n    # 构造一个容器用来存放我们的测试用例\n    suite = unittest.TestSuite()\n    # 添加类中的测试用例\n    suite.addTest(Test_Add('test_add_case1'))\n    suite.addTest(Test_Add('test_add_case2'))\n    # suite.addTest(Test_Add('test_add_case3'))\n    # suite.addTest(Test_Add('test_add_case4'))\n    run = unittest.TextTestRunner()\n    run.run(suite)\n```\n\n在这个测试中，我们只测试了前两个用例，也就是对字符串和数值型的加法进行测试。\n\n在命令行中输入`coverage run test_func_add.py`命令运行该测试脚本，输出结果如下：\n\n```python\nHello+World\n.3\n.\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n```\n\n再输入命令`coverage html`就能生成代码行覆盖率的报告，会生成`htmlcov`文件夹，打开其中的`index.html`文件，就能看到本次执行的覆盖率情况，如下图：\n\n![测试覆盖率结果总览](https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0ry0AmyXalgcxSN4CgQAkKp3KpGIzqNcCqgg5YUh3q7J5kncvtjU2Gww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)测试覆盖率结果总览\n\n\n我们点击`func_add.py`查看add函数测试的情况，如下图：\n\n\n\n![func_add.py脚本的测试覆盖率情况](https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0rL6U6v3cFiaibKMMxklQRjBlgoMuwN2o5y06ibd98PdjTTB9EyWG7Cuueg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)func_add.py脚本的测试覆盖率情况\n\n\n可以看到，单元测试脚本test_func_add.py的前两个测试用例只覆盖到了add函数中左边绿色的部分，而没有测试到红色的部分，代码行覆盖率为75%。\n\n\n\n因此，还有两种情况没有覆盖到，说明我们的单元测试中的测试用例还不够充分。\n\n\n\n在`test_func_add.py`中，我们把main函数中的注释去掉，把后两个测试用例也添加进来，这时候我们再运行上面的`coverage`模块的命令，重新生成`htmlcov`后，func_add.py的代码行覆盖率如下图：\n\n![增加测试用例后，func_add.py脚本的测试覆盖率情况](https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0r6ZRjBjVzXEkBp3aqYSumPXIjibHJKgP5dMLwKiccjfKia6kT4Hew15SyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)增加测试用例后，func_add.py脚本的测试覆盖率情况\n\n\n可以看到，增加测试用例后，我们调用的add函数代码行覆盖率为100%，所有的代码都覆盖到了。\n\n### Mock\n\nMock这个词在英语中有模拟的这个意思，因此我们可以猜测出这个库的主要功能是模拟一些东西。准确的说，Mock是Python中一个用于支持单元测试的库，它的主要功能是使用mock对象替代掉指定的Python对象，以达到模拟对象的行为。在Python3中，mock是辅助单元测试的一个模块。它允许您用模拟对象替换您的系统的部分，并对它们已使用的方式进行断言。\n\n在实际生产中的项目是非常复杂的，对其进行单元测试的时候，会遇到以下问题：\n\n- 接口的依赖\n- 外部接口调用\n- 测试环境非常复杂\n\n单元测试应该只针对当前单元进行测试, 所有的内部或外部的依赖应该是稳定的, 已经在别处进行测试过的。使用mock 就可以对外部依赖组件实现进行模拟并且替换掉, 从而使得单元测试将焦点只放在当前的单元功能。\n\n我们通过一个简单的例子来说明mock模块的使用。\n\n首先，我们有脚本`mock_multipy.py`，主要实现的功能是`Operator`类中的`multipy`函数，在这里我们可以假设该函数并没有实现好，只是存在这样一个函数，代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n# mock_multipy.py\n\nclass Operator():\n\n    def multipy(self, a, b):\n        pass\n```\n\n尽管我们没有实现`multipy`函数，但是我们还是想对这个函数的功能进行测试，这时候我们可以借助mock模块中的Mock类来实现。测试的脚本（`mock_example.py`）代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom unittest import mock\nimport unittest\n\nfrom mock_multipy import Operator\n\n# test Operator class\nclass TestCount(unittest.TestCase):\n\n    def test_add(self):\n        op = Operator()\n        # 利用Mock类，我们假设返回的结果为15\n        op.multipy = mock.Mock(return_value=15)\n        # 调用multipy函数，输入参数为4,5,实际并未调用\n        result = op.multipy(4, 5)\n        # 声明返回结果是否为15\n        self.assertEqual(result, 15)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n让我们对上述的代码做一些说明。\n\n```python\nop.multipy = mock.Mock(return_value=15)\n```\n\n通过Mock类来模拟调用Operator类中的multipy()函数，return_value 定义了multipy()方法的返回值。\n\n```python\nresult = op.multipy(4, 5)\n```\n\nresult值调用multipy()函数，输入参数为4,5，但实际并未调用，最后通过assertEqual()方法断言，返回的结果是否是预期的结果为15。输出的结果如下：\n\n```python\nRan 1 test in 0.002s\n\nOK\n```\n\n通过Mock类，我们即使在multipy函数并未实现的情况下，仍然能够通过想象函数执行的结果来进行测试，这样如果有后续的函数依赖multipy函数，也并不影响后续代码的测试。\n\n利用Mock模块中的patch函数，我们可以将上述测试的脚本代码简化如下：\n\n```python\n# -*- coding: utf-8 -*-\nimport unittest\n\nfrom unittest.mock import patch\nfrom mock_multipy import Operator\n\n# test Operator class\nclass TestCount(unittest.TestCase):\n\n    @patch(\"mock_multipy.Operator.multipy\")\n    def test_case1(self, tmp):\n        tmp.return_value = 15\n        result = Operator().multipy(4, 5)\n        self.assertEqual(15, result)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\npatch()装饰器可以很容易地模拟类或对象在模块测试。在测试过程中，您指定的对象将被替换为一个模拟（或其他对象），并在测试结束时还原。\n\n那如果我们后面又实现了multipy函数，是否仍然能够测试呢？\n\n修改`mock_multipy.py`脚本，代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n# mock_multipy.py\n\nclass Operator():\n\n    def multipy(self, a, b):\n        return a * b\n```\n\n这时候，我们再运行`mock_example.py`脚本，测试仍然通过，这是因为multipy函数返回的结果仍然是我们mock后返回的值，而并未调用真正的Operator类中的multipy函数。\n\n我们修改`mock_example.py`脚本如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom unittest import mock\nimport unittest\n\nfrom mock_multipy import Operator\n\n# test Operator class\nclass TestCount(unittest.TestCase):\n\n    def test_add(self):\n        op = Operator()\n        # 利用Mock类，添加side_effect参数\n        op.multipy = mock.Mock(return_value=15, side_effect=op.multipy)\n        # 调用multipy函数，输入参数为4,5,实际已调用\n        result = op.multipy(4, 5)\n        # 声明返回结果是否为15\n        self.assertEqual(result, 15)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n`side_effect`参数和`return_value`参数是相反的。它给mock分配了可替换的结果，覆盖了return_value。简单的说，一个模拟工厂调用将返回side_effect值，而不是return_value。所以，设置`side_effect`参数为Operator类中的multipy函数，那么return_value的作用失效。\n\n运行修改后的测试脚本，测试结果如下：\n\n```python\nRan 1 test in 0.004s\n\nFAILED (failures=1)\n\n\n15 != 20\n\nExpected :20\nActual   :15\n```\n\n可以发现，multipy函数返回的值为20，不等于我们期望的值15，这是side_effect函数的作用结果使然，返回的结果调用了Operator类中的multipy函数，所以返回值为20。\n\n在`self.assertEqual(result, 15)`中将15改成20，运行测试结果如下：\n\n```python\nRan 1 test in 0.002s\n\nOK\n```\n\n本次分享到此结束，感谢大家的阅读~","source":"_posts/python_md/Test with Coverage.md","raw":"---\ntitle: Test with Coverage\ndate: '2020/12/31 23:59'\ntags:\n  - python\n  - coverage\ncategories:\n  - 学习笔记\nabbrlink: 16005\ncover: \n---\n\n前几天，听了公司某位大佬关于编程心得的体会，其中讲到了“测试驱动开发”，感觉自己的测试技能薄弱，因此，写下这篇文章，希望对测试能有个入门。这段时间，笔者也体会到了测试的价值，一句话，学会测试，能够让你的开发更加高效。\n\n本文将介绍以下两个方面的内容：\n\n- Test with Coverage\n- Mock\n\n### Test with Coverage\n\n`测试覆盖率`通常被用来衡量测试的充分性和完整性。从广义的角度讲，主要分为两大类：面向项目的`需求覆盖率`和更偏向技术的`代码覆盖率`。对于开发人员来说，我们更注重代码覆盖率。\n\n`代码覆盖率`指的是至少执行了一次的条目数占整个条目数的百分比。如果条目数是语句，对应的就是`代码行覆盖率`；如果条目数是函数，对应的就是`函数覆盖率`；如果条目数是路径，对应的就是`路径覆盖率`，等等。统计代码覆盖率的根本目的是找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的废弃代码。通常我们希望代码覆盖率越高越好，代码覆盖率越高越能说明你的测试用例设计是充分且完备的，但测试的成本会随着代码覆盖率的提高而增加。\n\n在Python中，`coverage`模块帮助我们实现了`代码行覆盖率`，我们可以方便地使用它来完整测试的代码行覆盖率。\n\n我们通过一个例子来介绍`coverage`模块的使用。\n\n首先，我们有脚本`func_add.py`，实现了add函数，代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n\ndef add(a, b):\n    if isinstance(a, str) and isinstance(b, str):\n        return a + '+' + b\n    elif isinstance(a, list) and isinstance(b, list):\n        return a + b\n    elif isinstance(a, (int, float)) and isinstance(b, (int, float)):\n        return a + b\n    else:\n        return None\n```\n\n在add函数中，分四种情况实现了加法，分别是字符串，列表，属性值，以及其它情况。\n\n接着，我们用unittest模块来进行单元测试，代码脚本（`test_func_add.py`）如下：\n\n```python\nimport unittest\nfrom func_add import add\n\n\nclass Test_Add(unittest.TestCase):\n\n    def setUp(self):\n        pass\n\n    def test_add_case1(self):\n        a = \"Hello\"\n        b = \"World\"\n        res = add(a, b)\n        print(res)\n        self.assertEqual(res, \"Hello+World\")\n\n    def test_add_case2(self):\n        a = 1\n        b = 2\n        res = add(a, b)\n        print(res)\n        self.assertEqual(res, 3)\n\n    def test_add_case3(self):\n        a = [1, 2]\n        b = [3]\n        res = add(a, b)\n        print(res)\n        self.assertEqual(res, [1, 2, 3])\n\n    def test_add_case4(self):\n        a = 2\n        b = \"3\"\n        res = add(a, b)\n        print(None)\n        self.assertEqual(res, None)\n\n\nif __name__ == '__main__':\n\n    # 部分用例测试\n    # 构造一个容器用来存放我们的测试用例\n    suite = unittest.TestSuite()\n    # 添加类中的测试用例\n    suite.addTest(Test_Add('test_add_case1'))\n    suite.addTest(Test_Add('test_add_case2'))\n    # suite.addTest(Test_Add('test_add_case3'))\n    # suite.addTest(Test_Add('test_add_case4'))\n    run = unittest.TextTestRunner()\n    run.run(suite)\n```\n\n在这个测试中，我们只测试了前两个用例，也就是对字符串和数值型的加法进行测试。\n\n在命令行中输入`coverage run test_func_add.py`命令运行该测试脚本，输出结果如下：\n\n```python\nHello+World\n.3\n.\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n```\n\n再输入命令`coverage html`就能生成代码行覆盖率的报告，会生成`htmlcov`文件夹，打开其中的`index.html`文件，就能看到本次执行的覆盖率情况，如下图：\n\n![测试覆盖率结果总览](https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0ry0AmyXalgcxSN4CgQAkKp3KpGIzqNcCqgg5YUh3q7J5kncvtjU2Gww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)测试覆盖率结果总览\n\n\n我们点击`func_add.py`查看add函数测试的情况，如下图：\n\n\n\n![func_add.py脚本的测试覆盖率情况](https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0rL6U6v3cFiaibKMMxklQRjBlgoMuwN2o5y06ibd98PdjTTB9EyWG7Cuueg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)func_add.py脚本的测试覆盖率情况\n\n\n可以看到，单元测试脚本test_func_add.py的前两个测试用例只覆盖到了add函数中左边绿色的部分，而没有测试到红色的部分，代码行覆盖率为75%。\n\n\n\n因此，还有两种情况没有覆盖到，说明我们的单元测试中的测试用例还不够充分。\n\n\n\n在`test_func_add.py`中，我们把main函数中的注释去掉，把后两个测试用例也添加进来，这时候我们再运行上面的`coverage`模块的命令，重新生成`htmlcov`后，func_add.py的代码行覆盖率如下图：\n\n![增加测试用例后，func_add.py脚本的测试覆盖率情况](https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0r6ZRjBjVzXEkBp3aqYSumPXIjibHJKgP5dMLwKiccjfKia6kT4Hew15SyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)增加测试用例后，func_add.py脚本的测试覆盖率情况\n\n\n可以看到，增加测试用例后，我们调用的add函数代码行覆盖率为100%，所有的代码都覆盖到了。\n\n### Mock\n\nMock这个词在英语中有模拟的这个意思，因此我们可以猜测出这个库的主要功能是模拟一些东西。准确的说，Mock是Python中一个用于支持单元测试的库，它的主要功能是使用mock对象替代掉指定的Python对象，以达到模拟对象的行为。在Python3中，mock是辅助单元测试的一个模块。它允许您用模拟对象替换您的系统的部分，并对它们已使用的方式进行断言。\n\n在实际生产中的项目是非常复杂的，对其进行单元测试的时候，会遇到以下问题：\n\n- 接口的依赖\n- 外部接口调用\n- 测试环境非常复杂\n\n单元测试应该只针对当前单元进行测试, 所有的内部或外部的依赖应该是稳定的, 已经在别处进行测试过的。使用mock 就可以对外部依赖组件实现进行模拟并且替换掉, 从而使得单元测试将焦点只放在当前的单元功能。\n\n我们通过一个简单的例子来说明mock模块的使用。\n\n首先，我们有脚本`mock_multipy.py`，主要实现的功能是`Operator`类中的`multipy`函数，在这里我们可以假设该函数并没有实现好，只是存在这样一个函数，代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n# mock_multipy.py\n\nclass Operator():\n\n    def multipy(self, a, b):\n        pass\n```\n\n尽管我们没有实现`multipy`函数，但是我们还是想对这个函数的功能进行测试，这时候我们可以借助mock模块中的Mock类来实现。测试的脚本（`mock_example.py`）代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom unittest import mock\nimport unittest\n\nfrom mock_multipy import Operator\n\n# test Operator class\nclass TestCount(unittest.TestCase):\n\n    def test_add(self):\n        op = Operator()\n        # 利用Mock类，我们假设返回的结果为15\n        op.multipy = mock.Mock(return_value=15)\n        # 调用multipy函数，输入参数为4,5,实际并未调用\n        result = op.multipy(4, 5)\n        # 声明返回结果是否为15\n        self.assertEqual(result, 15)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n让我们对上述的代码做一些说明。\n\n```python\nop.multipy = mock.Mock(return_value=15)\n```\n\n通过Mock类来模拟调用Operator类中的multipy()函数，return_value 定义了multipy()方法的返回值。\n\n```python\nresult = op.multipy(4, 5)\n```\n\nresult值调用multipy()函数，输入参数为4,5，但实际并未调用，最后通过assertEqual()方法断言，返回的结果是否是预期的结果为15。输出的结果如下：\n\n```python\nRan 1 test in 0.002s\n\nOK\n```\n\n通过Mock类，我们即使在multipy函数并未实现的情况下，仍然能够通过想象函数执行的结果来进行测试，这样如果有后续的函数依赖multipy函数，也并不影响后续代码的测试。\n\n利用Mock模块中的patch函数，我们可以将上述测试的脚本代码简化如下：\n\n```python\n# -*- coding: utf-8 -*-\nimport unittest\n\nfrom unittest.mock import patch\nfrom mock_multipy import Operator\n\n# test Operator class\nclass TestCount(unittest.TestCase):\n\n    @patch(\"mock_multipy.Operator.multipy\")\n    def test_case1(self, tmp):\n        tmp.return_value = 15\n        result = Operator().multipy(4, 5)\n        self.assertEqual(15, result)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\npatch()装饰器可以很容易地模拟类或对象在模块测试。在测试过程中，您指定的对象将被替换为一个模拟（或其他对象），并在测试结束时还原。\n\n那如果我们后面又实现了multipy函数，是否仍然能够测试呢？\n\n修改`mock_multipy.py`脚本，代码如下：\n\n```python\n# -*- coding: utf-8 -*-\n# mock_multipy.py\n\nclass Operator():\n\n    def multipy(self, a, b):\n        return a * b\n```\n\n这时候，我们再运行`mock_example.py`脚本，测试仍然通过，这是因为multipy函数返回的结果仍然是我们mock后返回的值，而并未调用真正的Operator类中的multipy函数。\n\n我们修改`mock_example.py`脚本如下：\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom unittest import mock\nimport unittest\n\nfrom mock_multipy import Operator\n\n# test Operator class\nclass TestCount(unittest.TestCase):\n\n    def test_add(self):\n        op = Operator()\n        # 利用Mock类，添加side_effect参数\n        op.multipy = mock.Mock(return_value=15, side_effect=op.multipy)\n        # 调用multipy函数，输入参数为4,5,实际已调用\n        result = op.multipy(4, 5)\n        # 声明返回结果是否为15\n        self.assertEqual(result, 15)\n\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\n`side_effect`参数和`return_value`参数是相反的。它给mock分配了可替换的结果，覆盖了return_value。简单的说，一个模拟工厂调用将返回side_effect值，而不是return_value。所以，设置`side_effect`参数为Operator类中的multipy函数，那么return_value的作用失效。\n\n运行修改后的测试脚本，测试结果如下：\n\n```python\nRan 1 test in 0.004s\n\nFAILED (failures=1)\n\n\n15 != 20\n\nExpected :20\nActual   :15\n```\n\n可以发现，multipy函数返回的值为20，不等于我们期望的值15，这是side_effect函数的作用结果使然，返回的结果调用了Operator类中的multipy函数，所以返回值为20。\n\n在`self.assertEqual(result, 15)`中将15改成20，运行测试结果如下：\n\n```python\nRan 1 test in 0.002s\n\nOK\n```\n\n本次分享到此结束，感谢大家的阅读~","slug":"python_md/Test with Coverage","published":1,"updated":"2021-04-09T13:01:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5z0019w9q905yz2pnd","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><p>前几天，听了公司某位大佬关于编程心得的体会，其中讲到了“测试驱动开发”，感觉自己的测试技能薄弱，因此，写下这篇文章，希望对测试能有个入门。这段时间，笔者也体会到了测试的价值，一句话，学会测试，能够让你的开发更加高效。</p>\n<p>本文将介绍以下两个方面的内容：</p>\n<ul>\n<li>Test with Coverage</li>\n<li>Mock</li>\n</ul>\n<h3 id=\"Test-with-Coverage\"><a href=\"#Test-with-Coverage\" class=\"headerlink\" title=\"Test with Coverage\"></a>Test with Coverage</h3><p><code>测试覆盖率</code>通常被用来衡量测试的充分性和完整性。从广义的角度讲，主要分为两大类：面向项目的<code>需求覆盖率</code>和更偏向技术的<code>代码覆盖率</code>。对于开发人员来说，我们更注重代码覆盖率。</p>\n<p><code>代码覆盖率</code>指的是至少执行了一次的条目数占整个条目数的百分比。如果条目数是语句，对应的就是<code>代码行覆盖率</code>；如果条目数是函数，对应的就是<code>函数覆盖率</code>；如果条目数是路径，对应的就是<code>路径覆盖率</code>，等等。统计代码覆盖率的根本目的是找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的废弃代码。通常我们希望代码覆盖率越高越好，代码覆盖率越高越能说明你的测试用例设计是充分且完备的，但测试的成本会随着代码覆盖率的提高而增加。</p>\n<p>在Python中，<code>coverage</code>模块帮助我们实现了<code>代码行覆盖率</code>，我们可以方便地使用它来完整测试的代码行覆盖率。</p>\n<p>我们通过一个例子来介绍<code>coverage</code>模块的使用。</p>\n<p>首先，我们有脚本<code>func_add.py</code>，实现了add函数，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(a, <span class=\"built_in\">str</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">isinstance</span>(b, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + <span class=\"string\">&#x27;+&#x27;</span> + b</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(a, <span class=\"built_in\">list</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">isinstance</span>(b, <span class=\"built_in\">list</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(a, (<span class=\"built_in\">int</span>, <span class=\"built_in\">float</span>)) <span class=\"keyword\">and</span> <span class=\"built_in\">isinstance</span>(b, (<span class=\"built_in\">int</span>, <span class=\"built_in\">float</span>)):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>在add函数中，分四种情况实现了加法，分别是字符串，列表，属性值，以及其它情况。</p>\n<p>接着，我们用unittest模块来进行单元测试，代码脚本（<code>test_func_add.py</code>）如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> func_add <span class=\"keyword\">import</span> add</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test_Add</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case1</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">        b = <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(res)</span><br><span class=\"line\">        self.assertEqual(res, <span class=\"string\">&quot;Hello+World&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case2</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = <span class=\"number\">1</span></span><br><span class=\"line\">        b = <span class=\"number\">2</span></span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(res)</span><br><span class=\"line\">        self.assertEqual(res, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case3</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">        b = [<span class=\"number\">3</span>]</span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(res)</span><br><span class=\"line\">        self.assertEqual(res, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case4</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = <span class=\"number\">2</span></span><br><span class=\"line\">        b = <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(<span class=\"literal\">None</span>)</span><br><span class=\"line\">        self.assertEqual(res, <span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 部分用例测试</span></span><br><span class=\"line\">    <span class=\"comment\"># 构造一个容器用来存放我们的测试用例</span></span><br><span class=\"line\">    suite = unittest.TestSuite()</span><br><span class=\"line\">    <span class=\"comment\"># 添加类中的测试用例</span></span><br><span class=\"line\">    suite.addTest(Test_Add(<span class=\"string\">&#x27;test_add_case1&#x27;</span>))</span><br><span class=\"line\">    suite.addTest(Test_Add(<span class=\"string\">&#x27;test_add_case2&#x27;</span>))</span><br><span class=\"line\">    <span class=\"comment\"># suite.addTest(Test_Add(&#x27;test_add_case3&#x27;))</span></span><br><span class=\"line\">    <span class=\"comment\"># suite.addTest(Test_Add(&#x27;test_add_case4&#x27;))</span></span><br><span class=\"line\">    run = unittest.TextTestRunner()</span><br><span class=\"line\">    run.run(suite)</span><br></pre></td></tr></table></figure>\n<p>在这个测试中，我们只测试了前两个用例，也就是对字符串和数值型的加法进行测试。</p>\n<p>在命令行中输入<code>coverage run test_func_add.py</code>命令运行该测试脚本，输出结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello+World</span><br><span class=\"line\"><span class=\"number\">.3</span></span><br><span class=\"line\">.</span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran <span class=\"number\">2</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.000</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>再输入命令<code>coverage html</code>就能生成代码行覆盖率的报告，会生成<code>htmlcov</code>文件夹，打开其中的<code>index.html</code>文件，就能看到本次执行的覆盖率情况，如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0ry0AmyXalgcxSN4CgQAkKp3KpGIzqNcCqgg5YUh3q7J5kncvtjU2Gww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"测试覆盖率结果总览\">测试覆盖率结果总览</p>\n<p>我们点击<code>func_add.py</code>查看add函数测试的情况，如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0rL6U6v3cFiaibKMMxklQRjBlgoMuwN2o5y06ibd98PdjTTB9EyWG7Cuueg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"func_add.py脚本的测试覆盖率情况\">func_add.py脚本的测试覆盖率情况</p>\n<p>可以看到，单元测试脚本test_func_add.py的前两个测试用例只覆盖到了add函数中左边绿色的部分，而没有测试到红色的部分，代码行覆盖率为75%。</p>\n<p>因此，还有两种情况没有覆盖到，说明我们的单元测试中的测试用例还不够充分。</p>\n<p>在<code>test_func_add.py</code>中，我们把main函数中的注释去掉，把后两个测试用例也添加进来，这时候我们再运行上面的<code>coverage</code>模块的命令，重新生成<code>htmlcov</code>后，func_add.py的代码行覆盖率如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0r6ZRjBjVzXEkBp3aqYSumPXIjibHJKgP5dMLwKiccjfKia6kT4Hew15SyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"增加测试用例后，func_add.py脚本的测试覆盖率情况\">增加测试用例后，func_add.py脚本的测试覆盖率情况</p>\n<p>可以看到，增加测试用例后，我们调用的add函数代码行覆盖率为100%，所有的代码都覆盖到了。</p>\n<h3 id=\"Mock\"><a href=\"#Mock\" class=\"headerlink\" title=\"Mock\"></a>Mock</h3><p>Mock这个词在英语中有模拟的这个意思，因此我们可以猜测出这个库的主要功能是模拟一些东西。准确的说，Mock是Python中一个用于支持单元测试的库，它的主要功能是使用mock对象替代掉指定的Python对象，以达到模拟对象的行为。在Python3中，mock是辅助单元测试的一个模块。它允许您用模拟对象替换您的系统的部分，并对它们已使用的方式进行断言。</p>\n<p>在实际生产中的项目是非常复杂的，对其进行单元测试的时候，会遇到以下问题：</p>\n<ul>\n<li>接口的依赖</li>\n<li>外部接口调用</li>\n<li>测试环境非常复杂</li>\n</ul>\n<p>单元测试应该只针对当前单元进行测试, 所有的内部或外部的依赖应该是稳定的, 已经在别处进行测试过的。使用mock 就可以对外部依赖组件实现进行模拟并且替换掉, 从而使得单元测试将焦点只放在当前的单元功能。</p>\n<p>我们通过一个简单的例子来说明mock模块的使用。</p>\n<p>首先，我们有脚本<code>mock_multipy.py</code>，主要实现的功能是<code>Operator</code>类中的<code>multipy</code>函数，在这里我们可以假设该函数并没有实现好，只是存在这样一个函数，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># mock_multipy.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Operator</span>():</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipy</span>(<span class=\"params\">self, a, b</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>尽管我们没有实现<code>multipy</code>函数，但是我们还是想对这个函数的功能进行测试，这时候我们可以借助mock模块中的Mock类来实现。测试的脚本（<code>mock_example.py</code>）代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> mock_multipy <span class=\"keyword\">import</span> Operator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test Operator class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCount</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        op = Operator()</span><br><span class=\"line\">        <span class=\"comment\"># 利用Mock类，我们假设返回的结果为15</span></span><br><span class=\"line\">        op.multipy = mock.Mock(return_value=<span class=\"number\">15</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 调用multipy函数，输入参数为4,5,实际并未调用</span></span><br><span class=\"line\">        result = op.multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 声明返回结果是否为15</span></span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">15</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p>让我们对上述的代码做一些说明。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">op.multipy = mock.Mock(return_value=<span class=\"number\">15</span>)</span><br></pre></td></tr></table></figure>\n<p>通过Mock类来模拟调用Operator类中的multipy()函数，return_value 定义了multipy()方法的返回值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = op.multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>result值调用multipy()函数，输入参数为4,5，但实际并未调用，最后通过assertEqual()方法断言，返回的结果是否是预期的结果为15。输出的结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ran <span class=\"number\">1</span> test <span class=\"keyword\">in</span> <span class=\"number\">0.002</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>通过Mock类，我们即使在multipy函数并未实现的情况下，仍然能够通过想象函数执行的结果来进行测试，这样如果有后续的函数依赖multipy函数，也并不影响后续代码的测试。</p>\n<p>利用Mock模块中的patch函数，我们可以将上述测试的脚本代码简化如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> patch</span><br><span class=\"line\"><span class=\"keyword\">from</span> mock_multipy <span class=\"keyword\">import</span> Operator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test Operator class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCount</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @patch(<span class=\"params\"><span class=\"string\">&quot;mock_multipy.Operator.multipy&quot;</span></span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_case1</span>(<span class=\"params\">self, tmp</span>):</span></span><br><span class=\"line\">        tmp.return_value = <span class=\"number\">15</span></span><br><span class=\"line\">        result = Operator().multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">15</span>, result)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p>patch()装饰器可以很容易地模拟类或对象在模块测试。在测试过程中，您指定的对象将被替换为一个模拟（或其他对象），并在测试结束时还原。</p>\n<p>那如果我们后面又实现了multipy函数，是否仍然能够测试呢？</p>\n<p>修改<code>mock_multipy.py</code>脚本，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># mock_multipy.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Operator</span>():</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipy</span>(<span class=\"params\">self, a, b</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a * b</span><br></pre></td></tr></table></figure>\n<p>这时候，我们再运行<code>mock_example.py</code>脚本，测试仍然通过，这是因为multipy函数返回的结果仍然是我们mock后返回的值，而并未调用真正的Operator类中的multipy函数。</p>\n<p>我们修改<code>mock_example.py</code>脚本如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> mock_multipy <span class=\"keyword\">import</span> Operator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test Operator class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCount</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        op = Operator()</span><br><span class=\"line\">        <span class=\"comment\"># 利用Mock类，添加side_effect参数</span></span><br><span class=\"line\">        op.multipy = mock.Mock(return_value=<span class=\"number\">15</span>, side_effect=op.multipy)</span><br><span class=\"line\">        <span class=\"comment\"># 调用multipy函数，输入参数为4,5,实际已调用</span></span><br><span class=\"line\">        result = op.multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 声明返回结果是否为15</span></span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">15</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p><code>side_effect</code>参数和<code>return_value</code>参数是相反的。它给mock分配了可替换的结果，覆盖了return_value。简单的说，一个模拟工厂调用将返回side_effect值，而不是return_value。所以，设置<code>side_effect</code>参数为Operator类中的multipy函数，那么return_value的作用失效。</p>\n<p>运行修改后的测试脚本，测试结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ran <span class=\"number\">1</span> test <span class=\"keyword\">in</span> <span class=\"number\">0.004</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">FAILED (failures=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span> != <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">Expected :<span class=\"number\">20</span></span><br><span class=\"line\">Actual   :<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，multipy函数返回的值为20，不等于我们期望的值15，这是side_effect函数的作用结果使然，返回的结果调用了Operator类中的multipy函数，所以返回值为20。</p>\n<p>在<code>self.assertEqual(result, 15)</code>中将15改成20，运行测试结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ran <span class=\"number\">1</span> test <span class=\"keyword\">in</span> <span class=\"number\">0.002</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>本次分享到此结束，感谢大家的阅读~</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>前几天，听了公司某位大佬关于编程心得的体会，其中讲到了“测试驱动开发”，感觉自己的测试技能薄弱，因此，写下这篇文章，希望对测试能有个入门。这段时间，笔者也体会到了测试的价值，一句话，学会测试，能够让你的开发更加高效。</p>\n<p>本文将介绍以下两个方面的内容：</p>\n<ul>\n<li>Test with Coverage</li>\n<li>Mock</li>\n</ul>\n<h3 id=\"Test-with-Coverage\"><a href=\"#Test-with-Coverage\" class=\"headerlink\" title=\"Test with Coverage\"></a>Test with Coverage</h3><p><code>测试覆盖率</code>通常被用来衡量测试的充分性和完整性。从广义的角度讲，主要分为两大类：面向项目的<code>需求覆盖率</code>和更偏向技术的<code>代码覆盖率</code>。对于开发人员来说，我们更注重代码覆盖率。</p>\n<p><code>代码覆盖率</code>指的是至少执行了一次的条目数占整个条目数的百分比。如果条目数是语句，对应的就是<code>代码行覆盖率</code>；如果条目数是函数，对应的就是<code>函数覆盖率</code>；如果条目数是路径，对应的就是<code>路径覆盖率</code>，等等。统计代码覆盖率的根本目的是找出潜在的遗漏测试用例，并有针对性的进行补充，同时还可以识别出代码中那些由于需求变更等原因造成的废弃代码。通常我们希望代码覆盖率越高越好，代码覆盖率越高越能说明你的测试用例设计是充分且完备的，但测试的成本会随着代码覆盖率的提高而增加。</p>\n<p>在Python中，<code>coverage</code>模块帮助我们实现了<code>代码行覆盖率</code>，我们可以方便地使用它来完整测试的代码行覆盖率。</p>\n<p>我们通过一个例子来介绍<code>coverage</code>模块的使用。</p>\n<p>首先，我们有脚本<code>func_add.py</code>，实现了add函数，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span>(<span class=\"params\">a, b</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(a, <span class=\"built_in\">str</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">isinstance</span>(b, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + <span class=\"string\">&#x27;+&#x27;</span> + b</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(a, <span class=\"built_in\">list</span>) <span class=\"keyword\">and</span> <span class=\"built_in\">isinstance</span>(b, <span class=\"built_in\">list</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(a, (<span class=\"built_in\">int</span>, <span class=\"built_in\">float</span>)) <span class=\"keyword\">and</span> <span class=\"built_in\">isinstance</span>(b, (<span class=\"built_in\">int</span>, <span class=\"built_in\">float</span>)):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>在add函数中，分四种情况实现了加法，分别是字符串，列表，属性值，以及其它情况。</p>\n<p>接着，我们用unittest模块来进行单元测试，代码脚本（<code>test_func_add.py</code>）如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"><span class=\"keyword\">from</span> func_add <span class=\"keyword\">import</span> add</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test_Add</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case1</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = <span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">        b = <span class=\"string\">&quot;World&quot;</span></span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(res)</span><br><span class=\"line\">        self.assertEqual(res, <span class=\"string\">&quot;Hello+World&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case2</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = <span class=\"number\">1</span></span><br><span class=\"line\">        b = <span class=\"number\">2</span></span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(res)</span><br><span class=\"line\">        self.assertEqual(res, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case3</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">        b = [<span class=\"number\">3</span>]</span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(res)</span><br><span class=\"line\">        self.assertEqual(res, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add_case4</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        a = <span class=\"number\">2</span></span><br><span class=\"line\">        b = <span class=\"string\">&quot;3&quot;</span></span><br><span class=\"line\">        res = add(a, b)</span><br><span class=\"line\">        print(<span class=\"literal\">None</span>)</span><br><span class=\"line\">        self.assertEqual(res, <span class=\"literal\">None</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 部分用例测试</span></span><br><span class=\"line\">    <span class=\"comment\"># 构造一个容器用来存放我们的测试用例</span></span><br><span class=\"line\">    suite = unittest.TestSuite()</span><br><span class=\"line\">    <span class=\"comment\"># 添加类中的测试用例</span></span><br><span class=\"line\">    suite.addTest(Test_Add(<span class=\"string\">&#x27;test_add_case1&#x27;</span>))</span><br><span class=\"line\">    suite.addTest(Test_Add(<span class=\"string\">&#x27;test_add_case2&#x27;</span>))</span><br><span class=\"line\">    <span class=\"comment\"># suite.addTest(Test_Add(&#x27;test_add_case3&#x27;))</span></span><br><span class=\"line\">    <span class=\"comment\"># suite.addTest(Test_Add(&#x27;test_add_case4&#x27;))</span></span><br><span class=\"line\">    run = unittest.TextTestRunner()</span><br><span class=\"line\">    run.run(suite)</span><br></pre></td></tr></table></figure>\n<p>在这个测试中，我们只测试了前两个用例，也就是对字符串和数值型的加法进行测试。</p>\n<p>在命令行中输入<code>coverage run test_func_add.py</code>命令运行该测试脚本，输出结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello+World</span><br><span class=\"line\"><span class=\"number\">.3</span></span><br><span class=\"line\">.</span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran <span class=\"number\">2</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.000</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>再输入命令<code>coverage html</code>就能生成代码行覆盖率的报告，会生成<code>htmlcov</code>文件夹，打开其中的<code>index.html</code>文件，就能看到本次执行的覆盖率情况，如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0ry0AmyXalgcxSN4CgQAkKp3KpGIzqNcCqgg5YUh3q7J5kncvtjU2Gww/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"测试覆盖率结果总览\">测试覆盖率结果总览</p>\n<p>我们点击<code>func_add.py</code>查看add函数测试的情况，如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0rL6U6v3cFiaibKMMxklQRjBlgoMuwN2o5y06ibd98PdjTTB9EyWG7Cuueg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"func_add.py脚本的测试覆盖率情况\">func_add.py脚本的测试覆盖率情况</p>\n<p>可以看到，单元测试脚本test_func_add.py的前两个测试用例只覆盖到了add函数中左边绿色的部分，而没有测试到红色的部分，代码行覆盖率为75%。</p>\n<p>因此，还有两种情况没有覆盖到，说明我们的单元测试中的测试用例还不够充分。</p>\n<p>在<code>test_func_add.py</code>中，我们把main函数中的注释去掉，把后两个测试用例也添加进来，这时候我们再运行上面的<code>coverage</code>模块的命令，重新生成<code>htmlcov</code>后，func_add.py的代码行覆盖率如下图：</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/cRWNtpP7icvE6ibveno14khnUCJu77eu0r6ZRjBjVzXEkBp3aqYSumPXIjibHJKgP5dMLwKiccjfKia6kT4Hew15SyA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"增加测试用例后，func_add.py脚本的测试覆盖率情况\">增加测试用例后，func_add.py脚本的测试覆盖率情况</p>\n<p>可以看到，增加测试用例后，我们调用的add函数代码行覆盖率为100%，所有的代码都覆盖到了。</p>\n<h3 id=\"Mock\"><a href=\"#Mock\" class=\"headerlink\" title=\"Mock\"></a>Mock</h3><p>Mock这个词在英语中有模拟的这个意思，因此我们可以猜测出这个库的主要功能是模拟一些东西。准确的说，Mock是Python中一个用于支持单元测试的库，它的主要功能是使用mock对象替代掉指定的Python对象，以达到模拟对象的行为。在Python3中，mock是辅助单元测试的一个模块。它允许您用模拟对象替换您的系统的部分，并对它们已使用的方式进行断言。</p>\n<p>在实际生产中的项目是非常复杂的，对其进行单元测试的时候，会遇到以下问题：</p>\n<ul>\n<li>接口的依赖</li>\n<li>外部接口调用</li>\n<li>测试环境非常复杂</li>\n</ul>\n<p>单元测试应该只针对当前单元进行测试, 所有的内部或外部的依赖应该是稳定的, 已经在别处进行测试过的。使用mock 就可以对外部依赖组件实现进行模拟并且替换掉, 从而使得单元测试将焦点只放在当前的单元功能。</p>\n<p>我们通过一个简单的例子来说明mock模块的使用。</p>\n<p>首先，我们有脚本<code>mock_multipy.py</code>，主要实现的功能是<code>Operator</code>类中的<code>multipy</code>函数，在这里我们可以假设该函数并没有实现好，只是存在这样一个函数，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># mock_multipy.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Operator</span>():</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipy</span>(<span class=\"params\">self, a, b</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>尽管我们没有实现<code>multipy</code>函数，但是我们还是想对这个函数的功能进行测试，这时候我们可以借助mock模块中的Mock类来实现。测试的脚本（<code>mock_example.py</code>）代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> mock_multipy <span class=\"keyword\">import</span> Operator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test Operator class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCount</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        op = Operator()</span><br><span class=\"line\">        <span class=\"comment\"># 利用Mock类，我们假设返回的结果为15</span></span><br><span class=\"line\">        op.multipy = mock.Mock(return_value=<span class=\"number\">15</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 调用multipy函数，输入参数为4,5,实际并未调用</span></span><br><span class=\"line\">        result = op.multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 声明返回结果是否为15</span></span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">15</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p>让我们对上述的代码做一些说明。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">op.multipy = mock.Mock(return_value=<span class=\"number\">15</span>)</span><br></pre></td></tr></table></figure>\n<p>通过Mock类来模拟调用Operator类中的multipy()函数，return_value 定义了multipy()方法的返回值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result = op.multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<p>result值调用multipy()函数，输入参数为4,5，但实际并未调用，最后通过assertEqual()方法断言，返回的结果是否是预期的结果为15。输出的结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ran <span class=\"number\">1</span> test <span class=\"keyword\">in</span> <span class=\"number\">0.002</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>通过Mock类，我们即使在multipy函数并未实现的情况下，仍然能够通过想象函数执行的结果来进行测试，这样如果有后续的函数依赖multipy函数，也并不影响后续代码的测试。</p>\n<p>利用Mock模块中的patch函数，我们可以将上述测试的脚本代码简化如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest.mock <span class=\"keyword\">import</span> patch</span><br><span class=\"line\"><span class=\"keyword\">from</span> mock_multipy <span class=\"keyword\">import</span> Operator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test Operator class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCount</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @patch(<span class=\"params\"><span class=\"string\">&quot;mock_multipy.Operator.multipy&quot;</span></span>)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_case1</span>(<span class=\"params\">self, tmp</span>):</span></span><br><span class=\"line\">        tmp.return_value = <span class=\"number\">15</span></span><br><span class=\"line\">        result = Operator().multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        self.assertEqual(<span class=\"number\">15</span>, result)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p>patch()装饰器可以很容易地模拟类或对象在模块测试。在测试过程中，您指定的对象将被替换为一个模拟（或其他对象），并在测试结束时还原。</p>\n<p>那如果我们后面又实现了multipy函数，是否仍然能够测试呢？</p>\n<p>修改<code>mock_multipy.py</code>脚本，代码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"comment\"># mock_multipy.py</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Operator</span>():</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">multipy</span>(<span class=\"params\">self, a, b</span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> a * b</span><br></pre></td></tr></table></figure>\n<p>这时候，我们再运行<code>mock_example.py</code>脚本，测试仍然通过，这是因为multipy函数返回的结果仍然是我们mock后返回的值，而并未调用真正的Operator类中的multipy函数。</p>\n<p>我们修改<code>mock_example.py</code>脚本如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> unittest <span class=\"keyword\">import</span> mock</span><br><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> mock_multipy <span class=\"keyword\">import</span> Operator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># test Operator class</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestCount</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_add</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        op = Operator()</span><br><span class=\"line\">        <span class=\"comment\"># 利用Mock类，添加side_effect参数</span></span><br><span class=\"line\">        op.multipy = mock.Mock(return_value=<span class=\"number\">15</span>, side_effect=op.multipy)</span><br><span class=\"line\">        <span class=\"comment\"># 调用multipy函数，输入参数为4,5,实际已调用</span></span><br><span class=\"line\">        result = op.multipy(<span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 声明返回结果是否为15</span></span><br><span class=\"line\">        self.assertEqual(result, <span class=\"number\">15</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&#x27;__main__&#x27;</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure>\n<p><code>side_effect</code>参数和<code>return_value</code>参数是相反的。它给mock分配了可替换的结果，覆盖了return_value。简单的说，一个模拟工厂调用将返回side_effect值，而不是return_value。所以，设置<code>side_effect</code>参数为Operator类中的multipy函数，那么return_value的作用失效。</p>\n<p>运行修改后的测试脚本，测试结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ran <span class=\"number\">1</span> test <span class=\"keyword\">in</span> <span class=\"number\">0.004</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">FAILED (failures=<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">15</span> != <span class=\"number\">20</span></span><br><span class=\"line\"></span><br><span class=\"line\">Expected :<span class=\"number\">20</span></span><br><span class=\"line\">Actual   :<span class=\"number\">15</span></span><br></pre></td></tr></table></figure>\n<p>可以发现，multipy函数返回的值为20，不等于我们期望的值15，这是side_effect函数的作用结果使然，返回的结果调用了Operator类中的multipy函数，所以返回值为20。</p>\n<p>在<code>self.assertEqual(result, 15)</code>中将15改成20，运行测试结果如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Ran <span class=\"number\">1</span> test <span class=\"keyword\">in</span> <span class=\"number\">0.002</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>本次分享到此结束，感谢大家的阅读~</p>\n"},{"title":"Golang net包简介","date":"2020-12-31T15:59:00.000Z","abbrlink":14003,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"# 在 Golang 中使用 Go 关键字和 Channel 实现并行\n\n## Go 关键字和 channel 的用法\n\n##### go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下：\n\n```go\n//go 关键字放在方法调用前新建一个 goroutine 并让他执行方法体\ngo GetThingDone(param1, param2);\n\n//上例的变种，新建一个匿名方法并执行\ngo func(param1, param2) {\n}(val1, val2)\n\n//直接新建一个 goroutine 并在 goroutine 中执行代码块\ngo {\n    //do someting...\n}\n```\n\n##### 因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。\n\n```go\n//resultChan 是一个 int 类型的 channel。类似一个信封，里面放的是 int 类型的值。\nvar resultChan chan int\n//将 123 放到这个信封里面，供别人从信封中取用\nresultChan <- 123\n//从 resultChan 中取值。这个时候 result := 123\nresult := <- resultChan\n```\n\n## 使用 go 关键字和 channel 实现非阻塞调用\n\n##### 阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.js 使用的是回调的方式，Golang 使用的是 channel。\n\n```go\n/**\n * 每次调用方法会新建一个 channel : resultChan，\n * 同时新建一个 goroutine 来发起 http 请求并获取结果。\n * 获取到结果之后 goroutine 会将结果写入到 resultChan。\n */\nfunc UnblockGet(requestUrl string) chan string {\n    resultChan := make(chan string)\n    go func() {\n        request := httplib.Get(requestUrl)\n        content, err := request.String()\n        if err != nil {\n            content = \"\" + err.Error()\n        }\n        resultChan <- content\n    } ()\n    return resultChan\n}\n```\n\n##### 由于新建的 goroutine 不会阻塞函数主流程的执行，所以调用 UnblockGet 方法会立刻得到一个 resultChan 返回值。一旦 goroutine 执行完毕拿到结果就会写入到 resultChan 中，这时外部就可以从 resultChan 中获取执行结果。\n\n## 一个很 low 的并行示例\n\n```go\nfmt.Println(time.Now())\nresultChan1 := UnblockGet(\"http://127.0.0.1/test.php?i=1\")\nresultChan2 := UnblockGet(\"http://127.0.0.1/test.php?i=2\")\n\nfmt.Println(<-resultChan1)\nfmt.Println(<-resultChan1)\nfmt.Println(time.Now())\n```\n\n##### 上面两个 http 请求是在两个 goroutine 中并行的。总的执行时间小于 两个请求时间和。\n\n**这个例子只是为了体现 go 和 channel 的用法，有内存泄漏问题，千万不要在线上这么搞。因为新建的 channel 没有 close。下次写一个更高级一点的。**\n\n## 简单的实现 http multi GET\n\n```go\ntype RemoteResult struct {\n    Url string\n    Result string\n}\n\nfunc RemoteGet(requestUrl string, resultChan chan RemoteResult)  {\n    request := httplib.NewBeegoRequest(requestUrl, \"GET\")\n    request.SetTimeout(2 * time.Second, 5 * time.Second)\n    //request.String()\n    content, err := request.String()\n    if err != nil {\n        content = \"\" + err.Error()\n    }\n    resultChan <- RemoteResult{Url:requestUrl, Result:content}\n}\nfunc MultiGet(urls []string) []RemoteResult {\n    fmt.Println(time.Now())\n    resultChan := make(chan RemoteResult, len(urls))\n    defer close(resultChan)\n    var result []RemoteResult\n    //fmt.Println(result)\n    for _, url := range urls {\n        go RemoteGet(url, resultChan)\n    }\n    for i:= 0; i < len(urls); i++ {\n        res := <-resultChan\n```","source":"_posts/go_md/Go关键字和Channel.md","raw":"---\ntitle: Golang net包简介\ndate: '2020/12/31 23:59'\ntags:\n - go\ncategories:\n - 学习笔记\nabbrlink: 14003\ncover: \n---\n# 在 Golang 中使用 Go 关键字和 Channel 实现并行\n\n## Go 关键字和 channel 的用法\n\n##### go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下：\n\n```go\n//go 关键字放在方法调用前新建一个 goroutine 并让他执行方法体\ngo GetThingDone(param1, param2);\n\n//上例的变种，新建一个匿名方法并执行\ngo func(param1, param2) {\n}(val1, val2)\n\n//直接新建一个 goroutine 并在 goroutine 中执行代码块\ngo {\n    //do someting...\n}\n```\n\n##### 因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。\n\n```go\n//resultChan 是一个 int 类型的 channel。类似一个信封，里面放的是 int 类型的值。\nvar resultChan chan int\n//将 123 放到这个信封里面，供别人从信封中取用\nresultChan <- 123\n//从 resultChan 中取值。这个时候 result := 123\nresult := <- resultChan\n```\n\n## 使用 go 关键字和 channel 实现非阻塞调用\n\n##### 阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.js 使用的是回调的方式，Golang 使用的是 channel。\n\n```go\n/**\n * 每次调用方法会新建一个 channel : resultChan，\n * 同时新建一个 goroutine 来发起 http 请求并获取结果。\n * 获取到结果之后 goroutine 会将结果写入到 resultChan。\n */\nfunc UnblockGet(requestUrl string) chan string {\n    resultChan := make(chan string)\n    go func() {\n        request := httplib.Get(requestUrl)\n        content, err := request.String()\n        if err != nil {\n            content = \"\" + err.Error()\n        }\n        resultChan <- content\n    } ()\n    return resultChan\n}\n```\n\n##### 由于新建的 goroutine 不会阻塞函数主流程的执行，所以调用 UnblockGet 方法会立刻得到一个 resultChan 返回值。一旦 goroutine 执行完毕拿到结果就会写入到 resultChan 中，这时外部就可以从 resultChan 中获取执行结果。\n\n## 一个很 low 的并行示例\n\n```go\nfmt.Println(time.Now())\nresultChan1 := UnblockGet(\"http://127.0.0.1/test.php?i=1\")\nresultChan2 := UnblockGet(\"http://127.0.0.1/test.php?i=2\")\n\nfmt.Println(<-resultChan1)\nfmt.Println(<-resultChan1)\nfmt.Println(time.Now())\n```\n\n##### 上面两个 http 请求是在两个 goroutine 中并行的。总的执行时间小于 两个请求时间和。\n\n**这个例子只是为了体现 go 和 channel 的用法，有内存泄漏问题，千万不要在线上这么搞。因为新建的 channel 没有 close。下次写一个更高级一点的。**\n\n## 简单的实现 http multi GET\n\n```go\ntype RemoteResult struct {\n    Url string\n    Result string\n}\n\nfunc RemoteGet(requestUrl string, resultChan chan RemoteResult)  {\n    request := httplib.NewBeegoRequest(requestUrl, \"GET\")\n    request.SetTimeout(2 * time.Second, 5 * time.Second)\n    //request.String()\n    content, err := request.String()\n    if err != nil {\n        content = \"\" + err.Error()\n    }\n    resultChan <- RemoteResult{Url:requestUrl, Result:content}\n}\nfunc MultiGet(urls []string) []RemoteResult {\n    fmt.Println(time.Now())\n    resultChan := make(chan RemoteResult, len(urls))\n    defer close(resultChan)\n    var result []RemoteResult\n    //fmt.Println(result)\n    for _, url := range urls {\n        go RemoteGet(url, resultChan)\n    }\n    for i:= 0; i < len(urls); i++ {\n        res := <-resultChan\n```","slug":"go_md/Go关键字和Channel","published":1,"updated":"2021-04-09T12:48:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr5z001cw9q9epzs5fmt","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"在-Golang-中使用-Go-关键字和-Channel-实现并行\"><a href=\"#在-Golang-中使用-Go-关键字和-Channel-实现并行\" class=\"headerlink\" title=\"在 Golang 中使用 Go 关键字和 Channel 实现并行\"></a>在 Golang 中使用 Go 关键字和 Channel 实现并行</h1><h2 id=\"Go-关键字和-channel-的用法\"><a href=\"#Go-关键字和-channel-的用法\" class=\"headerlink\" title=\"Go 关键字和 channel 的用法\"></a>Go 关键字和 channel 的用法</h2><h5 id=\"go-关键字用来创建-goroutine-协程-，是实现并发的关键。go-关键字的用法如下：\"><a href=\"#go-关键字用来创建-goroutine-协程-，是实现并发的关键。go-关键字的用法如下：\" class=\"headerlink\" title=\"go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下：\"></a>go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下：</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go 关键字放在方法调用前新建一个 goroutine 并让他执行方法体</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> GetThingDone(param1, param2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//上例的变种，新建一个匿名方法并执行</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(param1, param2)</span></span> &#123;</span><br><span class=\"line\">&#125;(val1, val2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接新建一个 goroutine 并在 goroutine 中执行代码块</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do someting...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"因为-goroutine-在多核-cpu-环境下是并行的。如果代码块在多个-goroutine-中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用-channel-了。\"><a href=\"#因为-goroutine-在多核-cpu-环境下是并行的。如果代码块在多个-goroutine-中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用-channel-了。\" class=\"headerlink\" title=\"因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。\"></a>因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//resultChan 是一个 int 类型的 channel。类似一个信封，里面放的是 int 类型的值。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> resultChan <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"comment\">//将 123 放到这个信封里面，供别人从信封中取用</span></span><br><span class=\"line\">resultChan &lt;- <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">//从 resultChan 中取值。这个时候 result := 123</span></span><br><span class=\"line\">result := &lt;- resultChan</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-go-关键字和-channel-实现非阻塞调用\"><a href=\"#使用-go-关键字和-channel-实现非阻塞调用\" class=\"headerlink\" title=\"使用 go 关键字和 channel 实现非阻塞调用\"></a>使用 go 关键字和 channel 实现非阻塞调用</h2><h5 id=\"阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node-js-使用的是回调的方式，Golang-使用的是-channel。\"><a href=\"#阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node-js-使用的是回调的方式，Golang-使用的是-channel。\" class=\"headerlink\" title=\"阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.js 使用的是回调的方式，Golang 使用的是 channel。\"></a>阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.js 使用的是回调的方式，Golang 使用的是 channel。</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 每次调用方法会新建一个 channel : resultChan，</span></span><br><span class=\"line\"><span class=\"comment\"> * 同时新建一个 goroutine 来发起 http 请求并获取结果。</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取到结果之后 goroutine 会将结果写入到 resultChan。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">UnblockGet</span><span class=\"params\">(requestUrl <span class=\"keyword\">string</span>)</span> <span class=\"title\">chan</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    resultChan := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        request := httplib.Get(requestUrl)</span><br><span class=\"line\">        content, err := request.String()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            content = <span class=\"string\">&quot;&quot;</span> + err.Error()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resultChan &lt;- content</span><br><span class=\"line\">    &#125; ()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resultChan</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"由于新建的-goroutine-不会阻塞函数主流程的执行，所以调用-UnblockGet-方法会立刻得到一个-resultChan-返回值。一旦-goroutine-执行完毕拿到结果就会写入到-resultChan-中，这时外部就可以从-resultChan-中获取执行结果。\"><a href=\"#由于新建的-goroutine-不会阻塞函数主流程的执行，所以调用-UnblockGet-方法会立刻得到一个-resultChan-返回值。一旦-goroutine-执行完毕拿到结果就会写入到-resultChan-中，这时外部就可以从-resultChan-中获取执行结果。\" class=\"headerlink\" title=\"由于新建的 goroutine 不会阻塞函数主流程的执行，所以调用 UnblockGet 方法会立刻得到一个 resultChan 返回值。一旦 goroutine 执行完毕拿到结果就会写入到 resultChan 中，这时外部就可以从 resultChan 中获取执行结果。\"></a>由于新建的 goroutine 不会阻塞函数主流程的执行，所以调用 UnblockGet 方法会立刻得到一个 resultChan 返回值。一旦 goroutine 执行完毕拿到结果就会写入到 resultChan 中，这时外部就可以从 resultChan 中获取执行结果。</h5><h2 id=\"一个很-low-的并行示例\"><a href=\"#一个很-low-的并行示例\" class=\"headerlink\" title=\"一个很 low 的并行示例\"></a>一个很 low 的并行示例</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(time.Now())</span><br><span class=\"line\">resultChan1 := UnblockGet(<span class=\"string\">&quot;http://127.0.0.1/test.php?i=1&quot;</span>)</span><br><span class=\"line\">resultChan2 := UnblockGet(<span class=\"string\">&quot;http://127.0.0.1/test.php?i=2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(&lt;-resultChan1)</span><br><span class=\"line\">fmt.Println(&lt;-resultChan1)</span><br><span class=\"line\">fmt.Println(time.Now())</span><br></pre></td></tr></table></figure>\n<h5 id=\"上面两个-http-请求是在两个-goroutine-中并行的。总的执行时间小于-两个请求时间和。\"><a href=\"#上面两个-http-请求是在两个-goroutine-中并行的。总的执行时间小于-两个请求时间和。\" class=\"headerlink\" title=\"上面两个 http 请求是在两个 goroutine 中并行的。总的执行时间小于 两个请求时间和。\"></a>上面两个 http 请求是在两个 goroutine 中并行的。总的执行时间小于 两个请求时间和。</h5><p><strong>这个例子只是为了体现 go 和 channel 的用法，有内存泄漏问题，千万不要在线上这么搞。因为新建的 channel 没有 close。下次写一个更高级一点的。</strong></p>\n<h2 id=\"简单的实现-http-multi-GET\"><a href=\"#简单的实现-http-multi-GET\" class=\"headerlink\" title=\"简单的实现 http multi GET\"></a>简单的实现 http multi GET</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> RemoteResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Url <span class=\"keyword\">string</span></span><br><span class=\"line\">    Result <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RemoteGet</span><span class=\"params\">(requestUrl <span class=\"keyword\">string</span>, resultChan <span class=\"keyword\">chan</span> RemoteResult)</span></span>  &#123;</span><br><span class=\"line\">    request := httplib.NewBeegoRequest(requestUrl, <span class=\"string\">&quot;GET&quot;</span>)</span><br><span class=\"line\">    request.SetTimeout(<span class=\"number\">2</span> * time.Second, <span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">    <span class=\"comment\">//request.String()</span></span><br><span class=\"line\">    content, err := request.String()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        content = <span class=\"string\">&quot;&quot;</span> + err.Error()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resultChan &lt;- RemoteResult&#123;Url:requestUrl, Result:content&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MultiGet</span><span class=\"params\">(urls []<span class=\"keyword\">string</span>)</span> []<span class=\"title\">RemoteResult</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(time.Now())</span><br><span class=\"line\">    resultChan := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> RemoteResult, <span class=\"built_in\">len</span>(urls))</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(resultChan)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result []RemoteResult</span><br><span class=\"line\">    <span class=\"comment\">//fmt.Println(result)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, url := <span class=\"keyword\">range</span> urls &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> RemoteGet(url, resultChan)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(urls); i++ &#123;</span><br><span class=\"line\">        res := &lt;-resultChan</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"在-Golang-中使用-Go-关键字和-Channel-实现并行\"><a href=\"#在-Golang-中使用-Go-关键字和-Channel-实现并行\" class=\"headerlink\" title=\"在 Golang 中使用 Go 关键字和 Channel 实现并行\"></a>在 Golang 中使用 Go 关键字和 Channel 实现并行</h1><h2 id=\"Go-关键字和-channel-的用法\"><a href=\"#Go-关键字和-channel-的用法\" class=\"headerlink\" title=\"Go 关键字和 channel 的用法\"></a>Go 关键字和 channel 的用法</h2><h5 id=\"go-关键字用来创建-goroutine-协程-，是实现并发的关键。go-关键字的用法如下：\"><a href=\"#go-关键字用来创建-goroutine-协程-，是实现并发的关键。go-关键字的用法如下：\" class=\"headerlink\" title=\"go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下：\"></a>go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下：</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//go 关键字放在方法调用前新建一个 goroutine 并让他执行方法体</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> GetThingDone(param1, param2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//上例的变种，新建一个匿名方法并执行</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(param1, param2)</span></span> &#123;</span><br><span class=\"line\">&#125;(val1, val2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接新建一个 goroutine 并在 goroutine 中执行代码块</span></span><br><span class=\"line\"><span class=\"keyword\">go</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//do someting...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"因为-goroutine-在多核-cpu-环境下是并行的。如果代码块在多个-goroutine-中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用-channel-了。\"><a href=\"#因为-goroutine-在多核-cpu-环境下是并行的。如果代码块在多个-goroutine-中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用-channel-了。\" class=\"headerlink\" title=\"因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。\"></a>因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//resultChan 是一个 int 类型的 channel。类似一个信封，里面放的是 int 类型的值。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> resultChan <span class=\"keyword\">chan</span> <span class=\"keyword\">int</span></span><br><span class=\"line\"><span class=\"comment\">//将 123 放到这个信封里面，供别人从信封中取用</span></span><br><span class=\"line\">resultChan &lt;- <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"comment\">//从 resultChan 中取值。这个时候 result := 123</span></span><br><span class=\"line\">result := &lt;- resultChan</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用-go-关键字和-channel-实现非阻塞调用\"><a href=\"#使用-go-关键字和-channel-实现非阻塞调用\" class=\"headerlink\" title=\"使用 go 关键字和 channel 实现非阻塞调用\"></a>使用 go 关键字和 channel 实现非阻塞调用</h2><h5 id=\"阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node-js-使用的是回调的方式，Golang-使用的是-channel。\"><a href=\"#阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node-js-使用的是回调的方式，Golang-使用的是-channel。\" class=\"headerlink\" title=\"阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.js 使用的是回调的方式，Golang 使用的是 channel。\"></a>阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.js 使用的是回调的方式，Golang 使用的是 channel。</h5><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 每次调用方法会新建一个 channel : resultChan，</span></span><br><span class=\"line\"><span class=\"comment\"> * 同时新建一个 goroutine 来发起 http 请求并获取结果。</span></span><br><span class=\"line\"><span class=\"comment\"> * 获取到结果之后 goroutine 会将结果写入到 resultChan。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">UnblockGet</span><span class=\"params\">(requestUrl <span class=\"keyword\">string</span>)</span> <span class=\"title\">chan</span> <span class=\"title\">string</span></span> &#123;</span><br><span class=\"line\">    resultChan := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> <span class=\"keyword\">string</span>)</span><br><span class=\"line\">    <span class=\"keyword\">go</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">        request := httplib.Get(requestUrl)</span><br><span class=\"line\">        content, err := request.String()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">            content = <span class=\"string\">&quot;&quot;</span> + err.Error()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resultChan &lt;- content</span><br><span class=\"line\">    &#125; ()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> resultChan</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"由于新建的-goroutine-不会阻塞函数主流程的执行，所以调用-UnblockGet-方法会立刻得到一个-resultChan-返回值。一旦-goroutine-执行完毕拿到结果就会写入到-resultChan-中，这时外部就可以从-resultChan-中获取执行结果。\"><a href=\"#由于新建的-goroutine-不会阻塞函数主流程的执行，所以调用-UnblockGet-方法会立刻得到一个-resultChan-返回值。一旦-goroutine-执行完毕拿到结果就会写入到-resultChan-中，这时外部就可以从-resultChan-中获取执行结果。\" class=\"headerlink\" title=\"由于新建的 goroutine 不会阻塞函数主流程的执行，所以调用 UnblockGet 方法会立刻得到一个 resultChan 返回值。一旦 goroutine 执行完毕拿到结果就会写入到 resultChan 中，这时外部就可以从 resultChan 中获取执行结果。\"></a>由于新建的 goroutine 不会阻塞函数主流程的执行，所以调用 UnblockGet 方法会立刻得到一个 resultChan 返回值。一旦 goroutine 执行完毕拿到结果就会写入到 resultChan 中，这时外部就可以从 resultChan 中获取执行结果。</h5><h2 id=\"一个很-low-的并行示例\"><a href=\"#一个很-low-的并行示例\" class=\"headerlink\" title=\"一个很 low 的并行示例\"></a>一个很 low 的并行示例</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmt.Println(time.Now())</span><br><span class=\"line\">resultChan1 := UnblockGet(<span class=\"string\">&quot;http://127.0.0.1/test.php?i=1&quot;</span>)</span><br><span class=\"line\">resultChan2 := UnblockGet(<span class=\"string\">&quot;http://127.0.0.1/test.php?i=2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fmt.Println(&lt;-resultChan1)</span><br><span class=\"line\">fmt.Println(&lt;-resultChan1)</span><br><span class=\"line\">fmt.Println(time.Now())</span><br></pre></td></tr></table></figure>\n<h5 id=\"上面两个-http-请求是在两个-goroutine-中并行的。总的执行时间小于-两个请求时间和。\"><a href=\"#上面两个-http-请求是在两个-goroutine-中并行的。总的执行时间小于-两个请求时间和。\" class=\"headerlink\" title=\"上面两个 http 请求是在两个 goroutine 中并行的。总的执行时间小于 两个请求时间和。\"></a>上面两个 http 请求是在两个 goroutine 中并行的。总的执行时间小于 两个请求时间和。</h5><p><strong>这个例子只是为了体现 go 和 channel 的用法，有内存泄漏问题，千万不要在线上这么搞。因为新建的 channel 没有 close。下次写一个更高级一点的。</strong></p>\n<h2 id=\"简单的实现-http-multi-GET\"><a href=\"#简单的实现-http-multi-GET\" class=\"headerlink\" title=\"简单的实现 http multi GET\"></a>简单的实现 http multi GET</h2><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span> RemoteResult <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Url <span class=\"keyword\">string</span></span><br><span class=\"line\">    Result <span class=\"keyword\">string</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RemoteGet</span><span class=\"params\">(requestUrl <span class=\"keyword\">string</span>, resultChan <span class=\"keyword\">chan</span> RemoteResult)</span></span>  &#123;</span><br><span class=\"line\">    request := httplib.NewBeegoRequest(requestUrl, <span class=\"string\">&quot;GET&quot;</span>)</span><br><span class=\"line\">    request.SetTimeout(<span class=\"number\">2</span> * time.Second, <span class=\"number\">5</span> * time.Second)</span><br><span class=\"line\">    <span class=\"comment\">//request.String()</span></span><br><span class=\"line\">    content, err := request.String()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">        content = <span class=\"string\">&quot;&quot;</span> + err.Error()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    resultChan &lt;- RemoteResult&#123;Url:requestUrl, Result:content&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">MultiGet</span><span class=\"params\">(urls []<span class=\"keyword\">string</span>)</span> []<span class=\"title\">RemoteResult</span></span> &#123;</span><br><span class=\"line\">    fmt.Println(time.Now())</span><br><span class=\"line\">    resultChan := <span class=\"built_in\">make</span>(<span class=\"keyword\">chan</span> RemoteResult, <span class=\"built_in\">len</span>(urls))</span><br><span class=\"line\">    <span class=\"keyword\">defer</span> <span class=\"built_in\">close</span>(resultChan)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result []RemoteResult</span><br><span class=\"line\">    <span class=\"comment\">//fmt.Println(result)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> _, url := <span class=\"keyword\">range</span> urls &#123;</span><br><span class=\"line\">        <span class=\"keyword\">go</span> RemoteGet(url, resultChan)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i:= <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">len</span>(urls); i++ &#123;</span><br><span class=\"line\">        res := &lt;-resultChan</span><br></pre></td></tr></table></figure>"},{"title":"Jupyter notebooks 单元测试","date":"2020-12-31T15:59:00.000Z","abbrlink":16000,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# 在 Jupyter notebooks 中进行单元测试\n\n我们都知道开发过程中应该编写单元测试，实际上我们中的许多人都这样做。对于生产代码，库代码，或者归因于测试驱动的开发过程，这一点尤其正确。\n\n通常，Jupyter notebooks用于数据探究，因此用户可能不选择（或不需要）为其代码编写单元测试，因为当他们在Jupyter中运行时，通常会查看每个单元格的结果，然后得出结论，之后继续。但是，以我的经验来看，Jupyter通常会发生的情况是，Jupyter中的代码很快就超出了数据探究的范围，对于进一步的工作很有用。或者，Jupyter本身可能会产生有用的结果，需要定期运行。也许需要维护代码并将其与外部数据源集成。然后，确保可以测试和验证notebook中的代码就变得很重要。\n\n在这种情况下，我们有哪些选择对Jupyter代码来进行单元测试？在本文中，我将介绍在Jupyter notebooks中对Python代码进行单元测试的几个选项。\n\n**也许只是不做？**\n\nJupyter notebook 单元测试的第一个选择是根本不做。这样，我并不是说不要对代码进行单元测试，而是将其从notebook 中提取到单独的Python模块中，然后再将其重新导入notebook 中。应该使用通常对单元代码进行单元测试的方式来测试该代码，无论是使用unittest，pytest，doctest还是其他单元测试框架。本文不会详细介绍所有这些框架，但是对于python开发人员来说，一个不错的选择是不在其Jupyter notebook本中进行测试，而是使用多种可用于Python代码的测试框架，并在开发过程中尽快将代码移至外部模块。\n\n## 1. **在notebook中进行测试**\n\n如果最终决定要将代码保留在Jupyter notebook中，则实际上有一些单元测试选项。在复习其中的一些内容之前，让我们先设置一个在Jupyter notebook中可能会遇到的代码示例。假设您的notebook从API中提取了一些数据，从中计算出一些结果，然后生成了一些图表和其他数据摘要，这些摘要会一直保存在其他地方。也许有一个函数可以产生正确的API URL，我们想对该函数进行单元测试。此功能具有一些逻辑，可以根据报告的日期更改URL格式。这是经过调试的版本。\n\n```python\nimport datetime\nimport dateutil\n\ndef make_url(date):\n    \"\"\"Return the url for our API call based on date.\"\"\"\n\n    if isinstance(date, str):\n        date = dateutil.parser.parse(date).date()\n    elif not isinstance(date, datetime.date):\n        raise ValueError(\"must be a date\")\n    if date >= datetime.date(2020, 1, 1):\n        return f\"https://api.example.com/v2/{date.year}/{date.month}/{date.day}\"\n    else:\n        return f\"https://api.example.com/v1/{date:%Y-%m-%d}\"\n```\n\n## 2. **使用unittest进行单元测试**\n\n通常，当我们使用unittest进行测试时，我们会将测试方法放在单独的测试模块中，或者可能将这些方法混入主模块中。然后，我们需要执行`unittest.main`方法，可能是`__main__`防护中的默认方法。我们基本上可以在Jupyter notebook中执行相同的操作。我们可以创建一个`unitest.TestCase`类，执行所需的测试，然后仅在任何单元格中执行单元测试。您只需要保存`unittest.main`方法的输出并检查是否有错误。\n\n```python\nimport unittest\n\nclass TestUrl(unittest.TestCase):\n    def test_make_url_v2(self):\n        date = datetime.date(2020, 1, 1)\n        self.assertEqual(make_url(date), \"https://api.example.com/v2/2020/1/1\")\n        \n    def test_make_url_v1(self):\n        date = datetime.date(2019, 12, 31)\n        self.assertEqual(make_url(date), \"https://api.example.com/v1/2019-12-31\")\n\n        \nres = unittest.main(argv=[''], verbosity=3, exit=False)\n\n# if we want our notebook to stop processing due to failures, we need a cell itself to fail\nassert len(res.result.failures) == 0\ntest_make_url_v1 (__main__.TestUrl) ... ok\ntest_make_url_v2 (__main__.TestUrl) ... ok\n\n----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nOK\n```\n\n事实证明，这非常简单，如果您不介意在notebook中混合使用代码和进行测试，那么效果很好。\n\n## 3. **使用doctest进行单元测试**\n\n在代码中包含测试的另一种方法是使用doctest。Doctest使用特殊格式的代码文档，其中包括我们的测试和预期结果。下面是包含此特殊代码文档的更新方法，包括正例和负例。这是一种在一个地方测试和记录代码的简单方法，通常会在python模块中使用，main头文件将仅在其中运行doct测试，如下所示：\n\n```python\nif __name__ == __main__:\n    doctest.testmod()\n```\n\n由于我们在notebook中，因此只需将其添加到定义了代码的单元格中，它也将起作用。首先，这是我们更新的带有doctest注释的`make_url`方法。\n\n```python\ndef make_url(date):\n    \"\"\"Return the url for our API call based on date.\n    >>> make_url(\"1/1/2020\")\n    'https://api.example.com/v2/2020/1/1'\n    \n    >>> make_url(\"1-1-x1\")\n    Traceback (most recent call last):\n        ...\n    dateutil.parser._parser.ParserError: Unknown string format: 1-1-x1\n    \n    >>> make_url(\"1/1/20001\")\n    Traceback (most recent call last):\n        ...\n    dateutil.parser._parser.ParserError: year 20001 is out of range: 1/1/20001\n    \n    >>> make_url(datetime.date(2020,1,1))\n    'https://api.example.com/v2/2020/1/1'\n    \n    >>> make_url(datetime.date(2019,12,31))\n    'https://api.example.com/v1/2019-12-31'\n    \"\"\"\n    if isinstance(date, str):\n        date = dateutil.parser.parse(date).date()\n    elif not isinstance(date, datetime.date):\n        raise ValueError(\"must be a date\")\n    if date >= datetime.date(2020, 1, 1):\n        return f\"https://api.example.com/v2/{date.year}/{date.month}/{date.day}\"\n    else:\n        return f\"https://api.example.com/v1/{date:%Y-%m-%d}\"\n\nimport doctest\ndoctest.testmod()\nTestResults(failed=0, attempted=5)\n```\n\n## 4. **用testbook进行单元测试**\n\ntestbook项目是notebook 单元测试的另一种方式。它允许您从notebook 外部以纯Python代码方式引用notebook 。这使您可以在单独的Python模块中使用任何您喜欢的测试框架（例如pytest或unittest）。您可能会遇到这样的情况：允许用户修改和更新notebook代码是保持代码更新并为最终用户提供灵活性的最佳方法。但是您可能希望仍单独对代码进行测试和验证。Testbook使其成为一个选项。\n\n首先，您必须将其安装在您的环境中：\n\n```python\npip install testbook\n```\n\n或者在你的notebook中：\n\n```python\n%pip install testbook\n```\n\n现在，在一个单独的python文件中，您可以导入notebook代码并在那里进行测试。在该文件中，您将创建类似于以下代码的代码，然后使用您更喜欢实际执行单元测试的任何单元测试框架。您可以在Python文件中创建以下代码（例如jupyter_unit_tests.py）。\n\n```python\nimport datetime\nimport testbook\n\n@testbook.testbook('./jupyter_unit_tests.ipynb', execute=True)\ndef test_make_url(tb):\n    func = tb.ref(\"make_url\")\n    date = datetime.date(2020, 1, 2)\n    assert make_url(date) == \"https://api.example.com/v2/2020/1/1\"\n```\n\n在这种情况下，您现在可以使用任何单元测试框架来运行测试。例如，使用pytest，您只需运行以下命令：\n\n```python\npytest jupyter_unit_tests.py\n```\n\n这可以作为正常的单元测试，并且测试应该通过。但是，在撰写本文时，我意识到testbook代码对将单元测试中的参数传递回notebook内核进行测试的支持有限。这些参数是JSON序列化的，并且当前代码知道如何处理各种Python类型。但是，它不会将日期时间作为对象传递，而是作为字符串传递。由于我们的代码尝试将字符串解析为日期（在我对其进行修改之后），因此它可以工作。换句话说，上面的单元测试不是将`datetime.date`传递给`make_url`方法，而是传递一个字符串（2020-01-02），然后将其解析为一个日期。您如何将日期从单元测试传递到notebook代码中？您有以下几种选择。首先，您可以在notebook中创建一个日期对象，仅用于测试目的，然后在单元测试中引用它。\n\n```python\ntestdate1 = datetime.date(2020,1,1)  # for unit test\n```\n\n然后，您可以编写单元测试以在测试中使用该变量。\n\n第二种选择是将Python代码写入notebook，然后在单元测试中重新引用它。这两个选项都显示在外部单元测试的最终版本中。只需将其保存在`jupyter_unit_tests.py`上，然后使用您喜欢的单元测试框架来运行它。\n\n```python\nimport datetime\n\nimport testbook\n\n@testbook.testbook('./jupyter_unit_tests.ipynb', execute=True)\ndef test_make_url(tb):\n    f = tb.ref(\"make_url\")\n    d = \"2020-01-02\"\n    assert f(d) == \"https://api.example.com/v2/2020/1/2\"\n\n    # note that this is actually converted to a string\n    d = datetime.date(2020, 1, 2)\n    assert f(d) == \"https://api.example.com/v2/2020/1/2\"\n\n    # this one will be testing the date functionality\n    d2 = tb.ref(\"testdate1\")\n    assert f(d2) == \"https://api.example.com/v2/2020/1/1\"\n\n    # this one will inject similar code as above, then use it\n    tb.inject(\"d3 = datetime.date(2020, 2, 3)\")\n    d3 = tb.ref(\"d3\")\n    assert f(d3) == \"https://api.example.com/v2/2020/2/3\"\n```\n\n## 5. **总结**\n\n因此，无论您是单元测试的纯粹主义者还是只想在notebooks中添加一些单元测试，您都可以考虑以上几种选择。不要让notebooks的使用妨碍您在测试代码方面做正确的事情。","source":"_posts/python_md/Jupyter notebooks单元测试.md","raw":"---\ntitle: Jupyter notebooks 单元测试\ndate: '2020/12/31 23:59'\ntags:\n - python\ncategories:\n - 学习笔记\nabbrlink: 16000\ncover: \n---\n\n# 在 Jupyter notebooks 中进行单元测试\n\n我们都知道开发过程中应该编写单元测试，实际上我们中的许多人都这样做。对于生产代码，库代码，或者归因于测试驱动的开发过程，这一点尤其正确。\n\n通常，Jupyter notebooks用于数据探究，因此用户可能不选择（或不需要）为其代码编写单元测试，因为当他们在Jupyter中运行时，通常会查看每个单元格的结果，然后得出结论，之后继续。但是，以我的经验来看，Jupyter通常会发生的情况是，Jupyter中的代码很快就超出了数据探究的范围，对于进一步的工作很有用。或者，Jupyter本身可能会产生有用的结果，需要定期运行。也许需要维护代码并将其与外部数据源集成。然后，确保可以测试和验证notebook中的代码就变得很重要。\n\n在这种情况下，我们有哪些选择对Jupyter代码来进行单元测试？在本文中，我将介绍在Jupyter notebooks中对Python代码进行单元测试的几个选项。\n\n**也许只是不做？**\n\nJupyter notebook 单元测试的第一个选择是根本不做。这样，我并不是说不要对代码进行单元测试，而是将其从notebook 中提取到单独的Python模块中，然后再将其重新导入notebook 中。应该使用通常对单元代码进行单元测试的方式来测试该代码，无论是使用unittest，pytest，doctest还是其他单元测试框架。本文不会详细介绍所有这些框架，但是对于python开发人员来说，一个不错的选择是不在其Jupyter notebook本中进行测试，而是使用多种可用于Python代码的测试框架，并在开发过程中尽快将代码移至外部模块。\n\n## 1. **在notebook中进行测试**\n\n如果最终决定要将代码保留在Jupyter notebook中，则实际上有一些单元测试选项。在复习其中的一些内容之前，让我们先设置一个在Jupyter notebook中可能会遇到的代码示例。假设您的notebook从API中提取了一些数据，从中计算出一些结果，然后生成了一些图表和其他数据摘要，这些摘要会一直保存在其他地方。也许有一个函数可以产生正确的API URL，我们想对该函数进行单元测试。此功能具有一些逻辑，可以根据报告的日期更改URL格式。这是经过调试的版本。\n\n```python\nimport datetime\nimport dateutil\n\ndef make_url(date):\n    \"\"\"Return the url for our API call based on date.\"\"\"\n\n    if isinstance(date, str):\n        date = dateutil.parser.parse(date).date()\n    elif not isinstance(date, datetime.date):\n        raise ValueError(\"must be a date\")\n    if date >= datetime.date(2020, 1, 1):\n        return f\"https://api.example.com/v2/{date.year}/{date.month}/{date.day}\"\n    else:\n        return f\"https://api.example.com/v1/{date:%Y-%m-%d}\"\n```\n\n## 2. **使用unittest进行单元测试**\n\n通常，当我们使用unittest进行测试时，我们会将测试方法放在单独的测试模块中，或者可能将这些方法混入主模块中。然后，我们需要执行`unittest.main`方法，可能是`__main__`防护中的默认方法。我们基本上可以在Jupyter notebook中执行相同的操作。我们可以创建一个`unitest.TestCase`类，执行所需的测试，然后仅在任何单元格中执行单元测试。您只需要保存`unittest.main`方法的输出并检查是否有错误。\n\n```python\nimport unittest\n\nclass TestUrl(unittest.TestCase):\n    def test_make_url_v2(self):\n        date = datetime.date(2020, 1, 1)\n        self.assertEqual(make_url(date), \"https://api.example.com/v2/2020/1/1\")\n        \n    def test_make_url_v1(self):\n        date = datetime.date(2019, 12, 31)\n        self.assertEqual(make_url(date), \"https://api.example.com/v1/2019-12-31\")\n\n        \nres = unittest.main(argv=[''], verbosity=3, exit=False)\n\n# if we want our notebook to stop processing due to failures, we need a cell itself to fail\nassert len(res.result.failures) == 0\ntest_make_url_v1 (__main__.TestUrl) ... ok\ntest_make_url_v2 (__main__.TestUrl) ... ok\n\n----------------------------------------------------------------------\nRan 2 tests in 0.001s\n\nOK\n```\n\n事实证明，这非常简单，如果您不介意在notebook中混合使用代码和进行测试，那么效果很好。\n\n## 3. **使用doctest进行单元测试**\n\n在代码中包含测试的另一种方法是使用doctest。Doctest使用特殊格式的代码文档，其中包括我们的测试和预期结果。下面是包含此特殊代码文档的更新方法，包括正例和负例。这是一种在一个地方测试和记录代码的简单方法，通常会在python模块中使用，main头文件将仅在其中运行doct测试，如下所示：\n\n```python\nif __name__ == __main__:\n    doctest.testmod()\n```\n\n由于我们在notebook中，因此只需将其添加到定义了代码的单元格中，它也将起作用。首先，这是我们更新的带有doctest注释的`make_url`方法。\n\n```python\ndef make_url(date):\n    \"\"\"Return the url for our API call based on date.\n    >>> make_url(\"1/1/2020\")\n    'https://api.example.com/v2/2020/1/1'\n    \n    >>> make_url(\"1-1-x1\")\n    Traceback (most recent call last):\n        ...\n    dateutil.parser._parser.ParserError: Unknown string format: 1-1-x1\n    \n    >>> make_url(\"1/1/20001\")\n    Traceback (most recent call last):\n        ...\n    dateutil.parser._parser.ParserError: year 20001 is out of range: 1/1/20001\n    \n    >>> make_url(datetime.date(2020,1,1))\n    'https://api.example.com/v2/2020/1/1'\n    \n    >>> make_url(datetime.date(2019,12,31))\n    'https://api.example.com/v1/2019-12-31'\n    \"\"\"\n    if isinstance(date, str):\n        date = dateutil.parser.parse(date).date()\n    elif not isinstance(date, datetime.date):\n        raise ValueError(\"must be a date\")\n    if date >= datetime.date(2020, 1, 1):\n        return f\"https://api.example.com/v2/{date.year}/{date.month}/{date.day}\"\n    else:\n        return f\"https://api.example.com/v1/{date:%Y-%m-%d}\"\n\nimport doctest\ndoctest.testmod()\nTestResults(failed=0, attempted=5)\n```\n\n## 4. **用testbook进行单元测试**\n\ntestbook项目是notebook 单元测试的另一种方式。它允许您从notebook 外部以纯Python代码方式引用notebook 。这使您可以在单独的Python模块中使用任何您喜欢的测试框架（例如pytest或unittest）。您可能会遇到这样的情况：允许用户修改和更新notebook代码是保持代码更新并为最终用户提供灵活性的最佳方法。但是您可能希望仍单独对代码进行测试和验证。Testbook使其成为一个选项。\n\n首先，您必须将其安装在您的环境中：\n\n```python\npip install testbook\n```\n\n或者在你的notebook中：\n\n```python\n%pip install testbook\n```\n\n现在，在一个单独的python文件中，您可以导入notebook代码并在那里进行测试。在该文件中，您将创建类似于以下代码的代码，然后使用您更喜欢实际执行单元测试的任何单元测试框架。您可以在Python文件中创建以下代码（例如jupyter_unit_tests.py）。\n\n```python\nimport datetime\nimport testbook\n\n@testbook.testbook('./jupyter_unit_tests.ipynb', execute=True)\ndef test_make_url(tb):\n    func = tb.ref(\"make_url\")\n    date = datetime.date(2020, 1, 2)\n    assert make_url(date) == \"https://api.example.com/v2/2020/1/1\"\n```\n\n在这种情况下，您现在可以使用任何单元测试框架来运行测试。例如，使用pytest，您只需运行以下命令：\n\n```python\npytest jupyter_unit_tests.py\n```\n\n这可以作为正常的单元测试，并且测试应该通过。但是，在撰写本文时，我意识到testbook代码对将单元测试中的参数传递回notebook内核进行测试的支持有限。这些参数是JSON序列化的，并且当前代码知道如何处理各种Python类型。但是，它不会将日期时间作为对象传递，而是作为字符串传递。由于我们的代码尝试将字符串解析为日期（在我对其进行修改之后），因此它可以工作。换句话说，上面的单元测试不是将`datetime.date`传递给`make_url`方法，而是传递一个字符串（2020-01-02），然后将其解析为一个日期。您如何将日期从单元测试传递到notebook代码中？您有以下几种选择。首先，您可以在notebook中创建一个日期对象，仅用于测试目的，然后在单元测试中引用它。\n\n```python\ntestdate1 = datetime.date(2020,1,1)  # for unit test\n```\n\n然后，您可以编写单元测试以在测试中使用该变量。\n\n第二种选择是将Python代码写入notebook，然后在单元测试中重新引用它。这两个选项都显示在外部单元测试的最终版本中。只需将其保存在`jupyter_unit_tests.py`上，然后使用您喜欢的单元测试框架来运行它。\n\n```python\nimport datetime\n\nimport testbook\n\n@testbook.testbook('./jupyter_unit_tests.ipynb', execute=True)\ndef test_make_url(tb):\n    f = tb.ref(\"make_url\")\n    d = \"2020-01-02\"\n    assert f(d) == \"https://api.example.com/v2/2020/1/2\"\n\n    # note that this is actually converted to a string\n    d = datetime.date(2020, 1, 2)\n    assert f(d) == \"https://api.example.com/v2/2020/1/2\"\n\n    # this one will be testing the date functionality\n    d2 = tb.ref(\"testdate1\")\n    assert f(d2) == \"https://api.example.com/v2/2020/1/1\"\n\n    # this one will inject similar code as above, then use it\n    tb.inject(\"d3 = datetime.date(2020, 2, 3)\")\n    d3 = tb.ref(\"d3\")\n    assert f(d3) == \"https://api.example.com/v2/2020/2/3\"\n```\n\n## 5. **总结**\n\n因此，无论您是单元测试的纯粹主义者还是只想在notebooks中添加一些单元测试，您都可以考虑以上几种选择。不要让notebooks的使用妨碍您在测试代码方面做正确的事情。","slug":"python_md/Jupyter notebooks单元测试","published":1,"updated":"2021-04-08T14:09:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr60001fw9q9dmoxbnf5","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"在-Jupyter-notebooks-中进行单元测试\"><a href=\"#在-Jupyter-notebooks-中进行单元测试\" class=\"headerlink\" title=\"在 Jupyter notebooks 中进行单元测试\"></a>在 Jupyter notebooks 中进行单元测试</h1><p>我们都知道开发过程中应该编写单元测试，实际上我们中的许多人都这样做。对于生产代码，库代码，或者归因于测试驱动的开发过程，这一点尤其正确。</p>\n<p>通常，Jupyter notebooks用于数据探究，因此用户可能不选择（或不需要）为其代码编写单元测试，因为当他们在Jupyter中运行时，通常会查看每个单元格的结果，然后得出结论，之后继续。但是，以我的经验来看，Jupyter通常会发生的情况是，Jupyter中的代码很快就超出了数据探究的范围，对于进一步的工作很有用。或者，Jupyter本身可能会产生有用的结果，需要定期运行。也许需要维护代码并将其与外部数据源集成。然后，确保可以测试和验证notebook中的代码就变得很重要。</p>\n<p>在这种情况下，我们有哪些选择对Jupyter代码来进行单元测试？在本文中，我将介绍在Jupyter notebooks中对Python代码进行单元测试的几个选项。</p>\n<p><strong>也许只是不做？</strong></p>\n<p>Jupyter notebook 单元测试的第一个选择是根本不做。这样，我并不是说不要对代码进行单元测试，而是将其从notebook 中提取到单独的Python模块中，然后再将其重新导入notebook 中。应该使用通常对单元代码进行单元测试的方式来测试该代码，无论是使用unittest，pytest，doctest还是其他单元测试框架。本文不会详细介绍所有这些框架，但是对于python开发人员来说，一个不错的选择是不在其Jupyter notebook本中进行测试，而是使用多种可用于Python代码的测试框架，并在开发过程中尽快将代码移至外部模块。</p>\n<h2 id=\"1-在notebook中进行测试\"><a href=\"#1-在notebook中进行测试\" class=\"headerlink\" title=\"1. 在notebook中进行测试\"></a>1. <strong>在notebook中进行测试</strong></h2><p>如果最终决定要将代码保留在Jupyter notebook中，则实际上有一些单元测试选项。在复习其中的一些内容之前，让我们先设置一个在Jupyter notebook中可能会遇到的代码示例。假设您的notebook从API中提取了一些数据，从中计算出一些结果，然后生成了一些图表和其他数据摘要，这些摘要会一直保存在其他地方。也许有一个函数可以产生正确的API URL，我们想对该函数进行单元测试。此功能具有一些逻辑，可以根据报告的日期更改URL格式。这是经过调试的版本。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"keyword\">import</span> dateutil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_url</span>(<span class=\"params\">date</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the url for our API call based on date.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(date, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        date = dateutil.parser.parse(date).date()</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(date, datetime.date):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;must be a date&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> date &gt;= datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v2/<span class=\"subst\">&#123;date.year&#125;</span>/<span class=\"subst\">&#123;date.month&#125;</span>/<span class=\"subst\">&#123;date.day&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v1/<span class=\"subst\">&#123;date:%Y-%m-%d&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-使用unittest进行单元测试\"><a href=\"#2-使用unittest进行单元测试\" class=\"headerlink\" title=\"2. 使用unittest进行单元测试\"></a>2. <strong>使用unittest进行单元测试</strong></h2><p>通常，当我们使用unittest进行测试时，我们会将测试方法放在单独的测试模块中，或者可能将这些方法混入主模块中。然后，我们需要执行<code>unittest.main</code>方法，可能是<code>__main__</code>防护中的默认方法。我们基本上可以在Jupyter notebook中执行相同的操作。我们可以创建一个<code>unitest.TestCase</code>类，执行所需的测试，然后仅在任何单元格中执行单元测试。您只需要保存<code>unittest.main</code>方法的输出并检查是否有错误。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestUrl</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url_v2</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        date = datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.assertEqual(make_url(date), <span class=\"string\">&quot;https://api.example.com/v2/2020/1/1&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url_v1</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        date = datetime.date(<span class=\"number\">2019</span>, <span class=\"number\">12</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\">        self.assertEqual(make_url(date), <span class=\"string\">&quot;https://api.example.com/v1/2019-12-31&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">res = unittest.main(argv=[<span class=\"string\">&#x27;&#x27;</span>], verbosity=<span class=\"number\">3</span>, exit=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># if we want our notebook to stop processing due to failures, we need a cell itself to fail</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(res.result.failures) == <span class=\"number\">0</span></span><br><span class=\"line\">test_make_url_v1 (__main__.TestUrl) ... ok</span><br><span class=\"line\">test_make_url_v2 (__main__.TestUrl) ... ok</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran <span class=\"number\">2</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.001</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>事实证明，这非常简单，如果您不介意在notebook中混合使用代码和进行测试，那么效果很好。</p>\n<h2 id=\"3-使用doctest进行单元测试\"><a href=\"#3-使用doctest进行单元测试\" class=\"headerlink\" title=\"3. 使用doctest进行单元测试\"></a>3. <strong>使用doctest进行单元测试</strong></h2><p>在代码中包含测试的另一种方法是使用doctest。Doctest使用特殊格式的代码文档，其中包括我们的测试和预期结果。下面是包含此特殊代码文档的更新方法，包括正例和负例。这是一种在一个地方测试和记录代码的简单方法，通常会在python模块中使用，main头文件将仅在其中运行doct测试，如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == __main__:</span><br><span class=\"line\">    doctest.testmod()</span><br></pre></td></tr></table></figure>\n<p>由于我们在notebook中，因此只需将其添加到定义了代码的单元格中，它也将起作用。首先，这是我们更新的带有doctest注释的<code>make_url</code>方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_url</span>(<span class=\"params\">date</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the url for our API call based on date.</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(&quot;1/1/2020&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;https://api.example.com/v2/2020/1/1&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(&quot;1-1-x1&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">        ...</span></span><br><span class=\"line\"><span class=\"string\">    dateutil.parser._parser.ParserError: Unknown string format: 1-1-x1</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(&quot;1/1/20001&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">        ...</span></span><br><span class=\"line\"><span class=\"string\">    dateutil.parser._parser.ParserError: year 20001 is out of range: 1/1/20001</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(datetime.date(2020,1,1))</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;https://api.example.com/v2/2020/1/1&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(datetime.date(2019,12,31))</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;https://api.example.com/v1/2019-12-31&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(date, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        date = dateutil.parser.parse(date).date()</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(date, datetime.date):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;must be a date&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> date &gt;= datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v2/<span class=\"subst\">&#123;date.year&#125;</span>/<span class=\"subst\">&#123;date.month&#125;</span>/<span class=\"subst\">&#123;date.day&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v1/<span class=\"subst\">&#123;date:%Y-%m-%d&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> doctest</span><br><span class=\"line\">doctest.testmod()</span><br><span class=\"line\">TestResults(failed=<span class=\"number\">0</span>, attempted=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-用testbook进行单元测试\"><a href=\"#4-用testbook进行单元测试\" class=\"headerlink\" title=\"4. 用testbook进行单元测试\"></a>4. <strong>用testbook进行单元测试</strong></h2><p>testbook项目是notebook 单元测试的另一种方式。它允许您从notebook 外部以纯Python代码方式引用notebook 。这使您可以在单独的Python模块中使用任何您喜欢的测试框架（例如pytest或unittest）。您可能会遇到这样的情况：允许用户修改和更新notebook代码是保持代码更新并为最终用户提供灵活性的最佳方法。但是您可能希望仍单独对代码进行测试和验证。Testbook使其成为一个选项。</p>\n<p>首先，您必须将其安装在您的环境中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install testbook</span><br></pre></td></tr></table></figure>\n<p>或者在你的notebook中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%pip install testbook</span><br></pre></td></tr></table></figure>\n<p>现在，在一个单独的python文件中，您可以导入notebook代码并在那里进行测试。在该文件中，您将创建类似于以下代码的代码，然后使用您更喜欢实际执行单元测试的任何单元测试框架。您可以在Python文件中创建以下代码（例如jupyter_unit_tests.py）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"keyword\">import</span> testbook</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@testbook.testbook(<span class=\"params\"><span class=\"string\">&#x27;./jupyter_unit_tests.ipynb&#x27;</span>, execute=<span class=\"literal\">True</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url</span>(<span class=\"params\">tb</span>):</span></span><br><span class=\"line\">    func = tb.ref(<span class=\"string\">&quot;make_url&quot;</span>)</span><br><span class=\"line\">    date = datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> make_url(date) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/1&quot;</span></span><br></pre></td></tr></table></figure>\n<p>在这种情况下，您现在可以使用任何单元测试框架来运行测试。例如，使用pytest，您只需运行以下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pytest jupyter_unit_tests.py</span><br></pre></td></tr></table></figure>\n<p>这可以作为正常的单元测试，并且测试应该通过。但是，在撰写本文时，我意识到testbook代码对将单元测试中的参数传递回notebook内核进行测试的支持有限。这些参数是JSON序列化的，并且当前代码知道如何处理各种Python类型。但是，它不会将日期时间作为对象传递，而是作为字符串传递。由于我们的代码尝试将字符串解析为日期（在我对其进行修改之后），因此它可以工作。换句话说，上面的单元测试不是将<code>datetime.date</code>传递给<code>make_url</code>方法，而是传递一个字符串（2020-01-02），然后将其解析为一个日期。您如何将日期从单元测试传递到notebook代码中？您有以下几种选择。首先，您可以在notebook中创建一个日期对象，仅用于测试目的，然后在单元测试中引用它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testdate1 = datetime.date(<span class=\"number\">2020</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)  <span class=\"comment\"># for unit test</span></span><br></pre></td></tr></table></figure>\n<p>然后，您可以编写单元测试以在测试中使用该变量。</p>\n<p>第二种选择是将Python代码写入notebook，然后在单元测试中重新引用它。这两个选项都显示在外部单元测试的最终版本中。只需将其保存在<code>jupyter_unit_tests.py</code>上，然后使用您喜欢的单元测试框架来运行它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> testbook</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@testbook.testbook(<span class=\"params\"><span class=\"string\">&#x27;./jupyter_unit_tests.ipynb&#x27;</span>, execute=<span class=\"literal\">True</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url</span>(<span class=\"params\">tb</span>):</span></span><br><span class=\"line\">    f = tb.ref(<span class=\"string\">&quot;make_url&quot;</span>)</span><br><span class=\"line\">    d = <span class=\"string\">&quot;2020-01-02&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># note that this is actually converted to a string</span></span><br><span class=\"line\">    d = datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># this one will be testing the date functionality</span></span><br><span class=\"line\">    d2 = tb.ref(<span class=\"string\">&quot;testdate1&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d2) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># this one will inject similar code as above, then use it</span></span><br><span class=\"line\">    tb.inject(<span class=\"string\">&quot;d3 = datetime.date(2020, 2, 3)&quot;</span>)</span><br><span class=\"line\">    d3 = tb.ref(<span class=\"string\">&quot;d3&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d3) == <span class=\"string\">&quot;https://api.example.com/v2/2020/2/3&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. <strong>总结</strong></h2><p>因此，无论您是单元测试的纯粹主义者还是只想在notebooks中添加一些单元测试，您都可以考虑以上几种选择。不要让notebooks的使用妨碍您在测试代码方面做正确的事情。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"在-Jupyter-notebooks-中进行单元测试\"><a href=\"#在-Jupyter-notebooks-中进行单元测试\" class=\"headerlink\" title=\"在 Jupyter notebooks 中进行单元测试\"></a>在 Jupyter notebooks 中进行单元测试</h1><p>我们都知道开发过程中应该编写单元测试，实际上我们中的许多人都这样做。对于生产代码，库代码，或者归因于测试驱动的开发过程，这一点尤其正确。</p>\n<p>通常，Jupyter notebooks用于数据探究，因此用户可能不选择（或不需要）为其代码编写单元测试，因为当他们在Jupyter中运行时，通常会查看每个单元格的结果，然后得出结论，之后继续。但是，以我的经验来看，Jupyter通常会发生的情况是，Jupyter中的代码很快就超出了数据探究的范围，对于进一步的工作很有用。或者，Jupyter本身可能会产生有用的结果，需要定期运行。也许需要维护代码并将其与外部数据源集成。然后，确保可以测试和验证notebook中的代码就变得很重要。</p>\n<p>在这种情况下，我们有哪些选择对Jupyter代码来进行单元测试？在本文中，我将介绍在Jupyter notebooks中对Python代码进行单元测试的几个选项。</p>\n<p><strong>也许只是不做？</strong></p>\n<p>Jupyter notebook 单元测试的第一个选择是根本不做。这样，我并不是说不要对代码进行单元测试，而是将其从notebook 中提取到单独的Python模块中，然后再将其重新导入notebook 中。应该使用通常对单元代码进行单元测试的方式来测试该代码，无论是使用unittest，pytest，doctest还是其他单元测试框架。本文不会详细介绍所有这些框架，但是对于python开发人员来说，一个不错的选择是不在其Jupyter notebook本中进行测试，而是使用多种可用于Python代码的测试框架，并在开发过程中尽快将代码移至外部模块。</p>\n<h2 id=\"1-在notebook中进行测试\"><a href=\"#1-在notebook中进行测试\" class=\"headerlink\" title=\"1. 在notebook中进行测试\"></a>1. <strong>在notebook中进行测试</strong></h2><p>如果最终决定要将代码保留在Jupyter notebook中，则实际上有一些单元测试选项。在复习其中的一些内容之前，让我们先设置一个在Jupyter notebook中可能会遇到的代码示例。假设您的notebook从API中提取了一些数据，从中计算出一些结果，然后生成了一些图表和其他数据摘要，这些摘要会一直保存在其他地方。也许有一个函数可以产生正确的API URL，我们想对该函数进行单元测试。此功能具有一些逻辑，可以根据报告的日期更改URL格式。这是经过调试的版本。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"keyword\">import</span> dateutil</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_url</span>(<span class=\"params\">date</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the url for our API call based on date.&quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(date, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        date = dateutil.parser.parse(date).date()</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(date, datetime.date):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;must be a date&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> date &gt;= datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v2/<span class=\"subst\">&#123;date.year&#125;</span>/<span class=\"subst\">&#123;date.month&#125;</span>/<span class=\"subst\">&#123;date.day&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v1/<span class=\"subst\">&#123;date:%Y-%m-%d&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-使用unittest进行单元测试\"><a href=\"#2-使用unittest进行单元测试\" class=\"headerlink\" title=\"2. 使用unittest进行单元测试\"></a>2. <strong>使用unittest进行单元测试</strong></h2><p>通常，当我们使用unittest进行测试时，我们会将测试方法放在单独的测试模块中，或者可能将这些方法混入主模块中。然后，我们需要执行<code>unittest.main</code>方法，可能是<code>__main__</code>防护中的默认方法。我们基本上可以在Jupyter notebook中执行相同的操作。我们可以创建一个<code>unitest.TestCase</code>类，执行所需的测试，然后仅在任何单元格中执行单元测试。您只需要保存<code>unittest.main</code>方法的输出并检查是否有错误。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> unittest</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TestUrl</span>(<span class=\"params\">unittest.TestCase</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url_v2</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        date = datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\">        self.assertEqual(make_url(date), <span class=\"string\">&quot;https://api.example.com/v2/2020/1/1&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url_v1</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        date = datetime.date(<span class=\"number\">2019</span>, <span class=\"number\">12</span>, <span class=\"number\">31</span>)</span><br><span class=\"line\">        self.assertEqual(make_url(date), <span class=\"string\">&quot;https://api.example.com/v1/2019-12-31&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        </span><br><span class=\"line\">res = unittest.main(argv=[<span class=\"string\">&#x27;&#x27;</span>], verbosity=<span class=\"number\">3</span>, exit=<span class=\"literal\">False</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># if we want our notebook to stop processing due to failures, we need a cell itself to fail</span></span><br><span class=\"line\"><span class=\"keyword\">assert</span> <span class=\"built_in\">len</span>(res.result.failures) == <span class=\"number\">0</span></span><br><span class=\"line\">test_make_url_v1 (__main__.TestUrl) ... ok</span><br><span class=\"line\">test_make_url_v2 (__main__.TestUrl) ... ok</span><br><span class=\"line\"></span><br><span class=\"line\">----------------------------------------------------------------------</span><br><span class=\"line\">Ran <span class=\"number\">2</span> tests <span class=\"keyword\">in</span> <span class=\"number\">0.001</span>s</span><br><span class=\"line\"></span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>事实证明，这非常简单，如果您不介意在notebook中混合使用代码和进行测试，那么效果很好。</p>\n<h2 id=\"3-使用doctest进行单元测试\"><a href=\"#3-使用doctest进行单元测试\" class=\"headerlink\" title=\"3. 使用doctest进行单元测试\"></a>3. <strong>使用doctest进行单元测试</strong></h2><p>在代码中包含测试的另一种方法是使用doctest。Doctest使用特殊格式的代码文档，其中包括我们的测试和预期结果。下面是包含此特殊代码文档的更新方法，包括正例和负例。这是一种在一个地方测试和记录代码的简单方法，通常会在python模块中使用，main头文件将仅在其中运行doct测试，如下所示：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__ == __main__:</span><br><span class=\"line\">    doctest.testmod()</span><br></pre></td></tr></table></figure>\n<p>由于我们在notebook中，因此只需将其添加到定义了代码的单元格中，它也将起作用。首先，这是我们更新的带有doctest注释的<code>make_url</code>方法。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">make_url</span>(<span class=\"params\">date</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;Return the url for our API call based on date.</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(&quot;1/1/2020&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;https://api.example.com/v2/2020/1/1&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(&quot;1-1-x1&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">        ...</span></span><br><span class=\"line\"><span class=\"string\">    dateutil.parser._parser.ParserError: Unknown string format: 1-1-x1</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(&quot;1/1/20001&quot;)</span></span><br><span class=\"line\"><span class=\"string\">    Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">        ...</span></span><br><span class=\"line\"><span class=\"string\">    dateutil.parser._parser.ParserError: year 20001 is out of range: 1/1/20001</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(datetime.date(2020,1,1))</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;https://api.example.com/v2/2020/1/1&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; make_url(datetime.date(2019,12,31))</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;https://api.example.com/v1/2019-12-31&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(date, <span class=\"built_in\">str</span>):</span><br><span class=\"line\">        date = dateutil.parser.parse(date).date()</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(date, datetime.date):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">&quot;must be a date&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> date &gt;= datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v2/<span class=\"subst\">&#123;date.year&#125;</span>/<span class=\"subst\">&#123;date.month&#125;</span>/<span class=\"subst\">&#123;date.day&#125;</span>&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">f&quot;https://api.example.com/v1/<span class=\"subst\">&#123;date:%Y-%m-%d&#125;</span>&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> doctest</span><br><span class=\"line\">doctest.testmod()</span><br><span class=\"line\">TestResults(failed=<span class=\"number\">0</span>, attempted=<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-用testbook进行单元测试\"><a href=\"#4-用testbook进行单元测试\" class=\"headerlink\" title=\"4. 用testbook进行单元测试\"></a>4. <strong>用testbook进行单元测试</strong></h2><p>testbook项目是notebook 单元测试的另一种方式。它允许您从notebook 外部以纯Python代码方式引用notebook 。这使您可以在单独的Python模块中使用任何您喜欢的测试框架（例如pytest或unittest）。您可能会遇到这样的情况：允许用户修改和更新notebook代码是保持代码更新并为最终用户提供灵活性的最佳方法。但是您可能希望仍单独对代码进行测试和验证。Testbook使其成为一个选项。</p>\n<p>首先，您必须将其安装在您的环境中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip install testbook</span><br></pre></td></tr></table></figure>\n<p>或者在你的notebook中：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%pip install testbook</span><br></pre></td></tr></table></figure>\n<p>现在，在一个单独的python文件中，您可以导入notebook代码并在那里进行测试。在该文件中，您将创建类似于以下代码的代码，然后使用您更喜欢实际执行单元测试的任何单元测试框架。您可以在Python文件中创建以下代码（例如jupyter_unit_tests.py）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"><span class=\"keyword\">import</span> testbook</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@testbook.testbook(<span class=\"params\"><span class=\"string\">&#x27;./jupyter_unit_tests.ipynb&#x27;</span>, execute=<span class=\"literal\">True</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url</span>(<span class=\"params\">tb</span>):</span></span><br><span class=\"line\">    func = tb.ref(<span class=\"string\">&quot;make_url&quot;</span>)</span><br><span class=\"line\">    date = datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> make_url(date) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/1&quot;</span></span><br></pre></td></tr></table></figure>\n<p>在这种情况下，您现在可以使用任何单元测试框架来运行测试。例如，使用pytest，您只需运行以下命令：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pytest jupyter_unit_tests.py</span><br></pre></td></tr></table></figure>\n<p>这可以作为正常的单元测试，并且测试应该通过。但是，在撰写本文时，我意识到testbook代码对将单元测试中的参数传递回notebook内核进行测试的支持有限。这些参数是JSON序列化的，并且当前代码知道如何处理各种Python类型。但是，它不会将日期时间作为对象传递，而是作为字符串传递。由于我们的代码尝试将字符串解析为日期（在我对其进行修改之后），因此它可以工作。换句话说，上面的单元测试不是将<code>datetime.date</code>传递给<code>make_url</code>方法，而是传递一个字符串（2020-01-02），然后将其解析为一个日期。您如何将日期从单元测试传递到notebook代码中？您有以下几种选择。首先，您可以在notebook中创建一个日期对象，仅用于测试目的，然后在单元测试中引用它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">testdate1 = datetime.date(<span class=\"number\">2020</span>,<span class=\"number\">1</span>,<span class=\"number\">1</span>)  <span class=\"comment\"># for unit test</span></span><br></pre></td></tr></table></figure>\n<p>然后，您可以编写单元测试以在测试中使用该变量。</p>\n<p>第二种选择是将Python代码写入notebook，然后在单元测试中重新引用它。这两个选项都显示在外部单元测试的最终版本中。只需将其保存在<code>jupyter_unit_tests.py</code>上，然后使用您喜欢的单元测试框架来运行它。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> testbook</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@testbook.testbook(<span class=\"params\"><span class=\"string\">&#x27;./jupyter_unit_tests.ipynb&#x27;</span>, execute=<span class=\"literal\">True</span></span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_make_url</span>(<span class=\"params\">tb</span>):</span></span><br><span class=\"line\">    f = tb.ref(<span class=\"string\">&quot;make_url&quot;</span>)</span><br><span class=\"line\">    d = <span class=\"string\">&quot;2020-01-02&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># note that this is actually converted to a string</span></span><br><span class=\"line\">    d = datetime.date(<span class=\"number\">2020</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># this one will be testing the date functionality</span></span><br><span class=\"line\">    d2 = tb.ref(<span class=\"string\">&quot;testdate1&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d2) == <span class=\"string\">&quot;https://api.example.com/v2/2020/1/1&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># this one will inject similar code as above, then use it</span></span><br><span class=\"line\">    tb.inject(<span class=\"string\">&quot;d3 = datetime.date(2020, 2, 3)&quot;</span>)</span><br><span class=\"line\">    d3 = tb.ref(<span class=\"string\">&quot;d3&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">assert</span> f(d3) == <span class=\"string\">&quot;https://api.example.com/v2/2020/2/3&quot;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"5-总结\"><a href=\"#5-总结\" class=\"headerlink\" title=\"5. 总结\"></a>5. <strong>总结</strong></h2><p>因此，无论您是单元测试的纯粹主义者还是只想在notebooks中添加一些单元测试，您都可以考虑以上几种选择。不要让notebooks的使用妨碍您在测试代码方面做正确的事情。</p>\n"},{"title":"asm goto与JUMP_LABEL","date":"2020-12-31T15:59:00.000Z","abbrlink":15000,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n## asm goto与JUMP_LABEL\n\n版权声明：本文为CSDN博主「dog250」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n\n原文链接：https://blog.csdn.net/dog250/article/details/6123517\n\n------\n\n越来越多的工作现如今都交给了编译器，甚至连动态代码修改的数据组织这种事都交给了编译器。gcc提供了一个特性用于嵌入式汇编，那就是asm goto，其实这个特性没有什么神秘之处，就是在嵌入式汇编中go to到c代码的label，其最简单的用法如下(来自gcc的文档)：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/29b980e2bc932adf7464c8f17c5302cd.png)\n\nasm goto其实就是在outputs，inputs，registers-modified之外提供了嵌入式汇编的第四个“:”，后面可以跟一系列的c语言的label，然后你可以在嵌入式汇编中go to到这些label中一个。然而使用asm goto可以巧妙地将“一个大家都能想到的点子”规范化，就是说你只需要调用一个统一的接口--一个宏，编译器就将你想实现的东西给实现了，要不然代码写起来会很麻烦，这点上，编译器不嫌麻烦。这一个大家都能想出的点子的由来还得从内核的效率说起。\n\n以下的代码来自lwn的《Jump label》：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/fff4bc0460b6a42964f0707e37e2fdfc.png)\n\n即使有了unlikey优化，既然有if判断，cpu的分支预测就有可能失败，再者do_trace在代码上离if这么近，即使编译器再聪明，二进制代码的do_trace也不会离前面的代码太远的，这样由于局部性原理和cpu的预取机制，do_trace的代码很有可能就被预取入了cpu的cache，就算我们从来不打算trace代码也是如此。\n\n   我们需要的是如果不开启trace，那么do_trace永远不被欲取或者被预测，唯一的办法就是去掉if判断，永远不调用goto语句，像下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/f20c49b0c9978b8ef05c5f21b3086abb.png)\n\n在运行时修改载入内存的二进制代码就是我们大家都能想到的点子，就是说在运行的时候当我们知道trace_foo_enabled在某一时刻被设置为0的时候，我们动态的将二进制代码修改掉，将if代码段去掉，这样一个分支预测就不存在了，而且trace_foo_enabled这一个变量也不需要再被访问了(该变量在内存中，访问它肯定会涉及load/flush cache的动作，为了一个很可能没有用的变量操作cache很不值)。提前要说的是，我们可以使用这种方式去掉所有的分支预测，然而这并不可取，因为程序是动态运行的，很多用于判断的变量值都是根据程序的执行瞬息万变，正是这种根据判断结果采取不同动作的机制给与了程序灵活性，如果每当我们确定一个值时就修改二进制代码取消分支预测的话，其本身的开销将会远远大于分支预测的开销，更重要的是，紧接着那个值又变化了，我们不得不再次修改二进制代码，这期间要访问那个变量好几次。所以，只有在我们确定不经常变化的变量的判断上才能用这种方式取消分支预测，而像trace与否的判断正好符合我们的需求。\n\n   gcc编译器提供了asm goto的机制来满足我们的需求，使得我们可以在asm goto的基础上构建出一个叫做jump label的东西。下面的代码段说明了jump label的用法和原理：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/6bac3d6ecb4de4fb911fdea52ac3b685.png)\n\n标号0仅仅执行一个nop，不涉及cache，后面的pushp保存现有的p，很多情况下当前的p就是text，然后定义一个“表”，表中有两个元素：0b和trace#NUM，其实就是两个标号，在asm goto机制中，标号还可以更多，它们在嵌入式汇编的最后一个“:”后面依次排布。这些标号就是供选择的标号，执行流将跳入其中的一个标号处，具体跳到哪一个就看当前的二进制代码被修改成了“跳到哪一个”，因此asm goto为我们做的仅仅是提供一个地方(一个“:”)供我们将label传入，保存了一系列的表还是需要我们的c代码逻辑--jump label实现，这些表(其实就是一系列的三元组)方便我们根据这些表来修改运行中的二进制代码，最终修改二进制代码还是要由我们自己写代码完成的。\n\n   有了这个asm goto以及我们jump label代码的支持，内核对于是否trace这种小事就再也不用愁了(使用中的kernel一般是不用trace的，只有在出了问题以后或者调试内核时才使用trace，因此在主代码中加入“是否trace”的判断实在是一种沉重的负担)，如果对于某一个函数不需要trace，内核只需要执行一个操作将asm goto附近的代码改掉即可，比如改称下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/1cb5ae3625df65f6dd793016bd6ba1b8.png)\n\n如果需要trace，那么就改成：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/67b8b0eb1f1a2653847f192d3419f03d.png)\n\n这一切在kernel中的用法如下：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/c64bae7e63e732efcd28ab9f5698094a.png)\n\n第一行的“1”是一个标号，该标号后的代码执行的内容就是nop-第二行，第三行重新开始了一个p，这样的意义很大，下面的三元组：[instruction address] [jump target] [tracepoint key]的二进制代码就不会紧接着标号1(nop)了，这个三元组就是jump label机制的核心，指示了所有可能跳转到的标号，这里的技巧在于标号1，标号1也作为一个合法的可能跳转到的标号存在，和标号label是并列的，由于pushp和popp的存在，上面的代码汇编结果看起来是下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/5ab2c7d479df91a760c9d4a5a3c910a8.png)\n\n如果启用了trace，那么只需要将标号1修改成标号label就可以了：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/af59ab58bba48a1b8eb5365af15a3713.png)\n\n内核之所以能够找到需要修改代码的地址，就是借助于上面说的那个三元组(instruction address,jump target,tracepoint key)，其中instruction address就是这个地址，在linux的JUMP  LABEL机制中，它固定为标号1，也就是nop的标号，如果不启用trace，那么直接执行nop，如果启用了trace，那么将nop修改为jmp label即可，如果后来又禁用了trace，只需将它再次修改成三元组中的标号1即可，这一切过程中，三元组本身是不会改变的。注意，三元组中的tracepoint key在jump label机制中并没有什么实质的意义，它仅仅是为了组织kernel中“是否trace”变量用的，所有的“是否trace”变量组织成一个链表，链表的每一个节点下面挂着另一个子链表，该子链表中元素是所有使用这个“是否trace”变量的代码环境，包括代码的地址，标号的地址等。\n\n   下面看一下kernel对于JUMP_LABEL的实现框架。首先看一下三元组的数据结构：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/36bf84b3afa4158dd7d0aff0ee6e7a85.png)\n\n其次一个比较重要的数据结构是一个key节点，表示一个“是否trace”的变量：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bf51de614427cbe876e34154c0d163ed.png)\n\n启用一个trace意味着需要将一个key(类似于trace_foo_enabled)设置为1，然后修改所有判断该key的代码附近的二进制代码：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/8d12750add3c38f5500d3df3ce376fd3.png)\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bcf035cdda2f9ec3b303a4246f873571.png)\n\n以上就是使用asm goto实现的jump label，在2.6.37内核中被引入。\n\n附：.p以及.previous\n\n在汇编语言中使用.p和.previous指令可以将它们之间的代码编译到不同的p中，也就是不紧接着.p上面的代码。linux kernel中的异常处理就是用这两个伪指令实现的，定义了一个叫做fix的p和一个叫做ex_table的p，可能出现exception的代码用一个标号表示，ex_table中保存了一些二元组(出现异常代码的标号,异常处理程序的标号)，异常处理程序在fix这个p中，这样虽然代码看起来是下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/795f16a399b397a69fe06e8feaea5cbd.png)\n\n然而编译器会将fix和ex_table放到离text很远的地方的，这样cpu预取时就不会将fix或者ex_table的代码预取到执行cache了，只有在发生异常的时候才会使用fix和ex_table，而发生异常毕竟是一种罕见现象，这就是一种优化。","source":"_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL.md","raw":"---\ntitle: asm goto与JUMP_LABEL\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 学习笔记\nabbrlink: 15000\ncover: \n---\n\n## asm goto与JUMP_LABEL\n\n版权声明：本文为CSDN博主「dog250」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n\n原文链接：https://blog.csdn.net/dog250/article/details/6123517\n\n------\n\n越来越多的工作现如今都交给了编译器，甚至连动态代码修改的数据组织这种事都交给了编译器。gcc提供了一个特性用于嵌入式汇编，那就是asm goto，其实这个特性没有什么神秘之处，就是在嵌入式汇编中go to到c代码的label，其最简单的用法如下(来自gcc的文档)：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/29b980e2bc932adf7464c8f17c5302cd.png)\n\nasm goto其实就是在outputs，inputs，registers-modified之外提供了嵌入式汇编的第四个“:”，后面可以跟一系列的c语言的label，然后你可以在嵌入式汇编中go to到这些label中一个。然而使用asm goto可以巧妙地将“一个大家都能想到的点子”规范化，就是说你只需要调用一个统一的接口--一个宏，编译器就将你想实现的东西给实现了，要不然代码写起来会很麻烦，这点上，编译器不嫌麻烦。这一个大家都能想出的点子的由来还得从内核的效率说起。\n\n以下的代码来自lwn的《Jump label》：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/fff4bc0460b6a42964f0707e37e2fdfc.png)\n\n即使有了unlikey优化，既然有if判断，cpu的分支预测就有可能失败，再者do_trace在代码上离if这么近，即使编译器再聪明，二进制代码的do_trace也不会离前面的代码太远的，这样由于局部性原理和cpu的预取机制，do_trace的代码很有可能就被预取入了cpu的cache，就算我们从来不打算trace代码也是如此。\n\n   我们需要的是如果不开启trace，那么do_trace永远不被欲取或者被预测，唯一的办法就是去掉if判断，永远不调用goto语句，像下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/f20c49b0c9978b8ef05c5f21b3086abb.png)\n\n在运行时修改载入内存的二进制代码就是我们大家都能想到的点子，就是说在运行的时候当我们知道trace_foo_enabled在某一时刻被设置为0的时候，我们动态的将二进制代码修改掉，将if代码段去掉，这样一个分支预测就不存在了，而且trace_foo_enabled这一个变量也不需要再被访问了(该变量在内存中，访问它肯定会涉及load/flush cache的动作，为了一个很可能没有用的变量操作cache很不值)。提前要说的是，我们可以使用这种方式去掉所有的分支预测，然而这并不可取，因为程序是动态运行的，很多用于判断的变量值都是根据程序的执行瞬息万变，正是这种根据判断结果采取不同动作的机制给与了程序灵活性，如果每当我们确定一个值时就修改二进制代码取消分支预测的话，其本身的开销将会远远大于分支预测的开销，更重要的是，紧接着那个值又变化了，我们不得不再次修改二进制代码，这期间要访问那个变量好几次。所以，只有在我们确定不经常变化的变量的判断上才能用这种方式取消分支预测，而像trace与否的判断正好符合我们的需求。\n\n   gcc编译器提供了asm goto的机制来满足我们的需求，使得我们可以在asm goto的基础上构建出一个叫做jump label的东西。下面的代码段说明了jump label的用法和原理：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/6bac3d6ecb4de4fb911fdea52ac3b685.png)\n\n标号0仅仅执行一个nop，不涉及cache，后面的pushp保存现有的p，很多情况下当前的p就是text，然后定义一个“表”，表中有两个元素：0b和trace#NUM，其实就是两个标号，在asm goto机制中，标号还可以更多，它们在嵌入式汇编的最后一个“:”后面依次排布。这些标号就是供选择的标号，执行流将跳入其中的一个标号处，具体跳到哪一个就看当前的二进制代码被修改成了“跳到哪一个”，因此asm goto为我们做的仅仅是提供一个地方(一个“:”)供我们将label传入，保存了一系列的表还是需要我们的c代码逻辑--jump label实现，这些表(其实就是一系列的三元组)方便我们根据这些表来修改运行中的二进制代码，最终修改二进制代码还是要由我们自己写代码完成的。\n\n   有了这个asm goto以及我们jump label代码的支持，内核对于是否trace这种小事就再也不用愁了(使用中的kernel一般是不用trace的，只有在出了问题以后或者调试内核时才使用trace，因此在主代码中加入“是否trace”的判断实在是一种沉重的负担)，如果对于某一个函数不需要trace，内核只需要执行一个操作将asm goto附近的代码改掉即可，比如改称下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/1cb5ae3625df65f6dd793016bd6ba1b8.png)\n\n如果需要trace，那么就改成：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/67b8b0eb1f1a2653847f192d3419f03d.png)\n\n这一切在kernel中的用法如下：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/c64bae7e63e732efcd28ab9f5698094a.png)\n\n第一行的“1”是一个标号，该标号后的代码执行的内容就是nop-第二行，第三行重新开始了一个p，这样的意义很大，下面的三元组：[instruction address] [jump target] [tracepoint key]的二进制代码就不会紧接着标号1(nop)了，这个三元组就是jump label机制的核心，指示了所有可能跳转到的标号，这里的技巧在于标号1，标号1也作为一个合法的可能跳转到的标号存在，和标号label是并列的，由于pushp和popp的存在，上面的代码汇编结果看起来是下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/5ab2c7d479df91a760c9d4a5a3c910a8.png)\n\n如果启用了trace，那么只需要将标号1修改成标号label就可以了：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/af59ab58bba48a1b8eb5365af15a3713.png)\n\n内核之所以能够找到需要修改代码的地址，就是借助于上面说的那个三元组(instruction address,jump target,tracepoint key)，其中instruction address就是这个地址，在linux的JUMP  LABEL机制中，它固定为标号1，也就是nop的标号，如果不启用trace，那么直接执行nop，如果启用了trace，那么将nop修改为jmp label即可，如果后来又禁用了trace，只需将它再次修改成三元组中的标号1即可，这一切过程中，三元组本身是不会改变的。注意，三元组中的tracepoint key在jump label机制中并没有什么实质的意义，它仅仅是为了组织kernel中“是否trace”变量用的，所有的“是否trace”变量组织成一个链表，链表的每一个节点下面挂着另一个子链表，该子链表中元素是所有使用这个“是否trace”变量的代码环境，包括代码的地址，标号的地址等。\n\n   下面看一下kernel对于JUMP_LABEL的实现框架。首先看一下三元组的数据结构：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/36bf84b3afa4158dd7d0aff0ee6e7a85.png)\n\n其次一个比较重要的数据结构是一个key节点，表示一个“是否trace”的变量：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bf51de614427cbe876e34154c0d163ed.png)\n\n启用一个trace意味着需要将一个key(类似于trace_foo_enabled)设置为1，然后修改所有判断该key的代码附近的二进制代码：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/8d12750add3c38f5500d3df3ce376fd3.png)\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bcf035cdda2f9ec3b303a4246f873571.png)\n\n以上就是使用asm goto实现的jump label，在2.6.37内核中被引入。\n\n附：.p以及.previous\n\n在汇编语言中使用.p和.previous指令可以将它们之间的代码编译到不同的p中，也就是不紧接着.p上面的代码。linux kernel中的异常处理就是用这两个伪指令实现的，定义了一个叫做fix的p和一个叫做ex_table的p，可能出现exception的代码用一个标号表示，ex_table中保存了一些二元组(出现异常代码的标号,异常处理程序的标号)，异常处理程序在fix这个p中，这样虽然代码看起来是下面这样：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/795f16a399b397a69fe06e8feaea5cbd.png)\n\n然而编译器会将fix和ex_table放到离text很远的地方的，这样cpu预取时就不会将fix或者ex_table的代码预取到执行cache了，只有在发生异常的时候才会使用fix和ex_table，而发生异常毕竟是一种罕见现象，这就是一种优化。","slug":"linux_md/Linux Basic/asm goto与JUMP_LABEL","published":1,"updated":"2021-04-08T14:10:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr60001jw9q931gzhrtm","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h2 id=\"asm-goto与JUMP-LABEL\"><a href=\"#asm-goto与JUMP-LABEL\" class=\"headerlink\" title=\"asm goto与JUMP_LABEL\"></a>asm goto与JUMP_LABEL</h2><p>版权声明：本文为CSDN博主「dog250」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/dog250/article/details/6123517\">https://blog.csdn.net/dog250/article/details/6123517</a></p>\n<hr>\n<p>越来越多的工作现如今都交给了编译器，甚至连动态代码修改的数据组织这种事都交给了编译器。gcc提供了一个特性用于嵌入式汇编，那就是asm goto，其实这个特性没有什么神秘之处，就是在嵌入式汇编中go to到c代码的label，其最简单的用法如下(来自gcc的文档)：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/29b980e2bc932adf7464c8f17c5302cd.png)</p>\n<p>asm goto其实就是在outputs，inputs，registers-modified之外提供了嵌入式汇编的第四个“:”，后面可以跟一系列的c语言的label，然后你可以在嵌入式汇编中go to到这些label中一个。然而使用asm goto可以巧妙地将“一个大家都能想到的点子”规范化，就是说你只需要调用一个统一的接口–一个宏，编译器就将你想实现的东西给实现了，要不然代码写起来会很麻烦，这点上，编译器不嫌麻烦。这一个大家都能想出的点子的由来还得从内核的效率说起。</p>\n<p>以下的代码来自lwn的《Jump label》：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/fff4bc0460b6a42964f0707e37e2fdfc.png)</p>\n<p>即使有了unlikey优化，既然有if判断，cpu的分支预测就有可能失败，再者do_trace在代码上离if这么近，即使编译器再聪明，二进制代码的do_trace也不会离前面的代码太远的，这样由于局部性原理和cpu的预取机制，do_trace的代码很有可能就被预取入了cpu的cache，就算我们从来不打算trace代码也是如此。</p>\n<p>   我们需要的是如果不开启trace，那么do_trace永远不被欲取或者被预测，唯一的办法就是去掉if判断，永远不调用goto语句，像下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/f20c49b0c9978b8ef05c5f21b3086abb.png)</p>\n<p>在运行时修改载入内存的二进制代码就是我们大家都能想到的点子，就是说在运行的时候当我们知道trace_foo_enabled在某一时刻被设置为0的时候，我们动态的将二进制代码修改掉，将if代码段去掉，这样一个分支预测就不存在了，而且trace_foo_enabled这一个变量也不需要再被访问了(该变量在内存中，访问它肯定会涉及load/flush cache的动作，为了一个很可能没有用的变量操作cache很不值)。提前要说的是，我们可以使用这种方式去掉所有的分支预测，然而这并不可取，因为程序是动态运行的，很多用于判断的变量值都是根据程序的执行瞬息万变，正是这种根据判断结果采取不同动作的机制给与了程序灵活性，如果每当我们确定一个值时就修改二进制代码取消分支预测的话，其本身的开销将会远远大于分支预测的开销，更重要的是，紧接着那个值又变化了，我们不得不再次修改二进制代码，这期间要访问那个变量好几次。所以，只有在我们确定不经常变化的变量的判断上才能用这种方式取消分支预测，而像trace与否的判断正好符合我们的需求。</p>\n<p>   gcc编译器提供了asm goto的机制来满足我们的需求，使得我们可以在asm goto的基础上构建出一个叫做jump label的东西。下面的代码段说明了jump label的用法和原理：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/6bac3d6ecb4de4fb911fdea52ac3b685.png)</p>\n<p>标号0仅仅执行一个nop，不涉及cache，后面的pushp保存现有的p，很多情况下当前的p就是text，然后定义一个“表”，表中有两个元素：0b和trace#NUM，其实就是两个标号，在asm goto机制中，标号还可以更多，它们在嵌入式汇编的最后一个“:”后面依次排布。这些标号就是供选择的标号，执行流将跳入其中的一个标号处，具体跳到哪一个就看当前的二进制代码被修改成了“跳到哪一个”，因此asm goto为我们做的仅仅是提供一个地方(一个“:”)供我们将label传入，保存了一系列的表还是需要我们的c代码逻辑–jump label实现，这些表(其实就是一系列的三元组)方便我们根据这些表来修改运行中的二进制代码，最终修改二进制代码还是要由我们自己写代码完成的。</p>\n<p>   有了这个asm goto以及我们jump label代码的支持，内核对于是否trace这种小事就再也不用愁了(使用中的kernel一般是不用trace的，只有在出了问题以后或者调试内核时才使用trace，因此在主代码中加入“是否trace”的判断实在是一种沉重的负担)，如果对于某一个函数不需要trace，内核只需要执行一个操作将asm goto附近的代码改掉即可，比如改称下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/1cb5ae3625df65f6dd793016bd6ba1b8.png)</p>\n<p>如果需要trace，那么就改成：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/67b8b0eb1f1a2653847f192d3419f03d.png)</p>\n<p>这一切在kernel中的用法如下：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/c64bae7e63e732efcd28ab9f5698094a.png)</p>\n<p>第一行的“1”是一个标号，该标号后的代码执行的内容就是nop-第二行，第三行重新开始了一个p，这样的意义很大，下面的三元组：[instruction address] [jump target] [tracepoint key]的二进制代码就不会紧接着标号1(nop)了，这个三元组就是jump label机制的核心，指示了所有可能跳转到的标号，这里的技巧在于标号1，标号1也作为一个合法的可能跳转到的标号存在，和标号label是并列的，由于pushp和popp的存在，上面的代码汇编结果看起来是下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/5ab2c7d479df91a760c9d4a5a3c910a8.png)</p>\n<p>如果启用了trace，那么只需要将标号1修改成标号label就可以了：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/af59ab58bba48a1b8eb5365af15a3713.png)</p>\n<p>内核之所以能够找到需要修改代码的地址，就是借助于上面说的那个三元组(instruction address,jump target,tracepoint key)，其中instruction address就是这个地址，在linux的JUMP  LABEL机制中，它固定为标号1，也就是nop的标号，如果不启用trace，那么直接执行nop，如果启用了trace，那么将nop修改为jmp label即可，如果后来又禁用了trace，只需将它再次修改成三元组中的标号1即可，这一切过程中，三元组本身是不会改变的。注意，三元组中的tracepoint key在jump label机制中并没有什么实质的意义，它仅仅是为了组织kernel中“是否trace”变量用的，所有的“是否trace”变量组织成一个链表，链表的每一个节点下面挂着另一个子链表，该子链表中元素是所有使用这个“是否trace”变量的代码环境，包括代码的地址，标号的地址等。</p>\n<p>   下面看一下kernel对于JUMP_LABEL的实现框架。首先看一下三元组的数据结构：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/36bf84b3afa4158dd7d0aff0ee6e7a85.png)</p>\n<p>其次一个比较重要的数据结构是一个key节点，表示一个“是否trace”的变量：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bf51de614427cbe876e34154c0d163ed.png)</p>\n<p>启用一个trace意味着需要将一个key(类似于trace_foo_enabled)设置为1，然后修改所有判断该key的代码附近的二进制代码：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/8d12750add3c38f5500d3df3ce376fd3.png)</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bcf035cdda2f9ec3b303a4246f873571.png)</p>\n<p>以上就是使用asm goto实现的jump label，在2.6.37内核中被引入。</p>\n<p>附：.p以及.previous</p>\n<p>在汇编语言中使用.p和.previous指令可以将它们之间的代码编译到不同的p中，也就是不紧接着.p上面的代码。linux kernel中的异常处理就是用这两个伪指令实现的，定义了一个叫做fix的p和一个叫做ex_table的p，可能出现exception的代码用一个标号表示，ex_table中保存了一些二元组(出现异常代码的标号,异常处理程序的标号)，异常处理程序在fix这个p中，这样虽然代码看起来是下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/795f16a399b397a69fe06e8feaea5cbd.png)</p>\n<p>然而编译器会将fix和ex_table放到离text很远的地方的，这样cpu预取时就不会将fix或者ex_table的代码预取到执行cache了，只有在发生异常的时候才会使用fix和ex_table，而发生异常毕竟是一种罕见现象，这就是一种优化。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"asm-goto与JUMP-LABEL\"><a href=\"#asm-goto与JUMP-LABEL\" class=\"headerlink\" title=\"asm goto与JUMP_LABEL\"></a>asm goto与JUMP_LABEL</h2><p>版权声明：本文为CSDN博主「dog250」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>\n<p>原文链接：<a href=\"https://blog.csdn.net/dog250/article/details/6123517\">https://blog.csdn.net/dog250/article/details/6123517</a></p>\n<hr>\n<p>越来越多的工作现如今都交给了编译器，甚至连动态代码修改的数据组织这种事都交给了编译器。gcc提供了一个特性用于嵌入式汇编，那就是asm goto，其实这个特性没有什么神秘之处，就是在嵌入式汇编中go to到c代码的label，其最简单的用法如下(来自gcc的文档)：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/29b980e2bc932adf7464c8f17c5302cd.png)</p>\n<p>asm goto其实就是在outputs，inputs，registers-modified之外提供了嵌入式汇编的第四个“:”，后面可以跟一系列的c语言的label，然后你可以在嵌入式汇编中go to到这些label中一个。然而使用asm goto可以巧妙地将“一个大家都能想到的点子”规范化，就是说你只需要调用一个统一的接口–一个宏，编译器就将你想实现的东西给实现了，要不然代码写起来会很麻烦，这点上，编译器不嫌麻烦。这一个大家都能想出的点子的由来还得从内核的效率说起。</p>\n<p>以下的代码来自lwn的《Jump label》：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/fff4bc0460b6a42964f0707e37e2fdfc.png)</p>\n<p>即使有了unlikey优化，既然有if判断，cpu的分支预测就有可能失败，再者do_trace在代码上离if这么近，即使编译器再聪明，二进制代码的do_trace也不会离前面的代码太远的，这样由于局部性原理和cpu的预取机制，do_trace的代码很有可能就被预取入了cpu的cache，就算我们从来不打算trace代码也是如此。</p>\n<p>   我们需要的是如果不开启trace，那么do_trace永远不被欲取或者被预测，唯一的办法就是去掉if判断，永远不调用goto语句，像下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/f20c49b0c9978b8ef05c5f21b3086abb.png)</p>\n<p>在运行时修改载入内存的二进制代码就是我们大家都能想到的点子，就是说在运行的时候当我们知道trace_foo_enabled在某一时刻被设置为0的时候，我们动态的将二进制代码修改掉，将if代码段去掉，这样一个分支预测就不存在了，而且trace_foo_enabled这一个变量也不需要再被访问了(该变量在内存中，访问它肯定会涉及load/flush cache的动作，为了一个很可能没有用的变量操作cache很不值)。提前要说的是，我们可以使用这种方式去掉所有的分支预测，然而这并不可取，因为程序是动态运行的，很多用于判断的变量值都是根据程序的执行瞬息万变，正是这种根据判断结果采取不同动作的机制给与了程序灵活性，如果每当我们确定一个值时就修改二进制代码取消分支预测的话，其本身的开销将会远远大于分支预测的开销，更重要的是，紧接着那个值又变化了，我们不得不再次修改二进制代码，这期间要访问那个变量好几次。所以，只有在我们确定不经常变化的变量的判断上才能用这种方式取消分支预测，而像trace与否的判断正好符合我们的需求。</p>\n<p>   gcc编译器提供了asm goto的机制来满足我们的需求，使得我们可以在asm goto的基础上构建出一个叫做jump label的东西。下面的代码段说明了jump label的用法和原理：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/6bac3d6ecb4de4fb911fdea52ac3b685.png)</p>\n<p>标号0仅仅执行一个nop，不涉及cache，后面的pushp保存现有的p，很多情况下当前的p就是text，然后定义一个“表”，表中有两个元素：0b和trace#NUM，其实就是两个标号，在asm goto机制中，标号还可以更多，它们在嵌入式汇编的最后一个“:”后面依次排布。这些标号就是供选择的标号，执行流将跳入其中的一个标号处，具体跳到哪一个就看当前的二进制代码被修改成了“跳到哪一个”，因此asm goto为我们做的仅仅是提供一个地方(一个“:”)供我们将label传入，保存了一系列的表还是需要我们的c代码逻辑–jump label实现，这些表(其实就是一系列的三元组)方便我们根据这些表来修改运行中的二进制代码，最终修改二进制代码还是要由我们自己写代码完成的。</p>\n<p>   有了这个asm goto以及我们jump label代码的支持，内核对于是否trace这种小事就再也不用愁了(使用中的kernel一般是不用trace的，只有在出了问题以后或者调试内核时才使用trace，因此在主代码中加入“是否trace”的判断实在是一种沉重的负担)，如果对于某一个函数不需要trace，内核只需要执行一个操作将asm goto附近的代码改掉即可，比如改称下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/1cb5ae3625df65f6dd793016bd6ba1b8.png)</p>\n<p>如果需要trace，那么就改成：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/67b8b0eb1f1a2653847f192d3419f03d.png)</p>\n<p>这一切在kernel中的用法如下：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/c64bae7e63e732efcd28ab9f5698094a.png)</p>\n<p>第一行的“1”是一个标号，该标号后的代码执行的内容就是nop-第二行，第三行重新开始了一个p，这样的意义很大，下面的三元组：[instruction address] [jump target] [tracepoint key]的二进制代码就不会紧接着标号1(nop)了，这个三元组就是jump label机制的核心，指示了所有可能跳转到的标号，这里的技巧在于标号1，标号1也作为一个合法的可能跳转到的标号存在，和标号label是并列的，由于pushp和popp的存在，上面的代码汇编结果看起来是下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/5ab2c7d479df91a760c9d4a5a3c910a8.png)</p>\n<p>如果启用了trace，那么只需要将标号1修改成标号label就可以了：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/af59ab58bba48a1b8eb5365af15a3713.png)</p>\n<p>内核之所以能够找到需要修改代码的地址，就是借助于上面说的那个三元组(instruction address,jump target,tracepoint key)，其中instruction address就是这个地址，在linux的JUMP  LABEL机制中，它固定为标号1，也就是nop的标号，如果不启用trace，那么直接执行nop，如果启用了trace，那么将nop修改为jmp label即可，如果后来又禁用了trace，只需将它再次修改成三元组中的标号1即可，这一切过程中，三元组本身是不会改变的。注意，三元组中的tracepoint key在jump label机制中并没有什么实质的意义，它仅仅是为了组织kernel中“是否trace”变量用的，所有的“是否trace”变量组织成一个链表，链表的每一个节点下面挂着另一个子链表，该子链表中元素是所有使用这个“是否trace”变量的代码环境，包括代码的地址，标号的地址等。</p>\n<p>   下面看一下kernel对于JUMP_LABEL的实现框架。首先看一下三元组的数据结构：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/36bf84b3afa4158dd7d0aff0ee6e7a85.png)</p>\n<p>其次一个比较重要的数据结构是一个key节点，表示一个“是否trace”的变量：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bf51de614427cbe876e34154c0d163ed.png)</p>\n<p>启用一个trace意味着需要将一个key(类似于trace_foo_enabled)设置为1，然后修改所有判断该key的代码附近的二进制代码：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/8d12750add3c38f5500d3df3ce376fd3.png)</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bcf035cdda2f9ec3b303a4246f873571.png)</p>\n<p>以上就是使用asm goto实现的jump label，在2.6.37内核中被引入。</p>\n<p>附：.p以及.previous</p>\n<p>在汇编语言中使用.p和.previous指令可以将它们之间的代码编译到不同的p中，也就是不紧接着.p上面的代码。linux kernel中的异常处理就是用这两个伪指令实现的，定义了一个叫做fix的p和一个叫做ex_table的p，可能出现exception的代码用一个标号表示，ex_table中保存了一些二元组(出现异常代码的标号,异常处理程序的标号)，异常处理程序在fix这个p中，这样虽然代码看起来是下面这样：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/795f16a399b397a69fe06e8feaea5cbd.png)</p>\n<p>然而编译器会将fix和ex_table放到离text很远的地方的，这样cpu预取时就不会将fix或者ex_table的代码预取到执行cache了，只有在发生异常的时候才会使用fix和ex_table，而发生异常毕竟是一种罕见现象，这就是一种优化。</p>\n"},{"title":"世上最好的共享内存","date":"2020-12-31T15:59:00.000Z","abbrlink":15001,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n## 宋宝华：世上最好的共享内存\n\n\n\n共享单车、共享充电宝、共享雨伞，世间的共享有千万种，而我独爱共享内存。\n\n早期的共享内存，着重于强调把同一片内存，map到多个进程的虚拟地址空间（在相应进程找到一个VMA区域），以便于CPU可以在各个进程访问到这片内存。\n\n![img](./世上最好的共享内存/format,png.png)\n\n现阶段广泛应用于多媒体、Graphics领域的共享内存方式，某种意义上不再强调映射到进程虚拟地址空间的概念（那无非是为了让CPU访问），而更强调以某种“句柄”的形式，让大家知道某一片视频、图形图像数据的存在并可以借助此“句柄”来跨进程引用这片内存，让视频encoder、decoder、GPU等可以跨进程访问内存。所以不同进程用的加速硬件其实是不同的，他们更在乎的是可以通过一个handle拿到这片内存，而不再特别在乎CPU访问它的虚拟地址（当然仍然可以映射到进程的虚拟地址空间供CPU访问）。\n\n![img](./世上最好的共享内存/format,png-20210408215011301.png)\n\n只要内存的拷贝(memcpy)仍然是一个占据内存带宽、CPU利用率的消耗大户存在，共享内存作为Linux进程间通信、计算机系统里各个不同硬件组件通信的最高效方法，都将持续繁荣。关于内存拷贝会大多程度地占据CPU利用率，这个可以最简单地尝试拷贝1080P，帧率每秒60的电影画面，我保证你的系统的CPU，蛋会疼地不行。\n\n我早就想系统地写一篇综述Linux里面各种共享内存方式的文章了，但是一直被带娃这个事业牵绊，今日我决定顶着娃娃们的山呼海啸，也要写一篇文章不吐不快。\n\n共享内存的方式有很多种，目前主流的方式仍然有：\n\n![img](./世上最好的共享内存/format,png-20210408215025345.png)\n\n共享内存的方式\n\n1.基于传统SYS V的共享内存；\n\n2.基于POSIX mmap文件映射实现共享内存；\n\n3.通过memfd_create()和fd跨进程共享实现共享内存；\n\n4.多媒体、图形领域广泛使用的基于dma-buf的共享内存。\n\n共享内存\n\nSYS V共享内存\n\n历史悠久、年代久远、API怪异，对应内核代码linux/ipc/shm.c，当你编译内核的时候不选择CONFIG_SYSVIPC，则不再具备此能力。\n\n你在Linux敲ipcs命令看到的share memory就是这种共享内存：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.jpeg)\n\n下面写一个最简单的程序来看共享内存的写端sw.c：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215041892.png)\n\n以及共享内存的读端sr.c：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215049945.png)\n\n编译和准备运行：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215056849.png)\n\n在此之前我们看一下系统的free:\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215103876.png)\n\n下面运行sw和sr：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215112625.png)\n\n我们发现sr打印出来的和sw写进去的是一致的。这个时候我们再看下free：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215118480.png)\n\n可以看到used显著增大了（711632 -> 715908）, shared显著地增大了（2264 -> 6360），而cached这一列也显著地增大326604->330716。\n\n我们都知道cached这一列统计的是file-backed的文件的page cache的大小。理论上，共享内存属于匿名页，但是由于这里面有个非常特殊的tmpfs（/dev/shm指向/run/shm,/run/shm则mount为tmpfs）：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215127651.png)\n\n所以可以看出tmpfs的东西其实真的是有点含混：我们可以理解它为file-backed的匿名页（anonymous page），有点类似女声中的周深。前面我们反复强调，匿名页是没有文件背景的，这样当进行内存交换的时候，是与swap分区交换。磁盘文件系统里面的东西在内存的副本是file-backed的页面，所以不存在与swap分区交换的问题。但是tmpfs里面的东西，真的是在统计意义上统计到page cache了，但是它并没有真实的磁盘背景，这又和你访问磁盘文件系统里面的文件产生的page cache有本质的区别。所以，它是真地有那么一点misc的感觉，凡事都没有绝对，唯有变化本身是不变的。\n\n也可以通过ipcs找到新创建的SYS V共享内存：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215135031.jpeg)\n\nPOSIX共享内存\n\n我对POSIX shm_open()、mmap () API系列的共享内存的喜爱，远远超过SYS V 100倍。原谅我就是一个懒惰的人，我就是讨厌ftok、shmget、shmat、shmdt这样的API。\n\n上面的程序如果用POSIX的写法，可以简化成写端psw.c：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215142219.png)\n\n读端：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215150439.png)\n\n编译和执行：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215157588.png)\n\n这样我们会在/dev/shm/、/run/shm下面看到一个文件：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215203155.png)\n\n坦白讲，mmap、munmap这样的API让我找到了回家的感觉，刚入行做Linux的时候，写好framebuffer驱动后，就是把/dev/fb0 mmap到用户空间来操作，所以mmap这样的 API，真的是特别亲切，像亲人一样。\n\n当然，如果你不喜欢shm_open()这个API，你也可以用常规的open来打开文件，然后进行mmap。关键的是mmap，wikipedia如是说：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215211094.png)\n\nmmap\n\nIn computing, mmap(2) is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O. It implements demand paging, because file contents are not read from disk directly and initially do not use physical RAM at all. The actual reads from disk are performed in a \"lazy\" manner, after a specific location is accessed. After the memory is no longer needed, it is important to munmap(2) the pointers to it. Protection information can be managed using mprotect(2), and special treatment can be enforced using madvise(2).\n\nPOSIX的共享内存，仍然符合我们前面说的tmpfs的特点，在运行了sw,sr后，再运行psw和psr，我们发现free命令再次戏剧性变化：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215219100.png)\n\n请将这个free命令的结果与前2次的free结果的各个字段进行对照:\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215225519.jpeg)\n\n第3次比第2次的cached大了这么多？是因为我编写这篇文章边在访问磁盘里面的文件，当然POSIX的这个共享内存本身也导致cached增大了。\n\nmemfd_create\n\n如果说POSIX的mmap让我找到回家的感觉，那么memfd_create()则是万般惊艳。见过这种API，才知道什么叫天生尤物——而且是尤物中的尤物，它完全属于那种让码农第一眼看到就会两眼充血，恨不得眼珠子夺眶而出贴到它身上去的那种API；一般人见到它第一次，都会忽略了它的长相，因为它的身材实在太火辣太抢眼了。\n\n先不要浮想联翩，在所有的所有开始之前，我们要先提一下跨进程分享fd（文件描述符，对应我们很多时候说的“句柄”）这个重要的概念。\n\n众所周知，Linux的fd属于一个进程级别的东西。进入每个进程的/proc/pid/fd可以看到它的fd的列表：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215235412.png)\n\n这个进程的0，1，2和那个进程的0，1，2不是一回事。\n\n某年某月的某一天，人们发现，一个进程其实想访问另外一个进程的fd。当然，这只是目的不是手段。比如进程A有2个fd指向2片内存，如果进程B可以拿到这2个fd，其实就可以透过这2个fd访问到这2片内存。这个fd某种意义上充当了一个中间媒介的作用。有人说，那还不简单吗，如果进程A:\n\nfd = open();\n\nopen()如果返回100，把这个100告诉进程B不就可以了吗，进程B访问这个100就可以了。这说明你还是没搞明白fd是一个进程内部的东西，是不能跨进程的概念。你的100和我的100，不是一个东西。这些基本的东西你搞不明白，你搞别的都是白搭。\n\nLinux提供一个特殊的方法，可以把一个进程的fd甩锅、踢皮球给另外一个进程（其实“甩锅”这个词用在这里不合适，因为“甩锅”是一种推卸，而fd的传递是一种分享）。我特码一直想把我的bug甩（分）锅（享）出去，却发现总是被人把bug甩锅过来。\n\n那么如何甩（分）锅（享）fd呢？\n\nLinux里面的甩锅需要借助cmsg，用于在socket上传递控制消息（也称Ancillary data），使用SCM_RIGHTS，进程可以透过UNIX Socket把一个或者多个fd(file descriptor)传递给另外一个进程。\n\n比如下面的这个函数，可以透过socket把fds指向的n个fd发送给另外一个进程：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215243422.png)\n\n而另外一个进程，则可以透过如下函数接受这个fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215249606.png)\n\n那么问题来了，如果在进程A中有一个文件的fd是100，发送给进程B后，它还是100吗？不能这么简单地理解，fd本身是一个进程级别的概念，每个进程有自己的fd的列表，比如进程B收到进程A的fd的时候，进程B自身fd空间里面自己的前面200个fd都已经被占用了，那么进程B接受到的fd就可能是201。数字本身在Linux的fd里面真地是一点都不重要，除了几个特殊的0,1,2这样的数字外。同样的，如果你把 cat /proc/interrupts 显示出的中断号就看成是硬件里面的中断偏移号码(比如ARM GIC里某号硬件中断)，你会发现，这个关系整个是一个瞎扯。\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215257440.png)\n\n知道了甩锅API，那么重要的是，当它与memfd_create()结合的时候，我们准备甩出去的fd是怎么来？它是memfd_create()的返回值。\n\nmemfd_create()这个函数的玄妙之处在于它会返回一个“匿名”内存“文件”的fd，而它本身并没有实体的文件系统路径，其典型用法如下：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215306929.png)\n\n我们透过memfd_create()创建了一个“文件”，但是它实际映射到一片内存，而且在/xxx/yyy/zzz这样的文件系统下没有路径！没有路径！没有路径！\n\n所以，当你在Linux里面编程的时候，碰到这样的场景：需要一个fd，当成文件一样操作，但是又不需要真实地位于文件系统，那么，就请立即使用memfd_create()吧，它的manual page是这样描述的：\n\nmemfd_create\n\nmemfd_create() creates an anonymous file and returns a file descriptor that refers to it.  The file behaves like a regular file, and so can be modified, truncated, memory-mapped, and so on.\nHowever, unlike a regular file, it lives in RAM and has a volatile backing storage.\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.gif)\n\n重点理解其中的regular这个单词。它的行动像一个regular的文件，但是它的背景却不regular。\n\n那么，它和前面我们说的透过UNIX Socket甩锅fd又有什么关系呢？memfd_create()得到了fd，它在行为上类似规则的fd，所以也可以透过socket来进行甩锅，这样A进程相当于把一片与fd对应的内存，分享给了进程B。\n\n下面的代码进程A通过memfd_create()创建了2片4MB的内存，并且透过socket（路径/tmp/fd-pass.socket）发送给进程B这2片内存对应的fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215333648.jpeg)\n\n下面的代码进程B透过相同的socket接受这2片内存对应的fd，之后通过read()读取每个文件的前256个字节并打印：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215340645.jpeg)\n\n上述代码参考了: \n\nhttps://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/\n\n上述的代码中，进程B是在进行read(fds[i], buffer, sizeof(buffer))，这体现了基于fd进行操作的regular特点。当然，如果是共享内存，现实的代码肯定还是多半会是mmap：\n\nmmap(NULL, SIZE, PROT_READ, MAP_SHARED, fd, 0);\n\n那么，透过socket发送memfd_create() fd来进行进程间共享内存这种方法，它究竟惊艳在哪里？\n\n我认为首要的惊艳之处在于编程模型的惊艳。API简单、灵活、通用。进程之间想共享几片内存共享几片内存，想怎么共享怎么共享，想共享给谁共享给谁，无非是多了几个fd和socket的传递过程。比如，我从互联网上面收到了jpeg的视频码流，一帧帧的画面，进程A可以创建多片buffer来缓存画面，然后就可以透过把每片buffer对应的fd，递交给另外的进程去解码等。Avenue to Jane(大道至简)，简单的才是最好的！\n\nmemfd_create()的另外一个惊艳之处在于支持“封印”(sealing，就是你玩游戏的时候的封印)，sealing这个单词本身的意思是封条，在这个场景下，我更愿意把它翻译为“封印”。中国传说中的封印，多是采用如五行、太极、八卦等手段，并可有例如符咒、法器等物品的辅助。现指对某个单位施加一种力量，使其无法正常使用某些能力的本领（常出现于玄幻及神魔类作品，游戏中）。我这一生，最喜欢玩的游戏就是《仙剑奇侠传》和《轩辕剑——天之痕》，不知道是否暴露年龄了。\n\n采用memfd_create()的场景下，我们同样可以用某种法器，来控制共享内存的shrink、grow和write。最初的设想可以详见File Sealing & memfd_create()这篇文章：\n\nhttps://lwn.net/Articles/591108/\n\n我们如果在共享内存上施加了这样的封印，则可以限制对此片区域的ftruncate、write等动作，并建立某种意义上进程之间的相互信任，这是不是很拉风？\n\n还记得镇压孙悟空的五行山顶的封印吗？还记得孙悟空的紧箍咒吗？还记得悟空每次离开师傅的时候在师傅周围画的一个圈吗？\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215351143.jpeg)\n\n封印\n\n* SEAL_SHRINK: If set, the inode size cannot be reduced\n* SEAL_GROW: If set, the inode size cannot be increased\n* SEAL_WRITE: If set, the file content cannot be modified\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215504370.gif)\n\nFile Sealing & memfd_create()文中举到的一个典型使用场景是，如果graphics client把它与graphics compoistor共享的内存交给compoistor去render，compoistor必须保证可以拿到这片内存。这里面的风险是client可能透过ftruncate()把这个memory shrink小，这样compositor就拿不到完整的buffer，会造成crash。所以compositor只愿意接受含有SEAL_SHRINK封印的fd，如果没有，对不起，我们不能一起去西天取经。\n\n在支持memfd_create()后，我们应尽可能地使用这种方式来替代传统的POSIX和SYS V，基本它也是一个趋势，比如我们在wayland相关项目中能看到这样的patch：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215512581.jpeg)\n\ndma_buf\n\ndma_buf定义\n\nThe DMABUF framework provides a generic method for sharing buffers between multiple devices. Device drivers that support DMABUF can export a DMA buffer to userspace as a file descriptor (known as the exporter role), import a DMA buffer from userspace using a file descriptor previously exported for a different or the same device (known as the importer role), or both. \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215521174.gif)\n\n简单地来说，dma_buf可以实现buffer在多个设备的共享，应用可以把一片底层驱动A的buffer导出到用户空间成为一个fd，也可以把fd导入到底层驱动 B。当然，如果进行mmap()得到虚拟地址，CPU也是可以在用户空间访问到已经获得用户空间虚拟地址的底层buffer的。\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215527335.png)\n\n上图中，进程A访问设备A并获得其使用的buffer的fd，之后通过socket把fd发送给进程B，而后进程B导入fd到设备B，B获得对设备A中的buffer的共享访问。如果CPU也需要在用户态访问这片buffer，则进行了mmap()动作。\n\n为什么我们要共享DMA buffer？想象一个场景：你要把你的屏幕framebuffer的内容透过gstreamer多媒体组件的服务，变成h264的视频码流，广播到网络上面，变成流媒体播放。在这个场景中，我们就想尽一切可能的避免内存拷贝。\n\n技术上，管理framebuffer的驱动可以把这片buffer在底层实现为dma_buf，然后graphics compositor给这片buffer映射出来一个fd，之后透过socket发送fd 把这篇内存交给gstreamer相关的进程，如果gstreamer相关的“color space硬件转换”组件、“H264编码硬件组件”可以透过收到的fd还原出这些dma_buf的地址，则可以进行直接的加速操作了。比如color space透过接收到的fd1还原出framebuffer的地址，然后把转化的结果放到另外一片dma_buf，之后fd2对应这片YUV buffer被共享给h264编码器，h264编码器又透过fd2还原出YUV buffer的地址。\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215535838.png)\n\n这里面的核心点就是fd只是充当了一个“句柄”，用户进程和设备驱动透过fd最终寻找到底层的dma_buf，实现buffer在进程和硬件加速组件之间的zero-copy，这里面唯一进行了exchange的就是fd。\n\n再比如，如果把方向反过来，gstreamer从网络上收到了视频流，把它透过一系列动作转换为一片RGB的buffer，那么这片RGB的buffer最终还要在graphics compositor里面渲染到屏幕上，我们也需要透过dma_buf实现内存在video的decoder相关组件与GPU组件的共享。\n\nLinux内核的V4L2驱动(encoder、decoder多采用此种驱动)、DRM(Direct Rendering Manager，framebuffer/GPU相关)等都支持dma_buf。比如在DRM之上，进程可以透过\n\nint drmPrimeHandleToFD(int fd,\n\nuint32_t handle,\n\nuint32_t flags,\n\nint * prime_fd \n\n)\n\n获得底层framebuffer对应的fd。如果这个fd被分享给gstreamer相关进程的video的color space转换，而color space转换硬件组件又被实现为一个V4L2驱动，则我们可以透过V4L2提供的如下接口，将这片buffer提供给V4L2驱动供其导入：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215545396.png)\n\n如果是multi plane的话，则需要导入多个fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215552177.png)\n\n相关细节可以参考这个文档：\n\nhttps://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/dmabuf.html\n\n一切都是文件！不是文件创造条件也要把它变成文件！这就是Linux的世界观。是不是文件不重要，关键是你得觉得它是个文件。在dma_buf的场景下，fd这个东西，纯粹就是个\"句柄\"，方便大家通过这么一个fd能够对应到最终硬件需要访问的buffer。所以，透过fd的分享和传递，实际实现跨进程、跨设备（包括CPU）的内存共享。\n\n如果说前面的SYS V、POSIX、memfd_create()更加强调内存在进程间的共享，那么dma_buf则更加强调内存在设备间的共享，它未必需要跨进程。比如：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215600171.png)\n\n有的童鞋说，为嘛在一个进程里面设备A和B共享内存还需要fd来倒腾一遍呢？我直接设备A驱动弄个全局变量存buffer的物理地址，设备B的驱动访问这个全局变量不就好了吗？我只能说，你对Linux内核的只提供机制不提供策略，以及软件工程每个模块各司其责，高内聚和低耦合的理解，还停留在裸奔的阶段。在没有dma_buf等类似机制的情况下，如果用户空间仍然负责构建策略并连接设备A和B，人们为了追求代码的干净，往往要进行这样的内存拷贝：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215607387.png)\n\ndma_buf的支持依赖于驱动层是否实现了相关的callbacks。比如在v4l2驱动中，v4l2驱动支持把dma_buf导出（前面讲了v4l2也支持dma_buf的导入，关键看数据方向），它的代码体现在：\n\ndrivers/media/common/videobuf2/videobuf2-dma-contig.c中的：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215615006.png)\n\n其中的vb2_dc_dmabuf_ops是一个struct dma_buf_ops，它含有多个成员函数：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215624632.png)\n\n当用户call VIDIOC_EXPBUF这个IOCTL的时候，可以把dma_buf转化为fd：\n\nint ioctl(int fd, VIDIOC_EXPBUF, struct v4l2_exportbuffer *argp);\n\n对应着驱动层的代码则会调用dma_buf_fd()：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215631492.png)\n\n应用程序可以通过如下方式拿到底层的dma_buf的fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215637250.png)\n\ndma_buf的导入侧设备驱动，则会用到如下这些API：\n\ndma_buf_attach()\n\ndma_buf_map_attachment()\n\ndma_buf_unmap_attachment()\n\ndma_buf_detach()\n\n下面这张表，是笔者对这几种共享内存方式总的归纳：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215645563.png)\n\n落花满天蔽月光，借一杯附荐凤台上。\n\n全剧终\n————————————————\n版权声明：本文为CSDN博主「宋宝华」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/21cnbao/article/details/103470878","source":"_posts/linux_md/Linux Basic/世上最好的共享内存.md","raw":"---\ntitle: 世上最好的共享内存\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 学习笔记\nabbrlink: 15001\ncover: \n---\n\n## 宋宝华：世上最好的共享内存\n\n\n\n共享单车、共享充电宝、共享雨伞，世间的共享有千万种，而我独爱共享内存。\n\n早期的共享内存，着重于强调把同一片内存，map到多个进程的虚拟地址空间（在相应进程找到一个VMA区域），以便于CPU可以在各个进程访问到这片内存。\n\n![img](./世上最好的共享内存/format,png.png)\n\n现阶段广泛应用于多媒体、Graphics领域的共享内存方式，某种意义上不再强调映射到进程虚拟地址空间的概念（那无非是为了让CPU访问），而更强调以某种“句柄”的形式，让大家知道某一片视频、图形图像数据的存在并可以借助此“句柄”来跨进程引用这片内存，让视频encoder、decoder、GPU等可以跨进程访问内存。所以不同进程用的加速硬件其实是不同的，他们更在乎的是可以通过一个handle拿到这片内存，而不再特别在乎CPU访问它的虚拟地址（当然仍然可以映射到进程的虚拟地址空间供CPU访问）。\n\n![img](./世上最好的共享内存/format,png-20210408215011301.png)\n\n只要内存的拷贝(memcpy)仍然是一个占据内存带宽、CPU利用率的消耗大户存在，共享内存作为Linux进程间通信、计算机系统里各个不同硬件组件通信的最高效方法，都将持续繁荣。关于内存拷贝会大多程度地占据CPU利用率，这个可以最简单地尝试拷贝1080P，帧率每秒60的电影画面，我保证你的系统的CPU，蛋会疼地不行。\n\n我早就想系统地写一篇综述Linux里面各种共享内存方式的文章了，但是一直被带娃这个事业牵绊，今日我决定顶着娃娃们的山呼海啸，也要写一篇文章不吐不快。\n\n共享内存的方式有很多种，目前主流的方式仍然有：\n\n![img](./世上最好的共享内存/format,png-20210408215025345.png)\n\n共享内存的方式\n\n1.基于传统SYS V的共享内存；\n\n2.基于POSIX mmap文件映射实现共享内存；\n\n3.通过memfd_create()和fd跨进程共享实现共享内存；\n\n4.多媒体、图形领域广泛使用的基于dma-buf的共享内存。\n\n共享内存\n\nSYS V共享内存\n\n历史悠久、年代久远、API怪异，对应内核代码linux/ipc/shm.c，当你编译内核的时候不选择CONFIG_SYSVIPC，则不再具备此能力。\n\n你在Linux敲ipcs命令看到的share memory就是这种共享内存：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.jpeg)\n\n下面写一个最简单的程序来看共享内存的写端sw.c：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215041892.png)\n\n以及共享内存的读端sr.c：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215049945.png)\n\n编译和准备运行：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215056849.png)\n\n在此之前我们看一下系统的free:\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215103876.png)\n\n下面运行sw和sr：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215112625.png)\n\n我们发现sr打印出来的和sw写进去的是一致的。这个时候我们再看下free：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215118480.png)\n\n可以看到used显著增大了（711632 -> 715908）, shared显著地增大了（2264 -> 6360），而cached这一列也显著地增大326604->330716。\n\n我们都知道cached这一列统计的是file-backed的文件的page cache的大小。理论上，共享内存属于匿名页，但是由于这里面有个非常特殊的tmpfs（/dev/shm指向/run/shm,/run/shm则mount为tmpfs）：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215127651.png)\n\n所以可以看出tmpfs的东西其实真的是有点含混：我们可以理解它为file-backed的匿名页（anonymous page），有点类似女声中的周深。前面我们反复强调，匿名页是没有文件背景的，这样当进行内存交换的时候，是与swap分区交换。磁盘文件系统里面的东西在内存的副本是file-backed的页面，所以不存在与swap分区交换的问题。但是tmpfs里面的东西，真的是在统计意义上统计到page cache了，但是它并没有真实的磁盘背景，这又和你访问磁盘文件系统里面的文件产生的page cache有本质的区别。所以，它是真地有那么一点misc的感觉，凡事都没有绝对，唯有变化本身是不变的。\n\n也可以通过ipcs找到新创建的SYS V共享内存：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215135031.jpeg)\n\nPOSIX共享内存\n\n我对POSIX shm_open()、mmap () API系列的共享内存的喜爱，远远超过SYS V 100倍。原谅我就是一个懒惰的人，我就是讨厌ftok、shmget、shmat、shmdt这样的API。\n\n上面的程序如果用POSIX的写法，可以简化成写端psw.c：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215142219.png)\n\n读端：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215150439.png)\n\n编译和执行：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215157588.png)\n\n这样我们会在/dev/shm/、/run/shm下面看到一个文件：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215203155.png)\n\n坦白讲，mmap、munmap这样的API让我找到了回家的感觉，刚入行做Linux的时候，写好framebuffer驱动后，就是把/dev/fb0 mmap到用户空间来操作，所以mmap这样的 API，真的是特别亲切，像亲人一样。\n\n当然，如果你不喜欢shm_open()这个API，你也可以用常规的open来打开文件，然后进行mmap。关键的是mmap，wikipedia如是说：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215211094.png)\n\nmmap\n\nIn computing, mmap(2) is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O. It implements demand paging, because file contents are not read from disk directly and initially do not use physical RAM at all. The actual reads from disk are performed in a \"lazy\" manner, after a specific location is accessed. After the memory is no longer needed, it is important to munmap(2) the pointers to it. Protection information can be managed using mprotect(2), and special treatment can be enforced using madvise(2).\n\nPOSIX的共享内存，仍然符合我们前面说的tmpfs的特点，在运行了sw,sr后，再运行psw和psr，我们发现free命令再次戏剧性变化：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215219100.png)\n\n请将这个free命令的结果与前2次的free结果的各个字段进行对照:\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215225519.jpeg)\n\n第3次比第2次的cached大了这么多？是因为我编写这篇文章边在访问磁盘里面的文件，当然POSIX的这个共享内存本身也导致cached增大了。\n\nmemfd_create\n\n如果说POSIX的mmap让我找到回家的感觉，那么memfd_create()则是万般惊艳。见过这种API，才知道什么叫天生尤物——而且是尤物中的尤物，它完全属于那种让码农第一眼看到就会两眼充血，恨不得眼珠子夺眶而出贴到它身上去的那种API；一般人见到它第一次，都会忽略了它的长相，因为它的身材实在太火辣太抢眼了。\n\n先不要浮想联翩，在所有的所有开始之前，我们要先提一下跨进程分享fd（文件描述符，对应我们很多时候说的“句柄”）这个重要的概念。\n\n众所周知，Linux的fd属于一个进程级别的东西。进入每个进程的/proc/pid/fd可以看到它的fd的列表：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215235412.png)\n\n这个进程的0，1，2和那个进程的0，1，2不是一回事。\n\n某年某月的某一天，人们发现，一个进程其实想访问另外一个进程的fd。当然，这只是目的不是手段。比如进程A有2个fd指向2片内存，如果进程B可以拿到这2个fd，其实就可以透过这2个fd访问到这2片内存。这个fd某种意义上充当了一个中间媒介的作用。有人说，那还不简单吗，如果进程A:\n\nfd = open();\n\nopen()如果返回100，把这个100告诉进程B不就可以了吗，进程B访问这个100就可以了。这说明你还是没搞明白fd是一个进程内部的东西，是不能跨进程的概念。你的100和我的100，不是一个东西。这些基本的东西你搞不明白，你搞别的都是白搭。\n\nLinux提供一个特殊的方法，可以把一个进程的fd甩锅、踢皮球给另外一个进程（其实“甩锅”这个词用在这里不合适，因为“甩锅”是一种推卸，而fd的传递是一种分享）。我特码一直想把我的bug甩（分）锅（享）出去，却发现总是被人把bug甩锅过来。\n\n那么如何甩（分）锅（享）fd呢？\n\nLinux里面的甩锅需要借助cmsg，用于在socket上传递控制消息（也称Ancillary data），使用SCM_RIGHTS，进程可以透过UNIX Socket把一个或者多个fd(file descriptor)传递给另外一个进程。\n\n比如下面的这个函数，可以透过socket把fds指向的n个fd发送给另外一个进程：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215243422.png)\n\n而另外一个进程，则可以透过如下函数接受这个fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215249606.png)\n\n那么问题来了，如果在进程A中有一个文件的fd是100，发送给进程B后，它还是100吗？不能这么简单地理解，fd本身是一个进程级别的概念，每个进程有自己的fd的列表，比如进程B收到进程A的fd的时候，进程B自身fd空间里面自己的前面200个fd都已经被占用了，那么进程B接受到的fd就可能是201。数字本身在Linux的fd里面真地是一点都不重要，除了几个特殊的0,1,2这样的数字外。同样的，如果你把 cat /proc/interrupts 显示出的中断号就看成是硬件里面的中断偏移号码(比如ARM GIC里某号硬件中断)，你会发现，这个关系整个是一个瞎扯。\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215257440.png)\n\n知道了甩锅API，那么重要的是，当它与memfd_create()结合的时候，我们准备甩出去的fd是怎么来？它是memfd_create()的返回值。\n\nmemfd_create()这个函数的玄妙之处在于它会返回一个“匿名”内存“文件”的fd，而它本身并没有实体的文件系统路径，其典型用法如下：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215306929.png)\n\n我们透过memfd_create()创建了一个“文件”，但是它实际映射到一片内存，而且在/xxx/yyy/zzz这样的文件系统下没有路径！没有路径！没有路径！\n\n所以，当你在Linux里面编程的时候，碰到这样的场景：需要一个fd，当成文件一样操作，但是又不需要真实地位于文件系统，那么，就请立即使用memfd_create()吧，它的manual page是这样描述的：\n\nmemfd_create\n\nmemfd_create() creates an anonymous file and returns a file descriptor that refers to it.  The file behaves like a regular file, and so can be modified, truncated, memory-mapped, and so on.\nHowever, unlike a regular file, it lives in RAM and has a volatile backing storage.\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.gif)\n\n重点理解其中的regular这个单词。它的行动像一个regular的文件，但是它的背景却不regular。\n\n那么，它和前面我们说的透过UNIX Socket甩锅fd又有什么关系呢？memfd_create()得到了fd，它在行为上类似规则的fd，所以也可以透过socket来进行甩锅，这样A进程相当于把一片与fd对应的内存，分享给了进程B。\n\n下面的代码进程A通过memfd_create()创建了2片4MB的内存，并且透过socket（路径/tmp/fd-pass.socket）发送给进程B这2片内存对应的fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215333648.jpeg)\n\n下面的代码进程B透过相同的socket接受这2片内存对应的fd，之后通过read()读取每个文件的前256个字节并打印：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215340645.jpeg)\n\n上述代码参考了: \n\nhttps://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/\n\n上述的代码中，进程B是在进行read(fds[i], buffer, sizeof(buffer))，这体现了基于fd进行操作的regular特点。当然，如果是共享内存，现实的代码肯定还是多半会是mmap：\n\nmmap(NULL, SIZE, PROT_READ, MAP_SHARED, fd, 0);\n\n那么，透过socket发送memfd_create() fd来进行进程间共享内存这种方法，它究竟惊艳在哪里？\n\n我认为首要的惊艳之处在于编程模型的惊艳。API简单、灵活、通用。进程之间想共享几片内存共享几片内存，想怎么共享怎么共享，想共享给谁共享给谁，无非是多了几个fd和socket的传递过程。比如，我从互联网上面收到了jpeg的视频码流，一帧帧的画面，进程A可以创建多片buffer来缓存画面，然后就可以透过把每片buffer对应的fd，递交给另外的进程去解码等。Avenue to Jane(大道至简)，简单的才是最好的！\n\nmemfd_create()的另外一个惊艳之处在于支持“封印”(sealing，就是你玩游戏的时候的封印)，sealing这个单词本身的意思是封条，在这个场景下，我更愿意把它翻译为“封印”。中国传说中的封印，多是采用如五行、太极、八卦等手段，并可有例如符咒、法器等物品的辅助。现指对某个单位施加一种力量，使其无法正常使用某些能力的本领（常出现于玄幻及神魔类作品，游戏中）。我这一生，最喜欢玩的游戏就是《仙剑奇侠传》和《轩辕剑——天之痕》，不知道是否暴露年龄了。\n\n采用memfd_create()的场景下，我们同样可以用某种法器，来控制共享内存的shrink、grow和write。最初的设想可以详见File Sealing & memfd_create()这篇文章：\n\nhttps://lwn.net/Articles/591108/\n\n我们如果在共享内存上施加了这样的封印，则可以限制对此片区域的ftruncate、write等动作，并建立某种意义上进程之间的相互信任，这是不是很拉风？\n\n还记得镇压孙悟空的五行山顶的封印吗？还记得孙悟空的紧箍咒吗？还记得悟空每次离开师傅的时候在师傅周围画的一个圈吗？\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215351143.jpeg)\n\n封印\n\n* SEAL_SHRINK: If set, the inode size cannot be reduced\n* SEAL_GROW: If set, the inode size cannot be increased\n* SEAL_WRITE: If set, the file content cannot be modified\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215504370.gif)\n\nFile Sealing & memfd_create()文中举到的一个典型使用场景是，如果graphics client把它与graphics compoistor共享的内存交给compoistor去render，compoistor必须保证可以拿到这片内存。这里面的风险是client可能透过ftruncate()把这个memory shrink小，这样compositor就拿不到完整的buffer，会造成crash。所以compositor只愿意接受含有SEAL_SHRINK封印的fd，如果没有，对不起，我们不能一起去西天取经。\n\n在支持memfd_create()后，我们应尽可能地使用这种方式来替代传统的POSIX和SYS V，基本它也是一个趋势，比如我们在wayland相关项目中能看到这样的patch：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215512581.jpeg)\n\ndma_buf\n\ndma_buf定义\n\nThe DMABUF framework provides a generic method for sharing buffers between multiple devices. Device drivers that support DMABUF can export a DMA buffer to userspace as a file descriptor (known as the exporter role), import a DMA buffer from userspace using a file descriptor previously exported for a different or the same device (known as the importer role), or both. \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215521174.gif)\n\n简单地来说，dma_buf可以实现buffer在多个设备的共享，应用可以把一片底层驱动A的buffer导出到用户空间成为一个fd，也可以把fd导入到底层驱动 B。当然，如果进行mmap()得到虚拟地址，CPU也是可以在用户空间访问到已经获得用户空间虚拟地址的底层buffer的。\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215527335.png)\n\n上图中，进程A访问设备A并获得其使用的buffer的fd，之后通过socket把fd发送给进程B，而后进程B导入fd到设备B，B获得对设备A中的buffer的共享访问。如果CPU也需要在用户态访问这片buffer，则进行了mmap()动作。\n\n为什么我们要共享DMA buffer？想象一个场景：你要把你的屏幕framebuffer的内容透过gstreamer多媒体组件的服务，变成h264的视频码流，广播到网络上面，变成流媒体播放。在这个场景中，我们就想尽一切可能的避免内存拷贝。\n\n技术上，管理framebuffer的驱动可以把这片buffer在底层实现为dma_buf，然后graphics compositor给这片buffer映射出来一个fd，之后透过socket发送fd 把这篇内存交给gstreamer相关的进程，如果gstreamer相关的“color space硬件转换”组件、“H264编码硬件组件”可以透过收到的fd还原出这些dma_buf的地址，则可以进行直接的加速操作了。比如color space透过接收到的fd1还原出framebuffer的地址，然后把转化的结果放到另外一片dma_buf，之后fd2对应这片YUV buffer被共享给h264编码器，h264编码器又透过fd2还原出YUV buffer的地址。\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215535838.png)\n\n这里面的核心点就是fd只是充当了一个“句柄”，用户进程和设备驱动透过fd最终寻找到底层的dma_buf，实现buffer在进程和硬件加速组件之间的zero-copy，这里面唯一进行了exchange的就是fd。\n\n再比如，如果把方向反过来，gstreamer从网络上收到了视频流，把它透过一系列动作转换为一片RGB的buffer，那么这片RGB的buffer最终还要在graphics compositor里面渲染到屏幕上，我们也需要透过dma_buf实现内存在video的decoder相关组件与GPU组件的共享。\n\nLinux内核的V4L2驱动(encoder、decoder多采用此种驱动)、DRM(Direct Rendering Manager，framebuffer/GPU相关)等都支持dma_buf。比如在DRM之上，进程可以透过\n\nint drmPrimeHandleToFD(int fd,\n\nuint32_t handle,\n\nuint32_t flags,\n\nint * prime_fd \n\n)\n\n获得底层framebuffer对应的fd。如果这个fd被分享给gstreamer相关进程的video的color space转换，而color space转换硬件组件又被实现为一个V4L2驱动，则我们可以透过V4L2提供的如下接口，将这片buffer提供给V4L2驱动供其导入：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215545396.png)\n\n如果是multi plane的话，则需要导入多个fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215552177.png)\n\n相关细节可以参考这个文档：\n\nhttps://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/dmabuf.html\n\n一切都是文件！不是文件创造条件也要把它变成文件！这就是Linux的世界观。是不是文件不重要，关键是你得觉得它是个文件。在dma_buf的场景下，fd这个东西，纯粹就是个\"句柄\"，方便大家通过这么一个fd能够对应到最终硬件需要访问的buffer。所以，透过fd的分享和传递，实际实现跨进程、跨设备（包括CPU）的内存共享。\n\n如果说前面的SYS V、POSIX、memfd_create()更加强调内存在进程间的共享，那么dma_buf则更加强调内存在设备间的共享，它未必需要跨进程。比如：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215600171.png)\n\n有的童鞋说，为嘛在一个进程里面设备A和B共享内存还需要fd来倒腾一遍呢？我直接设备A驱动弄个全局变量存buffer的物理地址，设备B的驱动访问这个全局变量不就好了吗？我只能说，你对Linux内核的只提供机制不提供策略，以及软件工程每个模块各司其责，高内聚和低耦合的理解，还停留在裸奔的阶段。在没有dma_buf等类似机制的情况下，如果用户空间仍然负责构建策略并连接设备A和B，人们为了追求代码的干净，往往要进行这样的内存拷贝：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215607387.png)\n\ndma_buf的支持依赖于驱动层是否实现了相关的callbacks。比如在v4l2驱动中，v4l2驱动支持把dma_buf导出（前面讲了v4l2也支持dma_buf的导入，关键看数据方向），它的代码体现在：\n\ndrivers/media/common/videobuf2/videobuf2-dma-contig.c中的：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215615006.png)\n\n其中的vb2_dc_dmabuf_ops是一个struct dma_buf_ops，它含有多个成员函数：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215624632.png)\n\n当用户call VIDIOC_EXPBUF这个IOCTL的时候，可以把dma_buf转化为fd：\n\nint ioctl(int fd, VIDIOC_EXPBUF, struct v4l2_exportbuffer *argp);\n\n对应着驱动层的代码则会调用dma_buf_fd()：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215631492.png)\n\n应用程序可以通过如下方式拿到底层的dma_buf的fd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215637250.png)\n\ndma_buf的导入侧设备驱动，则会用到如下这些API：\n\ndma_buf_attach()\n\ndma_buf_map_attachment()\n\ndma_buf_unmap_attachment()\n\ndma_buf_detach()\n\n下面这张表，是笔者对这几种共享内存方式总的归纳：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215645563.png)\n\n落花满天蔽月光，借一杯附荐凤台上。\n\n全剧终\n————————————————\n版权声明：本文为CSDN博主「宋宝华」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/21cnbao/article/details/103470878","slug":"linux_md/Linux Basic/世上最好的共享内存","published":1,"updated":"2021-04-13T08:34:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr60001mw9q92q41a30q","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h2 id=\"宋宝华：世上最好的共享内存\"><a href=\"#宋宝华：世上最好的共享内存\" class=\"headerlink\" title=\"宋宝华：世上最好的共享内存\"></a>宋宝华：世上最好的共享内存</h2><p>共享单车、共享充电宝、共享雨伞，世间的共享有千万种，而我独爱共享内存。</p>\n<p>早期的共享内存，着重于强调把同一片内存，map到多个进程的虚拟地址空间（在相应进程找到一个VMA区域），以便于CPU可以在各个进程访问到这片内存。</p>\n<p><img src=\"./%E4%B8%96%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/format,png.png\" alt=\"img\"></p>\n<p>现阶段广泛应用于多媒体、Graphics领域的共享内存方式，某种意义上不再强调映射到进程虚拟地址空间的概念（那无非是为了让CPU访问），而更强调以某种“句柄”的形式，让大家知道某一片视频、图形图像数据的存在并可以借助此“句柄”来跨进程引用这片内存，让视频encoder、decoder、GPU等可以跨进程访问内存。所以不同进程用的加速硬件其实是不同的，他们更在乎的是可以通过一个handle拿到这片内存，而不再特别在乎CPU访问它的虚拟地址（当然仍然可以映射到进程的虚拟地址空间供CPU访问）。</p>\n<p><img src=\"./%E4%B8%96%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/format,png-20210408215011301.png\" alt=\"img\"></p>\n<p>只要内存的拷贝(memcpy)仍然是一个占据内存带宽、CPU利用率的消耗大户存在，共享内存作为Linux进程间通信、计算机系统里各个不同硬件组件通信的最高效方法，都将持续繁荣。关于内存拷贝会大多程度地占据CPU利用率，这个可以最简单地尝试拷贝1080P，帧率每秒60的电影画面，我保证你的系统的CPU，蛋会疼地不行。</p>\n<p>我早就想系统地写一篇综述Linux里面各种共享内存方式的文章了，但是一直被带娃这个事业牵绊，今日我决定顶着娃娃们的山呼海啸，也要写一篇文章不吐不快。</p>\n<p>共享内存的方式有很多种，目前主流的方式仍然有：</p>\n<p><img src=\"./%E4%B8%96%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/format,png-20210408215025345.png\" alt=\"img\"></p>\n<p>共享内存的方式</p>\n<p>1.基于传统SYS V的共享内存；</p>\n<p>2.基于POSIX mmap文件映射实现共享内存；</p>\n<p>3.通过memfd_create()和fd跨进程共享实现共享内存；</p>\n<p>4.多媒体、图形领域广泛使用的基于dma-buf的共享内存。</p>\n<p>共享内存</p>\n<p>SYS V共享内存</p>\n<p>历史悠久、年代久远、API怪异，对应内核代码linux/ipc/shm.c，当你编译内核的时候不选择CONFIG_SYSVIPC，则不再具备此能力。</p>\n<p>你在Linux敲ipcs命令看到的share memory就是这种共享内存：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.jpeg)</p>\n<p>下面写一个最简单的程序来看共享内存的写端sw.c：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215041892.png)</p>\n<p>以及共享内存的读端sr.c：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215049945.png)</p>\n<p>编译和准备运行：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215056849.png)</p>\n<p>在此之前我们看一下系统的free:</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215103876.png)</p>\n<p>下面运行sw和sr：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215112625.png)</p>\n<p>我们发现sr打印出来的和sw写进去的是一致的。这个时候我们再看下free：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215118480.png)</p>\n<p>可以看到used显著增大了（711632 -&gt; 715908）, shared显著地增大了（2264 -&gt; 6360），而cached这一列也显著地增大326604-&gt;330716。</p>\n<p>我们都知道cached这一列统计的是file-backed的文件的page cache的大小。理论上，共享内存属于匿名页，但是由于这里面有个非常特殊的tmpfs（/dev/shm指向/run/shm,/run/shm则mount为tmpfs）：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215127651.png)</p>\n<p>所以可以看出tmpfs的东西其实真的是有点含混：我们可以理解它为file-backed的匿名页（anonymous page），有点类似女声中的周深。前面我们反复强调，匿名页是没有文件背景的，这样当进行内存交换的时候，是与swap分区交换。磁盘文件系统里面的东西在内存的副本是file-backed的页面，所以不存在与swap分区交换的问题。但是tmpfs里面的东西，真的是在统计意义上统计到page cache了，但是它并没有真实的磁盘背景，这又和你访问磁盘文件系统里面的文件产生的page cache有本质的区别。所以，它是真地有那么一点misc的感觉，凡事都没有绝对，唯有变化本身是不变的。</p>\n<p>也可以通过ipcs找到新创建的SYS V共享内存：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215135031.jpeg)</p>\n<p>POSIX共享内存</p>\n<p>我对POSIX shm_open()、mmap () API系列的共享内存的喜爱，远远超过SYS V 100倍。原谅我就是一个懒惰的人，我就是讨厌ftok、shmget、shmat、shmdt这样的API。</p>\n<p>上面的程序如果用POSIX的写法，可以简化成写端psw.c：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215142219.png)</p>\n<p>读端：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215150439.png)</p>\n<p>编译和执行：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215157588.png)</p>\n<p>这样我们会在/dev/shm/、/run/shm下面看到一个文件：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215203155.png)</p>\n<p>坦白讲，mmap、munmap这样的API让我找到了回家的感觉，刚入行做Linux的时候，写好framebuffer驱动后，就是把/dev/fb0 mmap到用户空间来操作，所以mmap这样的 API，真的是特别亲切，像亲人一样。</p>\n<p>当然，如果你不喜欢shm_open()这个API，你也可以用常规的open来打开文件，然后进行mmap。关键的是mmap，wikipedia如是说：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215211094.png)</p>\n<p>mmap</p>\n<p>In computing, mmap(2) is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O. It implements demand paging, because file contents are not read from disk directly and initially do not use physical RAM at all. The actual reads from disk are performed in a “lazy” manner, after a specific location is accessed. After the memory is no longer needed, it is important to munmap(2) the pointers to it. Protection information can be managed using mprotect(2), and special treatment can be enforced using madvise(2).</p>\n<p>POSIX的共享内存，仍然符合我们前面说的tmpfs的特点，在运行了sw,sr后，再运行psw和psr，我们发现free命令再次戏剧性变化：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215219100.png)</p>\n<p>请将这个free命令的结果与前2次的free结果的各个字段进行对照:</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215225519.jpeg)</p>\n<p>第3次比第2次的cached大了这么多？是因为我编写这篇文章边在访问磁盘里面的文件，当然POSIX的这个共享内存本身也导致cached增大了。</p>\n<p>memfd_create</p>\n<p>如果说POSIX的mmap让我找到回家的感觉，那么memfd_create()则是万般惊艳。见过这种API，才知道什么叫天生尤物——而且是尤物中的尤物，它完全属于那种让码农第一眼看到就会两眼充血，恨不得眼珠子夺眶而出贴到它身上去的那种API；一般人见到它第一次，都会忽略了它的长相，因为它的身材实在太火辣太抢眼了。</p>\n<p>先不要浮想联翩，在所有的所有开始之前，我们要先提一下跨进程分享fd（文件描述符，对应我们很多时候说的“句柄”）这个重要的概念。</p>\n<p>众所周知，Linux的fd属于一个进程级别的东西。进入每个进程的/proc/pid/fd可以看到它的fd的列表：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215235412.png)</p>\n<p>这个进程的0，1，2和那个进程的0，1，2不是一回事。</p>\n<p>某年某月的某一天，人们发现，一个进程其实想访问另外一个进程的fd。当然，这只是目的不是手段。比如进程A有2个fd指向2片内存，如果进程B可以拿到这2个fd，其实就可以透过这2个fd访问到这2片内存。这个fd某种意义上充当了一个中间媒介的作用。有人说，那还不简单吗，如果进程A:</p>\n<p>fd = open();</p>\n<p>open()如果返回100，把这个100告诉进程B不就可以了吗，进程B访问这个100就可以了。这说明你还是没搞明白fd是一个进程内部的东西，是不能跨进程的概念。你的100和我的100，不是一个东西。这些基本的东西你搞不明白，你搞别的都是白搭。</p>\n<p>Linux提供一个特殊的方法，可以把一个进程的fd甩锅、踢皮球给另外一个进程（其实“甩锅”这个词用在这里不合适，因为“甩锅”是一种推卸，而fd的传递是一种分享）。我特码一直想把我的bug甩（分）锅（享）出去，却发现总是被人把bug甩锅过来。</p>\n<p>那么如何甩（分）锅（享）fd呢？</p>\n<p>Linux里面的甩锅需要借助cmsg，用于在socket上传递控制消息（也称Ancillary data），使用SCM_RIGHTS，进程可以透过UNIX Socket把一个或者多个fd(file descriptor)传递给另外一个进程。</p>\n<p>比如下面的这个函数，可以透过socket把fds指向的n个fd发送给另外一个进程：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215243422.png)</p>\n<p>而另外一个进程，则可以透过如下函数接受这个fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215249606.png)</p>\n<p>那么问题来了，如果在进程A中有一个文件的fd是100，发送给进程B后，它还是100吗？不能这么简单地理解，fd本身是一个进程级别的概念，每个进程有自己的fd的列表，比如进程B收到进程A的fd的时候，进程B自身fd空间里面自己的前面200个fd都已经被占用了，那么进程B接受到的fd就可能是201。数字本身在Linux的fd里面真地是一点都不重要，除了几个特殊的0,1,2这样的数字外。同样的，如果你把 cat /proc/interrupts 显示出的中断号就看成是硬件里面的中断偏移号码(比如ARM GIC里某号硬件中断)，你会发现，这个关系整个是一个瞎扯。</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215257440.png)</p>\n<p>知道了甩锅API，那么重要的是，当它与memfd_create()结合的时候，我们准备甩出去的fd是怎么来？它是memfd_create()的返回值。</p>\n<p>memfd_create()这个函数的玄妙之处在于它会返回一个“匿名”内存“文件”的fd，而它本身并没有实体的文件系统路径，其典型用法如下：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215306929.png)</p>\n<p>我们透过memfd_create()创建了一个“文件”，但是它实际映射到一片内存，而且在/xxx/yyy/zzz这样的文件系统下没有路径！没有路径！没有路径！</p>\n<p>所以，当你在Linux里面编程的时候，碰到这样的场景：需要一个fd，当成文件一样操作，但是又不需要真实地位于文件系统，那么，就请立即使用memfd_create()吧，它的manual page是这样描述的：</p>\n<p>memfd_create</p>\n<p>memfd_create() creates an anonymous file and returns a file descriptor that refers to it.  The file behaves like a regular file, and so can be modified, truncated, memory-mapped, and so on.<br>However, unlike a regular file, it lives in RAM and has a volatile backing storage.</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.gif)</p>\n<p>重点理解其中的regular这个单词。它的行动像一个regular的文件，但是它的背景却不regular。</p>\n<p>那么，它和前面我们说的透过UNIX Socket甩锅fd又有什么关系呢？memfd_create()得到了fd，它在行为上类似规则的fd，所以也可以透过socket来进行甩锅，这样A进程相当于把一片与fd对应的内存，分享给了进程B。</p>\n<p>下面的代码进程A通过memfd_create()创建了2片4MB的内存，并且透过socket（路径/tmp/fd-pass.socket）发送给进程B这2片内存对应的fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215333648.jpeg)</p>\n<p>下面的代码进程B透过相同的socket接受这2片内存对应的fd，之后通过read()读取每个文件的前256个字节并打印：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215340645.jpeg)</p>\n<p>上述代码参考了: </p>\n<p><a href=\"https://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/\">https://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/</a></p>\n<p>上述的代码中，进程B是在进行read(fds[i], buffer, sizeof(buffer))，这体现了基于fd进行操作的regular特点。当然，如果是共享内存，现实的代码肯定还是多半会是mmap：</p>\n<p>mmap(NULL, SIZE, PROT_READ, MAP_SHARED, fd, 0);</p>\n<p>那么，透过socket发送memfd_create() fd来进行进程间共享内存这种方法，它究竟惊艳在哪里？</p>\n<p>我认为首要的惊艳之处在于编程模型的惊艳。API简单、灵活、通用。进程之间想共享几片内存共享几片内存，想怎么共享怎么共享，想共享给谁共享给谁，无非是多了几个fd和socket的传递过程。比如，我从互联网上面收到了jpeg的视频码流，一帧帧的画面，进程A可以创建多片buffer来缓存画面，然后就可以透过把每片buffer对应的fd，递交给另外的进程去解码等。Avenue to Jane(大道至简)，简单的才是最好的！</p>\n<p>memfd_create()的另外一个惊艳之处在于支持“封印”(sealing，就是你玩游戏的时候的封印)，sealing这个单词本身的意思是封条，在这个场景下，我更愿意把它翻译为“封印”。中国传说中的封印，多是采用如五行、太极、八卦等手段，并可有例如符咒、法器等物品的辅助。现指对某个单位施加一种力量，使其无法正常使用某些能力的本领（常出现于玄幻及神魔类作品，游戏中）。我这一生，最喜欢玩的游戏就是《仙剑奇侠传》和《轩辕剑——天之痕》，不知道是否暴露年龄了。</p>\n<p>采用memfd_create()的场景下，我们同样可以用某种法器，来控制共享内存的shrink、grow和write。最初的设想可以详见File Sealing &amp; memfd_create()这篇文章：</p>\n<p><a href=\"https://lwn.net/Articles/591108/\">https://lwn.net/Articles/591108/</a></p>\n<p>我们如果在共享内存上施加了这样的封印，则可以限制对此片区域的ftruncate、write等动作，并建立某种意义上进程之间的相互信任，这是不是很拉风？</p>\n<p>还记得镇压孙悟空的五行山顶的封印吗？还记得孙悟空的紧箍咒吗？还记得悟空每次离开师傅的时候在师傅周围画的一个圈吗？</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215351143.jpeg)</p>\n<p>封印</p>\n<ul>\n<li>SEAL_SHRINK: If set, the inode size cannot be reduced</li>\n<li>SEAL_GROW: If set, the inode size cannot be increased</li>\n<li>SEAL_WRITE: If set, the file content cannot be modified</li>\n</ul>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215504370.gif)</p>\n<p>File Sealing &amp; memfd_create()文中举到的一个典型使用场景是，如果graphics client把它与graphics compoistor共享的内存交给compoistor去render，compoistor必须保证可以拿到这片内存。这里面的风险是client可能透过ftruncate()把这个memory shrink小，这样compositor就拿不到完整的buffer，会造成crash。所以compositor只愿意接受含有SEAL_SHRINK封印的fd，如果没有，对不起，我们不能一起去西天取经。</p>\n<p>在支持memfd_create()后，我们应尽可能地使用这种方式来替代传统的POSIX和SYS V，基本它也是一个趋势，比如我们在wayland相关项目中能看到这样的patch：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215512581.jpeg)</p>\n<p>dma_buf</p>\n<p>dma_buf定义</p>\n<p>The DMABUF framework provides a generic method for sharing buffers between multiple devices. Device drivers that support DMABUF can export a DMA buffer to userspace as a file descriptor (known as the exporter role), import a DMA buffer from userspace using a file descriptor previously exported for a different or the same device (known as the importer role), or both. </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215521174.gif)</p>\n<p>简单地来说，dma_buf可以实现buffer在多个设备的共享，应用可以把一片底层驱动A的buffer导出到用户空间成为一个fd，也可以把fd导入到底层驱动 B。当然，如果进行mmap()得到虚拟地址，CPU也是可以在用户空间访问到已经获得用户空间虚拟地址的底层buffer的。</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215527335.png)</p>\n<p>上图中，进程A访问设备A并获得其使用的buffer的fd，之后通过socket把fd发送给进程B，而后进程B导入fd到设备B，B获得对设备A中的buffer的共享访问。如果CPU也需要在用户态访问这片buffer，则进行了mmap()动作。</p>\n<p>为什么我们要共享DMA buffer？想象一个场景：你要把你的屏幕framebuffer的内容透过gstreamer多媒体组件的服务，变成h264的视频码流，广播到网络上面，变成流媒体播放。在这个场景中，我们就想尽一切可能的避免内存拷贝。</p>\n<p>技术上，管理framebuffer的驱动可以把这片buffer在底层实现为dma_buf，然后graphics compositor给这片buffer映射出来一个fd，之后透过socket发送fd 把这篇内存交给gstreamer相关的进程，如果gstreamer相关的“color space硬件转换”组件、“H264编码硬件组件”可以透过收到的fd还原出这些dma_buf的地址，则可以进行直接的加速操作了。比如color space透过接收到的fd1还原出framebuffer的地址，然后把转化的结果放到另外一片dma_buf，之后fd2对应这片YUV buffer被共享给h264编码器，h264编码器又透过fd2还原出YUV buffer的地址。</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215535838.png)</p>\n<p>这里面的核心点就是fd只是充当了一个“句柄”，用户进程和设备驱动透过fd最终寻找到底层的dma_buf，实现buffer在进程和硬件加速组件之间的zero-copy，这里面唯一进行了exchange的就是fd。</p>\n<p>再比如，如果把方向反过来，gstreamer从网络上收到了视频流，把它透过一系列动作转换为一片RGB的buffer，那么这片RGB的buffer最终还要在graphics compositor里面渲染到屏幕上，我们也需要透过dma_buf实现内存在video的decoder相关组件与GPU组件的共享。</p>\n<p>Linux内核的V4L2驱动(encoder、decoder多采用此种驱动)、DRM(Direct Rendering Manager，framebuffer/GPU相关)等都支持dma_buf。比如在DRM之上，进程可以透过</p>\n<p>int drmPrimeHandleToFD(int fd,</p>\n<p>uint32_t handle,</p>\n<p>uint32_t flags,</p>\n<p>int * prime_fd </p>\n<p>)</p>\n<p>获得底层framebuffer对应的fd。如果这个fd被分享给gstreamer相关进程的video的color space转换，而color space转换硬件组件又被实现为一个V4L2驱动，则我们可以透过V4L2提供的如下接口，将这片buffer提供给V4L2驱动供其导入：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215545396.png)</p>\n<p>如果是multi plane的话，则需要导入多个fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215552177.png)</p>\n<p>相关细节可以参考这个文档：</p>\n<p><a href=\"https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/dmabuf.html\">https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/dmabuf.html</a></p>\n<p>一切都是文件！不是文件创造条件也要把它变成文件！这就是Linux的世界观。是不是文件不重要，关键是你得觉得它是个文件。在dma_buf的场景下，fd这个东西，纯粹就是个”句柄”，方便大家通过这么一个fd能够对应到最终硬件需要访问的buffer。所以，透过fd的分享和传递，实际实现跨进程、跨设备（包括CPU）的内存共享。</p>\n<p>如果说前面的SYS V、POSIX、memfd_create()更加强调内存在进程间的共享，那么dma_buf则更加强调内存在设备间的共享，它未必需要跨进程。比如：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215600171.png)</p>\n<p>有的童鞋说，为嘛在一个进程里面设备A和B共享内存还需要fd来倒腾一遍呢？我直接设备A驱动弄个全局变量存buffer的物理地址，设备B的驱动访问这个全局变量不就好了吗？我只能说，你对Linux内核的只提供机制不提供策略，以及软件工程每个模块各司其责，高内聚和低耦合的理解，还停留在裸奔的阶段。在没有dma_buf等类似机制的情况下，如果用户空间仍然负责构建策略并连接设备A和B，人们为了追求代码的干净，往往要进行这样的内存拷贝：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215607387.png)</p>\n<p>dma_buf的支持依赖于驱动层是否实现了相关的callbacks。比如在v4l2驱动中，v4l2驱动支持把dma_buf导出（前面讲了v4l2也支持dma_buf的导入，关键看数据方向），它的代码体现在：</p>\n<p>drivers/media/common/videobuf2/videobuf2-dma-contig.c中的：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215615006.png)</p>\n<p>其中的vb2_dc_dmabuf_ops是一个struct dma_buf_ops，它含有多个成员函数：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215624632.png)</p>\n<p>当用户call VIDIOC_EXPBUF这个IOCTL的时候，可以把dma_buf转化为fd：</p>\n<p>int ioctl(int fd, VIDIOC_EXPBUF, struct v4l2_exportbuffer *argp);</p>\n<p>对应着驱动层的代码则会调用dma_buf_fd()：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215631492.png)</p>\n<p>应用程序可以通过如下方式拿到底层的dma_buf的fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215637250.png)</p>\n<p>dma_buf的导入侧设备驱动，则会用到如下这些API：</p>\n<p>dma_buf_attach()</p>\n<p>dma_buf_map_attachment()</p>\n<p>dma_buf_unmap_attachment()</p>\n<p>dma_buf_detach()</p>\n<p>下面这张表，是笔者对这几种共享内存方式总的归纳：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215645563.png)</p>\n<p>落花满天蔽月光，借一杯附荐凤台上。</p>\n<p>全剧终<br>————————————————<br>版权声明：本文为CSDN博主「宋宝华」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/21cnbao/article/details/103470878\">https://blog.csdn.net/21cnbao/article/details/103470878</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"宋宝华：世上最好的共享内存\"><a href=\"#宋宝华：世上最好的共享内存\" class=\"headerlink\" title=\"宋宝华：世上最好的共享内存\"></a>宋宝华：世上最好的共享内存</h2><p>共享单车、共享充电宝、共享雨伞，世间的共享有千万种，而我独爱共享内存。</p>\n<p>早期的共享内存，着重于强调把同一片内存，map到多个进程的虚拟地址空间（在相应进程找到一个VMA区域），以便于CPU可以在各个进程访问到这片内存。</p>\n<p><img src=\"./%E4%B8%96%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/format,png.png\" alt=\"img\"></p>\n<p>现阶段广泛应用于多媒体、Graphics领域的共享内存方式，某种意义上不再强调映射到进程虚拟地址空间的概念（那无非是为了让CPU访问），而更强调以某种“句柄”的形式，让大家知道某一片视频、图形图像数据的存在并可以借助此“句柄”来跨进程引用这片内存，让视频encoder、decoder、GPU等可以跨进程访问内存。所以不同进程用的加速硬件其实是不同的，他们更在乎的是可以通过一个handle拿到这片内存，而不再特别在乎CPU访问它的虚拟地址（当然仍然可以映射到进程的虚拟地址空间供CPU访问）。</p>\n<p><img src=\"./%E4%B8%96%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/format,png-20210408215011301.png\" alt=\"img\"></p>\n<p>只要内存的拷贝(memcpy)仍然是一个占据内存带宽、CPU利用率的消耗大户存在，共享内存作为Linux进程间通信、计算机系统里各个不同硬件组件通信的最高效方法，都将持续繁荣。关于内存拷贝会大多程度地占据CPU利用率，这个可以最简单地尝试拷贝1080P，帧率每秒60的电影画面，我保证你的系统的CPU，蛋会疼地不行。</p>\n<p>我早就想系统地写一篇综述Linux里面各种共享内存方式的文章了，但是一直被带娃这个事业牵绊，今日我决定顶着娃娃们的山呼海啸，也要写一篇文章不吐不快。</p>\n<p>共享内存的方式有很多种，目前主流的方式仍然有：</p>\n<p><img src=\"./%E4%B8%96%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/format,png-20210408215025345.png\" alt=\"img\"></p>\n<p>共享内存的方式</p>\n<p>1.基于传统SYS V的共享内存；</p>\n<p>2.基于POSIX mmap文件映射实现共享内存；</p>\n<p>3.通过memfd_create()和fd跨进程共享实现共享内存；</p>\n<p>4.多媒体、图形领域广泛使用的基于dma-buf的共享内存。</p>\n<p>共享内存</p>\n<p>SYS V共享内存</p>\n<p>历史悠久、年代久远、API怪异，对应内核代码linux/ipc/shm.c，当你编译内核的时候不选择CONFIG_SYSVIPC，则不再具备此能力。</p>\n<p>你在Linux敲ipcs命令看到的share memory就是这种共享内存：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.jpeg)</p>\n<p>下面写一个最简单的程序来看共享内存的写端sw.c：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215041892.png)</p>\n<p>以及共享内存的读端sr.c：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215049945.png)</p>\n<p>编译和准备运行：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215056849.png)</p>\n<p>在此之前我们看一下系统的free:</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215103876.png)</p>\n<p>下面运行sw和sr：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215112625.png)</p>\n<p>我们发现sr打印出来的和sw写进去的是一致的。这个时候我们再看下free：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215118480.png)</p>\n<p>可以看到used显著增大了（711632 -&gt; 715908）, shared显著地增大了（2264 -&gt; 6360），而cached这一列也显著地增大326604-&gt;330716。</p>\n<p>我们都知道cached这一列统计的是file-backed的文件的page cache的大小。理论上，共享内存属于匿名页，但是由于这里面有个非常特殊的tmpfs（/dev/shm指向/run/shm,/run/shm则mount为tmpfs）：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215127651.png)</p>\n<p>所以可以看出tmpfs的东西其实真的是有点含混：我们可以理解它为file-backed的匿名页（anonymous page），有点类似女声中的周深。前面我们反复强调，匿名页是没有文件背景的，这样当进行内存交换的时候，是与swap分区交换。磁盘文件系统里面的东西在内存的副本是file-backed的页面，所以不存在与swap分区交换的问题。但是tmpfs里面的东西，真的是在统计意义上统计到page cache了，但是它并没有真实的磁盘背景，这又和你访问磁盘文件系统里面的文件产生的page cache有本质的区别。所以，它是真地有那么一点misc的感觉，凡事都没有绝对，唯有变化本身是不变的。</p>\n<p>也可以通过ipcs找到新创建的SYS V共享内存：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215135031.jpeg)</p>\n<p>POSIX共享内存</p>\n<p>我对POSIX shm_open()、mmap () API系列的共享内存的喜爱，远远超过SYS V 100倍。原谅我就是一个懒惰的人，我就是讨厌ftok、shmget、shmat、shmdt这样的API。</p>\n<p>上面的程序如果用POSIX的写法，可以简化成写端psw.c：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215142219.png)</p>\n<p>读端：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215150439.png)</p>\n<p>编译和执行：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215157588.png)</p>\n<p>这样我们会在/dev/shm/、/run/shm下面看到一个文件：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215203155.png)</p>\n<p>坦白讲，mmap、munmap这样的API让我找到了回家的感觉，刚入行做Linux的时候，写好framebuffer驱动后，就是把/dev/fb0 mmap到用户空间来操作，所以mmap这样的 API，真的是特别亲切，像亲人一样。</p>\n<p>当然，如果你不喜欢shm_open()这个API，你也可以用常规的open来打开文件，然后进行mmap。关键的是mmap，wikipedia如是说：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215211094.png)</p>\n<p>mmap</p>\n<p>In computing, mmap(2) is a POSIX-compliant Unix system call that maps files or devices into memory. It is a method of memory-mapped file I/O. It implements demand paging, because file contents are not read from disk directly and initially do not use physical RAM at all. The actual reads from disk are performed in a “lazy” manner, after a specific location is accessed. After the memory is no longer needed, it is important to munmap(2) the pointers to it. Protection information can be managed using mprotect(2), and special treatment can be enforced using madvise(2).</p>\n<p>POSIX的共享内存，仍然符合我们前面说的tmpfs的特点，在运行了sw,sr后，再运行psw和psr，我们发现free命令再次戏剧性变化：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215219100.png)</p>\n<p>请将这个free命令的结果与前2次的free结果的各个字段进行对照:</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215225519.jpeg)</p>\n<p>第3次比第2次的cached大了这么多？是因为我编写这篇文章边在访问磁盘里面的文件，当然POSIX的这个共享内存本身也导致cached增大了。</p>\n<p>memfd_create</p>\n<p>如果说POSIX的mmap让我找到回家的感觉，那么memfd_create()则是万般惊艳。见过这种API，才知道什么叫天生尤物——而且是尤物中的尤物，它完全属于那种让码农第一眼看到就会两眼充血，恨不得眼珠子夺眶而出贴到它身上去的那种API；一般人见到它第一次，都会忽略了它的长相，因为它的身材实在太火辣太抢眼了。</p>\n<p>先不要浮想联翩，在所有的所有开始之前，我们要先提一下跨进程分享fd（文件描述符，对应我们很多时候说的“句柄”）这个重要的概念。</p>\n<p>众所周知，Linux的fd属于一个进程级别的东西。进入每个进程的/proc/pid/fd可以看到它的fd的列表：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215235412.png)</p>\n<p>这个进程的0，1，2和那个进程的0，1，2不是一回事。</p>\n<p>某年某月的某一天，人们发现，一个进程其实想访问另外一个进程的fd。当然，这只是目的不是手段。比如进程A有2个fd指向2片内存，如果进程B可以拿到这2个fd，其实就可以透过这2个fd访问到这2片内存。这个fd某种意义上充当了一个中间媒介的作用。有人说，那还不简单吗，如果进程A:</p>\n<p>fd = open();</p>\n<p>open()如果返回100，把这个100告诉进程B不就可以了吗，进程B访问这个100就可以了。这说明你还是没搞明白fd是一个进程内部的东西，是不能跨进程的概念。你的100和我的100，不是一个东西。这些基本的东西你搞不明白，你搞别的都是白搭。</p>\n<p>Linux提供一个特殊的方法，可以把一个进程的fd甩锅、踢皮球给另外一个进程（其实“甩锅”这个词用在这里不合适，因为“甩锅”是一种推卸，而fd的传递是一种分享）。我特码一直想把我的bug甩（分）锅（享）出去，却发现总是被人把bug甩锅过来。</p>\n<p>那么如何甩（分）锅（享）fd呢？</p>\n<p>Linux里面的甩锅需要借助cmsg，用于在socket上传递控制消息（也称Ancillary data），使用SCM_RIGHTS，进程可以透过UNIX Socket把一个或者多个fd(file descriptor)传递给另外一个进程。</p>\n<p>比如下面的这个函数，可以透过socket把fds指向的n个fd发送给另外一个进程：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215243422.png)</p>\n<p>而另外一个进程，则可以透过如下函数接受这个fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215249606.png)</p>\n<p>那么问题来了，如果在进程A中有一个文件的fd是100，发送给进程B后，它还是100吗？不能这么简单地理解，fd本身是一个进程级别的概念，每个进程有自己的fd的列表，比如进程B收到进程A的fd的时候，进程B自身fd空间里面自己的前面200个fd都已经被占用了，那么进程B接受到的fd就可能是201。数字本身在Linux的fd里面真地是一点都不重要，除了几个特殊的0,1,2这样的数字外。同样的，如果你把 cat /proc/interrupts 显示出的中断号就看成是硬件里面的中断偏移号码(比如ARM GIC里某号硬件中断)，你会发现，这个关系整个是一个瞎扯。</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215257440.png)</p>\n<p>知道了甩锅API，那么重要的是，当它与memfd_create()结合的时候，我们准备甩出去的fd是怎么来？它是memfd_create()的返回值。</p>\n<p>memfd_create()这个函数的玄妙之处在于它会返回一个“匿名”内存“文件”的fd，而它本身并没有实体的文件系统路径，其典型用法如下：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215306929.png)</p>\n<p>我们透过memfd_create()创建了一个“文件”，但是它实际映射到一片内存，而且在/xxx/yyy/zzz这样的文件系统下没有路径！没有路径！没有路径！</p>\n<p>所以，当你在Linux里面编程的时候，碰到这样的场景：需要一个fd，当成文件一样操作，但是又不需要真实地位于文件系统，那么，就请立即使用memfd_create()吧，它的manual page是这样描述的：</p>\n<p>memfd_create</p>\n<p>memfd_create() creates an anonymous file and returns a file descriptor that refers to it.  The file behaves like a regular file, and so can be modified, truncated, memory-mapped, and so on.<br>However, unlike a regular file, it lives in RAM and has a volatile backing storage.</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.gif)</p>\n<p>重点理解其中的regular这个单词。它的行动像一个regular的文件，但是它的背景却不regular。</p>\n<p>那么，它和前面我们说的透过UNIX Socket甩锅fd又有什么关系呢？memfd_create()得到了fd，它在行为上类似规则的fd，所以也可以透过socket来进行甩锅，这样A进程相当于把一片与fd对应的内存，分享给了进程B。</p>\n<p>下面的代码进程A通过memfd_create()创建了2片4MB的内存，并且透过socket（路径/tmp/fd-pass.socket）发送给进程B这2片内存对应的fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215333648.jpeg)</p>\n<p>下面的代码进程B透过相同的socket接受这2片内存对应的fd，之后通过read()读取每个文件的前256个字节并打印：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215340645.jpeg)</p>\n<p>上述代码参考了: </p>\n<p><a href=\"https://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/\">https://openforums.wordpress.com/2016/08/07/open-file-descriptor-passing-over-unix-domain-sockets/</a></p>\n<p>上述的代码中，进程B是在进行read(fds[i], buffer, sizeof(buffer))，这体现了基于fd进行操作的regular特点。当然，如果是共享内存，现实的代码肯定还是多半会是mmap：</p>\n<p>mmap(NULL, SIZE, PROT_READ, MAP_SHARED, fd, 0);</p>\n<p>那么，透过socket发送memfd_create() fd来进行进程间共享内存这种方法，它究竟惊艳在哪里？</p>\n<p>我认为首要的惊艳之处在于编程模型的惊艳。API简单、灵活、通用。进程之间想共享几片内存共享几片内存，想怎么共享怎么共享，想共享给谁共享给谁，无非是多了几个fd和socket的传递过程。比如，我从互联网上面收到了jpeg的视频码流，一帧帧的画面，进程A可以创建多片buffer来缓存画面，然后就可以透过把每片buffer对应的fd，递交给另外的进程去解码等。Avenue to Jane(大道至简)，简单的才是最好的！</p>\n<p>memfd_create()的另外一个惊艳之处在于支持“封印”(sealing，就是你玩游戏的时候的封印)，sealing这个单词本身的意思是封条，在这个场景下，我更愿意把它翻译为“封印”。中国传说中的封印，多是采用如五行、太极、八卦等手段，并可有例如符咒、法器等物品的辅助。现指对某个单位施加一种力量，使其无法正常使用某些能力的本领（常出现于玄幻及神魔类作品，游戏中）。我这一生，最喜欢玩的游戏就是《仙剑奇侠传》和《轩辕剑——天之痕》，不知道是否暴露年龄了。</p>\n<p>采用memfd_create()的场景下，我们同样可以用某种法器，来控制共享内存的shrink、grow和write。最初的设想可以详见File Sealing &amp; memfd_create()这篇文章：</p>\n<p><a href=\"https://lwn.net/Articles/591108/\">https://lwn.net/Articles/591108/</a></p>\n<p>我们如果在共享内存上施加了这样的封印，则可以限制对此片区域的ftruncate、write等动作，并建立某种意义上进程之间的相互信任，这是不是很拉风？</p>\n<p>还记得镇压孙悟空的五行山顶的封印吗？还记得孙悟空的紧箍咒吗？还记得悟空每次离开师傅的时候在师傅周围画的一个圈吗？</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215351143.jpeg)</p>\n<p>封印</p>\n<ul>\n<li>SEAL_SHRINK: If set, the inode size cannot be reduced</li>\n<li>SEAL_GROW: If set, the inode size cannot be increased</li>\n<li>SEAL_WRITE: If set, the file content cannot be modified</li>\n</ul>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215504370.gif)</p>\n<p>File Sealing &amp; memfd_create()文中举到的一个典型使用场景是，如果graphics client把它与graphics compoistor共享的内存交给compoistor去render，compoistor必须保证可以拿到这片内存。这里面的风险是client可能透过ftruncate()把这个memory shrink小，这样compositor就拿不到完整的buffer，会造成crash。所以compositor只愿意接受含有SEAL_SHRINK封印的fd，如果没有，对不起，我们不能一起去西天取经。</p>\n<p>在支持memfd_create()后，我们应尽可能地使用这种方式来替代传统的POSIX和SYS V，基本它也是一个趋势，比如我们在wayland相关项目中能看到这样的patch：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215512581.jpeg)</p>\n<p>dma_buf</p>\n<p>dma_buf定义</p>\n<p>The DMABUF framework provides a generic method for sharing buffers between multiple devices. Device drivers that support DMABUF can export a DMA buffer to userspace as a file descriptor (known as the exporter role), import a DMA buffer from userspace using a file descriptor previously exported for a different or the same device (known as the importer role), or both. </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215521174.gif)</p>\n<p>简单地来说，dma_buf可以实现buffer在多个设备的共享，应用可以把一片底层驱动A的buffer导出到用户空间成为一个fd，也可以把fd导入到底层驱动 B。当然，如果进行mmap()得到虚拟地址，CPU也是可以在用户空间访问到已经获得用户空间虚拟地址的底层buffer的。</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215527335.png)</p>\n<p>上图中，进程A访问设备A并获得其使用的buffer的fd，之后通过socket把fd发送给进程B，而后进程B导入fd到设备B，B获得对设备A中的buffer的共享访问。如果CPU也需要在用户态访问这片buffer，则进行了mmap()动作。</p>\n<p>为什么我们要共享DMA buffer？想象一个场景：你要把你的屏幕framebuffer的内容透过gstreamer多媒体组件的服务，变成h264的视频码流，广播到网络上面，变成流媒体播放。在这个场景中，我们就想尽一切可能的避免内存拷贝。</p>\n<p>技术上，管理framebuffer的驱动可以把这片buffer在底层实现为dma_buf，然后graphics compositor给这片buffer映射出来一个fd，之后透过socket发送fd 把这篇内存交给gstreamer相关的进程，如果gstreamer相关的“color space硬件转换”组件、“H264编码硬件组件”可以透过收到的fd还原出这些dma_buf的地址，则可以进行直接的加速操作了。比如color space透过接收到的fd1还原出framebuffer的地址，然后把转化的结果放到另外一片dma_buf，之后fd2对应这片YUV buffer被共享给h264编码器，h264编码器又透过fd2还原出YUV buffer的地址。</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215535838.png)</p>\n<p>这里面的核心点就是fd只是充当了一个“句柄”，用户进程和设备驱动透过fd最终寻找到底层的dma_buf，实现buffer在进程和硬件加速组件之间的zero-copy，这里面唯一进行了exchange的就是fd。</p>\n<p>再比如，如果把方向反过来，gstreamer从网络上收到了视频流，把它透过一系列动作转换为一片RGB的buffer，那么这片RGB的buffer最终还要在graphics compositor里面渲染到屏幕上，我们也需要透过dma_buf实现内存在video的decoder相关组件与GPU组件的共享。</p>\n<p>Linux内核的V4L2驱动(encoder、decoder多采用此种驱动)、DRM(Direct Rendering Manager，framebuffer/GPU相关)等都支持dma_buf。比如在DRM之上，进程可以透过</p>\n<p>int drmPrimeHandleToFD(int fd,</p>\n<p>uint32_t handle,</p>\n<p>uint32_t flags,</p>\n<p>int * prime_fd </p>\n<p>)</p>\n<p>获得底层framebuffer对应的fd。如果这个fd被分享给gstreamer相关进程的video的color space转换，而color space转换硬件组件又被实现为一个V4L2驱动，则我们可以透过V4L2提供的如下接口，将这片buffer提供给V4L2驱动供其导入：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215545396.png)</p>\n<p>如果是multi plane的话，则需要导入多个fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215552177.png)</p>\n<p>相关细节可以参考这个文档：</p>\n<p><a href=\"https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/dmabuf.html\">https://linuxtv.org/downloads/v4l-dvb-apis/uapi/v4l/dmabuf.html</a></p>\n<p>一切都是文件！不是文件创造条件也要把它变成文件！这就是Linux的世界观。是不是文件不重要，关键是你得觉得它是个文件。在dma_buf的场景下，fd这个东西，纯粹就是个”句柄”，方便大家通过这么一个fd能够对应到最终硬件需要访问的buffer。所以，透过fd的分享和传递，实际实现跨进程、跨设备（包括CPU）的内存共享。</p>\n<p>如果说前面的SYS V、POSIX、memfd_create()更加强调内存在进程间的共享，那么dma_buf则更加强调内存在设备间的共享，它未必需要跨进程。比如：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215600171.png)</p>\n<p>有的童鞋说，为嘛在一个进程里面设备A和B共享内存还需要fd来倒腾一遍呢？我直接设备A驱动弄个全局变量存buffer的物理地址，设备B的驱动访问这个全局变量不就好了吗？我只能说，你对Linux内核的只提供机制不提供策略，以及软件工程每个模块各司其责，高内聚和低耦合的理解，还停留在裸奔的阶段。在没有dma_buf等类似机制的情况下，如果用户空间仍然负责构建策略并连接设备A和B，人们为了追求代码的干净，往往要进行这样的内存拷贝：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215607387.png)</p>\n<p>dma_buf的支持依赖于驱动层是否实现了相关的callbacks。比如在v4l2驱动中，v4l2驱动支持把dma_buf导出（前面讲了v4l2也支持dma_buf的导入，关键看数据方向），它的代码体现在：</p>\n<p>drivers/media/common/videobuf2/videobuf2-dma-contig.c中的：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215615006.png)</p>\n<p>其中的vb2_dc_dmabuf_ops是一个struct dma_buf_ops，它含有多个成员函数：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215624632.png)</p>\n<p>当用户call VIDIOC_EXPBUF这个IOCTL的时候，可以把dma_buf转化为fd：</p>\n<p>int ioctl(int fd, VIDIOC_EXPBUF, struct v4l2_exportbuffer *argp);</p>\n<p>对应着驱动层的代码则会调用dma_buf_fd()：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215631492.png)</p>\n<p>应用程序可以通过如下方式拿到底层的dma_buf的fd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215637250.png)</p>\n<p>dma_buf的导入侧设备驱动，则会用到如下这些API：</p>\n<p>dma_buf_attach()</p>\n<p>dma_buf_map_attachment()</p>\n<p>dma_buf_unmap_attachment()</p>\n<p>dma_buf_detach()</p>\n<p>下面这张表，是笔者对这几种共享内存方式总的归纳：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215645563.png)</p>\n<p>落花满天蔽月光，借一杯附荐凤台上。</p>\n<p>全剧终<br>————————————————<br>版权声明：本文为CSDN博主「宋宝华」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/21cnbao/article/details/103470878\">https://blog.csdn.net/21cnbao/article/details/103470878</a></p>\n"},{"title":"Linux中的pushd和popd","date":"2020-12-31T15:59:00.000Z","abbrlink":15500,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# Linux中的pushd和popd\n\n通过使用pushd和popd可以极大地提高效率。\n\n## 1. 使用cd -进行目录切换\n\n一般，Shell中都可以通过cd -命令回到之前的目录，下面是一个例子：\n\n```shell\n$ pwd\n/home/lfqy\n$ cd /\n$ cd -\n/home/lfqy\n$ \n```\n\n实际上，cd -中，-就相当于变量$OLDPWD。cd -就相当于cd $OLDPWD。下面是一个例子：\n\n```shell\n$ pwd\n/home/lfqy\n$ cd /\n$ echo $OLDPWD\n/home/lfqy\n$ cd $OLDPWD\n$ pwd\n/home/lfqy\n$ \n```\n\n\n\n## 2. pushd、popd和dirs\n\npushd和popd是对一个目录栈进行操作，而dirs是显示目录栈的内容。而目录栈就是一个保存目录的栈结构，该栈结构的顶端永远都存放着当前目录（这里点从下面可以进一步看到）。\n\n### 2.1 dirs\n\ndirs常用的有两个参数：\n\n| 选项 | 含义                                          |\n| ---- | --------------------------------------------- |\n| -p   | 每行显示一条记录                              |\n| -v   | 每行显示一条记录，同时展示该记录在栈中的index |\n| -c   | 清空目录栈                                    |\n\n下面没有显示地对目录栈进行任何操作，我们来看下当前目录栈的内容是什么：\n\n```shell\n$ pwd\n/home/lfqy\n$ dirs -v\n 0  ~\n$ cd /\n$ dirs -v\n 0  /\n$ dirs -c\n$ dirs -v\n 0  /\n$ \n```\n\n可以看出，目录栈中只有一个目录(当然是在栈顶)，就是当前所在的目录。当切换目录之后，栈中的目录也随之改变。通过-c选项可以将目录栈中除当前目录之外的其它目录清除，由于上面的例子中目录栈只包含当前目录，所以没有变化。\n\n### 2.2  pushd\n\n每次pushd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。pushd的用法主要有如下几种：\n\n* pushd 目录\n\npushd后面如果直接跟目录使用，会切换到该目录并且将该目录置于目录栈的栈顶。(时时刻刻都要记住，目录栈的栈顶永远存放的是当前目录。如果当前目录发生变化，那么目录栈的栈顶元素肯定也变了；反过来，如果栈顶元素发生变化，那么当前目录肯定也变了。)下面是一个例子：\n\n```shell\n$ pwd\n/home/lfqy\n$ pushd /\n/ ~\n$ dirs -v\n 0  /\n 1  ~\n$ pushd ~/Music/\n~/Music / ~\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$\n```\n\n这样，不难看出，用pushd在切换目录的同时，也将历史目录以栈结构的形式保存了下来。\n\n* pushd不带任何参数。\n\npushd不带任何参数执行的效果就是，将目录栈最顶层的两个目录进行交换。前面说过，栈顶目录和当前目录一个发生变化，另一个也变。这样，实际上，就实现了cd -的功能。下面是一个例子(这个例子接上文的执行现场)：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ pushd\n/ ~/Music ~\n$ dirs -v\n 0  /\n 1  ~/Music\n 2  ~\n$ pushd\n~/Music / ~\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ \n```\n\n* pushd +n\n\n到这里，可能会想如果想切换到目录栈中的任意一个目录，该如何？pushd +n正是这个作用：pushd +n切换到目录栈中的第n个目录(这里的n就是dirs -v命令展示的index)，并将该目录以栈循环的方式推到栈顶。下面是一个例子(接上文的执行现场)，注意栈循环的方式带来的栈中内容的变化规律：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ pushd +2\n~ ~/Music /\n$ dirs -v\n 0  ~\n 1  ~/Music\n 2  /\n$ pushd +1\n~/Music / ~\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ \n```\n\n### 2.3 popd\n\n每次popd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。popd的用法主要有如下几种：\n\n* popd不带参数\n\npopd不带任何参数执行的效果，就是将目录栈中的栈顶元素出栈。这时，栈顶元素发生变化，自然当前目录也会发生相应的切换(接上文的执行现场)，下面是一个例子：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ popd\n/ ~\n$ dirs -v\n 0  /\n 1  ~\n$ popd\n~\n$ dirs -v\n 0  ~\n$ \n```\n\n* popd +n\n\n将目录栈中的第n个元素删除(这里的n就是命令dirs -v显示的目录index)。下面是一个例子：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ popd +2\n~/Music /\n$\n```\n\n这里可以发现，如果对于目录栈的操作没有引发栈顶元素的变化，将不会导致当前目录的切换。\n\n## 3. pushd和popd的+n和-n\n\n上面我们用的都是+n作为参数，实际在使用pushd和popd的时候，有时候也会用到-n参数。两者的差别如下：\n\n* +n的含义是从栈顶往栈底方向进行计数，从0开始；\n\n* -n的含义刚好相反，从栈底向栈顶方向计数，从0开始。\n\n    这样有点拗口，实际上，从默认的dirs命令(不带任何参数)的输出来解释最好理解了：\n\n    * +n是指从左往右数，\n\n    * -n是指从右往左数，\n\n    * 都是从0开始。","source":"_posts/linux_md/Linux Shell/Linux中的pushd和popd.md","raw":"---\ntitle: Linux中的pushd和popd\ndate: '2020/12/31 23:59'\ntags:\n - linux\ncategories:\n - 学习笔记\nabbrlink: 15500\ncover: \n---\n\n# Linux中的pushd和popd\n\n通过使用pushd和popd可以极大地提高效率。\n\n## 1. 使用cd -进行目录切换\n\n一般，Shell中都可以通过cd -命令回到之前的目录，下面是一个例子：\n\n```shell\n$ pwd\n/home/lfqy\n$ cd /\n$ cd -\n/home/lfqy\n$ \n```\n\n实际上，cd -中，-就相当于变量$OLDPWD。cd -就相当于cd $OLDPWD。下面是一个例子：\n\n```shell\n$ pwd\n/home/lfqy\n$ cd /\n$ echo $OLDPWD\n/home/lfqy\n$ cd $OLDPWD\n$ pwd\n/home/lfqy\n$ \n```\n\n\n\n## 2. pushd、popd和dirs\n\npushd和popd是对一个目录栈进行操作，而dirs是显示目录栈的内容。而目录栈就是一个保存目录的栈结构，该栈结构的顶端永远都存放着当前目录（这里点从下面可以进一步看到）。\n\n### 2.1 dirs\n\ndirs常用的有两个参数：\n\n| 选项 | 含义                                          |\n| ---- | --------------------------------------------- |\n| -p   | 每行显示一条记录                              |\n| -v   | 每行显示一条记录，同时展示该记录在栈中的index |\n| -c   | 清空目录栈                                    |\n\n下面没有显示地对目录栈进行任何操作，我们来看下当前目录栈的内容是什么：\n\n```shell\n$ pwd\n/home/lfqy\n$ dirs -v\n 0  ~\n$ cd /\n$ dirs -v\n 0  /\n$ dirs -c\n$ dirs -v\n 0  /\n$ \n```\n\n可以看出，目录栈中只有一个目录(当然是在栈顶)，就是当前所在的目录。当切换目录之后，栈中的目录也随之改变。通过-c选项可以将目录栈中除当前目录之外的其它目录清除，由于上面的例子中目录栈只包含当前目录，所以没有变化。\n\n### 2.2  pushd\n\n每次pushd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。pushd的用法主要有如下几种：\n\n* pushd 目录\n\npushd后面如果直接跟目录使用，会切换到该目录并且将该目录置于目录栈的栈顶。(时时刻刻都要记住，目录栈的栈顶永远存放的是当前目录。如果当前目录发生变化，那么目录栈的栈顶元素肯定也变了；反过来，如果栈顶元素发生变化，那么当前目录肯定也变了。)下面是一个例子：\n\n```shell\n$ pwd\n/home/lfqy\n$ pushd /\n/ ~\n$ dirs -v\n 0  /\n 1  ~\n$ pushd ~/Music/\n~/Music / ~\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$\n```\n\n这样，不难看出，用pushd在切换目录的同时，也将历史目录以栈结构的形式保存了下来。\n\n* pushd不带任何参数。\n\npushd不带任何参数执行的效果就是，将目录栈最顶层的两个目录进行交换。前面说过，栈顶目录和当前目录一个发生变化，另一个也变。这样，实际上，就实现了cd -的功能。下面是一个例子(这个例子接上文的执行现场)：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ pushd\n/ ~/Music ~\n$ dirs -v\n 0  /\n 1  ~/Music\n 2  ~\n$ pushd\n~/Music / ~\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ \n```\n\n* pushd +n\n\n到这里，可能会想如果想切换到目录栈中的任意一个目录，该如何？pushd +n正是这个作用：pushd +n切换到目录栈中的第n个目录(这里的n就是dirs -v命令展示的index)，并将该目录以栈循环的方式推到栈顶。下面是一个例子(接上文的执行现场)，注意栈循环的方式带来的栈中内容的变化规律：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ pushd +2\n~ ~/Music /\n$ dirs -v\n 0  ~\n 1  ~/Music\n 2  /\n$ pushd +1\n~/Music / ~\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ \n```\n\n### 2.3 popd\n\n每次popd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。popd的用法主要有如下几种：\n\n* popd不带参数\n\npopd不带任何参数执行的效果，就是将目录栈中的栈顶元素出栈。这时，栈顶元素发生变化，自然当前目录也会发生相应的切换(接上文的执行现场)，下面是一个例子：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ popd\n/ ~\n$ dirs -v\n 0  /\n 1  ~\n$ popd\n~\n$ dirs -v\n 0  ~\n$ \n```\n\n* popd +n\n\n将目录栈中的第n个元素删除(这里的n就是命令dirs -v显示的目录index)。下面是一个例子：\n\n```shell\n$ dirs -v\n 0  ~/Music\n 1  /\n 2  ~\n$ popd +2\n~/Music /\n$\n```\n\n这里可以发现，如果对于目录栈的操作没有引发栈顶元素的变化，将不会导致当前目录的切换。\n\n## 3. pushd和popd的+n和-n\n\n上面我们用的都是+n作为参数，实际在使用pushd和popd的时候，有时候也会用到-n参数。两者的差别如下：\n\n* +n的含义是从栈顶往栈底方向进行计数，从0开始；\n\n* -n的含义刚好相反，从栈底向栈顶方向计数，从0开始。\n\n    这样有点拗口，实际上，从默认的dirs命令(不带任何参数)的输出来解释最好理解了：\n\n    * +n是指从左往右数，\n\n    * -n是指从右往左数，\n\n    * 都是从0开始。","slug":"linux_md/Linux Shell/Linux中的pushd和popd","published":1,"updated":"2021-04-08T14:09:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr61001pw9q924il3pzp","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Linux中的pushd和popd\"><a href=\"#Linux中的pushd和popd\" class=\"headerlink\" title=\"Linux中的pushd和popd\"></a>Linux中的pushd和popd</h1><p>通过使用pushd和popd可以极大地提高效率。</p>\n<h2 id=\"1-使用cd-进行目录切换\"><a href=\"#1-使用cd-进行目录切换\" class=\"headerlink\" title=\"1. 使用cd -进行目录切换\"></a>1. 使用cd -进行目录切换</h2><p>一般，Shell中都可以通过cd -命令回到之前的目录，下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> -</span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<p>实际上，cd -中，-就相当于变量$OLDPWD。cd -就相当于cd $OLDPWD。下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$OLDPWD</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> <span class=\"variable\">$OLDPWD</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-pushd、popd和dirs\"><a href=\"#2-pushd、popd和dirs\" class=\"headerlink\" title=\"2. pushd、popd和dirs\"></a>2. pushd、popd和dirs</h2><p>pushd和popd是对一个目录栈进行操作，而dirs是显示目录栈的内容。而目录栈就是一个保存目录的栈结构，该栈结构的顶端永远都存放着当前目录（这里点从下面可以进一步看到）。</p>\n<h3 id=\"2-1-dirs\"><a href=\"#2-1-dirs\" class=\"headerlink\" title=\"2.1 dirs\"></a>2.1 dirs</h3><p>dirs常用的有两个参数：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-p</td>\n<td>每行显示一条记录</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>每行显示一条记录，同时展示该记录在栈中的index</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>清空目录栈</td>\n</tr>\n</tbody></table>\n<p>下面没有显示地对目录栈进行任何操作，我们来看下当前目录栈的内容是什么：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -c</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<p>可以看出，目录栈中只有一个目录(当然是在栈顶)，就是当前所在的目录。当切换目录之后，栈中的目录也随之改变。通过-c选项可以将目录栈中除当前目录之外的其它目录清除，由于上面的例子中目录栈只包含当前目录，所以没有变化。</p>\n<h3 id=\"2-2-pushd\"><a href=\"#2-2-pushd\" class=\"headerlink\" title=\"2.2  pushd\"></a>2.2  pushd</h3><p>每次pushd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。pushd的用法主要有如下几种：</p>\n<ul>\n<li>pushd 目录</li>\n</ul>\n<p>pushd后面如果直接跟目录使用，会切换到该目录并且将该目录置于目录栈的栈顶。(时时刻刻都要记住，目录栈的栈顶永远存放的是当前目录。如果当前目录发生变化，那么目录栈的栈顶元素肯定也变了；反过来，如果栈顶元素发生变化，那么当前目录肯定也变了。)下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> /</span></span><br><span class=\"line\">/ ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"> 1  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> ~/Music/</span></span><br><span class=\"line\">~/Music / ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span></span><br></pre></td></tr></table></figure>\n<p>这样，不难看出，用pushd在切换目录的同时，也将历史目录以栈结构的形式保存了下来。</p>\n<ul>\n<li>pushd不带任何参数。</li>\n</ul>\n<p>pushd不带任何参数执行的效果就是，将目录栈最顶层的两个目录进行交换。前面说过，栈顶目录和当前目录一个发生变化，另一个也变。这样，实际上，就实现了cd -的功能。下面是一个例子(这个例子接上文的执行现场)：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span></span></span><br><span class=\"line\">/ ~/Music ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"> 1  ~/Music</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span></span></span><br><span class=\"line\">~/Music / ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>pushd +n</li>\n</ul>\n<p>到这里，可能会想如果想切换到目录栈中的任意一个目录，该如何？pushd +n正是这个作用：pushd +n切换到目录栈中的第n个目录(这里的n就是dirs -v命令展示的index)，并将该目录以栈循环的方式推到栈顶。下面是一个例子(接上文的执行现场)，注意栈循环的方式带来的栈中内容的变化规律：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> +2</span></span><br><span class=\"line\">~ ~/Music /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~</span><br><span class=\"line\"> 1  ~/Music</span><br><span class=\"line\"> 2  /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> +1</span></span><br><span class=\"line\">~/Music / ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-popd\"><a href=\"#2-3-popd\" class=\"headerlink\" title=\"2.3 popd\"></a>2.3 popd</h3><p>每次popd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。popd的用法主要有如下几种：</p>\n<ul>\n<li>popd不带参数</li>\n</ul>\n<p>popd不带任何参数执行的效果，就是将目录栈中的栈顶元素出栈。这时，栈顶元素发生变化，自然当前目录也会发生相应的切换(接上文的执行现场)，下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">popd</span></span></span><br><span class=\"line\">/ ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"> 1  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">popd</span></span></span><br><span class=\"line\">~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>popd +n</li>\n</ul>\n<p>将目录栈中的第n个元素删除(这里的n就是命令dirs -v显示的目录index)。下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">popd</span> +2</span></span><br><span class=\"line\">~/Music /</span><br><span class=\"line\"><span class=\"meta\">$</span></span><br></pre></td></tr></table></figure>\n<p>这里可以发现，如果对于目录栈的操作没有引发栈顶元素的变化，将不会导致当前目录的切换。</p>\n<h2 id=\"3-pushd和popd的-n和-n\"><a href=\"#3-pushd和popd的-n和-n\" class=\"headerlink\" title=\"3. pushd和popd的+n和-n\"></a>3. pushd和popd的+n和-n</h2><p>上面我们用的都是+n作为参数，实际在使用pushd和popd的时候，有时候也会用到-n参数。两者的差别如下：</p>\n<ul>\n<li><p>+n的含义是从栈顶往栈底方向进行计数，从0开始；</p>\n</li>\n<li><p>-n的含义刚好相反，从栈底向栈顶方向计数，从0开始。</p>\n<p>  这样有点拗口，实际上，从默认的dirs命令(不带任何参数)的输出来解释最好理解了：</p>\n<ul>\n<li><p>+n是指从左往右数，</p>\n</li>\n<li><p>-n是指从右往左数，</p>\n</li>\n<li><p>都是从0开始。</p>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Linux中的pushd和popd\"><a href=\"#Linux中的pushd和popd\" class=\"headerlink\" title=\"Linux中的pushd和popd\"></a>Linux中的pushd和popd</h1><p>通过使用pushd和popd可以极大地提高效率。</p>\n<h2 id=\"1-使用cd-进行目录切换\"><a href=\"#1-使用cd-进行目录切换\" class=\"headerlink\" title=\"1. 使用cd -进行目录切换\"></a>1. 使用cd -进行目录切换</h2><p>一般，Shell中都可以通过cd -命令回到之前的目录，下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> -</span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<p>实际上，cd -中，-就相当于变量$OLDPWD。cd -就相当于cd $OLDPWD。下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">echo</span> <span class=\"variable\">$OLDPWD</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> <span class=\"variable\">$OLDPWD</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-pushd、popd和dirs\"><a href=\"#2-pushd、popd和dirs\" class=\"headerlink\" title=\"2. pushd、popd和dirs\"></a>2. pushd、popd和dirs</h2><p>pushd和popd是对一个目录栈进行操作，而dirs是显示目录栈的内容。而目录栈就是一个保存目录的栈结构，该栈结构的顶端永远都存放着当前目录（这里点从下面可以进一步看到）。</p>\n<h3 id=\"2-1-dirs\"><a href=\"#2-1-dirs\" class=\"headerlink\" title=\"2.1 dirs\"></a>2.1 dirs</h3><p>dirs常用的有两个参数：</p>\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-p</td>\n<td>每行显示一条记录</td>\n</tr>\n<tr>\n<td>-v</td>\n<td>每行显示一条记录，同时展示该记录在栈中的index</td>\n</tr>\n<tr>\n<td>-c</td>\n<td>清空目录栈</td>\n</tr>\n</tbody></table>\n<p>下面没有显示地对目录栈进行任何操作，我们来看下当前目录栈的内容是什么：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">cd</span> /</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -c</span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<p>可以看出，目录栈中只有一个目录(当然是在栈顶)，就是当前所在的目录。当切换目录之后，栈中的目录也随之改变。通过-c选项可以将目录栈中除当前目录之外的其它目录清除，由于上面的例子中目录栈只包含当前目录，所以没有变化。</p>\n<h3 id=\"2-2-pushd\"><a href=\"#2-2-pushd\" class=\"headerlink\" title=\"2.2  pushd\"></a>2.2  pushd</h3><p>每次pushd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。pushd的用法主要有如下几种：</p>\n<ul>\n<li>pushd 目录</li>\n</ul>\n<p>pushd后面如果直接跟目录使用，会切换到该目录并且将该目录置于目录栈的栈顶。(时时刻刻都要记住，目录栈的栈顶永远存放的是当前目录。如果当前目录发生变化，那么目录栈的栈顶元素肯定也变了；反过来，如果栈顶元素发生变化，那么当前目录肯定也变了。)下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pwd</span></span></span><br><span class=\"line\">/home/lfqy</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> /</span></span><br><span class=\"line\">/ ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"> 1  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> ~/Music/</span></span><br><span class=\"line\">~/Music / ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span></span><br></pre></td></tr></table></figure>\n<p>这样，不难看出，用pushd在切换目录的同时，也将历史目录以栈结构的形式保存了下来。</p>\n<ul>\n<li>pushd不带任何参数。</li>\n</ul>\n<p>pushd不带任何参数执行的效果就是，将目录栈最顶层的两个目录进行交换。前面说过，栈顶目录和当前目录一个发生变化，另一个也变。这样，实际上，就实现了cd -的功能。下面是一个例子(这个例子接上文的执行现场)：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span></span></span><br><span class=\"line\">/ ~/Music ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"> 1  ~/Music</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span></span></span><br><span class=\"line\">~/Music / ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>pushd +n</li>\n</ul>\n<p>到这里，可能会想如果想切换到目录栈中的任意一个目录，该如何？pushd +n正是这个作用：pushd +n切换到目录栈中的第n个目录(这里的n就是dirs -v命令展示的index)，并将该目录以栈循环的方式推到栈顶。下面是一个例子(接上文的执行现场)，注意栈循环的方式带来的栈中内容的变化规律：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> +2</span></span><br><span class=\"line\">~ ~/Music /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~</span><br><span class=\"line\"> 1  ~/Music</span><br><span class=\"line\"> 2  /</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">pushd</span> +1</span></span><br><span class=\"line\">~/Music / ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-3-popd\"><a href=\"#2-3-popd\" class=\"headerlink\" title=\"2.3 popd\"></a>2.3 popd</h3><p>每次popd命令执行完成之后，默认都会执行一个dirs命令来显示目录栈的内容。popd的用法主要有如下几种：</p>\n<ul>\n<li>popd不带参数</li>\n</ul>\n<p>popd不带任何参数执行的效果，就是将目录栈中的栈顶元素出栈。这时，栈顶元素发生变化，自然当前目录也会发生相应的切换(接上文的执行现场)，下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">popd</span></span></span><br><span class=\"line\">/ ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  /</span><br><span class=\"line\"> 1  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">popd</span></span></span><br><span class=\"line\">~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> </span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>popd +n</li>\n</ul>\n<p>将目录栈中的第n个元素删除(这里的n就是命令dirs -v显示的目录index)。下面是一个例子：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">dirs</span> -v</span></span><br><span class=\"line\"> 0  ~/Music</span><br><span class=\"line\"> 1  /</span><br><span class=\"line\"> 2  ~</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> <span class=\"built_in\">popd</span> +2</span></span><br><span class=\"line\">~/Music /</span><br><span class=\"line\"><span class=\"meta\">$</span></span><br></pre></td></tr></table></figure>\n<p>这里可以发现，如果对于目录栈的操作没有引发栈顶元素的变化，将不会导致当前目录的切换。</p>\n<h2 id=\"3-pushd和popd的-n和-n\"><a href=\"#3-pushd和popd的-n和-n\" class=\"headerlink\" title=\"3. pushd和popd的+n和-n\"></a>3. pushd和popd的+n和-n</h2><p>上面我们用的都是+n作为参数，实际在使用pushd和popd的时候，有时候也会用到-n参数。两者的差别如下：</p>\n<ul>\n<li><p>+n的含义是从栈顶往栈底方向进行计数，从0开始；</p>\n</li>\n<li><p>-n的含义刚好相反，从栈底向栈顶方向计数，从0开始。</p>\n<p>  这样有点拗口，实际上，从默认的dirs命令(不带任何参数)的输出来解释最好理解了：</p>\n<ul>\n<li><p>+n是指从左往右数，</p>\n</li>\n<li><p>-n是指从右往左数，</p>\n</li>\n<li><p>都是从0开始。</p>\n</li>\n</ul>\n</li>\n</ul>\n"},{"title":"How to write SPEC file","date":"2020-12-31T15:59:00.000Z","abbrlink":13009,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"# How to write SPEC file\n\nSPEC file is the rule to package a RPM build, compile files in source code(subsystem) and generates a file hierarchy and select them to package. \n\nthe Makefile and configure file will generate the needed bin/files and put them into a build hierarchy .\n\nlike:\n\n```\nscriptdir=$(libexecdir)/$(NAME)/scripts/ → here xxxdir like scriptdir is the package dir , now it's $(libexecdir) xxx\nscript_SCRIPTS=\\  → xxx SCRIPTS is the scripts that will put into the package dir after makefile exectued.\n$(top_srcdir)/conf/mkdir_for_swmdaemon.sh \\  → these are the file path under source code subsystem\n$(top_srcdir)/plugin/remove_release_json.sh \\  → so after makefile compile these files will put into $(libexecdir)/$(NAME)/scripts/\n$(top_srcdir)/plugin/swm_wait_vnf_ready.sh\n```\n\nthe SPEC file will selected the generated files and package them in %files filed.\n\n%files\n%{_libexecdir}/* → selected all files (after compile makefile) under {_libexecdir}/ , like about 3 files, we can see as\n\n\\# rpm -qlv swmdaemon-9999.8bf34939_f5ec347c-1.wf32.1614301476.x86_64\n\n-rwxr-xr-x 1 root root 1570 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/mkdir_for_swmdaemon.sh\n-rwxr-xr-x 1 root root 239 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/remove_release_json.sh\n-rwxr-xr-x 1 root root 672 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/swm_wait_vnf_ready.sh\n\nthis %{_libexecdir}/ is /usr/libexec, can see in bellow link\n\nhttps://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/\n\none SPEC file by default will generate one base RPM like it's name, if need more RPMs ,need to add in %package.\n\n\n\nhttps://rpm-packaging-guide.github.io/\n\n\n\nExcludeArch: aarch64  → only x86\n%global debug_package %{nil}  → no debug RPM (used in some script subsystem like python ,shell)\n\nRequires: %{name}-sudoers%{?_isa} = %{version}-%{release} → use the macro like %{name} %{?_isa} = %{version}-%{release}\nRequires: %{name}-AAA%{?_isa} = %{version}-%{release} \n\n%package sudoers   → sub RPMs  <Name>-sudoer\nSummary: Sudo for %{name}\nRequires: sudo     → sub RPMs require RPM\n\n\n\n%post systemd  → after install 'systemd' RPM will execute bellow command (script)\n%systemd_post swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service\n\n→%systemd_post is the macro can see the script by bellow command \n\n'/usr/bin/systemctl --no-reload preset' this is the %systemd_post\n\nswmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm\n[d13li@conde x86_64]$ rpm -q --scripts swmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm\npostinstall scriptlet (using /bin/sh):if [ $1 -eq 1 ] && [ -x /usr/bin/systemctl ]; then\n\\# Initial installation\n/usr/bin/systemctl --no-reload preset swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :\nfi\npreuninstall scriptlet (using /bin/sh):\n\n\nif [ $1 -eq 0 ] && [ -x /usr/bin/systemctl ]; then\n\\# Package removal, not upgrade\n/usr/bin/systemctl --no-reload disable --now swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :\nfi\npostuninstall program: /bin/sh\n[d13li@conde x86_64]$ pwd\n/home/d13li/workbench/swmdaemonIntegration/RPMS/x86_64\n\n\n\n%files sudoers\n%attr(0440, root, root) %{_sysconfdir}/sudoers.d/swmdaemon_sudoers → %attr will add file into package and set the attribute.\n\n\n\nsubsystem's can in cyclic dependency like in \"BuildRequires:\" file\n\nThere is one issue for swmdaemon.spec, swmdaemon depends on apigw and apigw depends on swmdaemon, need to solve it.\n\nEither swmdaemon or api-gateway-framework (or both) must be divided to two separate subsystems:\n\nCore subsystem, which doesn't depend on anything Plugin or integration subsystem, which depends on the core subsystem and swmdaemon or api-gateway-framework\n\n\n\na file in which RPM we can check in ENV like:\n\n\\# rpm -qf /var/api-gateway-framework/upstream-apis/\napi-gateway-framework-rcp-integration-1.44.0-1.wf32.x86_64\n\nin ENV check RPM can use\n\nrpm -qa | grep xxx\n\n\n\n.pc file will provide the lib path used marco to other user, that if the path change don't impact user.\n\nlike\n\n[swmdaemonplugin.pc.in](http://swmdaemonplugin.pc.in/):\n\nprefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nswmplugindir=${libdir}/swm.d/plugins  → this swmplugindir will use by CertMan etc. , CertMan can put it's plungin inder this folder.\n\n​                                 → so CertMan will need to `BuildRequires: pkgconfig(swmdaemonplugin)`\nName: swmdaemonplugin\nDescription: Plugin of blue green upgrade SWM daemon\nURL: @PACKAGE_URL@\nVersion: @PACKAGE_VERSION@\n\nhttps://en.wikipedia.org/wiki/Pkg-config\n\n**pkg-config** is a computer program that defines and supports a unified interface for querying installed [libraries](https://en.wikipedia.org/wiki/Library_(computer_science)) for the purpose of [compiling](https://en.wikipedia.org/wiki/Compiler) software that depends on them. It allows programmers and installation scripts to work without explicit knowledge of detailed library path information. pkg-config was originally designed for [Linux](https://en.wikipedia.org/wiki/Linux), but it is now also available for [BSD](https://en.wikipedia.org/wiki/Berkeley_Software_Distribution), [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows), [macOS](https://en.wikipedia.org/wiki/MacOS), and [Solaris](https://en.wikipedia.org/wiki/Solaris_(operating_system)).\n\n\n\nRPMs are started by kickstarts like, kickstarts start swmdaemonIntegration firstly, swmdaemonIntegration requries swmdaemon, so it will start swmdaemon later , etc.\n\nTang Shijun is response for rcp-kickstarts.\n\n[Add swmdaemonintegration for CU Cloud build (!83) · Merge Requests · RCP / rcp-kickstarts · GitLab (nokia.com)](https://gitlabe1.ext.net.nokia.com/RCP/rcp-kickstarts/-/merge_requests/83)","source":"_posts/linux_md/Makefile/How to write SPEC file.md","raw":"---\ntitle: How to write SPEC file\ndate: '2020/12/31 23:59'\ntags:\n - baisc\n - Encrypted\ncategories:\n - 个人项目\nabbrlink: 13009\ncover: \n---\n# How to write SPEC file\n\nSPEC file is the rule to package a RPM build, compile files in source code(subsystem) and generates a file hierarchy and select them to package. \n\nthe Makefile and configure file will generate the needed bin/files and put them into a build hierarchy .\n\nlike:\n\n```\nscriptdir=$(libexecdir)/$(NAME)/scripts/ → here xxxdir like scriptdir is the package dir , now it's $(libexecdir) xxx\nscript_SCRIPTS=\\  → xxx SCRIPTS is the scripts that will put into the package dir after makefile exectued.\n$(top_srcdir)/conf/mkdir_for_swmdaemon.sh \\  → these are the file path under source code subsystem\n$(top_srcdir)/plugin/remove_release_json.sh \\  → so after makefile compile these files will put into $(libexecdir)/$(NAME)/scripts/\n$(top_srcdir)/plugin/swm_wait_vnf_ready.sh\n```\n\nthe SPEC file will selected the generated files and package them in %files filed.\n\n%files\n%{_libexecdir}/* → selected all files (after compile makefile) under {_libexecdir}/ , like about 3 files, we can see as\n\n\\# rpm -qlv swmdaemon-9999.8bf34939_f5ec347c-1.wf32.1614301476.x86_64\n\n-rwxr-xr-x 1 root root 1570 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/mkdir_for_swmdaemon.sh\n-rwxr-xr-x 1 root root 239 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/remove_release_json.sh\n-rwxr-xr-x 1 root root 672 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/swm_wait_vnf_ready.sh\n\nthis %{_libexecdir}/ is /usr/libexec, can see in bellow link\n\nhttps://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/\n\none SPEC file by default will generate one base RPM like it's name, if need more RPMs ,need to add in %package.\n\n\n\nhttps://rpm-packaging-guide.github.io/\n\n\n\nExcludeArch: aarch64  → only x86\n%global debug_package %{nil}  → no debug RPM (used in some script subsystem like python ,shell)\n\nRequires: %{name}-sudoers%{?_isa} = %{version}-%{release} → use the macro like %{name} %{?_isa} = %{version}-%{release}\nRequires: %{name}-AAA%{?_isa} = %{version}-%{release} \n\n%package sudoers   → sub RPMs  <Name>-sudoer\nSummary: Sudo for %{name}\nRequires: sudo     → sub RPMs require RPM\n\n\n\n%post systemd  → after install 'systemd' RPM will execute bellow command (script)\n%systemd_post swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service\n\n→%systemd_post is the macro can see the script by bellow command \n\n'/usr/bin/systemctl --no-reload preset' this is the %systemd_post\n\nswmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm\n[d13li@conde x86_64]$ rpm -q --scripts swmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm\npostinstall scriptlet (using /bin/sh):if [ $1 -eq 1 ] && [ -x /usr/bin/systemctl ]; then\n\\# Initial installation\n/usr/bin/systemctl --no-reload preset swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :\nfi\npreuninstall scriptlet (using /bin/sh):\n\n\nif [ $1 -eq 0 ] && [ -x /usr/bin/systemctl ]; then\n\\# Package removal, not upgrade\n/usr/bin/systemctl --no-reload disable --now swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :\nfi\npostuninstall program: /bin/sh\n[d13li@conde x86_64]$ pwd\n/home/d13li/workbench/swmdaemonIntegration/RPMS/x86_64\n\n\n\n%files sudoers\n%attr(0440, root, root) %{_sysconfdir}/sudoers.d/swmdaemon_sudoers → %attr will add file into package and set the attribute.\n\n\n\nsubsystem's can in cyclic dependency like in \"BuildRequires:\" file\n\nThere is one issue for swmdaemon.spec, swmdaemon depends on apigw and apigw depends on swmdaemon, need to solve it.\n\nEither swmdaemon or api-gateway-framework (or both) must be divided to two separate subsystems:\n\nCore subsystem, which doesn't depend on anything Plugin or integration subsystem, which depends on the core subsystem and swmdaemon or api-gateway-framework\n\n\n\na file in which RPM we can check in ENV like:\n\n\\# rpm -qf /var/api-gateway-framework/upstream-apis/\napi-gateway-framework-rcp-integration-1.44.0-1.wf32.x86_64\n\nin ENV check RPM can use\n\nrpm -qa | grep xxx\n\n\n\n.pc file will provide the lib path used marco to other user, that if the path change don't impact user.\n\nlike\n\n[swmdaemonplugin.pc.in](http://swmdaemonplugin.pc.in/):\n\nprefix=@prefix@\nexec_prefix=@exec_prefix@\nlibdir=@libdir@\nswmplugindir=${libdir}/swm.d/plugins  → this swmplugindir will use by CertMan etc. , CertMan can put it's plungin inder this folder.\n\n​                                 → so CertMan will need to `BuildRequires: pkgconfig(swmdaemonplugin)`\nName: swmdaemonplugin\nDescription: Plugin of blue green upgrade SWM daemon\nURL: @PACKAGE_URL@\nVersion: @PACKAGE_VERSION@\n\nhttps://en.wikipedia.org/wiki/Pkg-config\n\n**pkg-config** is a computer program that defines and supports a unified interface for querying installed [libraries](https://en.wikipedia.org/wiki/Library_(computer_science)) for the purpose of [compiling](https://en.wikipedia.org/wiki/Compiler) software that depends on them. It allows programmers and installation scripts to work without explicit knowledge of detailed library path information. pkg-config was originally designed for [Linux](https://en.wikipedia.org/wiki/Linux), but it is now also available for [BSD](https://en.wikipedia.org/wiki/Berkeley_Software_Distribution), [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows), [macOS](https://en.wikipedia.org/wiki/MacOS), and [Solaris](https://en.wikipedia.org/wiki/Solaris_(operating_system)).\n\n\n\nRPMs are started by kickstarts like, kickstarts start swmdaemonIntegration firstly, swmdaemonIntegration requries swmdaemon, so it will start swmdaemon later , etc.\n\nTang Shijun is response for rcp-kickstarts.\n\n[Add swmdaemonintegration for CU Cloud build (!83) · Merge Requests · RCP / rcp-kickstarts · GitLab (nokia.com)](https://gitlabe1.ext.net.nokia.com/RCP/rcp-kickstarts/-/merge_requests/83)","slug":"linux_md/Makefile/How to write SPEC file","published":1,"updated":"2021-04-13T14:15:41.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr61001sw9q9goufew1w","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"How-to-write-SPEC-file\"><a href=\"#How-to-write-SPEC-file\" class=\"headerlink\" title=\"How to write SPEC file\"></a>How to write SPEC file</h1><p>SPEC file is the rule to package a RPM build, compile files in source code(subsystem) and generates a file hierarchy and select them to package. </p>\n<p>the Makefile and configure file will generate the needed bin/files and put them into a build hierarchy .</p>\n<p>like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scriptdir&#x3D;$(libexecdir)&#x2F;$(NAME)&#x2F;scripts&#x2F; → here xxxdir like scriptdir is the package dir , now it&#39;s $(libexecdir) xxx</span><br><span class=\"line\">script_SCRIPTS&#x3D;\\  → xxx SCRIPTS is the scripts that will put into the package dir after makefile exectued.</span><br><span class=\"line\">$(top_srcdir)&#x2F;conf&#x2F;mkdir_for_swmdaemon.sh \\  → these are the file path under source code subsystem</span><br><span class=\"line\">$(top_srcdir)&#x2F;plugin&#x2F;remove_release_json.sh \\  → so after makefile compile these files will put into $(libexecdir)&#x2F;$(NAME)&#x2F;scripts&#x2F;</span><br><span class=\"line\">$(top_srcdir)&#x2F;plugin&#x2F;swm_wait_vnf_ready.sh</span><br></pre></td></tr></table></figure>\n<p>the SPEC file will selected the generated files and package them in %files filed.</p>\n<p>%files<br>%{_libexecdir}/* → selected all files (after compile makefile) under {_libexecdir}/ , like about 3 files, we can see as</p>\n<p># rpm -qlv swmdaemon-9999.8bf34939_f5ec347c-1.wf32.1614301476.x86_64</p>\n<p>-rwxr-xr-x 1 root root 1570 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/mkdir_for_swmdaemon.sh<br>-rwxr-xr-x 1 root root 239 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/remove_release_json.sh<br>-rwxr-xr-x 1 root root 672 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/swm_wait_vnf_ready.sh</p>\n<p>this %{_libexecdir}/ is /usr/libexec, can see in bellow link</p>\n<p><a href=\"https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/\">https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/</a></p>\n<p>one SPEC file by default will generate one base RPM like it’s name, if need more RPMs ,need to add in %package.</p>\n<p><a href=\"https://rpm-packaging-guide.github.io/\">https://rpm-packaging-guide.github.io/</a></p>\n<p>ExcludeArch: aarch64  → only x86<br>%global debug_package %{nil}  → no debug RPM (used in some script subsystem like python ,shell)</p>\n<p>Requires: %{name}-sudoers%{?_isa} = %{version}-%{release} → use the macro like %{name} %{?_isa} = %{version}-%{release}<br>Requires: %{name}-AAA%{?_isa} = %{version}-%{release} </p>\n<p>%package sudoers   → sub RPMs  <Name>-sudoer<br>Summary: Sudo for %{name}<br>Requires: sudo     → sub RPMs require RPM</p>\n<p>%post systemd  → after install ‘systemd’ RPM will execute bellow command (script)<br>%systemd_post swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service</p>\n<p>→%systemd_post is the macro can see the script by bellow command </p>\n<p>‘/usr/bin/systemctl –no-reload preset’ this is the %systemd_post</p>\n<p>swmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm<br>[d13li@conde x86_64]$ rpm -q –scripts swmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm<br>postinstall scriptlet (using /bin/sh):if [ $1 -eq 1 ] &amp;&amp; [ -x /usr/bin/systemctl ]; then<br># Initial installation<br>/usr/bin/systemctl –no-reload preset swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :<br>fi<br>preuninstall scriptlet (using /bin/sh):</p>\n<p>if [ $1 -eq 0 ] &amp;&amp; [ -x /usr/bin/systemctl ]; then<br># Package removal, not upgrade<br>/usr/bin/systemctl –no-reload disable –now swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :<br>fi<br>postuninstall program: /bin/sh<br>[d13li@conde x86_64]$ pwd<br>/home/d13li/workbench/swmdaemonIntegration/RPMS/x86_64</p>\n<p>%files sudoers<br>%attr(0440, root, root) %{_sysconfdir}/sudoers.d/swmdaemon_sudoers → %attr will add file into package and set the attribute.</p>\n<p>subsystem’s can in cyclic dependency like in “BuildRequires:” file</p>\n<p>There is one issue for swmdaemon.spec, swmdaemon depends on apigw and apigw depends on swmdaemon, need to solve it.</p>\n<p>Either swmdaemon or api-gateway-framework (or both) must be divided to two separate subsystems:</p>\n<p>Core subsystem, which doesn’t depend on anything Plugin or integration subsystem, which depends on the core subsystem and swmdaemon or api-gateway-framework</p>\n<p>a file in which RPM we can check in ENV like:</p>\n<p># rpm -qf /var/api-gateway-framework/upstream-apis/<br>api-gateway-framework-rcp-integration-1.44.0-1.wf32.x86_64</p>\n<p>in ENV check RPM can use</p>\n<p>rpm -qa | grep xxx</p>\n<p>.pc file will provide the lib path used marco to other user, that if the path change don’t impact user.</p>\n<p>like</p>\n<p><a href=\"http://swmdaemonplugin.pc.in/\">swmdaemonplugin.pc.in</a>:</p>\n<p>prefix=@prefix@<br>exec_prefix=@exec_prefix@<br>libdir=@libdir@<br>swmplugindir=${libdir}/swm.d/plugins  → this swmplugindir will use by CertMan etc. , CertMan can put it’s plungin inder this folder.</p>\n<p>​                                 → so CertMan will need to <code>BuildRequires: pkgconfig(swmdaemonplugin)</code><br>Name: swmdaemonplugin<br>Description: Plugin of blue green upgrade SWM daemon<br>URL: @PACKAGE_URL@<br>Version: @PACKAGE_VERSION@</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Pkg-config\">https://en.wikipedia.org/wiki/Pkg-config</a></p>\n<p><strong>pkg-config</strong> is a computer program that defines and supports a unified interface for querying installed <a href=\"https://en.wikipedia.org/wiki/Library_(computer_science)\">libraries</a> for the purpose of <a href=\"https://en.wikipedia.org/wiki/Compiler\">compiling</a> software that depends on them. It allows programmers and installation scripts to work without explicit knowledge of detailed library path information. pkg-config was originally designed for <a href=\"https://en.wikipedia.org/wiki/Linux\">Linux</a>, but it is now also available for <a href=\"https://en.wikipedia.org/wiki/Berkeley_Software_Distribution\">BSD</a>, <a href=\"https://en.wikipedia.org/wiki/Microsoft_Windows\">Microsoft Windows</a>, <a href=\"https://en.wikipedia.org/wiki/MacOS\">macOS</a>, and <a href=\"https://en.wikipedia.org/wiki/Solaris_(operating_system)\">Solaris</a>.</p>\n<p>RPMs are started by kickstarts like, kickstarts start swmdaemonIntegration firstly, swmdaemonIntegration requries swmdaemon, so it will start swmdaemon later , etc.</p>\n<p>Tang Shijun is response for rcp-kickstarts.</p>\n<p><a href=\"https://gitlabe1.ext.net.nokia.com/RCP/rcp-kickstarts/-/merge_requests/83\">Add swmdaemonintegration for CU Cloud build (!83) · Merge Requests · RCP / rcp-kickstarts · GitLab (nokia.com)</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"How-to-write-SPEC-file\"><a href=\"#How-to-write-SPEC-file\" class=\"headerlink\" title=\"How to write SPEC file\"></a>How to write SPEC file</h1><p>SPEC file is the rule to package a RPM build, compile files in source code(subsystem) and generates a file hierarchy and select them to package. </p>\n<p>the Makefile and configure file will generate the needed bin/files and put them into a build hierarchy .</p>\n<p>like:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scriptdir&#x3D;$(libexecdir)&#x2F;$(NAME)&#x2F;scripts&#x2F; → here xxxdir like scriptdir is the package dir , now it&#39;s $(libexecdir) xxx</span><br><span class=\"line\">script_SCRIPTS&#x3D;\\  → xxx SCRIPTS is the scripts that will put into the package dir after makefile exectued.</span><br><span class=\"line\">$(top_srcdir)&#x2F;conf&#x2F;mkdir_for_swmdaemon.sh \\  → these are the file path under source code subsystem</span><br><span class=\"line\">$(top_srcdir)&#x2F;plugin&#x2F;remove_release_json.sh \\  → so after makefile compile these files will put into $(libexecdir)&#x2F;$(NAME)&#x2F;scripts&#x2F;</span><br><span class=\"line\">$(top_srcdir)&#x2F;plugin&#x2F;swm_wait_vnf_ready.sh</span><br></pre></td></tr></table></figure>\n<p>the SPEC file will selected the generated files and package them in %files filed.</p>\n<p>%files<br>%{_libexecdir}/* → selected all files (after compile makefile) under {_libexecdir}/ , like about 3 files, we can see as</p>\n<p># rpm -qlv swmdaemon-9999.8bf34939_f5ec347c-1.wf32.1614301476.x86_64</p>\n<p>-rwxr-xr-x 1 root root 1570 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/mkdir_for_swmdaemon.sh<br>-rwxr-xr-x 1 root root 239 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/remove_release_json.sh<br>-rwxr-xr-x 1 root root 672 Feb 26 09:04 /usr/libexec/swmdaemon/scripts/swm_wait_vnf_ready.sh</p>\n<p>this %{_libexecdir}/ is /usr/libexec, can see in bellow link</p>\n<p><a href=\"https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/\">https://docs.fedoraproject.org/en-US/packaging-guidelines/RPMMacros/</a></p>\n<p>one SPEC file by default will generate one base RPM like it’s name, if need more RPMs ,need to add in %package.</p>\n<p><a href=\"https://rpm-packaging-guide.github.io/\">https://rpm-packaging-guide.github.io/</a></p>\n<p>ExcludeArch: aarch64  → only x86<br>%global debug_package %{nil}  → no debug RPM (used in some script subsystem like python ,shell)</p>\n<p>Requires: %{name}-sudoers%{?_isa} = %{version}-%{release} → use the macro like %{name} %{?_isa} = %{version}-%{release}<br>Requires: %{name}-AAA%{?_isa} = %{version}-%{release} </p>\n<p>%package sudoers   → sub RPMs  <Name>-sudoer<br>Summary: Sudo for %{name}<br>Requires: sudo     → sub RPMs require RPM</p>\n<p>%post systemd  → after install ‘systemd’ RPM will execute bellow command (script)<br>%systemd_post swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service</p>\n<p>→%systemd_post is the macro can see the script by bellow command </p>\n<p>‘/usr/bin/systemctl –no-reload preset’ this is the %systemd_post</p>\n<p>swmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm<br>[d13li@conde x86_64]$ rpm -q –scripts swmdaemonIntegration-systemd-92dbdae-71460f8.wf32.x86_64.rpm<br>postinstall scriptlet (using /bin/sh):if [ $1 -eq 1 ] &amp;&amp; [ -x /usr/bin/systemctl ]; then<br># Initial installation<br>/usr/bin/systemctl –no-reload preset swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :<br>fi<br>preuninstall scriptlet (using /bin/sh):</p>\n<p>if [ $1 -eq 0 ] &amp;&amp; [ -x /usr/bin/systemctl ]; then<br># Package removal, not upgrade<br>/usr/bin/systemctl –no-reload disable –now swm-server.service swm-server-proxy.service swm-rest-framework.target swmdaemon-conf.service || :<br>fi<br>postuninstall program: /bin/sh<br>[d13li@conde x86_64]$ pwd<br>/home/d13li/workbench/swmdaemonIntegration/RPMS/x86_64</p>\n<p>%files sudoers<br>%attr(0440, root, root) %{_sysconfdir}/sudoers.d/swmdaemon_sudoers → %attr will add file into package and set the attribute.</p>\n<p>subsystem’s can in cyclic dependency like in “BuildRequires:” file</p>\n<p>There is one issue for swmdaemon.spec, swmdaemon depends on apigw and apigw depends on swmdaemon, need to solve it.</p>\n<p>Either swmdaemon or api-gateway-framework (or both) must be divided to two separate subsystems:</p>\n<p>Core subsystem, which doesn’t depend on anything Plugin or integration subsystem, which depends on the core subsystem and swmdaemon or api-gateway-framework</p>\n<p>a file in which RPM we can check in ENV like:</p>\n<p># rpm -qf /var/api-gateway-framework/upstream-apis/<br>api-gateway-framework-rcp-integration-1.44.0-1.wf32.x86_64</p>\n<p>in ENV check RPM can use</p>\n<p>rpm -qa | grep xxx</p>\n<p>.pc file will provide the lib path used marco to other user, that if the path change don’t impact user.</p>\n<p>like</p>\n<p><a href=\"http://swmdaemonplugin.pc.in/\">swmdaemonplugin.pc.in</a>:</p>\n<p>prefix=@prefix@<br>exec_prefix=@exec_prefix@<br>libdir=@libdir@<br>swmplugindir=${libdir}/swm.d/plugins  → this swmplugindir will use by CertMan etc. , CertMan can put it’s plungin inder this folder.</p>\n<p>​                                 → so CertMan will need to <code>BuildRequires: pkgconfig(swmdaemonplugin)</code><br>Name: swmdaemonplugin<br>Description: Plugin of blue green upgrade SWM daemon<br>URL: @PACKAGE_URL@<br>Version: @PACKAGE_VERSION@</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Pkg-config\">https://en.wikipedia.org/wiki/Pkg-config</a></p>\n<p><strong>pkg-config</strong> is a computer program that defines and supports a unified interface for querying installed <a href=\"https://en.wikipedia.org/wiki/Library_(computer_science)\">libraries</a> for the purpose of <a href=\"https://en.wikipedia.org/wiki/Compiler\">compiling</a> software that depends on them. It allows programmers and installation scripts to work without explicit knowledge of detailed library path information. pkg-config was originally designed for <a href=\"https://en.wikipedia.org/wiki/Linux\">Linux</a>, but it is now also available for <a href=\"https://en.wikipedia.org/wiki/Berkeley_Software_Distribution\">BSD</a>, <a href=\"https://en.wikipedia.org/wiki/Microsoft_Windows\">Microsoft Windows</a>, <a href=\"https://en.wikipedia.org/wiki/MacOS\">macOS</a>, and <a href=\"https://en.wikipedia.org/wiki/Solaris_(operating_system)\">Solaris</a>.</p>\n<p>RPMs are started by kickstarts like, kickstarts start swmdaemonIntegration firstly, swmdaemonIntegration requries swmdaemon, so it will start swmdaemon later , etc.</p>\n<p>Tang Shijun is response for rcp-kickstarts.</p>\n<p><a href=\"https://gitlabe1.ext.net.nokia.com/RCP/rcp-kickstarts/-/merge_requests/83\">Add swmdaemonintegration for CU Cloud build (!83) · Merge Requests · RCP / rcp-kickstarts · GitLab (nokia.com)</a></p>\n"},{"title":"怎么修改Logic K580的快捷键","date":"2020-12-31T15:59:00.000Z","abbrlink":18003,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# 怎么修改Logic K580的快捷键\n\n在使用Logic K580键盘的时候有时候会想要切换到默认的快捷键，使用如下的方法：\n\n{% asset_img k580.png %}\n\n<img src=\"/Users/phoenine/Documents/MyBlog/hexo/source/_posts/tips_md/怎么修改Logic K580的快捷键/k580.png\" alt=\"k580\" style=\"zoom:67%;\" />\n\n使用右边的Fn键+ESC键切换","source":"_posts/tips_md/怎么修改Logic K580的快捷键.md","raw":"---\ntitle: 怎么修改Logic K580的快捷键\ndate: '2020/12/31 23:59'\ntags:\n - tips\ncategories:\n - 使用教程\nabbrlink: 18003\ncover: \n---\n\n# 怎么修改Logic K580的快捷键\n\n在使用Logic K580键盘的时候有时候会想要切换到默认的快捷键，使用如下的方法：\n\n{% asset_img k580.png %}\n\n<img src=\"/Users/phoenine/Documents/MyBlog/hexo/source/_posts/tips_md/怎么修改Logic K580的快捷键/k580.png\" alt=\"k580\" style=\"zoom:67%;\" />\n\n使用右边的Fn键+ESC键切换","slug":"tips_md/怎么修改Logic K580的快捷键","published":1,"updated":"2021-04-09T13:14:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr62001uw9q9eunz4off","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"怎么修改Logic-K580的快捷键\"><a href=\"#怎么修改Logic-K580的快捷键\" class=\"headerlink\" title=\"怎么修改Logic K580的快捷键\"></a>怎么修改Logic K580的快捷键</h1><p>在使用Logic K580键盘的时候有时候会想要切换到默认的快捷键，使用如下的方法：</p>\n<img src=\"/Blog/posts/18003/k580.png\" class=\"\">\n\n<img src=\"/Users/phoenine/Documents/MyBlog/hexo/source/_posts/tips_md/怎么修改Logic K580的快捷键/k580.png\" alt=\"k580\" style=\"zoom:67%;\" />\n\n<p>使用右边的Fn键+ESC键切换</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"怎么修改Logic-K580的快捷键\"><a href=\"#怎么修改Logic-K580的快捷键\" class=\"headerlink\" title=\"怎么修改Logic K580的快捷键\"></a>怎么修改Logic K580的快捷键</h1><p>在使用Logic K580键盘的时候有时候会想要切换到默认的快捷键，使用如下的方法：</p>\n<img src=\"/Blog/posts/18003/k580.png\" class=\"\">\n\n<img src=\"/Users/phoenine/Documents/MyBlog/hexo/source/_posts/tips_md/怎么修改Logic K580的快捷键/k580.png\" alt=\"k580\" style=\"zoom:67%;\" />\n\n<p>使用右边的Fn键+ESC键切换</p>\n"},{"title":"Makefile.am的例子","date":"2020-12-31T15:59:00.000Z","abbrlink":13011,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"看看configure,ac的修改\n\n```makefile\n#===================================================================\n\nAC_PREREQ([2.69])\n\n#===================================================================\n\nAC_INIT([trsapp], [1.0.0], [], [], [https://gerrite1.ext.net.nokia.com:443/scm_rcp/trsapp])\n\n#===================================================================\n\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_YACC\nAC_PROG_LEX\nAC_PROG_LIBTOOL\n\n#===================================================================\n\nAC_CONFIG_MACRO_DIR([m4])\n\nAC_SUBST([CPPFLAGS], ['-I. -I${srcdir}/../include -I${srcdir}/../inc -I${srcdir}/../src'])\nAC_SUBST([CFLAGS], [ ])\nAC_SUBST([CXXFLAGS], [ ])\n\nAC_SUBST([pkgconfigdir], ['${prefix}/lib64/pkgconfig'])\n\nAC_ARG_WITH([trsprovider-dir],\n    AS_HELP_STRING(\n        [--with-trsprovider-dir[=PATH]],\n        [Deploy bash completion scripts in this directory.]),\n        [trsinfoscriptdir=${with_trsprovider_dir}],\n        [])\nAC_SUBST([trsinfoscriptdir])\n\n#AC_ARG_WITH(dpdk_prefix, [  --with-dpdk-prefix=PATH for installed DPDK], DPDK_PREFIX=$withval,DPDK_PREFIX=/usr)\nAC_SUBST([DPDK_PREFIX], ['/usr/'])\n\n#AC_ARG_WITH(fp_prefix, [  --with-fp-prefix=PATH for installed FP], FP_PREFIX=$withval,FP_PREFIX=/usr)\nAC_SUBST([FP_PREFIX], ['/usr/'])\n\nAC_SUBST([FASTPATH_LIB_DIR], ['${buildroot}/usr/lib/'])\nAC_SUBST([FASTPATH_PLUGIN_DIR], ['${FASTPATH_LIB_DIR}/fastpath'])\n\nAC_SUBST([FP_DIR], ['${FP_PREFIX}/include/fp'])\nAC_SUBST([FP_CPPFLAGS], [' \\\n\t\t\t\t\t\t-I${FP_DIR} \\\n\t\t\t\t\t\t-I${FP_DIR}/common \\\n\t\t\t\t\t\t-I${FP_DIR}/config \\\n\t\t\t\t\t\t-I${FP_DIR}/fptun \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ipsec/common\\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ipsec/common/filter \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ipsec6/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/svti/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/filter/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/filter6/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tunnel/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/vxlan/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tap/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tap/dataplane \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip/ \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/filter-bridge/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/mcast/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/bridge/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip6/ \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip6/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/pbr/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/vlan/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/macvlan/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/veth/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/lag/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tc/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tc/dataplane \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/gre/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath/include \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath/include/netinet \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath/arch/dpdk \\\n\t\t\t\t\t\t-I${FP_DIR}/libnetfpc \\\n\t\t\t\t\t\t-I${FP_DIR}/fpdebug \\\n                      '])\n\nAC_SUBST([FPNSDK_DIR], ['${FP_PREFIX}/include/fpn-sdk'])\nAC_SUBST([FPNSDK_CPPFLAGS], [' \\\n                            -I${FPNSDK_DIR} \\\n                            -I${FPNSDK_DIR}/dpdk \\\n                            -I${FPNSDK_DIR}/dpdk/mk \\\n                            -I${FPNSDK_DIR}/dpdk/crypto \\\n                            -I${FPNSDK_DIR}/mk \\\n                            -I${FPNSDK_DIR}/dpvi \\\n                            -I${FPNSDK_DIR}/sched \\\n                            -I${FPNSDK_DIR}/shmem \\\n                            -I${FPNSDK_DIR}/timer \\\n                            -I${FPNSDK_DIR}/config \\\n                            -I${FPNSDK_DIR}/crypto \\\n                          '])\n\nAC_DEFUN([AX_CFLAGS_ADD],[AX_C_CHECK_FLAG($1, , , CFLAGS=\"$CFLAGS $1\")])\nAX_CFLAGS_ADD([-Wno-error=zero-length-bounds])\nAX_CFLAGS_ADD([-Wno-zero-length-bounds])\n\n#===================================================================\n\nAC_CONFIG_FILES([\n  Makefile\n  lib/libcmdkw/Makefile\n  lib/libcutest/build/Makefile\n  lib/libtrssdk/build/Makefile\n  lib/libtrssdk/tst/Makefile\n  lib/libtrsiwf/build/Makefile\n  lib/libtrsiwf/tst/Makefile\n  src/trscli/build/Makefile\n  src/TrsConfig/Makefile\n  lib/libtrsl2app/build/Makefile\n  src/l2appcli/build/Makefile\n  symptomreport/Makefile\n])\n\n#code coverage related macro and variables\nAX_CODE_COVERAGE\nAC_SUBST([CODE_COVERAGE_LCOV_RMOPTS], ['*tst/* */include/* *src/*.h'])\nAC_SUBST([CODE_COVERAGE_OUTPUT_DIRECTORY], ['lcov_report/C'])\n\n\nPKG_CHECK_MODULES([LIBDPDK], [libdpdk])\nPKG_CHECK_MODULES([LIBCOMMONIO], [libcommonio])\nPKG_CHECK_MODULES([LIBDPDKINIT], [libdpdkinit])\nPKG_CHECK_MODULES([LIBCMOCKA], [cmocka])\n\n#===================================================================\n\nAM_INIT_AUTOMAKE([subdir-objects foreign 1.13 tar-pax])\n\n#===================================================================\n\nAC_OUTPUT\n\n```\n\n看看trsapp的例子：\n\n```makefile\nACLOCAL_AMFLAGS = -I m4                            //将自定义的宏编译成可用的宏\n#===================================================================\n\nSUBDIRS = lib/libcmdkw lib/libtrssdk/build         //说明当下目录哪些子目录需要编译\nSUBDIRS += lib/libtrssdk/build\nSUBDIRS += lib/libtrsiwf/build\nSUBDIRS += lib/libcutest/build\nSUBDIRS += src/trscli/build\nSUBDIRS += src/TrsConfig\nSUBDIRS += lib/libtrsl2app/build\nSUBDIRS += src/l2appcli/build\nSUBDIRS += symptomreport\n#===================================================================\n\nUTESTDIRS = lib/libtrssdk/tst\nUTESTDIRS += lib/libtrsiwf/tst\n\n#===================================================================\n#UNIT Test Code Coverage\n@CODE_COVERAGE_RULES@\n\n#Command to check to generate code coverage\ncheck:\n        @dirs='$(UTESTDIRS)'; \\\n        for dir in $$dirs; \\\n        do \\\n                echo \"Making utest in $$dir\";\\\n                ${MAKE} check-code-coverage -C $$dir;\\\n        done\n\n#===================================================================\n```\n\n伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。\n\n1、如果我们指定的目标不是创建目标文件，而是使用makefile执行一些特定的命令，例如：\n\n```makefile\nclean:    \n\t\trm *.o temp\n```\n\n我们希望，只要输入”make clean“后，”rm *.o temp“命令就会执行。但是，当当前目录中存在一个和指定目标重名的文件时，例如clean文件，结果就不是我们想要的了。输入”make clean“后，“rm *.o temp” 命令一定不会被执行。  \n\n解决的办法是:将目标clean定义成伪目标就成了。无论当前目录下是否存在“clean”这个文件，输入“make clean”后，“rm *.o temp”命令都会被执行。\n\n注意：这种做法的带来的好处还不止此，它同时提高了make的执行效率，因为将clean定义成伪目标后，make的执行程序不会试图寻找clean的隐含规则。\n**2、PHONY可以确保源文件（\\*.c \\*.h）修改后，对应的目标文件会被重建。倘若缺少了PHONY，可以看到情况会很糟。**  \n\n现在做一个实验，实验的目录是/work，在这个目录中，包含了四个目录test、add、sub、include 和一个顶层目录makefile文件。test、add、sub三个目录分别包含了三个源程序test.c、add.c、sub.c和三个子目录makefile，目录include的是头文件heads.h的目录，分别展开四个目录的内容如下","source":"_posts/linux_md/Makefile/Makefile.am的例子.md","raw":"---\ntitle: Makefile.am的例子\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 个人项目\nabbrlink: 13011\ncover: \n---\n看看configure,ac的修改\n\n```makefile\n#===================================================================\n\nAC_PREREQ([2.69])\n\n#===================================================================\n\nAC_INIT([trsapp], [1.0.0], [], [], [https://gerrite1.ext.net.nokia.com:443/scm_rcp/trsapp])\n\n#===================================================================\n\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_YACC\nAC_PROG_LEX\nAC_PROG_LIBTOOL\n\n#===================================================================\n\nAC_CONFIG_MACRO_DIR([m4])\n\nAC_SUBST([CPPFLAGS], ['-I. -I${srcdir}/../include -I${srcdir}/../inc -I${srcdir}/../src'])\nAC_SUBST([CFLAGS], [ ])\nAC_SUBST([CXXFLAGS], [ ])\n\nAC_SUBST([pkgconfigdir], ['${prefix}/lib64/pkgconfig'])\n\nAC_ARG_WITH([trsprovider-dir],\n    AS_HELP_STRING(\n        [--with-trsprovider-dir[=PATH]],\n        [Deploy bash completion scripts in this directory.]),\n        [trsinfoscriptdir=${with_trsprovider_dir}],\n        [])\nAC_SUBST([trsinfoscriptdir])\n\n#AC_ARG_WITH(dpdk_prefix, [  --with-dpdk-prefix=PATH for installed DPDK], DPDK_PREFIX=$withval,DPDK_PREFIX=/usr)\nAC_SUBST([DPDK_PREFIX], ['/usr/'])\n\n#AC_ARG_WITH(fp_prefix, [  --with-fp-prefix=PATH for installed FP], FP_PREFIX=$withval,FP_PREFIX=/usr)\nAC_SUBST([FP_PREFIX], ['/usr/'])\n\nAC_SUBST([FASTPATH_LIB_DIR], ['${buildroot}/usr/lib/'])\nAC_SUBST([FASTPATH_PLUGIN_DIR], ['${FASTPATH_LIB_DIR}/fastpath'])\n\nAC_SUBST([FP_DIR], ['${FP_PREFIX}/include/fp'])\nAC_SUBST([FP_CPPFLAGS], [' \\\n\t\t\t\t\t\t-I${FP_DIR} \\\n\t\t\t\t\t\t-I${FP_DIR}/common \\\n\t\t\t\t\t\t-I${FP_DIR}/config \\\n\t\t\t\t\t\t-I${FP_DIR}/fptun \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ipsec/common\\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ipsec/common/filter \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ipsec6/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/svti/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/filter/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/filter6/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tunnel/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/vxlan/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tap/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tap/dataplane \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip/ \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/filter-bridge/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/mcast/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/bridge/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip6/ \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/ip6/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/pbr/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/vlan/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/macvlan/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/veth/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/lag/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tc/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/tc/dataplane \\\n\t\t\t\t\t\t-I${FP_DIR}/fp-modules/gre/common \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath/include \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath/include/netinet \\\n\t\t\t\t\t\t-I${FP_DIR}/fastpath/arch/dpdk \\\n\t\t\t\t\t\t-I${FP_DIR}/libnetfpc \\\n\t\t\t\t\t\t-I${FP_DIR}/fpdebug \\\n                      '])\n\nAC_SUBST([FPNSDK_DIR], ['${FP_PREFIX}/include/fpn-sdk'])\nAC_SUBST([FPNSDK_CPPFLAGS], [' \\\n                            -I${FPNSDK_DIR} \\\n                            -I${FPNSDK_DIR}/dpdk \\\n                            -I${FPNSDK_DIR}/dpdk/mk \\\n                            -I${FPNSDK_DIR}/dpdk/crypto \\\n                            -I${FPNSDK_DIR}/mk \\\n                            -I${FPNSDK_DIR}/dpvi \\\n                            -I${FPNSDK_DIR}/sched \\\n                            -I${FPNSDK_DIR}/shmem \\\n                            -I${FPNSDK_DIR}/timer \\\n                            -I${FPNSDK_DIR}/config \\\n                            -I${FPNSDK_DIR}/crypto \\\n                          '])\n\nAC_DEFUN([AX_CFLAGS_ADD],[AX_C_CHECK_FLAG($1, , , CFLAGS=\"$CFLAGS $1\")])\nAX_CFLAGS_ADD([-Wno-error=zero-length-bounds])\nAX_CFLAGS_ADD([-Wno-zero-length-bounds])\n\n#===================================================================\n\nAC_CONFIG_FILES([\n  Makefile\n  lib/libcmdkw/Makefile\n  lib/libcutest/build/Makefile\n  lib/libtrssdk/build/Makefile\n  lib/libtrssdk/tst/Makefile\n  lib/libtrsiwf/build/Makefile\n  lib/libtrsiwf/tst/Makefile\n  src/trscli/build/Makefile\n  src/TrsConfig/Makefile\n  lib/libtrsl2app/build/Makefile\n  src/l2appcli/build/Makefile\n  symptomreport/Makefile\n])\n\n#code coverage related macro and variables\nAX_CODE_COVERAGE\nAC_SUBST([CODE_COVERAGE_LCOV_RMOPTS], ['*tst/* */include/* *src/*.h'])\nAC_SUBST([CODE_COVERAGE_OUTPUT_DIRECTORY], ['lcov_report/C'])\n\n\nPKG_CHECK_MODULES([LIBDPDK], [libdpdk])\nPKG_CHECK_MODULES([LIBCOMMONIO], [libcommonio])\nPKG_CHECK_MODULES([LIBDPDKINIT], [libdpdkinit])\nPKG_CHECK_MODULES([LIBCMOCKA], [cmocka])\n\n#===================================================================\n\nAM_INIT_AUTOMAKE([subdir-objects foreign 1.13 tar-pax])\n\n#===================================================================\n\nAC_OUTPUT\n\n```\n\n看看trsapp的例子：\n\n```makefile\nACLOCAL_AMFLAGS = -I m4                            //将自定义的宏编译成可用的宏\n#===================================================================\n\nSUBDIRS = lib/libcmdkw lib/libtrssdk/build         //说明当下目录哪些子目录需要编译\nSUBDIRS += lib/libtrssdk/build\nSUBDIRS += lib/libtrsiwf/build\nSUBDIRS += lib/libcutest/build\nSUBDIRS += src/trscli/build\nSUBDIRS += src/TrsConfig\nSUBDIRS += lib/libtrsl2app/build\nSUBDIRS += src/l2appcli/build\nSUBDIRS += symptomreport\n#===================================================================\n\nUTESTDIRS = lib/libtrssdk/tst\nUTESTDIRS += lib/libtrsiwf/tst\n\n#===================================================================\n#UNIT Test Code Coverage\n@CODE_COVERAGE_RULES@\n\n#Command to check to generate code coverage\ncheck:\n        @dirs='$(UTESTDIRS)'; \\\n        for dir in $$dirs; \\\n        do \\\n                echo \"Making utest in $$dir\";\\\n                ${MAKE} check-code-coverage -C $$dir;\\\n        done\n\n#===================================================================\n```\n\n伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。\n\n1、如果我们指定的目标不是创建目标文件，而是使用makefile执行一些特定的命令，例如：\n\n```makefile\nclean:    \n\t\trm *.o temp\n```\n\n我们希望，只要输入”make clean“后，”rm *.o temp“命令就会执行。但是，当当前目录中存在一个和指定目标重名的文件时，例如clean文件，结果就不是我们想要的了。输入”make clean“后，“rm *.o temp” 命令一定不会被执行。  \n\n解决的办法是:将目标clean定义成伪目标就成了。无论当前目录下是否存在“clean”这个文件，输入“make clean”后，“rm *.o temp”命令都会被执行。\n\n注意：这种做法的带来的好处还不止此，它同时提高了make的执行效率，因为将clean定义成伪目标后，make的执行程序不会试图寻找clean的隐含规则。\n**2、PHONY可以确保源文件（\\*.c \\*.h）修改后，对应的目标文件会被重建。倘若缺少了PHONY，可以看到情况会很糟。**  \n\n现在做一个实验，实验的目录是/work，在这个目录中，包含了四个目录test、add、sub、include 和一个顶层目录makefile文件。test、add、sub三个目录分别包含了三个源程序test.c、add.c、sub.c和三个子目录makefile，目录include的是头文件heads.h的目录，分别展开四个目录的内容如下","slug":"linux_md/Makefile/Makefile.am的例子","published":1,"updated":"2021-04-08T14:11:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr62001yw9q9a5nb0kzh","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><p>看看configure,ac的修改</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_PREREQ([2.69])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_INIT([trsapp], [1.0.0], [], [], [https://gerrite1.ext.net.nokia.com:443/scm_rcp/trsapp])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_PROG_CC</span><br><span class=\"line\">AC_PROG_CXX</span><br><span class=\"line\">AC_PROG_YACC</span><br><span class=\"line\">AC_PROG_LEX</span><br><span class=\"line\">AC_PROG_LIBTOOL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_CONFIG_MACRO_DIR([m4])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([CPPFLAGS], [&#x27;-I. -I$&#123;srcdir&#125;/../<span class=\"keyword\">include</span> -I$&#123;srcdir&#125;/../inc -I$&#123;srcdir&#125;/../src&#x27;])</span><br><span class=\"line\">AC_SUBST([CFLAGS], [ ])</span><br><span class=\"line\">AC_SUBST([CXXFLAGS], [ ])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([pkgconfigdir], [&#x27;$&#123;prefix&#125;/lib64/pkgconfig&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_ARG_WITH([trsprovider-dir],</span><br><span class=\"line\">    AS_HELP_STRING(</span><br><span class=\"line\">        [--with-trsprovider-dir[=PATH]],</span><br><span class=\"line\">        [Deploy bash completion scripts in this directory.]),</span><br><span class=\"line\">        [trsinfoscriptdir=$&#123;with_trsprovider_dir&#125;],</span><br><span class=\"line\">        [])</span><br><span class=\"line\">AC_SUBST([trsinfoscriptdir])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#AC_ARG_WITH(dpdk_prefix, [  --with-dpdk-prefix=PATH for installed DPDK], DPDK_PREFIX=$withval,DPDK_PREFIX=/usr)</span></span><br><span class=\"line\">AC_SUBST([DPDK_PREFIX], [&#x27;/usr/&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#AC_ARG_WITH(fp_prefix, [  --with-fp-prefix=PATH for installed FP], FP_PREFIX=$withval,FP_PREFIX=/usr)</span></span><br><span class=\"line\">AC_SUBST([FP_PREFIX], [&#x27;/usr/&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([FASTPATH_LIB_DIR], [&#x27;$&#123;buildroot&#125;/usr/lib/&#x27;])</span><br><span class=\"line\">AC_SUBST([FASTPATH_PLUGIN_DIR], [&#x27;$&#123;FASTPATH_LIB_DIR&#125;/fastpath&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([FP_DIR], [&#x27;$&#123;FP_PREFIX&#125;/<span class=\"keyword\">include</span>/fp&#x27;])</span><br><span class=\"line\">AC_SUBST([FP_CPPFLAGS], [&#x27; \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125; \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/config \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fptun \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ipsec/common\\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ipsec/common/filter \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ipsec6/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/svti/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/filter/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/filter6/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tunnel/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/vxlan/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tap/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tap/dataplane \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip/ \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/filter-bridge/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/mcast/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/bridge/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip6/ \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip6/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/pbr/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/vlan/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/macvlan/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/veth/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/lag/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tc/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tc/dataplane \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/gre/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath/<span class=\"keyword\">include</span> \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath/<span class=\"keyword\">include</span>/netinet \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath/arch/dpdk \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/libnetfpc \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fpdebug \\</span><br><span class=\"line\">                      &#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([FPNSDK_DIR], [&#x27;$&#123;FP_PREFIX&#125;/<span class=\"keyword\">include</span>/fpn-sdk&#x27;])</span><br><span class=\"line\">AC_SUBST([FPNSDK_CPPFLAGS], [&#x27; \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125; \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpdk \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpdk/mk \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpdk/crypto \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/mk \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpvi \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/sched \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/shmem \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/timer \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/config \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/crypto \\</span><br><span class=\"line\">                          &#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_DEFUN([AX_CFLAGS_ADD],[AX_C_CHECK_FLAG($1, , , CFLAGS=<span class=\"string\">&quot;$CFLAGS $1&quot;</span>)])</span><br><span class=\"line\">AX_CFLAGS_ADD([-Wno-error=zero-length-bounds])</span><br><span class=\"line\">AX_CFLAGS_ADD([-Wno-zero-length-bounds])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_CONFIG_FILES([</span><br><span class=\"line\">  Makefile</span><br><span class=\"line\">  lib/libcmdkw/Makefile</span><br><span class=\"line\">  lib/libcutest/build/Makefile</span><br><span class=\"line\">  lib/libtrssdk/build/Makefile</span><br><span class=\"line\">  lib/libtrssdk/tst/Makefile</span><br><span class=\"line\">  lib/libtrsiwf/build/Makefile</span><br><span class=\"line\">  lib/libtrsiwf/tst/Makefile</span><br><span class=\"line\">  src/trscli/build/Makefile</span><br><span class=\"line\">  src/TrsConfig/Makefile</span><br><span class=\"line\">  lib/libtrsl2app/build/Makefile</span><br><span class=\"line\">  src/l2appcli/build/Makefile</span><br><span class=\"line\">  symptomreport/Makefile</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#code coverage related macro and variables</span></span><br><span class=\"line\">AX_CODE_COVERAGE</span><br><span class=\"line\">AC_SUBST([CODE_COVERAGE_LCOV_RMOPTS], [&#x27;*tst/* */<span class=\"keyword\">include</span>/* *src/*.h&#x27;])</span><br><span class=\"line\">AC_SUBST([CODE_COVERAGE_OUTPUT_DIRECTORY], [&#x27;lcov_report/C&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PKG_CHECK_MODULES([LIBDPDK], [libdpdk])</span><br><span class=\"line\">PKG_CHECK_MODULES([LIBCOMMONIO], [libcommonio])</span><br><span class=\"line\">PKG_CHECK_MODULES([LIBDPDKINIT], [libdpdkinit])</span><br><span class=\"line\">PKG_CHECK_MODULES([LIBCMOCKA], [cmocka])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AM_INIT_AUTOMAKE([subdir-objects foreign 1.13 tar-pax])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_OUTPUT</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>看看trsapp的例子：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACLOCAL_AMFLAGS = -I m4                            //将自定义的宏编译成可用的宏</span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">SUBDIRS = lib/libcmdkw lib/libtrssdk/build         //说明当下目录哪些子目录需要编译</span><br><span class=\"line\">SUBDIRS += lib/libtrssdk/build</span><br><span class=\"line\">SUBDIRS += lib/libtrsiwf/build</span><br><span class=\"line\">SUBDIRS += lib/libcutest/build</span><br><span class=\"line\">SUBDIRS += src/trscli/build</span><br><span class=\"line\">SUBDIRS += src/TrsConfig</span><br><span class=\"line\">SUBDIRS += lib/libtrsl2app/build</span><br><span class=\"line\">SUBDIRS += src/l2appcli/build</span><br><span class=\"line\">SUBDIRS += symptomreport</span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">UTESTDIRS = lib/libtrssdk/tst</span><br><span class=\"line\">UTESTDIRS += lib/libtrsiwf/tst</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"><span class=\"comment\">#UNIT Test Code Coverage</span></span><br><span class=\"line\">@CODE_COVERAGE_RULES@</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Command to check to generate code coverage</span></span><br><span class=\"line\"><span class=\"section\">check:</span></span><br><span class=\"line\">        @dirs=&#x27;<span class=\"variable\">$(UTESTDIRS)</span>&#x27;; \\</span><br><span class=\"line\">        for dir in $$dirs; \\</span><br><span class=\"line\">        do \\</span><br><span class=\"line\">                echo <span class=\"string\">&quot;Making utest in $$dir&quot;</span>;\\</span><br><span class=\"line\">                $&#123;MAKE&#125; check-code-coverage -C $$dir;\\</span><br><span class=\"line\">        done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br></pre></td></tr></table></figure>\n<p>伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。</p>\n<p>1、如果我们指定的目标不是创建目标文件，而是使用makefile执行一些特定的命令，例如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:    </span></span><br><span class=\"line\">\t\trm *.o temp</span><br></pre></td></tr></table></figure>\n<p>我们希望，只要输入”make clean“后，”rm *.o temp“命令就会执行。但是，当当前目录中存在一个和指定目标重名的文件时，例如clean文件，结果就不是我们想要的了。输入”make clean“后，“rm *.o temp” 命令一定不会被执行。  </p>\n<p>解决的办法是:将目标clean定义成伪目标就成了。无论当前目录下是否存在“clean”这个文件，输入“make clean”后，“rm *.o temp”命令都会被执行。</p>\n<p>注意：这种做法的带来的好处还不止此，它同时提高了make的执行效率，因为将clean定义成伪目标后，make的执行程序不会试图寻找clean的隐含规则。<br><strong>2、PHONY可以确保源文件（*.c *.h）修改后，对应的目标文件会被重建。倘若缺少了PHONY，可以看到情况会很糟。</strong>  </p>\n<p>现在做一个实验，实验的目录是/work，在这个目录中，包含了四个目录test、add、sub、include 和一个顶层目录makefile文件。test、add、sub三个目录分别包含了三个源程序test.c、add.c、sub.c和三个子目录makefile，目录include的是头文件heads.h的目录，分别展开四个目录的内容如下</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p>看看configure,ac的修改</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_PREREQ([2.69])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_INIT([trsapp], [1.0.0], [], [], [https://gerrite1.ext.net.nokia.com:443/scm_rcp/trsapp])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_PROG_CC</span><br><span class=\"line\">AC_PROG_CXX</span><br><span class=\"line\">AC_PROG_YACC</span><br><span class=\"line\">AC_PROG_LEX</span><br><span class=\"line\">AC_PROG_LIBTOOL</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_CONFIG_MACRO_DIR([m4])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([CPPFLAGS], [&#x27;-I. -I$&#123;srcdir&#125;/../<span class=\"keyword\">include</span> -I$&#123;srcdir&#125;/../inc -I$&#123;srcdir&#125;/../src&#x27;])</span><br><span class=\"line\">AC_SUBST([CFLAGS], [ ])</span><br><span class=\"line\">AC_SUBST([CXXFLAGS], [ ])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([pkgconfigdir], [&#x27;$&#123;prefix&#125;/lib64/pkgconfig&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_ARG_WITH([trsprovider-dir],</span><br><span class=\"line\">    AS_HELP_STRING(</span><br><span class=\"line\">        [--with-trsprovider-dir[=PATH]],</span><br><span class=\"line\">        [Deploy bash completion scripts in this directory.]),</span><br><span class=\"line\">        [trsinfoscriptdir=$&#123;with_trsprovider_dir&#125;],</span><br><span class=\"line\">        [])</span><br><span class=\"line\">AC_SUBST([trsinfoscriptdir])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#AC_ARG_WITH(dpdk_prefix, [  --with-dpdk-prefix=PATH for installed DPDK], DPDK_PREFIX=$withval,DPDK_PREFIX=/usr)</span></span><br><span class=\"line\">AC_SUBST([DPDK_PREFIX], [&#x27;/usr/&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#AC_ARG_WITH(fp_prefix, [  --with-fp-prefix=PATH for installed FP], FP_PREFIX=$withval,FP_PREFIX=/usr)</span></span><br><span class=\"line\">AC_SUBST([FP_PREFIX], [&#x27;/usr/&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([FASTPATH_LIB_DIR], [&#x27;$&#123;buildroot&#125;/usr/lib/&#x27;])</span><br><span class=\"line\">AC_SUBST([FASTPATH_PLUGIN_DIR], [&#x27;$&#123;FASTPATH_LIB_DIR&#125;/fastpath&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([FP_DIR], [&#x27;$&#123;FP_PREFIX&#125;/<span class=\"keyword\">include</span>/fp&#x27;])</span><br><span class=\"line\">AC_SUBST([FP_CPPFLAGS], [&#x27; \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125; \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/config \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fptun \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ipsec/common\\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ipsec/common/filter \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ipsec6/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/svti/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/filter/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/filter6/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tunnel/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/vxlan/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tap/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tap/dataplane \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip/ \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/filter-bridge/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/mcast/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/bridge/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip6/ \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/ip6/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/pbr/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/vlan/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/macvlan/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/veth/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/lag/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tc/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/tc/dataplane \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fp-modules/gre/common \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath/<span class=\"keyword\">include</span> \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath/<span class=\"keyword\">include</span>/netinet \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fastpath/arch/dpdk \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/libnetfpc \\</span><br><span class=\"line\">\t\t\t\t\t\t-I$&#123;FP_DIR&#125;/fpdebug \\</span><br><span class=\"line\">                      &#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_SUBST([FPNSDK_DIR], [&#x27;$&#123;FP_PREFIX&#125;/<span class=\"keyword\">include</span>/fpn-sdk&#x27;])</span><br><span class=\"line\">AC_SUBST([FPNSDK_CPPFLAGS], [&#x27; \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125; \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpdk \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpdk/mk \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpdk/crypto \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/mk \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/dpvi \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/sched \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/shmem \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/timer \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/config \\</span><br><span class=\"line\">                            -I$&#123;FPNSDK_DIR&#125;/crypto \\</span><br><span class=\"line\">                          &#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\">AC_DEFUN([AX_CFLAGS_ADD],[AX_C_CHECK_FLAG($1, , , CFLAGS=<span class=\"string\">&quot;$CFLAGS $1&quot;</span>)])</span><br><span class=\"line\">AX_CFLAGS_ADD([-Wno-error=zero-length-bounds])</span><br><span class=\"line\">AX_CFLAGS_ADD([-Wno-zero-length-bounds])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_CONFIG_FILES([</span><br><span class=\"line\">  Makefile</span><br><span class=\"line\">  lib/libcmdkw/Makefile</span><br><span class=\"line\">  lib/libcutest/build/Makefile</span><br><span class=\"line\">  lib/libtrssdk/build/Makefile</span><br><span class=\"line\">  lib/libtrssdk/tst/Makefile</span><br><span class=\"line\">  lib/libtrsiwf/build/Makefile</span><br><span class=\"line\">  lib/libtrsiwf/tst/Makefile</span><br><span class=\"line\">  src/trscli/build/Makefile</span><br><span class=\"line\">  src/TrsConfig/Makefile</span><br><span class=\"line\">  lib/libtrsl2app/build/Makefile</span><br><span class=\"line\">  src/l2appcli/build/Makefile</span><br><span class=\"line\">  symptomreport/Makefile</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#code coverage related macro and variables</span></span><br><span class=\"line\">AX_CODE_COVERAGE</span><br><span class=\"line\">AC_SUBST([CODE_COVERAGE_LCOV_RMOPTS], [&#x27;*tst/* */<span class=\"keyword\">include</span>/* *src/*.h&#x27;])</span><br><span class=\"line\">AC_SUBST([CODE_COVERAGE_OUTPUT_DIRECTORY], [&#x27;lcov_report/C&#x27;])</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">PKG_CHECK_MODULES([LIBDPDK], [libdpdk])</span><br><span class=\"line\">PKG_CHECK_MODULES([LIBCOMMONIO], [libcommonio])</span><br><span class=\"line\">PKG_CHECK_MODULES([LIBDPDKINIT], [libdpdkinit])</span><br><span class=\"line\">PKG_CHECK_MODULES([LIBCMOCKA], [cmocka])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AM_INIT_AUTOMAKE([subdir-objects foreign 1.13 tar-pax])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">AC_OUTPUT</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>看看trsapp的例子：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ACLOCAL_AMFLAGS = -I m4                            //将自定义的宏编译成可用的宏</span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">SUBDIRS = lib/libcmdkw lib/libtrssdk/build         //说明当下目录哪些子目录需要编译</span><br><span class=\"line\">SUBDIRS += lib/libtrssdk/build</span><br><span class=\"line\">SUBDIRS += lib/libtrsiwf/build</span><br><span class=\"line\">SUBDIRS += lib/libcutest/build</span><br><span class=\"line\">SUBDIRS += src/trscli/build</span><br><span class=\"line\">SUBDIRS += src/TrsConfig</span><br><span class=\"line\">SUBDIRS += lib/libtrsl2app/build</span><br><span class=\"line\">SUBDIRS += src/l2appcli/build</span><br><span class=\"line\">SUBDIRS += symptomreport</span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"></span><br><span class=\"line\">UTESTDIRS = lib/libtrssdk/tst</span><br><span class=\"line\">UTESTDIRS += lib/libtrsiwf/tst</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br><span class=\"line\"><span class=\"comment\">#UNIT Test Code Coverage</span></span><br><span class=\"line\">@CODE_COVERAGE_RULES@</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Command to check to generate code coverage</span></span><br><span class=\"line\"><span class=\"section\">check:</span></span><br><span class=\"line\">        @dirs=&#x27;<span class=\"variable\">$(UTESTDIRS)</span>&#x27;; \\</span><br><span class=\"line\">        for dir in $$dirs; \\</span><br><span class=\"line\">        do \\</span><br><span class=\"line\">                echo <span class=\"string\">&quot;Making utest in $$dir&quot;</span>;\\</span><br><span class=\"line\">                $&#123;MAKE&#125; check-code-coverage -C $$dir;\\</span><br><span class=\"line\">        done</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#===================================================================</span></span><br></pre></td></tr></table></figure>\n<p>伪目标是这样一个目标：它不代表一个真正的文件名，在执行make时可以指定这个目标来执行所在规则定义的命令，有时也可以将一个伪目标称为标签。伪目标通过PHONY来指明。</p>\n<p>1、如果我们指定的目标不是创建目标文件，而是使用makefile执行一些特定的命令，例如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:    </span></span><br><span class=\"line\">\t\trm *.o temp</span><br></pre></td></tr></table></figure>\n<p>我们希望，只要输入”make clean“后，”rm *.o temp“命令就会执行。但是，当当前目录中存在一个和指定目标重名的文件时，例如clean文件，结果就不是我们想要的了。输入”make clean“后，“rm *.o temp” 命令一定不会被执行。  </p>\n<p>解决的办法是:将目标clean定义成伪目标就成了。无论当前目录下是否存在“clean”这个文件，输入“make clean”后，“rm *.o temp”命令都会被执行。</p>\n<p>注意：这种做法的带来的好处还不止此，它同时提高了make的执行效率，因为将clean定义成伪目标后，make的执行程序不会试图寻找clean的隐含规则。<br><strong>2、PHONY可以确保源文件（*.c *.h）修改后，对应的目标文件会被重建。倘若缺少了PHONY，可以看到情况会很糟。</strong>  </p>\n<p>现在做一个实验，实验的目录是/work，在这个目录中，包含了四个目录test、add、sub、include 和一个顶层目录makefile文件。test、add、sub三个目录分别包含了三个源程序test.c、add.c、sub.c和三个子目录makefile，目录include的是头文件heads.h的目录，分别展开四个目录的内容如下</p>\n"},{"title":"论一切都是文件之匿名inode","date":"2020-12-31T15:59:00.000Z","abbrlink":15002,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n## 宋宝华：论一切都是文件之匿名inode\n\n01\n\n唯有文件得人心\n\n当一个女生让你替她抓100只萤火虫，她一定不是为了折磨你，而是因为她爱上了你。当你们之间经历了无数的恩恩怨怨和彼此伤害，她再次让你替她抓100只萤火虫，那一定是因为她还爱着你。 \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5013388ec46043c59f4fb4b3e373e955.png)\n\n为什么？因为这就是套路，是在下偶尔瞟一眼古装肥皂剧总结出来的套路。\n\nLinux里面最大的套路，就是“一切都是文件”。爱一个人，就为她捉萤火虫；做一件事，就让它成为一个“文件”。 \n\n为什么自古深情留不住，唯有“文件”得人心呢？因为文件在用户态最直观的形式是随着一次open，获得一个fd，有了这个fd，长城内外，你基本可以为所欲为：\n\n- 在本进程内，fd的最直观操作是open、close、mmap、ioctl、poll这些。 m map 让你具备把fd透射到内存的能力，所以你可以通过指针访问文件的内容。再者，这个mmap，如果底层透射的是framebuffer、V4L2、DRM等，则让我们具备了从用户态操作底层显存、多媒体数据等的能力；比如，无论是V4L2还是DRM，都支持把底层的dma_buf导出为fd。poll则提供给用户阻塞等待某事件发生的能力。 至于ioctl，就更加不用说了，你可以透过ioctl灵活地为fd添加控制命令。\n- 在跨进程的情况下，Linux支持fd的跨进程socket传输，从而可以实现共享内存、dma_buf跨进程共享等。比如一个进程可以通过send_fd可以把fd发送出去：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/1fce6c5c621b4fd09919e87f52c59801.png)\n\n而另外一个进程可以通过recv_fd把fd收过来： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/a0d3b15c19454faabb33b6fab3704d6f.png)\n\n这种fd在长城内外可以互访，fd最终可以指向dma_buf同时可以被mmap，而dma_buf又最终可以被显卡、显示控制器、video decoder/encoder等设备访问的能力，让fd打通了设备、CPU和跨进程的障碍，从此可以横着走。 \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/277dafd9086b4d148de8b617f9252b62.png)\n\n我们在《 宋宝华：世上最好的共享内存(Linux共享内存最透彻的一篇) 》一文中已经详细阐述过这个过程，这里我们就不再赘述了。本文的重点在于匿名inode。 \n\n02\n\ninode源头file活水\n\n我们把文件想象成一个object，那么inode描述的是本源，和最终的object一一对应；dentry是inode的一个路径马甲，比如我们可以通过\"ln\"命令为同一个inode创建很多的硬链接马甲；而file则是活水，进程对object的一次“open”，获得一个file，导致用户态得到一个\"fd\"的句柄来操作这个object。\n\n经典的inode、dentry、file谁都不缺席的模型是这样的：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/d48bc627be544288b73fe774962b1010.png)\n\n上图中，我们有一个inode，这个inode有2个dentry，进程A、B open的是第一个dentry；而进程C、D open的是第二个dentry。变了的是file和fd，不变的是inode，中间的dentry马甲没那么重要。\n\n但是在inode、dentry、file这个经典铁三角中，从来都是可以有一个缺席者的，那就是dentry，因为，有时候用户态想获得长城内外行走的便利，但是却不想这个inode在文件系统里面留下一个路径的痕迹。简单来说，我希望有个fd，但是这个fd，你在从\"/\"往下面搜索的任何一条路径下，你都找不到它，它根本在根文件系统以下不存在路径，它是无名氏，它没有马甲，它是个传说。\n\n比如，近期名震江湖的剑客usefaultfd允许我们在用户空间处理page fault，我们是通过userfaultfd这个系统调用先获得一个fd，之后就可以对它进行各种ioctl了： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/e0230f143c434814ba2cdc39c2faaa68.png)\n\n我们透过userfaultfd系统获得了一个fd，它在/xxx/yyy/zzz这样的文件系统下没有路径。这种情况下的fd，对应着的是一个没有名字的匿名inode，你显然没有办法像fd = open (\"xxx\", ..)那样来得到匿名inode的fd，因为\"xxx\"是一个路径，而匿名inode没有xxx，所以你是直接透过syscall userfaultfd这样的系统调用，来获得anon_inode在你的进程里面对应的fd的:\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/675fef6379254f7fb5c7b3a934c32255.png)\n\n人过留名，雁过留声；杀人者，打虎武松也。但是anon inode不吃这一套，它是一个绝顶的轻功高手，它给与的，是透过fd长城内外行走的能力，但是，在文件系统里面却从未来过。这是用户真实的需求，如果这种需求一定要透过一个dentry的open才能实现，这未免有点画蛇添足了。\n\n03\n\n匿名inode的内核实例\n\n我们接下来可以随便打开个anon inode的实例来看看它是怎么工作的了。首先userfaultd是一个系统调用：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/cb54f7e833a743b1962c47dcd996e921.png)\n\n这个代码里面比较核心的是就是，它通过： \n\nanon_inode_getfd_secure\n\n生成一个匿名inode，并获得一个句柄fd。重点别忘记了，这种“文件”也是可以有file_operations的，比如上面anon_inode_getfd_secure参数中的userfaultfd_fops：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/9a7eb6b3c35d45a1a4eaf1b76cc1398c.png)\n\n这样，我们就可以在file_operations的ioctl，poll，read等callback里面实现自己特别的“文件”逻辑，这是我们自由发挥的舞台。 \n\n说起anon_inode_getfd_secure，它再往底层走一级是__anon_inode_getfd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0e672cd9bd994dc285f89e617c06305b.png)\n\n进而再走一级是__anon_inode_getfile：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/7e632a0669e34ab69bac30c3f5e4dd60.png)\n\n所以本质上，是先造一个anon_inode，然后再在这个anon_inode上面造一个pseudo的file，最后通过fd_install(fd, file)，把fd和file缠在一起。再次强调，用户有了这个fd就可以为所欲为；而内核本身，则是通过file_operations的不同实现来为所欲为的。 \n\nanon_inode之上添加一个系统调用，造一种特殊的fd，让用户去poll，去ioctl，把想象空间拉大了。这种实现方法，如此拉风灵活，以至于它本身也成为了一种套路。比如内核里面fs目录下的： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0af65e9d09c34b96890eba35cecb648b.png)\n\neventfd，eventpoll，fscontext，io_uring，fanotify，inotify，signalfd，timerfd.......\n\n正所谓， 待到秋来九月八，我花开后百花杀。冲天香阵透长安，满城尽带黄金甲。文件，哪怕最终是匿名的，都以冲天的香阵，弥漫整个Linux的世界。\n\n04\n\n用户使用匿名inode\n\n到了要说再见的时刻了，用户可见的就是fd，通过fd来使用匿名inode。下面我们来制造一个page fault的例子，让用户态来处理它，这个例子直接简化自userfaultfd的man page。我们在主线程中，通过mmap申请一页内存，然后通过userfaultfd的ioctl告诉内核这页的开始地址和长度，以及通过UFFDIO_REGISTER告诉内核这页的page fault想用户空间处理：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/36e34f1760bb4ac6a3192f57d58264ca.png)\n\n然后我们在pthread_create创建的fault_handler_thread线程中，poll userfaultfd等待事件，之后把一页全是0x66的内容拷贝到page fault发生的那一页： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5a7596802fc1411bbbca9f481cc42913.png)\n\n我们运行这个程序得到的输出如下：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/539b3cebc6034a6187bb941433906a9a.png)\n\n我们主线程在执行addr[0]=0x5A5A5A5A的时候，触发了page fault。在fault线程里面，page fault发生后，poll阻塞返回，之后用户通过read读到了一个uffd_msg的结构体，里面的成员包含了page fault的地址。之后，我们通过UFFDIO_COPY这个ioctl，把内容为0x66的页面拷贝给page fault的页面。\n\n可以看出来： \n\n- poll在等什么，完全被定制化了；\n- read能读什么，完全被定制化了；\n- ioctl能控制什么，完全被定制化了。\n\n我们通过“文件”这个不变的“静”，制造了poll、read、ioctl的灵动自如。兵法有云，以不变应万变，以万变应不变。","source":"_posts/linux_md/Linux Basic/论一切都是文件之匿名inode.md","raw":"---\ntitle: 论一切都是文件之匿名inode\ndate: '2020/12/31 23:59'\ntags:\n - linux\ncategories:\n - 学习笔记\nabbrlink: 15002\ncover: \n---\n\n## 宋宝华：论一切都是文件之匿名inode\n\n01\n\n唯有文件得人心\n\n当一个女生让你替她抓100只萤火虫，她一定不是为了折磨你，而是因为她爱上了你。当你们之间经历了无数的恩恩怨怨和彼此伤害，她再次让你替她抓100只萤火虫，那一定是因为她还爱着你。 \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5013388ec46043c59f4fb4b3e373e955.png)\n\n为什么？因为这就是套路，是在下偶尔瞟一眼古装肥皂剧总结出来的套路。\n\nLinux里面最大的套路，就是“一切都是文件”。爱一个人，就为她捉萤火虫；做一件事，就让它成为一个“文件”。 \n\n为什么自古深情留不住，唯有“文件”得人心呢？因为文件在用户态最直观的形式是随着一次open，获得一个fd，有了这个fd，长城内外，你基本可以为所欲为：\n\n- 在本进程内，fd的最直观操作是open、close、mmap、ioctl、poll这些。 m map 让你具备把fd透射到内存的能力，所以你可以通过指针访问文件的内容。再者，这个mmap，如果底层透射的是framebuffer、V4L2、DRM等，则让我们具备了从用户态操作底层显存、多媒体数据等的能力；比如，无论是V4L2还是DRM，都支持把底层的dma_buf导出为fd。poll则提供给用户阻塞等待某事件发生的能力。 至于ioctl，就更加不用说了，你可以透过ioctl灵活地为fd添加控制命令。\n- 在跨进程的情况下，Linux支持fd的跨进程socket传输，从而可以实现共享内存、dma_buf跨进程共享等。比如一个进程可以通过send_fd可以把fd发送出去：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/1fce6c5c621b4fd09919e87f52c59801.png)\n\n而另外一个进程可以通过recv_fd把fd收过来： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/a0d3b15c19454faabb33b6fab3704d6f.png)\n\n这种fd在长城内外可以互访，fd最终可以指向dma_buf同时可以被mmap，而dma_buf又最终可以被显卡、显示控制器、video decoder/encoder等设备访问的能力，让fd打通了设备、CPU和跨进程的障碍，从此可以横着走。 \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/277dafd9086b4d148de8b617f9252b62.png)\n\n我们在《 宋宝华：世上最好的共享内存(Linux共享内存最透彻的一篇) 》一文中已经详细阐述过这个过程，这里我们就不再赘述了。本文的重点在于匿名inode。 \n\n02\n\ninode源头file活水\n\n我们把文件想象成一个object，那么inode描述的是本源，和最终的object一一对应；dentry是inode的一个路径马甲，比如我们可以通过\"ln\"命令为同一个inode创建很多的硬链接马甲；而file则是活水，进程对object的一次“open”，获得一个file，导致用户态得到一个\"fd\"的句柄来操作这个object。\n\n经典的inode、dentry、file谁都不缺席的模型是这样的：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/d48bc627be544288b73fe774962b1010.png)\n\n上图中，我们有一个inode，这个inode有2个dentry，进程A、B open的是第一个dentry；而进程C、D open的是第二个dentry。变了的是file和fd，不变的是inode，中间的dentry马甲没那么重要。\n\n但是在inode、dentry、file这个经典铁三角中，从来都是可以有一个缺席者的，那就是dentry，因为，有时候用户态想获得长城内外行走的便利，但是却不想这个inode在文件系统里面留下一个路径的痕迹。简单来说，我希望有个fd，但是这个fd，你在从\"/\"往下面搜索的任何一条路径下，你都找不到它，它根本在根文件系统以下不存在路径，它是无名氏，它没有马甲，它是个传说。\n\n比如，近期名震江湖的剑客usefaultfd允许我们在用户空间处理page fault，我们是通过userfaultfd这个系统调用先获得一个fd，之后就可以对它进行各种ioctl了： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/e0230f143c434814ba2cdc39c2faaa68.png)\n\n我们透过userfaultfd系统获得了一个fd，它在/xxx/yyy/zzz这样的文件系统下没有路径。这种情况下的fd，对应着的是一个没有名字的匿名inode，你显然没有办法像fd = open (\"xxx\", ..)那样来得到匿名inode的fd，因为\"xxx\"是一个路径，而匿名inode没有xxx，所以你是直接透过syscall userfaultfd这样的系统调用，来获得anon_inode在你的进程里面对应的fd的:\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/675fef6379254f7fb5c7b3a934c32255.png)\n\n人过留名，雁过留声；杀人者，打虎武松也。但是anon inode不吃这一套，它是一个绝顶的轻功高手，它给与的，是透过fd长城内外行走的能力，但是，在文件系统里面却从未来过。这是用户真实的需求，如果这种需求一定要透过一个dentry的open才能实现，这未免有点画蛇添足了。\n\n03\n\n匿名inode的内核实例\n\n我们接下来可以随便打开个anon inode的实例来看看它是怎么工作的了。首先userfaultd是一个系统调用：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/cb54f7e833a743b1962c47dcd996e921.png)\n\n这个代码里面比较核心的是就是，它通过： \n\nanon_inode_getfd_secure\n\n生成一个匿名inode，并获得一个句柄fd。重点别忘记了，这种“文件”也是可以有file_operations的，比如上面anon_inode_getfd_secure参数中的userfaultfd_fops：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/9a7eb6b3c35d45a1a4eaf1b76cc1398c.png)\n\n这样，我们就可以在file_operations的ioctl，poll，read等callback里面实现自己特别的“文件”逻辑，这是我们自由发挥的舞台。 \n\n说起anon_inode_getfd_secure，它再往底层走一级是__anon_inode_getfd：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0e672cd9bd994dc285f89e617c06305b.png)\n\n进而再走一级是__anon_inode_getfile：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/7e632a0669e34ab69bac30c3f5e4dd60.png)\n\n所以本质上，是先造一个anon_inode，然后再在这个anon_inode上面造一个pseudo的file，最后通过fd_install(fd, file)，把fd和file缠在一起。再次强调，用户有了这个fd就可以为所欲为；而内核本身，则是通过file_operations的不同实现来为所欲为的。 \n\nanon_inode之上添加一个系统调用，造一种特殊的fd，让用户去poll，去ioctl，把想象空间拉大了。这种实现方法，如此拉风灵活，以至于它本身也成为了一种套路。比如内核里面fs目录下的： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0af65e9d09c34b96890eba35cecb648b.png)\n\neventfd，eventpoll，fscontext，io_uring，fanotify，inotify，signalfd，timerfd.......\n\n正所谓， 待到秋来九月八，我花开后百花杀。冲天香阵透长安，满城尽带黄金甲。文件，哪怕最终是匿名的，都以冲天的香阵，弥漫整个Linux的世界。\n\n04\n\n用户使用匿名inode\n\n到了要说再见的时刻了，用户可见的就是fd，通过fd来使用匿名inode。下面我们来制造一个page fault的例子，让用户态来处理它，这个例子直接简化自userfaultfd的man page。我们在主线程中，通过mmap申请一页内存，然后通过userfaultfd的ioctl告诉内核这页的开始地址和长度，以及通过UFFDIO_REGISTER告诉内核这页的page fault想用户空间处理：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/36e34f1760bb4ac6a3192f57d58264ca.png)\n\n然后我们在pthread_create创建的fault_handler_thread线程中，poll userfaultfd等待事件，之后把一页全是0x66的内容拷贝到page fault发生的那一页： \n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5a7596802fc1411bbbca9f481cc42913.png)\n\n我们运行这个程序得到的输出如下：\n\n![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/539b3cebc6034a6187bb941433906a9a.png)\n\n我们主线程在执行addr[0]=0x5A5A5A5A的时候，触发了page fault。在fault线程里面，page fault发生后，poll阻塞返回，之后用户通过read读到了一个uffd_msg的结构体，里面的成员包含了page fault的地址。之后，我们通过UFFDIO_COPY这个ioctl，把内容为0x66的页面拷贝给page fault的页面。\n\n可以看出来： \n\n- poll在等什么，完全被定制化了；\n- read能读什么，完全被定制化了；\n- ioctl能控制什么，完全被定制化了。\n\n我们通过“文件”这个不变的“静”，制造了poll、read、ioctl的灵动自如。兵法有云，以不变应万变，以万变应不变。","slug":"linux_md/Linux Basic/论一切都是文件之匿名inode","published":1,"updated":"2021-04-08T14:09:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr620021w9q981wk5ffk","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h2 id=\"宋宝华：论一切都是文件之匿名inode\"><a href=\"#宋宝华：论一切都是文件之匿名inode\" class=\"headerlink\" title=\"宋宝华：论一切都是文件之匿名inode\"></a>宋宝华：论一切都是文件之匿名inode</h2><p>01</p>\n<p>唯有文件得人心</p>\n<p>当一个女生让你替她抓100只萤火虫，她一定不是为了折磨你，而是因为她爱上了你。当你们之间经历了无数的恩恩怨怨和彼此伤害，她再次让你替她抓100只萤火虫，那一定是因为她还爱着你。 </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5013388ec46043c59f4fb4b3e373e955.png)</p>\n<p>为什么？因为这就是套路，是在下偶尔瞟一眼古装肥皂剧总结出来的套路。</p>\n<p>Linux里面最大的套路，就是“一切都是文件”。爱一个人，就为她捉萤火虫；做一件事，就让它成为一个“文件”。 </p>\n<p>为什么自古深情留不住，唯有“文件”得人心呢？因为文件在用户态最直观的形式是随着一次open，获得一个fd，有了这个fd，长城内外，你基本可以为所欲为：</p>\n<ul>\n<li>在本进程内，fd的最直观操作是open、close、mmap、ioctl、poll这些。 m map 让你具备把fd透射到内存的能力，所以你可以通过指针访问文件的内容。再者，这个mmap，如果底层透射的是framebuffer、V4L2、DRM等，则让我们具备了从用户态操作底层显存、多媒体数据等的能力；比如，无论是V4L2还是DRM，都支持把底层的dma_buf导出为fd。poll则提供给用户阻塞等待某事件发生的能力。 至于ioctl，就更加不用说了，你可以透过ioctl灵活地为fd添加控制命令。</li>\n<li>在跨进程的情况下，Linux支持fd的跨进程socket传输，从而可以实现共享内存、dma_buf跨进程共享等。比如一个进程可以通过send_fd可以把fd发送出去：</li>\n</ul>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/1fce6c5c621b4fd09919e87f52c59801.png)</p>\n<p>而另外一个进程可以通过recv_fd把fd收过来： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/a0d3b15c19454faabb33b6fab3704d6f.png)</p>\n<p>这种fd在长城内外可以互访，fd最终可以指向dma_buf同时可以被mmap，而dma_buf又最终可以被显卡、显示控制器、video decoder/encoder等设备访问的能力，让fd打通了设备、CPU和跨进程的障碍，从此可以横着走。 </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/277dafd9086b4d148de8b617f9252b62.png)</p>\n<p>我们在《 宋宝华：世上最好的共享内存(Linux共享内存最透彻的一篇) 》一文中已经详细阐述过这个过程，这里我们就不再赘述了。本文的重点在于匿名inode。 </p>\n<p>02</p>\n<p>inode源头file活水</p>\n<p>我们把文件想象成一个object，那么inode描述的是本源，和最终的object一一对应；dentry是inode的一个路径马甲，比如我们可以通过”ln”命令为同一个inode创建很多的硬链接马甲；而file则是活水，进程对object的一次“open”，获得一个file，导致用户态得到一个”fd”的句柄来操作这个object。</p>\n<p>经典的inode、dentry、file谁都不缺席的模型是这样的：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/d48bc627be544288b73fe774962b1010.png)</p>\n<p>上图中，我们有一个inode，这个inode有2个dentry，进程A、B open的是第一个dentry；而进程C、D open的是第二个dentry。变了的是file和fd，不变的是inode，中间的dentry马甲没那么重要。</p>\n<p>但是在inode、dentry、file这个经典铁三角中，从来都是可以有一个缺席者的，那就是dentry，因为，有时候用户态想获得长城内外行走的便利，但是却不想这个inode在文件系统里面留下一个路径的痕迹。简单来说，我希望有个fd，但是这个fd，你在从”/“往下面搜索的任何一条路径下，你都找不到它，它根本在根文件系统以下不存在路径，它是无名氏，它没有马甲，它是个传说。</p>\n<p>比如，近期名震江湖的剑客usefaultfd允许我们在用户空间处理page fault，我们是通过userfaultfd这个系统调用先获得一个fd，之后就可以对它进行各种ioctl了： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/e0230f143c434814ba2cdc39c2faaa68.png)</p>\n<p>我们透过userfaultfd系统获得了一个fd，它在/xxx/yyy/zzz这样的文件系统下没有路径。这种情况下的fd，对应着的是一个没有名字的匿名inode，你显然没有办法像fd = open (“xxx”, ..)那样来得到匿名inode的fd，因为”xxx”是一个路径，而匿名inode没有xxx，所以你是直接透过syscall userfaultfd这样的系统调用，来获得anon_inode在你的进程里面对应的fd的:</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/675fef6379254f7fb5c7b3a934c32255.png)</p>\n<p>人过留名，雁过留声；杀人者，打虎武松也。但是anon inode不吃这一套，它是一个绝顶的轻功高手，它给与的，是透过fd长城内外行走的能力，但是，在文件系统里面却从未来过。这是用户真实的需求，如果这种需求一定要透过一个dentry的open才能实现，这未免有点画蛇添足了。</p>\n<p>03</p>\n<p>匿名inode的内核实例</p>\n<p>我们接下来可以随便打开个anon inode的实例来看看它是怎么工作的了。首先userfaultd是一个系统调用：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/cb54f7e833a743b1962c47dcd996e921.png)</p>\n<p>这个代码里面比较核心的是就是，它通过： </p>\n<p>anon_inode_getfd_secure</p>\n<p>生成一个匿名inode，并获得一个句柄fd。重点别忘记了，这种“文件”也是可以有file_operations的，比如上面anon_inode_getfd_secure参数中的userfaultfd_fops：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/9a7eb6b3c35d45a1a4eaf1b76cc1398c.png)</p>\n<p>这样，我们就可以在file_operations的ioctl，poll，read等callback里面实现自己特别的“文件”逻辑，这是我们自由发挥的舞台。 </p>\n<p>说起anon_inode_getfd_secure，它再往底层走一级是__anon_inode_getfd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0e672cd9bd994dc285f89e617c06305b.png)</p>\n<p>进而再走一级是__anon_inode_getfile：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/7e632a0669e34ab69bac30c3f5e4dd60.png)</p>\n<p>所以本质上，是先造一个anon_inode，然后再在这个anon_inode上面造一个pseudo的file，最后通过fd_install(fd, file)，把fd和file缠在一起。再次强调，用户有了这个fd就可以为所欲为；而内核本身，则是通过file_operations的不同实现来为所欲为的。 </p>\n<p>anon_inode之上添加一个系统调用，造一种特殊的fd，让用户去poll，去ioctl，把想象空间拉大了。这种实现方法，如此拉风灵活，以至于它本身也成为了一种套路。比如内核里面fs目录下的： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0af65e9d09c34b96890eba35cecb648b.png)</p>\n<p>eventfd，eventpoll，fscontext，io_uring，fanotify，inotify，signalfd，timerfd…….</p>\n<p>正所谓， 待到秋来九月八，我花开后百花杀。冲天香阵透长安，满城尽带黄金甲。文件，哪怕最终是匿名的，都以冲天的香阵，弥漫整个Linux的世界。</p>\n<p>04</p>\n<p>用户使用匿名inode</p>\n<p>到了要说再见的时刻了，用户可见的就是fd，通过fd来使用匿名inode。下面我们来制造一个page fault的例子，让用户态来处理它，这个例子直接简化自userfaultfd的man page。我们在主线程中，通过mmap申请一页内存，然后通过userfaultfd的ioctl告诉内核这页的开始地址和长度，以及通过UFFDIO_REGISTER告诉内核这页的page fault想用户空间处理：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/36e34f1760bb4ac6a3192f57d58264ca.png)</p>\n<p>然后我们在pthread_create创建的fault_handler_thread线程中，poll userfaultfd等待事件，之后把一页全是0x66的内容拷贝到page fault发生的那一页： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5a7596802fc1411bbbca9f481cc42913.png)</p>\n<p>我们运行这个程序得到的输出如下：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/539b3cebc6034a6187bb941433906a9a.png)</p>\n<p>我们主线程在执行addr[0]=0x5A5A5A5A的时候，触发了page fault。在fault线程里面，page fault发生后，poll阻塞返回，之后用户通过read读到了一个uffd_msg的结构体，里面的成员包含了page fault的地址。之后，我们通过UFFDIO_COPY这个ioctl，把内容为0x66的页面拷贝给page fault的页面。</p>\n<p>可以看出来： </p>\n<ul>\n<li>poll在等什么，完全被定制化了；</li>\n<li>read能读什么，完全被定制化了；</li>\n<li>ioctl能控制什么，完全被定制化了。</li>\n</ul>\n<p>我们通过“文件”这个不变的“静”，制造了poll、read、ioctl的灵动自如。兵法有云，以不变应万变，以万变应不变。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h2 id=\"宋宝华：论一切都是文件之匿名inode\"><a href=\"#宋宝华：论一切都是文件之匿名inode\" class=\"headerlink\" title=\"宋宝华：论一切都是文件之匿名inode\"></a>宋宝华：论一切都是文件之匿名inode</h2><p>01</p>\n<p>唯有文件得人心</p>\n<p>当一个女生让你替她抓100只萤火虫，她一定不是为了折磨你，而是因为她爱上了你。当你们之间经历了无数的恩恩怨怨和彼此伤害，她再次让你替她抓100只萤火虫，那一定是因为她还爱着你。 </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5013388ec46043c59f4fb4b3e373e955.png)</p>\n<p>为什么？因为这就是套路，是在下偶尔瞟一眼古装肥皂剧总结出来的套路。</p>\n<p>Linux里面最大的套路，就是“一切都是文件”。爱一个人，就为她捉萤火虫；做一件事，就让它成为一个“文件”。 </p>\n<p>为什么自古深情留不住，唯有“文件”得人心呢？因为文件在用户态最直观的形式是随着一次open，获得一个fd，有了这个fd，长城内外，你基本可以为所欲为：</p>\n<ul>\n<li>在本进程内，fd的最直观操作是open、close、mmap、ioctl、poll这些。 m map 让你具备把fd透射到内存的能力，所以你可以通过指针访问文件的内容。再者，这个mmap，如果底层透射的是framebuffer、V4L2、DRM等，则让我们具备了从用户态操作底层显存、多媒体数据等的能力；比如，无论是V4L2还是DRM，都支持把底层的dma_buf导出为fd。poll则提供给用户阻塞等待某事件发生的能力。 至于ioctl，就更加不用说了，你可以透过ioctl灵活地为fd添加控制命令。</li>\n<li>在跨进程的情况下，Linux支持fd的跨进程socket传输，从而可以实现共享内存、dma_buf跨进程共享等。比如一个进程可以通过send_fd可以把fd发送出去：</li>\n</ul>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/1fce6c5c621b4fd09919e87f52c59801.png)</p>\n<p>而另外一个进程可以通过recv_fd把fd收过来： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/a0d3b15c19454faabb33b6fab3704d6f.png)</p>\n<p>这种fd在长城内外可以互访，fd最终可以指向dma_buf同时可以被mmap，而dma_buf又最终可以被显卡、显示控制器、video decoder/encoder等设备访问的能力，让fd打通了设备、CPU和跨进程的障碍，从此可以横着走。 </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/277dafd9086b4d148de8b617f9252b62.png)</p>\n<p>我们在《 宋宝华：世上最好的共享内存(Linux共享内存最透彻的一篇) 》一文中已经详细阐述过这个过程，这里我们就不再赘述了。本文的重点在于匿名inode。 </p>\n<p>02</p>\n<p>inode源头file活水</p>\n<p>我们把文件想象成一个object，那么inode描述的是本源，和最终的object一一对应；dentry是inode的一个路径马甲，比如我们可以通过”ln”命令为同一个inode创建很多的硬链接马甲；而file则是活水，进程对object的一次“open”，获得一个file，导致用户态得到一个”fd”的句柄来操作这个object。</p>\n<p>经典的inode、dentry、file谁都不缺席的模型是这样的：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/d48bc627be544288b73fe774962b1010.png)</p>\n<p>上图中，我们有一个inode，这个inode有2个dentry，进程A、B open的是第一个dentry；而进程C、D open的是第二个dentry。变了的是file和fd，不变的是inode，中间的dentry马甲没那么重要。</p>\n<p>但是在inode、dentry、file这个经典铁三角中，从来都是可以有一个缺席者的，那就是dentry，因为，有时候用户态想获得长城内外行走的便利，但是却不想这个inode在文件系统里面留下一个路径的痕迹。简单来说，我希望有个fd，但是这个fd，你在从”/“往下面搜索的任何一条路径下，你都找不到它，它根本在根文件系统以下不存在路径，它是无名氏，它没有马甲，它是个传说。</p>\n<p>比如，近期名震江湖的剑客usefaultfd允许我们在用户空间处理page fault，我们是通过userfaultfd这个系统调用先获得一个fd，之后就可以对它进行各种ioctl了： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/e0230f143c434814ba2cdc39c2faaa68.png)</p>\n<p>我们透过userfaultfd系统获得了一个fd，它在/xxx/yyy/zzz这样的文件系统下没有路径。这种情况下的fd，对应着的是一个没有名字的匿名inode，你显然没有办法像fd = open (“xxx”, ..)那样来得到匿名inode的fd，因为”xxx”是一个路径，而匿名inode没有xxx，所以你是直接透过syscall userfaultfd这样的系统调用，来获得anon_inode在你的进程里面对应的fd的:</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/675fef6379254f7fb5c7b3a934c32255.png)</p>\n<p>人过留名，雁过留声；杀人者，打虎武松也。但是anon inode不吃这一套，它是一个绝顶的轻功高手，它给与的，是透过fd长城内外行走的能力，但是，在文件系统里面却从未来过。这是用户真实的需求，如果这种需求一定要透过一个dentry的open才能实现，这未免有点画蛇添足了。</p>\n<p>03</p>\n<p>匿名inode的内核实例</p>\n<p>我们接下来可以随便打开个anon inode的实例来看看它是怎么工作的了。首先userfaultd是一个系统调用：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/cb54f7e833a743b1962c47dcd996e921.png)</p>\n<p>这个代码里面比较核心的是就是，它通过： </p>\n<p>anon_inode_getfd_secure</p>\n<p>生成一个匿名inode，并获得一个句柄fd。重点别忘记了，这种“文件”也是可以有file_operations的，比如上面anon_inode_getfd_secure参数中的userfaultfd_fops：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/9a7eb6b3c35d45a1a4eaf1b76cc1398c.png)</p>\n<p>这样，我们就可以在file_operations的ioctl，poll，read等callback里面实现自己特别的“文件”逻辑，这是我们自由发挥的舞台。 </p>\n<p>说起anon_inode_getfd_secure，它再往底层走一级是__anon_inode_getfd：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0e672cd9bd994dc285f89e617c06305b.png)</p>\n<p>进而再走一级是__anon_inode_getfile：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/7e632a0669e34ab69bac30c3f5e4dd60.png)</p>\n<p>所以本质上，是先造一个anon_inode，然后再在这个anon_inode上面造一个pseudo的file，最后通过fd_install(fd, file)，把fd和file缠在一起。再次强调，用户有了这个fd就可以为所欲为；而内核本身，则是通过file_operations的不同实现来为所欲为的。 </p>\n<p>anon_inode之上添加一个系统调用，造一种特殊的fd，让用户去poll，去ioctl，把想象空间拉大了。这种实现方法，如此拉风灵活，以至于它本身也成为了一种套路。比如内核里面fs目录下的： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0af65e9d09c34b96890eba35cecb648b.png)</p>\n<p>eventfd，eventpoll，fscontext，io_uring，fanotify，inotify，signalfd，timerfd…….</p>\n<p>正所谓， 待到秋来九月八，我花开后百花杀。冲天香阵透长安，满城尽带黄金甲。文件，哪怕最终是匿名的，都以冲天的香阵，弥漫整个Linux的世界。</p>\n<p>04</p>\n<p>用户使用匿名inode</p>\n<p>到了要说再见的时刻了，用户可见的就是fd，通过fd来使用匿名inode。下面我们来制造一个page fault的例子，让用户态来处理它，这个例子直接简化自userfaultfd的man page。我们在主线程中，通过mmap申请一页内存，然后通过userfaultfd的ioctl告诉内核这页的开始地址和长度，以及通过UFFDIO_REGISTER告诉内核这页的page fault想用户空间处理：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/36e34f1760bb4ac6a3192f57d58264ca.png)</p>\n<p>然后我们在pthread_create创建的fault_handler_thread线程中，poll userfaultfd等待事件，之后把一页全是0x66的内容拷贝到page fault发生的那一页： </p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5a7596802fc1411bbbca9f481cc42913.png)</p>\n<p>我们运行这个程序得到的输出如下：</p>\n<p>![img](/Users/phoenine/Documents/MyBlog/hexo/source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/539b3cebc6034a6187bb941433906a9a.png)</p>\n<p>我们主线程在执行addr[0]=0x5A5A5A5A的时候，触发了page fault。在fault线程里面，page fault发生后，poll阻塞返回，之后用户通过read读到了一个uffd_msg的结构体，里面的成员包含了page fault的地址。之后，我们通过UFFDIO_COPY这个ioctl，把内容为0x66的页面拷贝给page fault的页面。</p>\n<p>可以看出来： </p>\n<ul>\n<li>poll在等什么，完全被定制化了；</li>\n<li>read能读什么，完全被定制化了；</li>\n<li>ioctl能控制什么，完全被定制化了。</li>\n</ul>\n<p>我们通过“文件”这个不变的“静”，制造了poll、read、ioctl的灵动自如。兵法有云，以不变应万变，以万变应不变。</p>\n"},{"title":"SPEC file writing - Best Practices","date":"2020-12-31T15:59:00.000Z","abbrlink":13014,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n\n# SPEC file writing - Best Practices\n\n## Do not leave empty tags\n\nAlways fill \"Summary\", \"description\", etc tags. Never left things blank.\nThey will be displayed when queried using \"rpm -qi <rpm>\". \n\n## SPEC Directives values aligned to same column\n\nIt is easier to read SPEC files if values of directives are aligned to same column like this:\n\n**sample spec**\n\n```makefile\nName:           RUOAM-CommonLibrary\nVersion:        %{_version}\nRelease:        %{_release}\nSummary:        Common library\nGroup:          Fronthaul Gateway\nLicense:        Nokia License\nURL:            https://bhgerrit.ext.net.nokia.com/scm_fhgw/RUOAM-CommonLibrary\nAutoReqProv:    no\n \nRequires:       container-logging-service-libs\n \n%description\n%{summary}\n \n%package devel\nSummary:        Development files for %{name}\nGroup:          Development/Libraries\nRequires:       %{name}-libs%{?_isa} = %{version}-%{release}\n```\n\n## New lines\n\nSeparate each section with new lines but don't use new lines inside sections. Refer above spec file example.\n\n## Using Macros\n\nWherever possible, try to use macros and do not hardcode any paths. \nMost commonly used macros\n\n%{_prefix}    → /opt/nokia/\n%{_libdir}     → /opt/nokia/lib64/\n%{_includedir} → /opt/nokia/include/\n\n## %install section\n\nTry not to crate directories and copy files in %install section. It is ok to do it in un avoidable conditions, but the best place to do such things is Makefile.am\n\n**Avoid this in spec file**\n\n```\n%install\n...\nmkdir -p %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_config_scripts/\nmkdir -p %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_feature_configs/\nmkdir -p %{buildroot}/opt/nokia/RUOAM-NetconfStartup/preconfiguration_scripts/\n \ncp ../CPRIN/ODU/module_config_scripts/*.sh  %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_config_scripts/\ncp ../CPRIN/ODU/module_config_scripts/*.py  %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_config_scripts/\ncp ../CPRIN/ODU/module_feature_configs/01_base_modules.conf %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_feature_configs/\n```\n\n\n\nIn [Makefile.am](http://makefile.am/), to specify the destination directory create variable ending with \"dir\" (for ex: yanginstalldir)\nTo copy existing script to the destination path, use \"dist_<dir-variable-name>_SCRIPTS (for ex: dist_yanginstall_SCRIPTS)\nTo copy existing data/configuration file to the destination path, use \"dist_<dir-variable-name>_SCRIPTS (for ex: dist_yanginit_DATA)\nSimilarly, if files are not available but are crated as part of 'make' from any input files (for ex \".in\" files), then use \"nodist\" instead of \"dist\" (these are useful when doing \"make dist\")\n\nThese steps will make sure that the destination directory is created in build environment, and files are copied with correct permissions (based on SCRIPTS/DATA etc).\nThen these paths has to be just specified in %files section to make them part of rpm.\n\n**Do this in Makefile.am**\n\n```\nyanginstalldir=$(NETCONF_MODULE_CONFIG_DIR)\ndist_yanginstall_SCRIPTS=$(top_srcdir)/scripts/install_default_user.py \\\n                         $(top_srcdir)/scripts/host_key.py\n \npreconfigdir=$(NETCONF_PRE_CONFIG_DIR)\ndist_preconfig_SCRIPTS=$(top_srcdir)/scripts/01_copy_usermgmt_persist_wrapper.py\n \nusermgmtdir=/opt/nokia/RUOAM-UserManagement/\ndist_usermgmt_SCRIPTS=$(top_srcdir)/scripts/usermgmt_persist_files.py\n \nyanginitdir=$(NETCONF_YANG_DIR)\ndist_yanginit_DATA=$(top_srcdir)/yang/o-ran-usermgmt.yang\n```\n\n## %files section\n\nFiles and directories included recursively.\nDirectories and files must not be listed multiple times in %files section. Having a directory in %files section automatically includes all files and directories recursively in that directory.\n\nNever add test files in the main package. Create separate package for devel/test and install only when required.\n\n## File attributes\n\nIn cases where the package builder cannot create the files to be packaged with the proper ownership and permissions, the %attr macro can be used to make things right.\nFile attributes should be set in %files section instead of %post section.\n\n```\n%attr(-, root, root) /var/%{name}/\n%config(noreplace) %attr(0660, 1000, 1000) /var/%{name}/data\n```\n\nSee, http://ftp.rpm.org/max-rpm/s1-rpm-anywhere-specifying-file-attributes.html\n\n## Directory ownership\n\nEach file should be owned by just a single RPM. One must not list directories owned by other packages in their file section. However, one must make sure to take ownership of those file that do belong to them.\n\n## Adding Container only components\n\nWhen adding container only components, never forget to specify *include_in_build* to *no* is rpm.spec file.\n\n```\n...\nAutoReqProv:    no\n \n%define include_in_build no\n \n%description\n...\n```\n\n## rpm macro check\n\nWith command 'rpm --showrc' , you can get list all available macros. For example , if you need to find what macro is pointing to /etc directory , you can run\n\n```\n# rpm --showrc | grep '\\/etc'\n-13: _sysconfdir %{_prefix}/etc\n \n# Or opposite query\n \n# rpm --eval %{_sysconfdir}\n/usr/etc\n```\n\n## Additional useful tools\n\n### *rpmspec*\n\nrpmspec is useful for getting info from spec file, it parses the spec file and provides various data such as what RPMs will spec build etc. For example:\n\n```\n$ rpmspec -q fhgw/rpm.spec\nwarning: line 2: Possible unexpanded macro in: Version: %{_version}\nwarning: line 3: Possible unexpanded macro in: Release: %{_release}\nwarning: line 20: Possible unexpanded macro in: Requires: RUOAM-CommonLibrary-libs(x86-64) = %{_version}-%{_release}\nRUOAM-CommonLibrary-%{_version}-%{_release}.x86_64\nRUOAM-CommonLibrary-devel-%{_version}-%{_release}.x86_64\nRUOAM-CommonLibrary-libs-%{_version}-%{_release}.x86_64\n```\n\nFor more information see rpmspec man page with man rpmspec.","source":"_posts/linux_md/Makefile/SPEC file writing - Best Practices.md","raw":"---\ntitle: SPEC file writing - Best Practices\ndate: '2020/12/31 23:59'\ntags:\n - baisc\n - Encrypted\ncategories:\n - 个人项目\nabbrlink: 13014\ncover: \n---\n\n\n# SPEC file writing - Best Practices\n\n## Do not leave empty tags\n\nAlways fill \"Summary\", \"description\", etc tags. Never left things blank.\nThey will be displayed when queried using \"rpm -qi <rpm>\". \n\n## SPEC Directives values aligned to same column\n\nIt is easier to read SPEC files if values of directives are aligned to same column like this:\n\n**sample spec**\n\n```makefile\nName:           RUOAM-CommonLibrary\nVersion:        %{_version}\nRelease:        %{_release}\nSummary:        Common library\nGroup:          Fronthaul Gateway\nLicense:        Nokia License\nURL:            https://bhgerrit.ext.net.nokia.com/scm_fhgw/RUOAM-CommonLibrary\nAutoReqProv:    no\n \nRequires:       container-logging-service-libs\n \n%description\n%{summary}\n \n%package devel\nSummary:        Development files for %{name}\nGroup:          Development/Libraries\nRequires:       %{name}-libs%{?_isa} = %{version}-%{release}\n```\n\n## New lines\n\nSeparate each section with new lines but don't use new lines inside sections. Refer above spec file example.\n\n## Using Macros\n\nWherever possible, try to use macros and do not hardcode any paths. \nMost commonly used macros\n\n%{_prefix}    → /opt/nokia/\n%{_libdir}     → /opt/nokia/lib64/\n%{_includedir} → /opt/nokia/include/\n\n## %install section\n\nTry not to crate directories and copy files in %install section. It is ok to do it in un avoidable conditions, but the best place to do such things is Makefile.am\n\n**Avoid this in spec file**\n\n```\n%install\n...\nmkdir -p %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_config_scripts/\nmkdir -p %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_feature_configs/\nmkdir -p %{buildroot}/opt/nokia/RUOAM-NetconfStartup/preconfiguration_scripts/\n \ncp ../CPRIN/ODU/module_config_scripts/*.sh  %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_config_scripts/\ncp ../CPRIN/ODU/module_config_scripts/*.py  %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_config_scripts/\ncp ../CPRIN/ODU/module_feature_configs/01_base_modules.conf %{buildroot}/opt/nokia/RUOAM-NetconfStartup/module_feature_configs/\n```\n\n\n\nIn [Makefile.am](http://makefile.am/), to specify the destination directory create variable ending with \"dir\" (for ex: yanginstalldir)\nTo copy existing script to the destination path, use \"dist_<dir-variable-name>_SCRIPTS (for ex: dist_yanginstall_SCRIPTS)\nTo copy existing data/configuration file to the destination path, use \"dist_<dir-variable-name>_SCRIPTS (for ex: dist_yanginit_DATA)\nSimilarly, if files are not available but are crated as part of 'make' from any input files (for ex \".in\" files), then use \"nodist\" instead of \"dist\" (these are useful when doing \"make dist\")\n\nThese steps will make sure that the destination directory is created in build environment, and files are copied with correct permissions (based on SCRIPTS/DATA etc).\nThen these paths has to be just specified in %files section to make them part of rpm.\n\n**Do this in Makefile.am**\n\n```\nyanginstalldir=$(NETCONF_MODULE_CONFIG_DIR)\ndist_yanginstall_SCRIPTS=$(top_srcdir)/scripts/install_default_user.py \\\n                         $(top_srcdir)/scripts/host_key.py\n \npreconfigdir=$(NETCONF_PRE_CONFIG_DIR)\ndist_preconfig_SCRIPTS=$(top_srcdir)/scripts/01_copy_usermgmt_persist_wrapper.py\n \nusermgmtdir=/opt/nokia/RUOAM-UserManagement/\ndist_usermgmt_SCRIPTS=$(top_srcdir)/scripts/usermgmt_persist_files.py\n \nyanginitdir=$(NETCONF_YANG_DIR)\ndist_yanginit_DATA=$(top_srcdir)/yang/o-ran-usermgmt.yang\n```\n\n## %files section\n\nFiles and directories included recursively.\nDirectories and files must not be listed multiple times in %files section. Having a directory in %files section automatically includes all files and directories recursively in that directory.\n\nNever add test files in the main package. Create separate package for devel/test and install only when required.\n\n## File attributes\n\nIn cases where the package builder cannot create the files to be packaged with the proper ownership and permissions, the %attr macro can be used to make things right.\nFile attributes should be set in %files section instead of %post section.\n\n```\n%attr(-, root, root) /var/%{name}/\n%config(noreplace) %attr(0660, 1000, 1000) /var/%{name}/data\n```\n\nSee, http://ftp.rpm.org/max-rpm/s1-rpm-anywhere-specifying-file-attributes.html\n\n## Directory ownership\n\nEach file should be owned by just a single RPM. One must not list directories owned by other packages in their file section. However, one must make sure to take ownership of those file that do belong to them.\n\n## Adding Container only components\n\nWhen adding container only components, never forget to specify *include_in_build* to *no* is rpm.spec file.\n\n```\n...\nAutoReqProv:    no\n \n%define include_in_build no\n \n%description\n...\n```\n\n## rpm macro check\n\nWith command 'rpm --showrc' , you can get list all available macros. For example , if you need to find what macro is pointing to /etc directory , you can run\n\n```\n# rpm --showrc | grep '\\/etc'\n-13: _sysconfdir %{_prefix}/etc\n \n# Or opposite query\n \n# rpm --eval %{_sysconfdir}\n/usr/etc\n```\n\n## Additional useful tools\n\n### *rpmspec*\n\nrpmspec is useful for getting info from spec file, it parses the spec file and provides various data such as what RPMs will spec build etc. For example:\n\n```\n$ rpmspec -q fhgw/rpm.spec\nwarning: line 2: Possible unexpanded macro in: Version: %{_version}\nwarning: line 3: Possible unexpanded macro in: Release: %{_release}\nwarning: line 20: Possible unexpanded macro in: Requires: RUOAM-CommonLibrary-libs(x86-64) = %{_version}-%{_release}\nRUOAM-CommonLibrary-%{_version}-%{_release}.x86_64\nRUOAM-CommonLibrary-devel-%{_version}-%{_release}.x86_64\nRUOAM-CommonLibrary-libs-%{_version}-%{_release}.x86_64\n```\n\nFor more information see rpmspec man page with man rpmspec.","slug":"linux_md/Makefile/SPEC file writing - Best Practices","published":1,"updated":"2021-04-13T14:15:51.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr630025w9q9615qb8xm","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"SPEC-file-writing-Best-Practices\"><a href=\"#SPEC-file-writing-Best-Practices\" class=\"headerlink\" title=\"SPEC file writing - Best Practices\"></a>SPEC file writing - Best Practices</h1><h2 id=\"Do-not-leave-empty-tags\"><a href=\"#Do-not-leave-empty-tags\" class=\"headerlink\" title=\"Do not leave empty tags\"></a>Do not leave empty tags</h2><p>Always fill “Summary”, “description”, etc tags. Never left things blank.<br>They will be displayed when queried using “rpm -qi <rpm>“. </p>\n<h2 id=\"SPEC-Directives-values-aligned-to-same-column\"><a href=\"#SPEC-Directives-values-aligned-to-same-column\" class=\"headerlink\" title=\"SPEC Directives values aligned to same column\"></a>SPEC Directives values aligned to same column</h2><p>It is easier to read SPEC files if values of directives are aligned to same column like this:</p>\n<p><strong>sample spec</strong></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">Name:           RUOAM-CommonLibrary</span></span><br><span class=\"line\"><span class=\"section\">Version:        %&#123;_version&#125;</span></span><br><span class=\"line\"><span class=\"section\">Release:        %&#123;_release&#125;</span></span><br><span class=\"line\"><span class=\"section\">Summary:        Common library</span></span><br><span class=\"line\"><span class=\"section\">Group:          Fronthaul Gateway</span></span><br><span class=\"line\"><span class=\"section\">License:        Nokia License</span></span><br><span class=\"line\"><span class=\"section\">URL:            https://bhgerrit.ext.net.nokia.com/scm_fhgw/RUOAM-CommonLibrary</span></span><br><span class=\"line\"><span class=\"section\">AutoReqProv:    no</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"section\">Requires:       container-logging-service-libs</span></span><br><span class=\"line\"> </span><br><span class=\"line\">%description</span><br><span class=\"line\">%&#123;summary&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">%package devel</span><br><span class=\"line\"><span class=\"section\">Summary:        Development files for %&#123;name&#125;</span></span><br><span class=\"line\"><span class=\"section\">Group:          Development/Libraries</span></span><br><span class=\"line\"><span class=\"section\">Requires:       %&#123;name&#125;-libs%&#123;?_isa&#125; = %&#123;version&#125;-%&#123;release&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"New-lines\"><a href=\"#New-lines\" class=\"headerlink\" title=\"New lines\"></a>New lines</h2><p>Separate each section with new lines but don’t use new lines inside sections. Refer above spec file example.</p>\n<h2 id=\"Using-Macros\"><a href=\"#Using-Macros\" class=\"headerlink\" title=\"Using Macros\"></a>Using Macros</h2><p>Wherever possible, try to use macros and do not hardcode any paths.<br>Most commonly used macros</p>\n<p>%{_prefix}    → /opt/nokia/<br>%{_libdir}     → /opt/nokia/lib64/<br>%{_includedir} → /opt/nokia/include/</p>\n<h2 id=\"install-section\"><a href=\"#install-section\" class=\"headerlink\" title=\"%install section\"></a>%install section</h2><p>Try not to crate directories and copy files in %install section. It is ok to do it in un avoidable conditions, but the best place to do such things is Makefile.am</p>\n<p><strong>Avoid this in spec file</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%install</span><br><span class=\"line\">...</span><br><span class=\"line\">mkdir -p %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_config_scripts&#x2F;</span><br><span class=\"line\">mkdir -p %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_feature_configs&#x2F;</span><br><span class=\"line\">mkdir -p %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;preconfiguration_scripts&#x2F;</span><br><span class=\"line\"> </span><br><span class=\"line\">cp ..&#x2F;CPRIN&#x2F;ODU&#x2F;module_config_scripts&#x2F;*.sh  %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_config_scripts&#x2F;</span><br><span class=\"line\">cp ..&#x2F;CPRIN&#x2F;ODU&#x2F;module_config_scripts&#x2F;*.py  %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_config_scripts&#x2F;</span><br><span class=\"line\">cp ..&#x2F;CPRIN&#x2F;ODU&#x2F;module_feature_configs&#x2F;01_base_modules.conf %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_feature_configs&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<p>In <a href=\"http://makefile.am/\">Makefile.am</a>, to specify the destination directory create variable ending with “dir” (for ex: yanginstalldir)<br>To copy existing script to the destination path, use “dist_<dir-variable-name><em>SCRIPTS (for ex: dist_yanginstall_SCRIPTS)<br>To copy existing data/configuration file to the destination path, use “dist</em><dir-variable-name>_SCRIPTS (for ex: dist_yanginit_DATA)<br>Similarly, if files are not available but are crated as part of ‘make’ from any input files (for ex “.in” files), then use “nodist” instead of “dist” (these are useful when doing “make dist”)</p>\n<p>These steps will make sure that the destination directory is created in build environment, and files are copied with correct permissions (based on SCRIPTS/DATA etc).<br>Then these paths has to be just specified in %files section to make them part of rpm.</p>\n<p><strong>Do this in Makefile.am</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yanginstalldir&#x3D;$(NETCONF_MODULE_CONFIG_DIR)</span><br><span class=\"line\">dist_yanginstall_SCRIPTS&#x3D;$(top_srcdir)&#x2F;scripts&#x2F;install_default_user.py \\</span><br><span class=\"line\">                         $(top_srcdir)&#x2F;scripts&#x2F;host_key.py</span><br><span class=\"line\"> </span><br><span class=\"line\">preconfigdir&#x3D;$(NETCONF_PRE_CONFIG_DIR)</span><br><span class=\"line\">dist_preconfig_SCRIPTS&#x3D;$(top_srcdir)&#x2F;scripts&#x2F;01_copy_usermgmt_persist_wrapper.py</span><br><span class=\"line\"> </span><br><span class=\"line\">usermgmtdir&#x3D;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-UserManagement&#x2F;</span><br><span class=\"line\">dist_usermgmt_SCRIPTS&#x3D;$(top_srcdir)&#x2F;scripts&#x2F;usermgmt_persist_files.py</span><br><span class=\"line\"> </span><br><span class=\"line\">yanginitdir&#x3D;$(NETCONF_YANG_DIR)</span><br><span class=\"line\">dist_yanginit_DATA&#x3D;$(top_srcdir)&#x2F;yang&#x2F;o-ran-usermgmt.yang</span><br></pre></td></tr></table></figure>\n<h2 id=\"files-section\"><a href=\"#files-section\" class=\"headerlink\" title=\"%files section\"></a>%files section</h2><p>Files and directories included recursively.<br>Directories and files must not be listed multiple times in %files section. Having a directory in %files section automatically includes all files and directories recursively in that directory.</p>\n<p>Never add test files in the main package. Create separate package for devel/test and install only when required.</p>\n<h2 id=\"File-attributes\"><a href=\"#File-attributes\" class=\"headerlink\" title=\"File attributes\"></a>File attributes</h2><p>In cases where the package builder cannot create the files to be packaged with the proper ownership and permissions, the %attr macro can be used to make things right.<br>File attributes should be set in %files section instead of %post section.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%attr(-, root, root) &#x2F;var&#x2F;%&#123;name&#125;&#x2F;</span><br><span class=\"line\">%config(noreplace) %attr(0660, 1000, 1000) &#x2F;var&#x2F;%&#123;name&#125;&#x2F;data</span><br></pre></td></tr></table></figure>\n<p>See, <a href=\"http://ftp.rpm.org/max-rpm/s1-rpm-anywhere-specifying-file-attributes.html\">http://ftp.rpm.org/max-rpm/s1-rpm-anywhere-specifying-file-attributes.html</a></p>\n<h2 id=\"Directory-ownership\"><a href=\"#Directory-ownership\" class=\"headerlink\" title=\"Directory ownership\"></a>Directory ownership</h2><p>Each file should be owned by just a single RPM. One must not list directories owned by other packages in their file section. However, one must make sure to take ownership of those file that do belong to them.</p>\n<h2 id=\"Adding-Container-only-components\"><a href=\"#Adding-Container-only-components\" class=\"headerlink\" title=\"Adding Container only components\"></a>Adding Container only components</h2><p>When adding container only components, never forget to specify <em>include_in_build</em> to <em>no</em> is rpm.spec file.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">AutoReqProv:    no</span><br><span class=\"line\"> </span><br><span class=\"line\">%define include_in_build no</span><br><span class=\"line\"> </span><br><span class=\"line\">%description</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"rpm-macro-check\"><a href=\"#rpm-macro-check\" class=\"headerlink\" title=\"rpm macro check\"></a>rpm macro check</h2><p>With command ‘rpm –showrc’ , you can get list all available macros. For example , if you need to find what macro is pointing to /etc directory , you can run</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># rpm --showrc | grep &#39;\\&#x2F;etc&#39;</span><br><span class=\"line\">-13: _sysconfdir %&#123;_prefix&#125;&#x2F;etc</span><br><span class=\"line\"> </span><br><span class=\"line\"># Or opposite query</span><br><span class=\"line\"> </span><br><span class=\"line\"># rpm --eval %&#123;_sysconfdir&#125;</span><br><span class=\"line\">&#x2F;usr&#x2F;etc</span><br></pre></td></tr></table></figure>\n<h2 id=\"Additional-useful-tools\"><a href=\"#Additional-useful-tools\" class=\"headerlink\" title=\"Additional useful tools\"></a>Additional useful tools</h2><h3 id=\"rpmspec\"><a href=\"#rpmspec\" class=\"headerlink\" title=\"rpmspec\"></a><em>rpmspec</em></h3><p>rpmspec is useful for getting info from spec file, it parses the spec file and provides various data such as what RPMs will spec build etc. For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rpmspec -q fhgw&#x2F;rpm.spec</span><br><span class=\"line\">warning: line 2: Possible unexpanded macro in: Version: %&#123;_version&#125;</span><br><span class=\"line\">warning: line 3: Possible unexpanded macro in: Release: %&#123;_release&#125;</span><br><span class=\"line\">warning: line 20: Possible unexpanded macro in: Requires: RUOAM-CommonLibrary-libs(x86-64) &#x3D; %&#123;_version&#125;-%&#123;_release&#125;</span><br><span class=\"line\">RUOAM-CommonLibrary-%&#123;_version&#125;-%&#123;_release&#125;.x86_64</span><br><span class=\"line\">RUOAM-CommonLibrary-devel-%&#123;_version&#125;-%&#123;_release&#125;.x86_64</span><br><span class=\"line\">RUOAM-CommonLibrary-libs-%&#123;_version&#125;-%&#123;_release&#125;.x86_64</span><br></pre></td></tr></table></figure>\n<p>For more information see rpmspec man page with man rpmspec.</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"SPEC-file-writing-Best-Practices\"><a href=\"#SPEC-file-writing-Best-Practices\" class=\"headerlink\" title=\"SPEC file writing - Best Practices\"></a>SPEC file writing - Best Practices</h1><h2 id=\"Do-not-leave-empty-tags\"><a href=\"#Do-not-leave-empty-tags\" class=\"headerlink\" title=\"Do not leave empty tags\"></a>Do not leave empty tags</h2><p>Always fill “Summary”, “description”, etc tags. Never left things blank.<br>They will be displayed when queried using “rpm -qi <rpm>“. </p>\n<h2 id=\"SPEC-Directives-values-aligned-to-same-column\"><a href=\"#SPEC-Directives-values-aligned-to-same-column\" class=\"headerlink\" title=\"SPEC Directives values aligned to same column\"></a>SPEC Directives values aligned to same column</h2><p>It is easier to read SPEC files if values of directives are aligned to same column like this:</p>\n<p><strong>sample spec</strong></p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">Name:           RUOAM-CommonLibrary</span></span><br><span class=\"line\"><span class=\"section\">Version:        %&#123;_version&#125;</span></span><br><span class=\"line\"><span class=\"section\">Release:        %&#123;_release&#125;</span></span><br><span class=\"line\"><span class=\"section\">Summary:        Common library</span></span><br><span class=\"line\"><span class=\"section\">Group:          Fronthaul Gateway</span></span><br><span class=\"line\"><span class=\"section\">License:        Nokia License</span></span><br><span class=\"line\"><span class=\"section\">URL:            https://bhgerrit.ext.net.nokia.com/scm_fhgw/RUOAM-CommonLibrary</span></span><br><span class=\"line\"><span class=\"section\">AutoReqProv:    no</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"section\">Requires:       container-logging-service-libs</span></span><br><span class=\"line\"> </span><br><span class=\"line\">%description</span><br><span class=\"line\">%&#123;summary&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">%package devel</span><br><span class=\"line\"><span class=\"section\">Summary:        Development files for %&#123;name&#125;</span></span><br><span class=\"line\"><span class=\"section\">Group:          Development/Libraries</span></span><br><span class=\"line\"><span class=\"section\">Requires:       %&#123;name&#125;-libs%&#123;?_isa&#125; = %&#123;version&#125;-%&#123;release&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"New-lines\"><a href=\"#New-lines\" class=\"headerlink\" title=\"New lines\"></a>New lines</h2><p>Separate each section with new lines but don’t use new lines inside sections. Refer above spec file example.</p>\n<h2 id=\"Using-Macros\"><a href=\"#Using-Macros\" class=\"headerlink\" title=\"Using Macros\"></a>Using Macros</h2><p>Wherever possible, try to use macros and do not hardcode any paths.<br>Most commonly used macros</p>\n<p>%{_prefix}    → /opt/nokia/<br>%{_libdir}     → /opt/nokia/lib64/<br>%{_includedir} → /opt/nokia/include/</p>\n<h2 id=\"install-section\"><a href=\"#install-section\" class=\"headerlink\" title=\"%install section\"></a>%install section</h2><p>Try not to crate directories and copy files in %install section. It is ok to do it in un avoidable conditions, but the best place to do such things is Makefile.am</p>\n<p><strong>Avoid this in spec file</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%install</span><br><span class=\"line\">...</span><br><span class=\"line\">mkdir -p %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_config_scripts&#x2F;</span><br><span class=\"line\">mkdir -p %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_feature_configs&#x2F;</span><br><span class=\"line\">mkdir -p %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;preconfiguration_scripts&#x2F;</span><br><span class=\"line\"> </span><br><span class=\"line\">cp ..&#x2F;CPRIN&#x2F;ODU&#x2F;module_config_scripts&#x2F;*.sh  %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_config_scripts&#x2F;</span><br><span class=\"line\">cp ..&#x2F;CPRIN&#x2F;ODU&#x2F;module_config_scripts&#x2F;*.py  %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_config_scripts&#x2F;</span><br><span class=\"line\">cp ..&#x2F;CPRIN&#x2F;ODU&#x2F;module_feature_configs&#x2F;01_base_modules.conf %&#123;buildroot&#125;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-NetconfStartup&#x2F;module_feature_configs&#x2F;</span><br></pre></td></tr></table></figure>\n\n\n<p>In <a href=\"http://makefile.am/\">Makefile.am</a>, to specify the destination directory create variable ending with “dir” (for ex: yanginstalldir)<br>To copy existing script to the destination path, use “dist_<dir-variable-name><em>SCRIPTS (for ex: dist_yanginstall_SCRIPTS)<br>To copy existing data/configuration file to the destination path, use “dist</em><dir-variable-name>_SCRIPTS (for ex: dist_yanginit_DATA)<br>Similarly, if files are not available but are crated as part of ‘make’ from any input files (for ex “.in” files), then use “nodist” instead of “dist” (these are useful when doing “make dist”)</p>\n<p>These steps will make sure that the destination directory is created in build environment, and files are copied with correct permissions (based on SCRIPTS/DATA etc).<br>Then these paths has to be just specified in %files section to make them part of rpm.</p>\n<p><strong>Do this in Makefile.am</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yanginstalldir&#x3D;$(NETCONF_MODULE_CONFIG_DIR)</span><br><span class=\"line\">dist_yanginstall_SCRIPTS&#x3D;$(top_srcdir)&#x2F;scripts&#x2F;install_default_user.py \\</span><br><span class=\"line\">                         $(top_srcdir)&#x2F;scripts&#x2F;host_key.py</span><br><span class=\"line\"> </span><br><span class=\"line\">preconfigdir&#x3D;$(NETCONF_PRE_CONFIG_DIR)</span><br><span class=\"line\">dist_preconfig_SCRIPTS&#x3D;$(top_srcdir)&#x2F;scripts&#x2F;01_copy_usermgmt_persist_wrapper.py</span><br><span class=\"line\"> </span><br><span class=\"line\">usermgmtdir&#x3D;&#x2F;opt&#x2F;nokia&#x2F;RUOAM-UserManagement&#x2F;</span><br><span class=\"line\">dist_usermgmt_SCRIPTS&#x3D;$(top_srcdir)&#x2F;scripts&#x2F;usermgmt_persist_files.py</span><br><span class=\"line\"> </span><br><span class=\"line\">yanginitdir&#x3D;$(NETCONF_YANG_DIR)</span><br><span class=\"line\">dist_yanginit_DATA&#x3D;$(top_srcdir)&#x2F;yang&#x2F;o-ran-usermgmt.yang</span><br></pre></td></tr></table></figure>\n<h2 id=\"files-section\"><a href=\"#files-section\" class=\"headerlink\" title=\"%files section\"></a>%files section</h2><p>Files and directories included recursively.<br>Directories and files must not be listed multiple times in %files section. Having a directory in %files section automatically includes all files and directories recursively in that directory.</p>\n<p>Never add test files in the main package. Create separate package for devel/test and install only when required.</p>\n<h2 id=\"File-attributes\"><a href=\"#File-attributes\" class=\"headerlink\" title=\"File attributes\"></a>File attributes</h2><p>In cases where the package builder cannot create the files to be packaged with the proper ownership and permissions, the %attr macro can be used to make things right.<br>File attributes should be set in %files section instead of %post section.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">%attr(-, root, root) &#x2F;var&#x2F;%&#123;name&#125;&#x2F;</span><br><span class=\"line\">%config(noreplace) %attr(0660, 1000, 1000) &#x2F;var&#x2F;%&#123;name&#125;&#x2F;data</span><br></pre></td></tr></table></figure>\n<p>See, <a href=\"http://ftp.rpm.org/max-rpm/s1-rpm-anywhere-specifying-file-attributes.html\">http://ftp.rpm.org/max-rpm/s1-rpm-anywhere-specifying-file-attributes.html</a></p>\n<h2 id=\"Directory-ownership\"><a href=\"#Directory-ownership\" class=\"headerlink\" title=\"Directory ownership\"></a>Directory ownership</h2><p>Each file should be owned by just a single RPM. One must not list directories owned by other packages in their file section. However, one must make sure to take ownership of those file that do belong to them.</p>\n<h2 id=\"Adding-Container-only-components\"><a href=\"#Adding-Container-only-components\" class=\"headerlink\" title=\"Adding Container only components\"></a>Adding Container only components</h2><p>When adding container only components, never forget to specify <em>include_in_build</em> to <em>no</em> is rpm.spec file.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">AutoReqProv:    no</span><br><span class=\"line\"> </span><br><span class=\"line\">%define include_in_build no</span><br><span class=\"line\"> </span><br><span class=\"line\">%description</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<h2 id=\"rpm-macro-check\"><a href=\"#rpm-macro-check\" class=\"headerlink\" title=\"rpm macro check\"></a>rpm macro check</h2><p>With command ‘rpm –showrc’ , you can get list all available macros. For example , if you need to find what macro is pointing to /etc directory , you can run</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># rpm --showrc | grep &#39;\\&#x2F;etc&#39;</span><br><span class=\"line\">-13: _sysconfdir %&#123;_prefix&#125;&#x2F;etc</span><br><span class=\"line\"> </span><br><span class=\"line\"># Or opposite query</span><br><span class=\"line\"> </span><br><span class=\"line\"># rpm --eval %&#123;_sysconfdir&#125;</span><br><span class=\"line\">&#x2F;usr&#x2F;etc</span><br></pre></td></tr></table></figure>\n<h2 id=\"Additional-useful-tools\"><a href=\"#Additional-useful-tools\" class=\"headerlink\" title=\"Additional useful tools\"></a>Additional useful tools</h2><h3 id=\"rpmspec\"><a href=\"#rpmspec\" class=\"headerlink\" title=\"rpmspec\"></a><em>rpmspec</em></h3><p>rpmspec is useful for getting info from spec file, it parses the spec file and provides various data such as what RPMs will spec build etc. For example:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ rpmspec -q fhgw&#x2F;rpm.spec</span><br><span class=\"line\">warning: line 2: Possible unexpanded macro in: Version: %&#123;_version&#125;</span><br><span class=\"line\">warning: line 3: Possible unexpanded macro in: Release: %&#123;_release&#125;</span><br><span class=\"line\">warning: line 20: Possible unexpanded macro in: Requires: RUOAM-CommonLibrary-libs(x86-64) &#x3D; %&#123;_version&#125;-%&#123;_release&#125;</span><br><span class=\"line\">RUOAM-CommonLibrary-%&#123;_version&#125;-%&#123;_release&#125;.x86_64</span><br><span class=\"line\">RUOAM-CommonLibrary-devel-%&#123;_version&#125;-%&#123;_release&#125;.x86_64</span><br><span class=\"line\">RUOAM-CommonLibrary-libs-%&#123;_version&#125;-%&#123;_release&#125;.x86_64</span><br></pre></td></tr></table></figure>\n<p>For more information see rpmspec man page with man rpmspec.</p>\n"},{"title":"configure.ac介绍","date":"2020-12-31T15:59:00.000Z","abbrlink":13008,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"**configure.ac介绍**\n\nhttps://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html\n\nautoconfig:\n\n[Autoconf (gnu.org)](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Introduction)\n\nautomake:\n\n[Top (automake) (gnu.org)](https://www.gnu.org/software/automake/manual/html_node/index.html)\n\n## 常用预定义宏：\n\n### 基础设置\n\nAC_INIT(PACKAGE, VERSION, BUG_REPORT_EMAIL)\n\nAC_PREREQ(VERSION) # 最小支持的autoconf版本号\n\nAC_CONFIG_SRCDIR(FILE) # safe check 确保configure的确是在正确的目录中被执行的\n\nAC_CONFIG_AUX_DIR(DIR) # 辅助目录地址，存放install-sh和depcomp等辅助工具文件，若不指定会在当前目录直接创建辅助工具文件\n\n### Automake设置\n\nAM_INIT_AUTOMAKE([OPTIONS...]) # 检查由Automake生成的Makefile所需的工具，此时可以指定的常用选项有：\n\n- -Wall 启用所有warning警告\n- -Werror 将warning视作error\n- foreign 表示项目不是完全遵循GNU标准的，放宽某些GNU标准检查\n- 1.11.1 生命支持的最小的Automake版本\n\nAC_PROG_RANLIB：如果需要生成静态库，则需要加入这一句\n\nAC_PROG_LIBTOOL：如果需要生成动态库，则加入这一句，表示用libtool自动生成动态库\n\n### 寻找所需程序\n\nAC_PROC_CC # 检查c编译器cc存在\n\nAC_PROC_CXX\n\nAC_PROC_SED/AC_PROC_YACC/AC_PROC_LEX # 查找合适的实现，并将$SED, $YACC等变量设置为找到的实现\n\nAC_CHECK_PROGS(VAR, PROGS, [VAL-IF-NOT-FOUND]) # 依次测试空格分隔的PROGS是否存在，将VAR设置为第一个找到的PROG，若所有PROGS都不存在，将VAR设置为VAL-IF-NOT-FOUND\n\n### 错误提示及退出\n\nAC_MSG_ERROR(ERROR-DESC, [EXIT-STATUS]) # 打印错误信息并退出\n\nAC_MSG_WARN(ERROR-DESC) # 打印错误信息，但不退出\n\n### 为config.h及Makefile定义变量\n\nAC_DEFINE(VAR, VALUE, DESC) # 定义一个在config.h中出现的宏\n\nAC_SUBST(VAR, [VALUE]) # 定义一个Makefile中的变量，若不指定VALUE，会以configure.ac被处理完毕时的VAR变量的值为准进行定义\n\n### 库文件检查\n\nAC_CHECK_LIB(LIBRARY, FUNC, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND]) # 检查LIB是否存在，若LIB存在，是否包含FUNC，若检查结果是都存在，执行ACT-IF-FOUND，否则执行ACT-IF-NOT-FOUND。如果只有LIB存在，而FUNC不存在，该宏会将LIBS变量定义为 $LIBS = \"-lLIBRARY, $LIBS\"并在config.h中定义#define HAVE_LIBLIBRARY，注意标红的LIBRARY，都是AC_CHECK_LIB宏中传入的第一个参数。\n\nAC_CHECK_HEADERS(HEADERS, ...) # 检查每个HEADERS是否存在，若存在就在config.h中定义#define HAVE_HEADER_H，若HEADER包含目录分隔符/，则会被替换为下划线\n\nAC_CHECK_HEADER(HEADER, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND])\n\n### 输出指令\n\nAC_CONFIG_HEADERS(HEADERS...) # 为每个HEADER.in创建HEADER，一般来说只要使用AC_CONFIC_HEADERS([config.h])即可，因为autoheader只会根据configure.ac中的宏创建HEADERS中出现的第一个HEADER对应的HEADER.in，一般来说就是config.h.in\n\nAC_CONFIG_FILES(FILES...) # 为每个FILE.in创建FILE，一般来说只要使用这个宏来根据Makefile.in创建Makefile，Automake会为每一个FILE.am创建一个FILE.in，从而允许该宏从Makefile.in创建Makefile\n\n## 常用宏组合：\n\n### 检查是否存在程序，如果不存在就打印错误信息并退出\n\nAC_CHECK_PROGS([TAR], [tar gtar], [:])\n\nif test \"$TAR\" = :; then\n\n AC_MSG_ERROR([This package needs tar.])\n\nfi\n\n### 检查是否存在库及函数，并定义Makefile变量：\n\nAC_CHECK_LIB([efence], [malloc], [EFENCELIB=-lefence])\n\nAC_SUBST([EFENCELIB])\n\n## .in文件模版\n\n.in文件是模版文件，以一个简单的script.in文件为例：\n\n```makefile\n#!/bin/sh\nSED=’@SED@’\nTAR=’@TAR@’\nd=$1; shift; mkdir \"$d\"\nfor f; do\n \"$SED\" ’s/#.*//’ \"$f\" \\\n   >\"$d/$f\"\ndone\n\"$TAR\" cf \"$d.tar\" \"$d\"\n```\n\n以上，@XXX@是占位符，会在被处理时替换成由AC_SUBST定义的值；\n\nMakefile.in就是这样一个模版文件，不过由于configure.ac在处理Makefile.in时，对每个AC_SUBST定义的变量都又进行了XXX=@XXX@这样的变量定义，因此在Makefile.in中既可以使用@XXX@又可以使用$XXX来引用变量值。","source":"_posts/linux_md/Makefile/configure.ac介绍.md","raw":"---\ntitle: configure.ac介绍\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 个人项目\nabbrlink: 13008\ncover: \n---\n**configure.ac介绍**\n\nhttps://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html\n\nautoconfig:\n\n[Autoconf (gnu.org)](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Introduction)\n\nautomake:\n\n[Top (automake) (gnu.org)](https://www.gnu.org/software/automake/manual/html_node/index.html)\n\n## 常用预定义宏：\n\n### 基础设置\n\nAC_INIT(PACKAGE, VERSION, BUG_REPORT_EMAIL)\n\nAC_PREREQ(VERSION) # 最小支持的autoconf版本号\n\nAC_CONFIG_SRCDIR(FILE) # safe check 确保configure的确是在正确的目录中被执行的\n\nAC_CONFIG_AUX_DIR(DIR) # 辅助目录地址，存放install-sh和depcomp等辅助工具文件，若不指定会在当前目录直接创建辅助工具文件\n\n### Automake设置\n\nAM_INIT_AUTOMAKE([OPTIONS...]) # 检查由Automake生成的Makefile所需的工具，此时可以指定的常用选项有：\n\n- -Wall 启用所有warning警告\n- -Werror 将warning视作error\n- foreign 表示项目不是完全遵循GNU标准的，放宽某些GNU标准检查\n- 1.11.1 生命支持的最小的Automake版本\n\nAC_PROG_RANLIB：如果需要生成静态库，则需要加入这一句\n\nAC_PROG_LIBTOOL：如果需要生成动态库，则加入这一句，表示用libtool自动生成动态库\n\n### 寻找所需程序\n\nAC_PROC_CC # 检查c编译器cc存在\n\nAC_PROC_CXX\n\nAC_PROC_SED/AC_PROC_YACC/AC_PROC_LEX # 查找合适的实现，并将$SED, $YACC等变量设置为找到的实现\n\nAC_CHECK_PROGS(VAR, PROGS, [VAL-IF-NOT-FOUND]) # 依次测试空格分隔的PROGS是否存在，将VAR设置为第一个找到的PROG，若所有PROGS都不存在，将VAR设置为VAL-IF-NOT-FOUND\n\n### 错误提示及退出\n\nAC_MSG_ERROR(ERROR-DESC, [EXIT-STATUS]) # 打印错误信息并退出\n\nAC_MSG_WARN(ERROR-DESC) # 打印错误信息，但不退出\n\n### 为config.h及Makefile定义变量\n\nAC_DEFINE(VAR, VALUE, DESC) # 定义一个在config.h中出现的宏\n\nAC_SUBST(VAR, [VALUE]) # 定义一个Makefile中的变量，若不指定VALUE，会以configure.ac被处理完毕时的VAR变量的值为准进行定义\n\n### 库文件检查\n\nAC_CHECK_LIB(LIBRARY, FUNC, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND]) # 检查LIB是否存在，若LIB存在，是否包含FUNC，若检查结果是都存在，执行ACT-IF-FOUND，否则执行ACT-IF-NOT-FOUND。如果只有LIB存在，而FUNC不存在，该宏会将LIBS变量定义为 $LIBS = \"-lLIBRARY, $LIBS\"并在config.h中定义#define HAVE_LIBLIBRARY，注意标红的LIBRARY，都是AC_CHECK_LIB宏中传入的第一个参数。\n\nAC_CHECK_HEADERS(HEADERS, ...) # 检查每个HEADERS是否存在，若存在就在config.h中定义#define HAVE_HEADER_H，若HEADER包含目录分隔符/，则会被替换为下划线\n\nAC_CHECK_HEADER(HEADER, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND])\n\n### 输出指令\n\nAC_CONFIG_HEADERS(HEADERS...) # 为每个HEADER.in创建HEADER，一般来说只要使用AC_CONFIC_HEADERS([config.h])即可，因为autoheader只会根据configure.ac中的宏创建HEADERS中出现的第一个HEADER对应的HEADER.in，一般来说就是config.h.in\n\nAC_CONFIG_FILES(FILES...) # 为每个FILE.in创建FILE，一般来说只要使用这个宏来根据Makefile.in创建Makefile，Automake会为每一个FILE.am创建一个FILE.in，从而允许该宏从Makefile.in创建Makefile\n\n## 常用宏组合：\n\n### 检查是否存在程序，如果不存在就打印错误信息并退出\n\nAC_CHECK_PROGS([TAR], [tar gtar], [:])\n\nif test \"$TAR\" = :; then\n\n AC_MSG_ERROR([This package needs tar.])\n\nfi\n\n### 检查是否存在库及函数，并定义Makefile变量：\n\nAC_CHECK_LIB([efence], [malloc], [EFENCELIB=-lefence])\n\nAC_SUBST([EFENCELIB])\n\n## .in文件模版\n\n.in文件是模版文件，以一个简单的script.in文件为例：\n\n```makefile\n#!/bin/sh\nSED=’@SED@’\nTAR=’@TAR@’\nd=$1; shift; mkdir \"$d\"\nfor f; do\n \"$SED\" ’s/#.*//’ \"$f\" \\\n   >\"$d/$f\"\ndone\n\"$TAR\" cf \"$d.tar\" \"$d\"\n```\n\n以上，@XXX@是占位符，会在被处理时替换成由AC_SUBST定义的值；\n\nMakefile.in就是这样一个模版文件，不过由于configure.ac在处理Makefile.in时，对每个AC_SUBST定义的变量都又进行了XXX=@XXX@这样的变量定义，因此在Makefile.in中既可以使用@XXX@又可以使用$XXX来引用变量值。","slug":"linux_md/Makefile/configure.ac介绍","published":1,"updated":"2021-04-13T09:21:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr630027w9q9huejft8u","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><p><strong>configure.ac介绍</strong></p>\n<p><a href=\"https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html\">https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html</a></p>\n<p>autoconfig:</p>\n<p><a href=\"https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Introduction\">Autoconf (gnu.org)</a></p>\n<p>automake:</p>\n<p><a href=\"https://www.gnu.org/software/automake/manual/html_node/index.html\">Top (automake) (gnu.org)</a></p>\n<h2 id=\"常用预定义宏：\"><a href=\"#常用预定义宏：\" class=\"headerlink\" title=\"常用预定义宏：\"></a>常用预定义宏：</h2><h3 id=\"基础设置\"><a href=\"#基础设置\" class=\"headerlink\" title=\"基础设置\"></a>基础设置</h3><p>AC_INIT(PACKAGE, VERSION, BUG_REPORT_EMAIL)</p>\n<p>AC_PREREQ(VERSION) # 最小支持的autoconf版本号</p>\n<p>AC_CONFIG_SRCDIR(FILE) # safe check 确保configure的确是在正确的目录中被执行的</p>\n<p>AC_CONFIG_AUX_DIR(DIR) # 辅助目录地址，存放install-sh和depcomp等辅助工具文件，若不指定会在当前目录直接创建辅助工具文件</p>\n<h3 id=\"Automake设置\"><a href=\"#Automake设置\" class=\"headerlink\" title=\"Automake设置\"></a>Automake设置</h3><p>AM_INIT_AUTOMAKE([OPTIONS…]) # 检查由Automake生成的Makefile所需的工具，此时可以指定的常用选项有：</p>\n<ul>\n<li>-Wall 启用所有warning警告</li>\n<li>-Werror 将warning视作error</li>\n<li>foreign 表示项目不是完全遵循GNU标准的，放宽某些GNU标准检查</li>\n<li>1.11.1 生命支持的最小的Automake版本</li>\n</ul>\n<p>AC_PROG_RANLIB：如果需要生成静态库，则需要加入这一句</p>\n<p>AC_PROG_LIBTOOL：如果需要生成动态库，则加入这一句，表示用libtool自动生成动态库</p>\n<h3 id=\"寻找所需程序\"><a href=\"#寻找所需程序\" class=\"headerlink\" title=\"寻找所需程序\"></a>寻找所需程序</h3><p>AC_PROC_CC # 检查c编译器cc存在</p>\n<p>AC_PROC_CXX</p>\n<p>AC_PROC_SED/AC_PROC_YACC/AC_PROC_LEX # 查找合适的实现，并将$SED, $YACC等变量设置为找到的实现</p>\n<p>AC_CHECK_PROGS(VAR, PROGS, [VAL-IF-NOT-FOUND]) # 依次测试空格分隔的PROGS是否存在，将VAR设置为第一个找到的PROG，若所有PROGS都不存在，将VAR设置为VAL-IF-NOT-FOUND</p>\n<h3 id=\"错误提示及退出\"><a href=\"#错误提示及退出\" class=\"headerlink\" title=\"错误提示及退出\"></a>错误提示及退出</h3><p>AC_MSG_ERROR(ERROR-DESC, [EXIT-STATUS]) # 打印错误信息并退出</p>\n<p>AC_MSG_WARN(ERROR-DESC) # 打印错误信息，但不退出</p>\n<h3 id=\"为config-h及Makefile定义变量\"><a href=\"#为config-h及Makefile定义变量\" class=\"headerlink\" title=\"为config.h及Makefile定义变量\"></a>为config.h及Makefile定义变量</h3><p>AC_DEFINE(VAR, VALUE, DESC) # 定义一个在config.h中出现的宏</p>\n<p>AC_SUBST(VAR, [VALUE]) # 定义一个Makefile中的变量，若不指定VALUE，会以configure.ac被处理完毕时的VAR变量的值为准进行定义</p>\n<h3 id=\"库文件检查\"><a href=\"#库文件检查\" class=\"headerlink\" title=\"库文件检查\"></a>库文件检查</h3><p>AC_CHECK_LIB(LIBRARY, FUNC, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND]) # 检查LIB是否存在，若LIB存在，是否包含FUNC，若检查结果是都存在，执行ACT-IF-FOUND，否则执行ACT-IF-NOT-FOUND。如果只有LIB存在，而FUNC不存在，该宏会将LIBS变量定义为 $LIBS = “-lLIBRARY, $LIBS”并在config.h中定义#define HAVE_LIBLIBRARY，注意标红的LIBRARY，都是AC_CHECK_LIB宏中传入的第一个参数。</p>\n<p>AC_CHECK_HEADERS(HEADERS, …) # 检查每个HEADERS是否存在，若存在就在config.h中定义#define HAVE_HEADER_H，若HEADER包含目录分隔符/，则会被替换为下划线</p>\n<p>AC_CHECK_HEADER(HEADER, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND])</p>\n<h3 id=\"输出指令\"><a href=\"#输出指令\" class=\"headerlink\" title=\"输出指令\"></a>输出指令</h3><p>AC_CONFIG_HEADERS(HEADERS…) # 为每个HEADER.in创建HEADER，一般来说只要使用AC_CONFIC_HEADERS([config.h])即可，因为autoheader只会根据configure.ac中的宏创建HEADERS中出现的第一个HEADER对应的HEADER.in，一般来说就是config.h.in</p>\n<p>AC_CONFIG_FILES(FILES…) # 为每个FILE.in创建FILE，一般来说只要使用这个宏来根据Makefile.in创建Makefile，Automake会为每一个FILE.am创建一个FILE.in，从而允许该宏从Makefile.in创建Makefile</p>\n<h2 id=\"常用宏组合：\"><a href=\"#常用宏组合：\" class=\"headerlink\" title=\"常用宏组合：\"></a>常用宏组合：</h2><h3 id=\"检查是否存在程序，如果不存在就打印错误信息并退出\"><a href=\"#检查是否存在程序，如果不存在就打印错误信息并退出\" class=\"headerlink\" title=\"检查是否存在程序，如果不存在就打印错误信息并退出\"></a>检查是否存在程序，如果不存在就打印错误信息并退出</h3><p>AC_CHECK_PROGS([TAR], [tar gtar], [:])</p>\n<p>if test “$TAR” = :; then</p>\n<p> AC_MSG_ERROR([This package needs tar.])</p>\n<p>fi</p>\n<h3 id=\"检查是否存在库及函数，并定义Makefile变量：\"><a href=\"#检查是否存在库及函数，并定义Makefile变量：\" class=\"headerlink\" title=\"检查是否存在库及函数，并定义Makefile变量：\"></a>检查是否存在库及函数，并定义Makefile变量：</h3><p>AC_CHECK_LIB([efence], [malloc], [EFENCELIB=-lefence])</p>\n<p>AC_SUBST([EFENCELIB])</p>\n<h2 id=\"in文件模版\"><a href=\"#in文件模版\" class=\"headerlink\" title=\".in文件模版\"></a>.in文件模版</h2><p>.in文件是模版文件，以一个简单的script.in文件为例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/bin/sh</span></span><br><span class=\"line\">SED=’@SED@’</span><br><span class=\"line\">TAR=’@TAR@’</span><br><span class=\"line\">d=$1; shift; mkdir <span class=\"string\">&quot;$d&quot;</span></span><br><span class=\"line\">for f; do</span><br><span class=\"line\"> <span class=\"string\">&quot;$SED&quot;</span> ’s/<span class=\"comment\">#.*//’ &quot;$f&quot; \\</span></span><br><span class=\"line\">   &gt;<span class=\"string\">&quot;$d/$f&quot;</span></span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"string\">&quot;$TAR&quot;</span> cf <span class=\"string\">&quot;$d.tar&quot;</span> <span class=\"string\">&quot;$d&quot;</span></span><br></pre></td></tr></table></figure>\n<p>以上，@XXX@是占位符，会在被处理时替换成由AC_SUBST定义的值；</p>\n<p>Makefile.in就是这样一个模版文件，不过由于configure.ac在处理Makefile.in时，对每个AC_SUBST定义的变量都又进行了XXX=@XXX@这样的变量定义，因此在Makefile.in中既可以使用@XXX@又可以使用$XXX来引用变量值。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p><strong>configure.ac介绍</strong></p>\n<p><a href=\"https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html\">https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html</a></p>\n<p>autoconfig:</p>\n<p><a href=\"https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.70/autoconf.html#Introduction\">Autoconf (gnu.org)</a></p>\n<p>automake:</p>\n<p><a href=\"https://www.gnu.org/software/automake/manual/html_node/index.html\">Top (automake) (gnu.org)</a></p>\n<h2 id=\"常用预定义宏：\"><a href=\"#常用预定义宏：\" class=\"headerlink\" title=\"常用预定义宏：\"></a>常用预定义宏：</h2><h3 id=\"基础设置\"><a href=\"#基础设置\" class=\"headerlink\" title=\"基础设置\"></a>基础设置</h3><p>AC_INIT(PACKAGE, VERSION, BUG_REPORT_EMAIL)</p>\n<p>AC_PREREQ(VERSION) # 最小支持的autoconf版本号</p>\n<p>AC_CONFIG_SRCDIR(FILE) # safe check 确保configure的确是在正确的目录中被执行的</p>\n<p>AC_CONFIG_AUX_DIR(DIR) # 辅助目录地址，存放install-sh和depcomp等辅助工具文件，若不指定会在当前目录直接创建辅助工具文件</p>\n<h3 id=\"Automake设置\"><a href=\"#Automake设置\" class=\"headerlink\" title=\"Automake设置\"></a>Automake设置</h3><p>AM_INIT_AUTOMAKE([OPTIONS…]) # 检查由Automake生成的Makefile所需的工具，此时可以指定的常用选项有：</p>\n<ul>\n<li>-Wall 启用所有warning警告</li>\n<li>-Werror 将warning视作error</li>\n<li>foreign 表示项目不是完全遵循GNU标准的，放宽某些GNU标准检查</li>\n<li>1.11.1 生命支持的最小的Automake版本</li>\n</ul>\n<p>AC_PROG_RANLIB：如果需要生成静态库，则需要加入这一句</p>\n<p>AC_PROG_LIBTOOL：如果需要生成动态库，则加入这一句，表示用libtool自动生成动态库</p>\n<h3 id=\"寻找所需程序\"><a href=\"#寻找所需程序\" class=\"headerlink\" title=\"寻找所需程序\"></a>寻找所需程序</h3><p>AC_PROC_CC # 检查c编译器cc存在</p>\n<p>AC_PROC_CXX</p>\n<p>AC_PROC_SED/AC_PROC_YACC/AC_PROC_LEX # 查找合适的实现，并将$SED, $YACC等变量设置为找到的实现</p>\n<p>AC_CHECK_PROGS(VAR, PROGS, [VAL-IF-NOT-FOUND]) # 依次测试空格分隔的PROGS是否存在，将VAR设置为第一个找到的PROG，若所有PROGS都不存在，将VAR设置为VAL-IF-NOT-FOUND</p>\n<h3 id=\"错误提示及退出\"><a href=\"#错误提示及退出\" class=\"headerlink\" title=\"错误提示及退出\"></a>错误提示及退出</h3><p>AC_MSG_ERROR(ERROR-DESC, [EXIT-STATUS]) # 打印错误信息并退出</p>\n<p>AC_MSG_WARN(ERROR-DESC) # 打印错误信息，但不退出</p>\n<h3 id=\"为config-h及Makefile定义变量\"><a href=\"#为config-h及Makefile定义变量\" class=\"headerlink\" title=\"为config.h及Makefile定义变量\"></a>为config.h及Makefile定义变量</h3><p>AC_DEFINE(VAR, VALUE, DESC) # 定义一个在config.h中出现的宏</p>\n<p>AC_SUBST(VAR, [VALUE]) # 定义一个Makefile中的变量，若不指定VALUE，会以configure.ac被处理完毕时的VAR变量的值为准进行定义</p>\n<h3 id=\"库文件检查\"><a href=\"#库文件检查\" class=\"headerlink\" title=\"库文件检查\"></a>库文件检查</h3><p>AC_CHECK_LIB(LIBRARY, FUNC, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND]) # 检查LIB是否存在，若LIB存在，是否包含FUNC，若检查结果是都存在，执行ACT-IF-FOUND，否则执行ACT-IF-NOT-FOUND。如果只有LIB存在，而FUNC不存在，该宏会将LIBS变量定义为 $LIBS = “-lLIBRARY, $LIBS”并在config.h中定义#define HAVE_LIBLIBRARY，注意标红的LIBRARY，都是AC_CHECK_LIB宏中传入的第一个参数。</p>\n<p>AC_CHECK_HEADERS(HEADERS, …) # 检查每个HEADERS是否存在，若存在就在config.h中定义#define HAVE_HEADER_H，若HEADER包含目录分隔符/，则会被替换为下划线</p>\n<p>AC_CHECK_HEADER(HEADER, [ACT-IF-FOUND], [ACT-IF-NOT-FOUND])</p>\n<h3 id=\"输出指令\"><a href=\"#输出指令\" class=\"headerlink\" title=\"输出指令\"></a>输出指令</h3><p>AC_CONFIG_HEADERS(HEADERS…) # 为每个HEADER.in创建HEADER，一般来说只要使用AC_CONFIC_HEADERS([config.h])即可，因为autoheader只会根据configure.ac中的宏创建HEADERS中出现的第一个HEADER对应的HEADER.in，一般来说就是config.h.in</p>\n<p>AC_CONFIG_FILES(FILES…) # 为每个FILE.in创建FILE，一般来说只要使用这个宏来根据Makefile.in创建Makefile，Automake会为每一个FILE.am创建一个FILE.in，从而允许该宏从Makefile.in创建Makefile</p>\n<h2 id=\"常用宏组合：\"><a href=\"#常用宏组合：\" class=\"headerlink\" title=\"常用宏组合：\"></a>常用宏组合：</h2><h3 id=\"检查是否存在程序，如果不存在就打印错误信息并退出\"><a href=\"#检查是否存在程序，如果不存在就打印错误信息并退出\" class=\"headerlink\" title=\"检查是否存在程序，如果不存在就打印错误信息并退出\"></a>检查是否存在程序，如果不存在就打印错误信息并退出</h3><p>AC_CHECK_PROGS([TAR], [tar gtar], [:])</p>\n<p>if test “$TAR” = :; then</p>\n<p> AC_MSG_ERROR([This package needs tar.])</p>\n<p>fi</p>\n<h3 id=\"检查是否存在库及函数，并定义Makefile变量：\"><a href=\"#检查是否存在库及函数，并定义Makefile变量：\" class=\"headerlink\" title=\"检查是否存在库及函数，并定义Makefile变量：\"></a>检查是否存在库及函数，并定义Makefile变量：</h3><p>AC_CHECK_LIB([efence], [malloc], [EFENCELIB=-lefence])</p>\n<p>AC_SUBST([EFENCELIB])</p>\n<h2 id=\"in文件模版\"><a href=\"#in文件模版\" class=\"headerlink\" title=\".in文件模版\"></a>.in文件模版</h2><p>.in文件是模版文件，以一个简单的script.in文件为例：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/bin/sh</span></span><br><span class=\"line\">SED=’@SED@’</span><br><span class=\"line\">TAR=’@TAR@’</span><br><span class=\"line\">d=$1; shift; mkdir <span class=\"string\">&quot;$d&quot;</span></span><br><span class=\"line\">for f; do</span><br><span class=\"line\"> <span class=\"string\">&quot;$SED&quot;</span> ’s/<span class=\"comment\">#.*//’ &quot;$f&quot; \\</span></span><br><span class=\"line\">   &gt;<span class=\"string\">&quot;$d/$f&quot;</span></span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"string\">&quot;$TAR&quot;</span> cf <span class=\"string\">&quot;$d.tar&quot;</span> <span class=\"string\">&quot;$d&quot;</span></span><br></pre></td></tr></table></figure>\n<p>以上，@XXX@是占位符，会在被处理时替换成由AC_SUBST定义的值；</p>\n<p>Makefile.in就是这样一个模版文件，不过由于configure.ac在处理Makefile.in时，对每个AC_SUBST定义的变量都又进行了XXX=@XXX@这样的变量定义，因此在Makefile.in中既可以使用@XXX@又可以使用$XXX来引用变量值。</p>\n"},{"title":"automake基础","date":"2021-04-13T08:59:00.000Z","abbrlink":13020,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# automake基础\n\n[转载]: https://www.laruence.com/2009/11/18/1154.html\t\"automake,autoconf使用详解\"\n\n作为Linux下的程序开发人员,大家一定都遇到过Makefile,用make命令来编译自己写的程序确实是很方便.一般情况下,大家都是手工写一个简单Makefile,如果要想写出一个符合自由软件惯例的Makefile就不那么容易了.\n在本文中,将给大家介绍如何使用autoconf和automake两个工具来帮助我们自动地生成符合自由软件惯例的 Makefile,这样就可以象常见的 GNU程序一样,只要使用\"./configure\",\"make\",\"make instal\"就可以把程序安装到Linux系统中去了.\n这将特别适合想做开放源代码软件的程序开发人员,又或如果你只是自己写些小的Toy程序,那么这个文章对你也会有很大的帮助.\n\n## Makefile介绍\n\nMakefile是用于自动编译和链接的 ,一个工程有很多文件组成,每一个文件的改变都会导致工程的重新链接,但是不是 所有的文件都需要重新编译,Makefile中纪录有文件的信息,在 make时会决定在链接的时候需要重新编译哪些文件.　\nMakefile的宗旨就是 ：让编译器知道要编译一个文件需要依赖其他的 哪些文件.当那些依赖文件有了改变,编译器会自动的发现最终的生成文件已经过时,而重新编译相应的 模块.　　\nMakefile的 基本结构不是 很复杂,但当一个程序开发人员开始写Makefile时,经常会怀疑自己写的 是 否符合惯例,而且自己写的 Makefile经常和自己的 开发环境相关联,当系统环境变量或路径发生了变化后,Makefile可能还要跟着修改.这样就造成了手工书写Makefile的 诸多问题,automake恰好能很好地帮助我们解决这些问题.　　\n使用automake,程序开发人员只需要写一些简单的 含有预定义宏的 文件,由autoconf根据一个宏文件生成configure,由automake根据另一个宏文件生成Makefile.in,再使用configure依据Makefile.in来生成一个符合惯例的 Makefile.下面我们将详细介绍Makefile的 automake生成方法.\n\n## 使用的环境\n\n本文所提到的 程序是 基于Linux发行版本：Fedora Core release 1,它包含了我们要用到的 autoconf,automake.\n\n## 从helloworld入手\n\n我们从大家最常使用的 例子程序helloworld开始.\n下面的 过程如果简单地说来就是 ：\n新建三个文件：\n\n```makefile\n　　　helloworld.c　　　\n　　　configure.in　　　\n　　　Makefile.am\n```\n\n然后执行：\n\n```makefile\naclocal; autoconf; automake --add-missing; ./configure; make; ./helloworld\n```\n\n就可以看到Makefile被产生出来,而且可以将helloworld.c编译通过.\n很简单吧,几条命令就可以做出一个符合惯例的 Makefile,感觉如何呀.\n**现在 开始介绍详细的 过程：**\n\n1. 建目录\n    在 你的工作目录下建一个helloworld目录,我们用它来存放helloworld程序及相关文件,如在 /home/my/build下：\n\n```makefile\n$ mkdir helloword\n$ cd helloworld\n```\n\n2. helloworld.c\n    然后用你自己最喜欢的 编辑器写一个hellowrold.c文件,如命令：vi helloworld.c.使用下面的 代码作为helloworld.c的 内容.\n\n```c\n#include <stdio.h>\n\nint main(int argc, char** argv)\n{\n    printf(\"%s\", 'Hello, Linux World!\\n\");     \n    return 0;\n}\n```\n\n完成后保存退出.\n现在 在 helloworld目录下就应该有一个你自己写的 helloworld.c了.\n\n3. 生成configure\n\n    我们使用autoscan命令来帮助我们根据目录下的 源代码生成一个configure.in的 模板文件. 命令：\n\n```makefile\n$ autoscan\n$ ls\nconfigure.scan helloworld.c\n```\n\n执行后在 hellowrold目录下会生成一个文件：configure.scan,我们可以拿它作为configure.in的 蓝本.\n现在 将configure.scan改名为configure.in,并且编辑它,按下面的 内容修改,去掉无关的 语句：\n\n```makefile\n==========================configure.in内容开始=========================================\n# -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\nAC_INIT(helloworld.c)\nAM_INIT_AUTOMAKE(helloworld, 1.0)\n# Checks for programs.\nAC_PROG_CC\n# Checks for libraries.\n# Checks for header files.\n# Checks for typedefs, structures, and compiler characteristics.\n# Checks for library functions.\nAC_OUTPUT(Makefile)\n==========================configure.in内容结束=========================================\n```\n\n然后执行命令aclocal和autoconf,分别会产生aclocal.m4及configure两个文件：\n\n```makefile\n$ aclocal\n$ls\naclocal.m4 configure.in helloworld.c\n$ autoconf\n$ ls\naclocal.m4 autom4te.cache configure configure.in helloworld.c\n```\n\n大家可以看到configure.in内容是 一些宏定义,这些宏经autoconf处理后会变成检查系统特性.环境变量.软件必须的 参数的 shell脚本.\nautoconf 是 用来生成自动配置软件源代码脚本（configure）的 工具.configure脚本能独立于autoconf运行,且在 运行的 过程中,不需要用户的 干预.\n要生成configure文件,你必须告诉autoconf如何找到你所用的 宏.方式是 使用aclocal程序来生成你的 aclocal.m4.\naclocal根据configure.in文件的 内容,自动生成aclocal.m4文件.aclocal是 一个perl 脚本程序,它的 定义是 ：\"aclocal - create aclocal.m4 by scanning configure.ac\".\nautoconf从configure.in这个列举编译软件时所需要各种参数的 模板文件中创建configure.\nautoconf需要GNU m4宏处理器来处理aclocal.m4,生成configure脚本.\nm4是 一个宏处理器.将输入拷贝到输出,同时将宏展开.宏可以是 内嵌的 ,也可以是 用户定义的 .除了可以展开宏,m4还有一些内建的 函数,用来引用文件,执行命令,整数运算,文本操作,循环等.m4既可以作为编译器的 前端,也可以单独作为一个宏处理器.\n\n4. 新建Makefile.am\n    新建Makefile.am文件,命令：\n\n```makefile\n$ vi Makefile.am\n　　内容如下:\nAUTOMAKE_OPTIONS=foreign\nbin_PROGRAMS=helloworld\nhelloworld_SOURCES=helloworld.c\n```\n\nautomake会根据你写的 Makefile.am来自动生成Makefile.in.\nMakefile.am中定义的 宏和目标,会指导automake生成指定的 代码.例如,宏bin_PROGRAMS将导致编译和连接的 目标被生成.\n\n5. 运行automake:\n\n```makefile\n$ automake --add-missing\nconfigure.in: installing `./install-sh'\nconfigure.in: installing `./mkinstalldirs'\nconfigure.in: installing `./missing'\nMakefile.am: installing `./depcomp'\n```\n\nautomake会根据Makefile.am文件产生一些文件,包含最重要的 Makefile.in.\n\n6. 执行configure生成Makefile\n\n```makefile\n$./configure\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking for gcc... gcc\nchecking for C compiler default output... a.out\nchecking whether the C compiler works... yes\nchecking whether we are cross compiling... no\nchecking for suffix of executables...\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to accept ANSI C... none needed\nchecking for style of include used by make... GNU\nchecking dependency style of gcc... gcc3\nconfigure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: executing depfiles commands\n$ ls -l Makefile\n-rw-rw-r-- 1 yutao yutao 15035 Oct 15 10:40 Makefile\n```\n\n你可以看到,此时Makefile已经产生出来了.\n\n7. 使用Makefile编译代码\n\n```makefile\n$make\nif gcc -DPACKAGE_NAME=\\\"FULL-PACKAGE-NAME\\\" -DPACKAGE_TARNAME=\\\"full-package-name\\\" -DPACKAGE_VERSION=\\\"VERSION\\\" -DPACKAGE_STRING=\\\"FULL-PACKAGE-NAME\\ VERSION\\\" -DPACKAGE_BUGREPORT=\\\"BUG-REPORT-ADDRESS\\\" -DPACKAGE=\\\"helloworld\\\" -DVERSION=\\\"1.0\\\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_STDLIB_H=1  -I. -I.     -g -O2 -MT helloworld.o -MD -MP -MF \".deps/helloworld.Tpo\" -c -o helloworld.o helloworld.c; \\\nthen mv -f \".deps/helloworld.Tpo\" \".deps/helloworld.Po\"; else rm -f \".deps/helloworld.Tpo\"; exit 1; fi\ngcc  -g -O2   -o helloworld  helloworld.o\n```\n\n运行helloworld\n\n```makefile\n$ ./helloworld\nHello, Linux World!\n```\n\n这样helloworld就编译出来了,你如果按上面的 步骤来做的 话,应该也会很容易地编译出正确的 helloworld文件.你还可以试着使用一些其他的 make命令,如make clean,make install,make dist,看看它们会给你什么样的 效果.感觉如何？自己也能写出这么专业的 Makefile,老板一定会对你刮目相看.\n\n## 深入浅出\n\n针对上面提到的各个命令,我们再做些详细的介绍.\n\n{%asset_img Makefile基础.png %}\n\n![Makefile基础](.\\automake基础\\Makefile基础.png)","source":"_posts/linux_md/Makefile/automake基础.md","raw":"---\ntitle: automake基础\ndate: '2021/04/13 16:59'\ntags:\n - automake\n - linux\ncategories:\n - 学习笔记\nabbrlink: 13020\ncover: \n---\n\n# automake基础\n\n[转载]: https://www.laruence.com/2009/11/18/1154.html\t\"automake,autoconf使用详解\"\n\n作为Linux下的程序开发人员,大家一定都遇到过Makefile,用make命令来编译自己写的程序确实是很方便.一般情况下,大家都是手工写一个简单Makefile,如果要想写出一个符合自由软件惯例的Makefile就不那么容易了.\n在本文中,将给大家介绍如何使用autoconf和automake两个工具来帮助我们自动地生成符合自由软件惯例的 Makefile,这样就可以象常见的 GNU程序一样,只要使用\"./configure\",\"make\",\"make instal\"就可以把程序安装到Linux系统中去了.\n这将特别适合想做开放源代码软件的程序开发人员,又或如果你只是自己写些小的Toy程序,那么这个文章对你也会有很大的帮助.\n\n## Makefile介绍\n\nMakefile是用于自动编译和链接的 ,一个工程有很多文件组成,每一个文件的改变都会导致工程的重新链接,但是不是 所有的文件都需要重新编译,Makefile中纪录有文件的信息,在 make时会决定在链接的时候需要重新编译哪些文件.　\nMakefile的宗旨就是 ：让编译器知道要编译一个文件需要依赖其他的 哪些文件.当那些依赖文件有了改变,编译器会自动的发现最终的生成文件已经过时,而重新编译相应的 模块.　　\nMakefile的 基本结构不是 很复杂,但当一个程序开发人员开始写Makefile时,经常会怀疑自己写的 是 否符合惯例,而且自己写的 Makefile经常和自己的 开发环境相关联,当系统环境变量或路径发生了变化后,Makefile可能还要跟着修改.这样就造成了手工书写Makefile的 诸多问题,automake恰好能很好地帮助我们解决这些问题.　　\n使用automake,程序开发人员只需要写一些简单的 含有预定义宏的 文件,由autoconf根据一个宏文件生成configure,由automake根据另一个宏文件生成Makefile.in,再使用configure依据Makefile.in来生成一个符合惯例的 Makefile.下面我们将详细介绍Makefile的 automake生成方法.\n\n## 使用的环境\n\n本文所提到的 程序是 基于Linux发行版本：Fedora Core release 1,它包含了我们要用到的 autoconf,automake.\n\n## 从helloworld入手\n\n我们从大家最常使用的 例子程序helloworld开始.\n下面的 过程如果简单地说来就是 ：\n新建三个文件：\n\n```makefile\n　　　helloworld.c　　　\n　　　configure.in　　　\n　　　Makefile.am\n```\n\n然后执行：\n\n```makefile\naclocal; autoconf; automake --add-missing; ./configure; make; ./helloworld\n```\n\n就可以看到Makefile被产生出来,而且可以将helloworld.c编译通过.\n很简单吧,几条命令就可以做出一个符合惯例的 Makefile,感觉如何呀.\n**现在 开始介绍详细的 过程：**\n\n1. 建目录\n    在 你的工作目录下建一个helloworld目录,我们用它来存放helloworld程序及相关文件,如在 /home/my/build下：\n\n```makefile\n$ mkdir helloword\n$ cd helloworld\n```\n\n2. helloworld.c\n    然后用你自己最喜欢的 编辑器写一个hellowrold.c文件,如命令：vi helloworld.c.使用下面的 代码作为helloworld.c的 内容.\n\n```c\n#include <stdio.h>\n\nint main(int argc, char** argv)\n{\n    printf(\"%s\", 'Hello, Linux World!\\n\");     \n    return 0;\n}\n```\n\n完成后保存退出.\n现在 在 helloworld目录下就应该有一个你自己写的 helloworld.c了.\n\n3. 生成configure\n\n    我们使用autoscan命令来帮助我们根据目录下的 源代码生成一个configure.in的 模板文件. 命令：\n\n```makefile\n$ autoscan\n$ ls\nconfigure.scan helloworld.c\n```\n\n执行后在 hellowrold目录下会生成一个文件：configure.scan,我们可以拿它作为configure.in的 蓝本.\n现在 将configure.scan改名为configure.in,并且编辑它,按下面的 内容修改,去掉无关的 语句：\n\n```makefile\n==========================configure.in内容开始=========================================\n# -*- Autoconf -*-\n# Process this file with autoconf to produce a configure script.\nAC_INIT(helloworld.c)\nAM_INIT_AUTOMAKE(helloworld, 1.0)\n# Checks for programs.\nAC_PROG_CC\n# Checks for libraries.\n# Checks for header files.\n# Checks for typedefs, structures, and compiler characteristics.\n# Checks for library functions.\nAC_OUTPUT(Makefile)\n==========================configure.in内容结束=========================================\n```\n\n然后执行命令aclocal和autoconf,分别会产生aclocal.m4及configure两个文件：\n\n```makefile\n$ aclocal\n$ls\naclocal.m4 configure.in helloworld.c\n$ autoconf\n$ ls\naclocal.m4 autom4te.cache configure configure.in helloworld.c\n```\n\n大家可以看到configure.in内容是 一些宏定义,这些宏经autoconf处理后会变成检查系统特性.环境变量.软件必须的 参数的 shell脚本.\nautoconf 是 用来生成自动配置软件源代码脚本（configure）的 工具.configure脚本能独立于autoconf运行,且在 运行的 过程中,不需要用户的 干预.\n要生成configure文件,你必须告诉autoconf如何找到你所用的 宏.方式是 使用aclocal程序来生成你的 aclocal.m4.\naclocal根据configure.in文件的 内容,自动生成aclocal.m4文件.aclocal是 一个perl 脚本程序,它的 定义是 ：\"aclocal - create aclocal.m4 by scanning configure.ac\".\nautoconf从configure.in这个列举编译软件时所需要各种参数的 模板文件中创建configure.\nautoconf需要GNU m4宏处理器来处理aclocal.m4,生成configure脚本.\nm4是 一个宏处理器.将输入拷贝到输出,同时将宏展开.宏可以是 内嵌的 ,也可以是 用户定义的 .除了可以展开宏,m4还有一些内建的 函数,用来引用文件,执行命令,整数运算,文本操作,循环等.m4既可以作为编译器的 前端,也可以单独作为一个宏处理器.\n\n4. 新建Makefile.am\n    新建Makefile.am文件,命令：\n\n```makefile\n$ vi Makefile.am\n　　内容如下:\nAUTOMAKE_OPTIONS=foreign\nbin_PROGRAMS=helloworld\nhelloworld_SOURCES=helloworld.c\n```\n\nautomake会根据你写的 Makefile.am来自动生成Makefile.in.\nMakefile.am中定义的 宏和目标,会指导automake生成指定的 代码.例如,宏bin_PROGRAMS将导致编译和连接的 目标被生成.\n\n5. 运行automake:\n\n```makefile\n$ automake --add-missing\nconfigure.in: installing `./install-sh'\nconfigure.in: installing `./mkinstalldirs'\nconfigure.in: installing `./missing'\nMakefile.am: installing `./depcomp'\n```\n\nautomake会根据Makefile.am文件产生一些文件,包含最重要的 Makefile.in.\n\n6. 执行configure生成Makefile\n\n```makefile\n$./configure\nchecking for a BSD-compatible install... /usr/bin/install -c\nchecking whether build environment is sane... yes\nchecking for gawk... gawk\nchecking whether make sets $(MAKE)... yes\nchecking for gcc... gcc\nchecking for C compiler default output... a.out\nchecking whether the C compiler works... yes\nchecking whether we are cross compiling... no\nchecking for suffix of executables...\nchecking for suffix of object files... o\nchecking whether we are using the GNU C compiler... yes\nchecking whether gcc accepts -g... yes\nchecking for gcc option to accept ANSI C... none needed\nchecking for style of include used by make... GNU\nchecking dependency style of gcc... gcc3\nconfigure: creating ./config.status\nconfig.status: creating Makefile\nconfig.status: executing depfiles commands\n$ ls -l Makefile\n-rw-rw-r-- 1 yutao yutao 15035 Oct 15 10:40 Makefile\n```\n\n你可以看到,此时Makefile已经产生出来了.\n\n7. 使用Makefile编译代码\n\n```makefile\n$make\nif gcc -DPACKAGE_NAME=\\\"FULL-PACKAGE-NAME\\\" -DPACKAGE_TARNAME=\\\"full-package-name\\\" -DPACKAGE_VERSION=\\\"VERSION\\\" -DPACKAGE_STRING=\\\"FULL-PACKAGE-NAME\\ VERSION\\\" -DPACKAGE_BUGREPORT=\\\"BUG-REPORT-ADDRESS\\\" -DPACKAGE=\\\"helloworld\\\" -DVERSION=\\\"1.0\\\" -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_STDLIB_H=1  -I. -I.     -g -O2 -MT helloworld.o -MD -MP -MF \".deps/helloworld.Tpo\" -c -o helloworld.o helloworld.c; \\\nthen mv -f \".deps/helloworld.Tpo\" \".deps/helloworld.Po\"; else rm -f \".deps/helloworld.Tpo\"; exit 1; fi\ngcc  -g -O2   -o helloworld  helloworld.o\n```\n\n运行helloworld\n\n```makefile\n$ ./helloworld\nHello, Linux World!\n```\n\n这样helloworld就编译出来了,你如果按上面的 步骤来做的 话,应该也会很容易地编译出正确的 helloworld文件.你还可以试着使用一些其他的 make命令,如make clean,make install,make dist,看看它们会给你什么样的 效果.感觉如何？自己也能写出这么专业的 Makefile,老板一定会对你刮目相看.\n\n## 深入浅出\n\n针对上面提到的各个命令,我们再做些详细的介绍.\n\n{%asset_img Makefile基础.png %}\n\n![Makefile基础](.\\automake基础\\Makefile基础.png)","slug":"linux_md/Makefile/automake基础","published":1,"updated":"2021-04-13T11:40:02.510Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr64002bw9q93zfr149h","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"automake基础\"><a href=\"#automake基础\" class=\"headerlink\" title=\"automake基础\"></a>automake基础</h1><p>作为Linux下的程序开发人员,大家一定都遇到过Makefile,用make命令来编译自己写的程序确实是很方便.一般情况下,大家都是手工写一个简单Makefile,如果要想写出一个符合自由软件惯例的Makefile就不那么容易了.<br>在本文中,将给大家介绍如何使用autoconf和automake两个工具来帮助我们自动地生成符合自由软件惯例的 Makefile,这样就可以象常见的 GNU程序一样,只要使用”./configure”,”make”,”make instal”就可以把程序安装到Linux系统中去了.<br>这将特别适合想做开放源代码软件的程序开发人员,又或如果你只是自己写些小的Toy程序,那么这个文章对你也会有很大的帮助.</p>\n<h2 id=\"Makefile介绍\"><a href=\"#Makefile介绍\" class=\"headerlink\" title=\"Makefile介绍\"></a>Makefile介绍</h2><p>Makefile是用于自动编译和链接的 ,一个工程有很多文件组成,每一个文件的改变都会导致工程的重新链接,但是不是 所有的文件都需要重新编译,Makefile中纪录有文件的信息,在 make时会决定在链接的时候需要重新编译哪些文件.　<br>Makefile的宗旨就是 ：让编译器知道要编译一个文件需要依赖其他的 哪些文件.当那些依赖文件有了改变,编译器会自动的发现最终的生成文件已经过时,而重新编译相应的 模块.　　<br>Makefile的 基本结构不是 很复杂,但当一个程序开发人员开始写Makefile时,经常会怀疑自己写的 是 否符合惯例,而且自己写的 Makefile经常和自己的 开发环境相关联,当系统环境变量或路径发生了变化后,Makefile可能还要跟着修改.这样就造成了手工书写Makefile的 诸多问题,automake恰好能很好地帮助我们解决这些问题.　　<br>使用automake,程序开发人员只需要写一些简单的 含有预定义宏的 文件,由autoconf根据一个宏文件生成configure,由automake根据另一个宏文件生成Makefile.in,再使用configure依据Makefile.in来生成一个符合惯例的 Makefile.下面我们将详细介绍Makefile的 automake生成方法.</p>\n<h2 id=\"使用的环境\"><a href=\"#使用的环境\" class=\"headerlink\" title=\"使用的环境\"></a>使用的环境</h2><p>本文所提到的 程序是 基于Linux发行版本：Fedora Core release 1,它包含了我们要用到的 autoconf,automake.</p>\n<h2 id=\"从helloworld入手\"><a href=\"#从helloworld入手\" class=\"headerlink\" title=\"从helloworld入手\"></a>从helloworld入手</h2><p>我们从大家最常使用的 例子程序helloworld开始.<br>下面的 过程如果简单地说来就是 ：<br>新建三个文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　helloworld.c　　　</span><br><span class=\"line\">　　　configure.in　　　</span><br><span class=\"line\">　　　Makefile.am</span><br></pre></td></tr></table></figure>\n<p>然后执行：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aclocal; autoconf; automake --add-missing; ./configure; make; ./helloworld</span><br></pre></td></tr></table></figure>\n<p>就可以看到Makefile被产生出来,而且可以将helloworld.c编译通过.<br>很简单吧,几条命令就可以做出一个符合惯例的 Makefile,感觉如何呀.<br><strong>现在 开始介绍详细的 过程：</strong></p>\n<ol>\n<li>建目录<br> 在 你的工作目录下建一个helloworld目录,我们用它来存放helloworld程序及相关文件,如在 /home/my/build下：</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir helloword</span><br><span class=\"line\">$ cd helloworld</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>helloworld.c<br> 然后用你自己最喜欢的 编辑器写一个hellowrold.c文件,如命令：vi helloworld.c.使用下面的 代码作为helloworld.c的 内容.</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printf(&quot;%s&quot;, &#x27;Hello, Linux World!\\n&quot;);     </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成后保存退出.<br>现在 在 helloworld目录下就应该有一个你自己写的 helloworld.c了.</p>\n<ol start=\"3\">\n<li><p>生成configure</p>\n<p> 我们使用autoscan命令来帮助我们根据目录下的 源代码生成一个configure.in的 模板文件. 命令：</p>\n</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ autoscan</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">configure.scan helloworld.c</span><br></pre></td></tr></table></figure>\n<p>执行后在 hellowrold目录下会生成一个文件：configure.scan,我们可以拿它作为configure.in的 蓝本.<br>现在 将configure.scan改名为configure.in,并且编辑它,按下面的 内容修改,去掉无关的 语句：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========================configure.in内容开始=========================================</span><br><span class=\"line\"><span class=\"comment\"># -*- Autoconf -*-</span></span><br><span class=\"line\"><span class=\"comment\"># Process this file with autoconf to produce a configure script.</span></span><br><span class=\"line\">AC_INIT(helloworld.c)</span><br><span class=\"line\">AM_INIT_AUTOMAKE(helloworld, 1.0)</span><br><span class=\"line\"><span class=\"comment\"># Checks for programs.</span></span><br><span class=\"line\">AC_PROG_CC</span><br><span class=\"line\"><span class=\"comment\"># Checks for libraries.</span></span><br><span class=\"line\"><span class=\"comment\"># Checks for header files.</span></span><br><span class=\"line\"><span class=\"comment\"># Checks for typedefs, structures, and compiler characteristics.</span></span><br><span class=\"line\"><span class=\"comment\"># Checks for library functions.</span></span><br><span class=\"line\">AC_OUTPUT(Makefile)</span><br><span class=\"line\">==========================configure.in内容结束=========================================</span><br></pre></td></tr></table></figure>\n<p>然后执行命令aclocal和autoconf,分别会产生aclocal.m4及configure两个文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ aclocal</span><br><span class=\"line\">$ls</span><br><span class=\"line\">aclocal.m4 configure.in helloworld.c</span><br><span class=\"line\">$ autoconf</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">aclocal.m4 autom4te.cache configure configure.in helloworld.c</span><br></pre></td></tr></table></figure>\n<p>大家可以看到configure.in内容是 一些宏定义,这些宏经autoconf处理后会变成检查系统特性.环境变量.软件必须的 参数的 shell脚本.<br>autoconf 是 用来生成自动配置软件源代码脚本（configure）的 工具.configure脚本能独立于autoconf运行,且在 运行的 过程中,不需要用户的 干预.<br>要生成configure文件,你必须告诉autoconf如何找到你所用的 宏.方式是 使用aclocal程序来生成你的 aclocal.m4.<br>aclocal根据configure.in文件的 内容,自动生成aclocal.m4文件.aclocal是 一个perl 脚本程序,它的 定义是 ：”aclocal - create aclocal.m4 by scanning configure.ac”.<br>autoconf从configure.in这个列举编译软件时所需要各种参数的 模板文件中创建configure.<br>autoconf需要GNU m4宏处理器来处理aclocal.m4,生成configure脚本.<br>m4是 一个宏处理器.将输入拷贝到输出,同时将宏展开.宏可以是 内嵌的 ,也可以是 用户定义的 .除了可以展开宏,m4还有一些内建的 函数,用来引用文件,执行命令,整数运算,文本操作,循环等.m4既可以作为编译器的 前端,也可以单独作为一个宏处理器.</p>\n<ol start=\"4\">\n<li>新建Makefile.am<br> 新建Makefile.am文件,命令：</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi Makefile.am</span><br><span class=\"line\">　　内容如下:</span><br><span class=\"line\">AUTOMAKE_OPTIONS=foreign</span><br><span class=\"line\">bin_PROGRAMS=helloworld</span><br><span class=\"line\">helloworld_SOURCES=helloworld.c</span><br></pre></td></tr></table></figure>\n<p>automake会根据你写的 Makefile.am来自动生成Makefile.in.<br>Makefile.am中定义的 宏和目标,会指导automake生成指定的 代码.例如,宏bin_PROGRAMS将导致编译和连接的 目标被生成.</p>\n<ol start=\"5\">\n<li>运行automake:</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ automake --add-missing</span><br><span class=\"line\"><span class=\"section\">configure.in: installing `./install-sh&#x27;</span></span><br><span class=\"line\"><span class=\"section\">configure.in: installing `./mkinstalldirs&#x27;</span></span><br><span class=\"line\"><span class=\"section\">configure.in: installing `./missing&#x27;</span></span><br><span class=\"line\"><span class=\"section\">Makefile.am: installing `./depcomp&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>automake会根据Makefile.am文件产生一些文件,包含最重要的 Makefile.in.</p>\n<ol start=\"6\">\n<li>执行configure生成Makefile</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$./configure</span><br><span class=\"line\">checking for a BSD-compatible install... /usr/bin/install -c</span><br><span class=\"line\">checking whether build environment is sane... yes</span><br><span class=\"line\">checking for gawk... gawk</span><br><span class=\"line\">checking whether make sets <span class=\"variable\">$(MAKE)</span>... yes</span><br><span class=\"line\">checking for gcc... gcc</span><br><span class=\"line\">checking for C compiler default output... a.out</span><br><span class=\"line\">checking whether the C compiler works... yes</span><br><span class=\"line\">checking whether we are cross compiling... no</span><br><span class=\"line\">checking for suffix of executables...</span><br><span class=\"line\">checking for suffix of object files... o</span><br><span class=\"line\">checking whether we are using the GNU C compiler... yes</span><br><span class=\"line\">checking whether gcc accepts -g... yes</span><br><span class=\"line\">checking for gcc option to accept ANSI C... none needed</span><br><span class=\"line\">checking for style of <span class=\"keyword\">include</span> used by make... GNU</span><br><span class=\"line\">checking dependency style of gcc... gcc3</span><br><span class=\"line\"><span class=\"section\">configure: creating ./config.status</span></span><br><span class=\"line\"><span class=\"section\">config.status: creating Makefile</span></span><br><span class=\"line\"><span class=\"section\">config.status: executing depfiles commands</span></span><br><span class=\"line\">$ ls -l Makefile</span><br><span class=\"line\">-rw-rw-r-- 1 yutao yutao 15035 Oct 15 10:40 Makefile</span><br></pre></td></tr></table></figure>\n<p>你可以看到,此时Makefile已经产生出来了.</p>\n<ol start=\"7\">\n<li>使用Makefile编译代码</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$make</span><br><span class=\"line\">if gcc -DPACKAGE_NAME=\\<span class=\"string\">&quot;FULL-PACKAGE-NAME\\&quot; -DPACKAGE_TARNAME=\\&quot;full-package-name\\&quot; -DPACKAGE_VERSION=\\&quot;VERSION\\&quot; -DPACKAGE_STRING=\\&quot;FULL-PACKAGE-NAME\\ VERSION\\&quot; -DPACKAGE_BUGREPORT=\\&quot;BUG-REPORT-ADDRESS\\&quot; -DPACKAGE=\\&quot;helloworld\\&quot; -DVERSION=\\&quot;1.0\\&quot; -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_STDLIB_H=1  -I. -I.     -g -O2 -MT helloworld.o -MD -MP -MF &quot;</span>.deps/helloworld.Tpo<span class=\"string\">&quot; -c -o helloworld.o helloworld.c; \\</span></span><br><span class=\"line\"><span class=\"string\">then mv -f &quot;</span>.deps/helloworld.Tpo<span class=\"string\">&quot; &quot;</span>.deps/helloworld.Po<span class=\"string\">&quot;; else rm -f &quot;</span>.deps/helloworld.Tpo<span class=\"string\">&quot;; exit 1; fi</span></span><br><span class=\"line\"><span class=\"string\">gcc  -g -O2   -o helloworld  helloworld.o</span></span><br></pre></td></tr></table></figure>\n<p>运行helloworld</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./helloworld</span><br><span class=\"line\">Hello, Linux World!</span><br></pre></td></tr></table></figure>\n<p>这样helloworld就编译出来了,你如果按上面的 步骤来做的 话,应该也会很容易地编译出正确的 helloworld文件.你还可以试着使用一些其他的 make命令,如make clean,make install,make dist,看看它们会给你什么样的 效果.感觉如何？自己也能写出这么专业的 Makefile,老板一定会对你刮目相看.</p>\n<h2 id=\"深入浅出\"><a href=\"#深入浅出\" class=\"headerlink\" title=\"深入浅出\"></a>深入浅出</h2><p>针对上面提到的各个命令,我们再做些详细的介绍.</p>\n<img src=\"/Blog/posts/13020/Makefile%E5%9F%BA%E7%A1%80.png\" class=\"\">\n\n<p><img src=\".%5Cautomake%E5%9F%BA%E7%A1%80%5CMakefile%E5%9F%BA%E7%A1%80.png\" alt=\"Makefile基础\"></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"automake基础\"><a href=\"#automake基础\" class=\"headerlink\" title=\"automake基础\"></a>automake基础</h1><p>作为Linux下的程序开发人员,大家一定都遇到过Makefile,用make命令来编译自己写的程序确实是很方便.一般情况下,大家都是手工写一个简单Makefile,如果要想写出一个符合自由软件惯例的Makefile就不那么容易了.<br>在本文中,将给大家介绍如何使用autoconf和automake两个工具来帮助我们自动地生成符合自由软件惯例的 Makefile,这样就可以象常见的 GNU程序一样,只要使用”./configure”,”make”,”make instal”就可以把程序安装到Linux系统中去了.<br>这将特别适合想做开放源代码软件的程序开发人员,又或如果你只是自己写些小的Toy程序,那么这个文章对你也会有很大的帮助.</p>\n<h2 id=\"Makefile介绍\"><a href=\"#Makefile介绍\" class=\"headerlink\" title=\"Makefile介绍\"></a>Makefile介绍</h2><p>Makefile是用于自动编译和链接的 ,一个工程有很多文件组成,每一个文件的改变都会导致工程的重新链接,但是不是 所有的文件都需要重新编译,Makefile中纪录有文件的信息,在 make时会决定在链接的时候需要重新编译哪些文件.　<br>Makefile的宗旨就是 ：让编译器知道要编译一个文件需要依赖其他的 哪些文件.当那些依赖文件有了改变,编译器会自动的发现最终的生成文件已经过时,而重新编译相应的 模块.　　<br>Makefile的 基本结构不是 很复杂,但当一个程序开发人员开始写Makefile时,经常会怀疑自己写的 是 否符合惯例,而且自己写的 Makefile经常和自己的 开发环境相关联,当系统环境变量或路径发生了变化后,Makefile可能还要跟着修改.这样就造成了手工书写Makefile的 诸多问题,automake恰好能很好地帮助我们解决这些问题.　　<br>使用automake,程序开发人员只需要写一些简单的 含有预定义宏的 文件,由autoconf根据一个宏文件生成configure,由automake根据另一个宏文件生成Makefile.in,再使用configure依据Makefile.in来生成一个符合惯例的 Makefile.下面我们将详细介绍Makefile的 automake生成方法.</p>\n<h2 id=\"使用的环境\"><a href=\"#使用的环境\" class=\"headerlink\" title=\"使用的环境\"></a>使用的环境</h2><p>本文所提到的 程序是 基于Linux发行版本：Fedora Core release 1,它包含了我们要用到的 autoconf,automake.</p>\n<h2 id=\"从helloworld入手\"><a href=\"#从helloworld入手\" class=\"headerlink\" title=\"从helloworld入手\"></a>从helloworld入手</h2><p>我们从大家最常使用的 例子程序helloworld开始.<br>下面的 过程如果简单地说来就是 ：<br>新建三个文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　　　helloworld.c　　　</span><br><span class=\"line\">　　　configure.in　　　</span><br><span class=\"line\">　　　Makefile.am</span><br></pre></td></tr></table></figure>\n<p>然后执行：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">aclocal; autoconf; automake --add-missing; ./configure; make; ./helloworld</span><br></pre></td></tr></table></figure>\n<p>就可以看到Makefile被产生出来,而且可以将helloworld.c编译通过.<br>很简单吧,几条命令就可以做出一个符合惯例的 Makefile,感觉如何呀.<br><strong>现在 开始介绍详细的 过程：</strong></p>\n<ol>\n<li>建目录<br> 在 你的工作目录下建一个helloworld目录,我们用它来存放helloworld程序及相关文件,如在 /home/my/build下：</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir helloword</span><br><span class=\"line\">$ cd helloworld</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>helloworld.c<br> 然后用你自己最喜欢的 编辑器写一个hellowrold.c文件,如命令：vi helloworld.c.使用下面的 代码作为helloworld.c的 内容.</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    printf(&quot;%s&quot;, &#x27;Hello, Linux World!\\n&quot;);     </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>完成后保存退出.<br>现在 在 helloworld目录下就应该有一个你自己写的 helloworld.c了.</p>\n<ol start=\"3\">\n<li><p>生成configure</p>\n<p> 我们使用autoscan命令来帮助我们根据目录下的 源代码生成一个configure.in的 模板文件. 命令：</p>\n</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ autoscan</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">configure.scan helloworld.c</span><br></pre></td></tr></table></figure>\n<p>执行后在 hellowrold目录下会生成一个文件：configure.scan,我们可以拿它作为configure.in的 蓝本.<br>现在 将configure.scan改名为configure.in,并且编辑它,按下面的 内容修改,去掉无关的 语句：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">==========================configure.in内容开始=========================================</span><br><span class=\"line\"><span class=\"comment\"># -*- Autoconf -*-</span></span><br><span class=\"line\"><span class=\"comment\"># Process this file with autoconf to produce a configure script.</span></span><br><span class=\"line\">AC_INIT(helloworld.c)</span><br><span class=\"line\">AM_INIT_AUTOMAKE(helloworld, 1.0)</span><br><span class=\"line\"><span class=\"comment\"># Checks for programs.</span></span><br><span class=\"line\">AC_PROG_CC</span><br><span class=\"line\"><span class=\"comment\"># Checks for libraries.</span></span><br><span class=\"line\"><span class=\"comment\"># Checks for header files.</span></span><br><span class=\"line\"><span class=\"comment\"># Checks for typedefs, structures, and compiler characteristics.</span></span><br><span class=\"line\"><span class=\"comment\"># Checks for library functions.</span></span><br><span class=\"line\">AC_OUTPUT(Makefile)</span><br><span class=\"line\">==========================configure.in内容结束=========================================</span><br></pre></td></tr></table></figure>\n<p>然后执行命令aclocal和autoconf,分别会产生aclocal.m4及configure两个文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ aclocal</span><br><span class=\"line\">$ls</span><br><span class=\"line\">aclocal.m4 configure.in helloworld.c</span><br><span class=\"line\">$ autoconf</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">aclocal.m4 autom4te.cache configure configure.in helloworld.c</span><br></pre></td></tr></table></figure>\n<p>大家可以看到configure.in内容是 一些宏定义,这些宏经autoconf处理后会变成检查系统特性.环境变量.软件必须的 参数的 shell脚本.<br>autoconf 是 用来生成自动配置软件源代码脚本（configure）的 工具.configure脚本能独立于autoconf运行,且在 运行的 过程中,不需要用户的 干预.<br>要生成configure文件,你必须告诉autoconf如何找到你所用的 宏.方式是 使用aclocal程序来生成你的 aclocal.m4.<br>aclocal根据configure.in文件的 内容,自动生成aclocal.m4文件.aclocal是 一个perl 脚本程序,它的 定义是 ：”aclocal - create aclocal.m4 by scanning configure.ac”.<br>autoconf从configure.in这个列举编译软件时所需要各种参数的 模板文件中创建configure.<br>autoconf需要GNU m4宏处理器来处理aclocal.m4,生成configure脚本.<br>m4是 一个宏处理器.将输入拷贝到输出,同时将宏展开.宏可以是 内嵌的 ,也可以是 用户定义的 .除了可以展开宏,m4还有一些内建的 函数,用来引用文件,执行命令,整数运算,文本操作,循环等.m4既可以作为编译器的 前端,也可以单独作为一个宏处理器.</p>\n<ol start=\"4\">\n<li>新建Makefile.am<br> 新建Makefile.am文件,命令：</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ vi Makefile.am</span><br><span class=\"line\">　　内容如下:</span><br><span class=\"line\">AUTOMAKE_OPTIONS=foreign</span><br><span class=\"line\">bin_PROGRAMS=helloworld</span><br><span class=\"line\">helloworld_SOURCES=helloworld.c</span><br></pre></td></tr></table></figure>\n<p>automake会根据你写的 Makefile.am来自动生成Makefile.in.<br>Makefile.am中定义的 宏和目标,会指导automake生成指定的 代码.例如,宏bin_PROGRAMS将导致编译和连接的 目标被生成.</p>\n<ol start=\"5\">\n<li>运行automake:</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ automake --add-missing</span><br><span class=\"line\"><span class=\"section\">configure.in: installing `./install-sh&#x27;</span></span><br><span class=\"line\"><span class=\"section\">configure.in: installing `./mkinstalldirs&#x27;</span></span><br><span class=\"line\"><span class=\"section\">configure.in: installing `./missing&#x27;</span></span><br><span class=\"line\"><span class=\"section\">Makefile.am: installing `./depcomp&#x27;</span></span><br></pre></td></tr></table></figure>\n<p>automake会根据Makefile.am文件产生一些文件,包含最重要的 Makefile.in.</p>\n<ol start=\"6\">\n<li>执行configure生成Makefile</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$./configure</span><br><span class=\"line\">checking for a BSD-compatible install... /usr/bin/install -c</span><br><span class=\"line\">checking whether build environment is sane... yes</span><br><span class=\"line\">checking for gawk... gawk</span><br><span class=\"line\">checking whether make sets <span class=\"variable\">$(MAKE)</span>... yes</span><br><span class=\"line\">checking for gcc... gcc</span><br><span class=\"line\">checking for C compiler default output... a.out</span><br><span class=\"line\">checking whether the C compiler works... yes</span><br><span class=\"line\">checking whether we are cross compiling... no</span><br><span class=\"line\">checking for suffix of executables...</span><br><span class=\"line\">checking for suffix of object files... o</span><br><span class=\"line\">checking whether we are using the GNU C compiler... yes</span><br><span class=\"line\">checking whether gcc accepts -g... yes</span><br><span class=\"line\">checking for gcc option to accept ANSI C... none needed</span><br><span class=\"line\">checking for style of <span class=\"keyword\">include</span> used by make... GNU</span><br><span class=\"line\">checking dependency style of gcc... gcc3</span><br><span class=\"line\"><span class=\"section\">configure: creating ./config.status</span></span><br><span class=\"line\"><span class=\"section\">config.status: creating Makefile</span></span><br><span class=\"line\"><span class=\"section\">config.status: executing depfiles commands</span></span><br><span class=\"line\">$ ls -l Makefile</span><br><span class=\"line\">-rw-rw-r-- 1 yutao yutao 15035 Oct 15 10:40 Makefile</span><br></pre></td></tr></table></figure>\n<p>你可以看到,此时Makefile已经产生出来了.</p>\n<ol start=\"7\">\n<li>使用Makefile编译代码</li>\n</ol>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$make</span><br><span class=\"line\">if gcc -DPACKAGE_NAME=\\<span class=\"string\">&quot;FULL-PACKAGE-NAME\\&quot; -DPACKAGE_TARNAME=\\&quot;full-package-name\\&quot; -DPACKAGE_VERSION=\\&quot;VERSION\\&quot; -DPACKAGE_STRING=\\&quot;FULL-PACKAGE-NAME\\ VERSION\\&quot; -DPACKAGE_BUGREPORT=\\&quot;BUG-REPORT-ADDRESS\\&quot; -DPACKAGE=\\&quot;helloworld\\&quot; -DVERSION=\\&quot;1.0\\&quot; -DSTDC_HEADERS=1 -DHAVE_SYS_TYPES_H=1 -DHAVE_SYS_STAT_H=1 -DHAVE_STDLIB_H=1 -DHAVE_STRING_H=1 -DHAVE_MEMORY_H=1 -DHAVE_STRINGS_H=1 -DHAVE_INTTYPES_H=1 -DHAVE_STDINT_H=1 -DHAVE_UNISTD_H=1 -DHAVE_STDLIB_H=1  -I. -I.     -g -O2 -MT helloworld.o -MD -MP -MF &quot;</span>.deps/helloworld.Tpo<span class=\"string\">&quot; -c -o helloworld.o helloworld.c; \\</span></span><br><span class=\"line\"><span class=\"string\">then mv -f &quot;</span>.deps/helloworld.Tpo<span class=\"string\">&quot; &quot;</span>.deps/helloworld.Po<span class=\"string\">&quot;; else rm -f &quot;</span>.deps/helloworld.Tpo<span class=\"string\">&quot;; exit 1; fi</span></span><br><span class=\"line\"><span class=\"string\">gcc  -g -O2   -o helloworld  helloworld.o</span></span><br></pre></td></tr></table></figure>\n<p>运行helloworld</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ ./helloworld</span><br><span class=\"line\">Hello, Linux World!</span><br></pre></td></tr></table></figure>\n<p>这样helloworld就编译出来了,你如果按上面的 步骤来做的 话,应该也会很容易地编译出正确的 helloworld文件.你还可以试着使用一些其他的 make命令,如make clean,make install,make dist,看看它们会给你什么样的 效果.感觉如何？自己也能写出这么专业的 Makefile,老板一定会对你刮目相看.</p>\n<h2 id=\"深入浅出\"><a href=\"#深入浅出\" class=\"headerlink\" title=\"深入浅出\"></a>深入浅出</h2><p>针对上面提到的各个命令,我们再做些详细的介绍.</p>\n<img src=\"/Blog/posts/13020/Makefile%E5%9F%BA%E7%A1%80.png\" class=\"\">\n\n<p><img src=\".%5Cautomake%E5%9F%BA%E7%A1%80%5CMakefile%E5%9F%BA%E7%A1%80.png\" alt=\"Makefile基础\"></p>\n"},{"title":"Makefile基础","date":"2020-12-31T15:59:00.000Z","abbrlink":13012,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"# Makefile基础\n\n> 什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不得不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。**make是一个命令工具，是一个解释makefile中指令的命令工具**，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。\n\n------\n\n现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat **linux** 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。  在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。\n\n## **1. 关于程序的编译和链接**   \n\n在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是passical，首先要把源文件编译成**中间代码文件**，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做***\\*编译\\**（compile）**。然后再把大量的Object File合成执行文件，这个动作叫作**链接**（link）。\n\n**编译时**，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。\n\n**链接时**，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，**我们要给中间目标文件打个包**，在Windows下这种包叫“**库文件”（Library File)**，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。\n\n总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，**编译器只检测程序语法，和函数、变量是否被声明**。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.\n\n好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。\n\n## **2. Makefile 介绍**   \n\nmake命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。   首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。如果这个工程的**头文件**被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。   只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动**智能**地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。\n\n### **2.1 Makefile的规则**   \n\n在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。\n\n```makefile\ntarget... : prerequisites ...\ncommand\n...\n...\n```\n\n- **target**：目标文件，可以是**Object File**，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。\n\n* **prerequisites**：要生成那个target所需要的文件或是目标。    \n\n* **command**：make需要执行的命令。（任意的Shell命令）\n\n这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。    说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）\n\n### **2.2 一个示例**\n\n正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。\n\n```makefile\nedit : main.o kbd.o command.o display.o \\\n       insert.o search.o files.o utils.o\n       cc -o edit main.o kbd.o command.o display.o \\\n                  insert.o search.o files.o utils.o\n\nmain.o : main.c defs.h\n         cc -c main.c\nkbd.o : kbd.c defs.h command.h\n        cc -c kbd.c\ncommand.o : command.c defs.h command.h\n            cc -c command.c\ndisplay.o : display.c defs.h buffer.h\n            cc -c display.c\ninsert.o : insert.c defs.h buffer.h\n           cc -c insert.c\nsearch.o : search.c defs.h buffer.h\n           cc -c search.c\nfiles.o : files.c defs.h buffer.h command.h\n           cc -c files.c\nutils.o : utils.c defs.h\n           cc -c utils.c\nclean :\n        rm edit main.o kbd.o command.o display.o \\\n                insert.o search.o files.o utils.o\n```\n\n**反斜杠（\\）**是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。\n\n在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。*\n\n在定义好依赖关系后，后续的那一行定义了如何生成目标文件的**操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令**。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。\n\n**这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像**C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。\n\n### **2.3 make是如何工作的**\n\n在默认的方式下，也就是我们只输入make命令。那么:\n\n- make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 \n\n* 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 \n\n* 如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 \n\n* 如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。\n\n* 当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。  \n\n这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。\n\n通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——**“make clean”，以此来清除所有的目标文件，以便重编译**。\n\n于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。\n\n### **2.4 makefile中使用变量**\n\n 在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$<”、“$@”等，这些是自动化变量，我会在后面介绍。\n\n#### 2.4.1 变量的基础\n\n变量在声明时需要给予初值，而在使用时，需要给在变量名前**加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来**。如果你要使用真实的“$”字符，那么你需要用“$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：\n\n```\nobjects = program.o foo.o utils.o\nprogram : $(objects)\ncc -o program $(objects)\n$(objects) : defs.h\n```\n\n变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：\n\n```\nfoo = c\nprog.o : prog.$(foo)\n$(foo)$(foo) -$(foo) prog.$(foo)\n```\n\n展开后得到：\n\n```makefile\nprog.o : prog.c\n\t\tcc -c prog.c\n```\n\n当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。\n\n#### 2.4.2 **变量中的变量**\n\n在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：\n\n```makefile\nfoo = $(bar)\nbar = $(ugh)\nugh = Huh?\nall:\necho $(foo)\n```\n\n我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。\n\n这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：\n\n```makefile\nCFLAGS = $(include_dirs) -O\ninclude_dirs = -Ifoo -Ibar\n```\n\n当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：\n\n`CFLAGS = $(CFLAGS) -O`\n\n或：\n\nA = $(B)\n\nB = $(A)\n\n这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。\n\n为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：\n\n```makefile\nx := foo\ny := $(x) bar\nx := later\n```\n\n其等价于：\n\n```makefile\ny := foo bar\nx := later\n```\n\n值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：\n\n```\ny := $(x) bar\nx := foo\n```\n\n那么，y的值是“bar”，而不是“foo bar”。\n\n在上面的例子中，先让我们看看edit的规则：   \n\n```makefile\nedit : main.o kbd.o command.o display.o \\\n       insert.o search.o files.o utils.o\n       cc -o edit main.o kbd.o command.o display.o \\\n       insert.o search.o files.o utils.o\n```\n\n我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成**c语言**中的宏可能会更好。\n\n比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.o search.o files.o utils.o\n```\n\n于是，我们就可以很方便地在我们的makefile中以**“$(objects)”**的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.osearch.o files.o utils.o\nedit : $(objects)\n\t   cc -o edit $(objects)\nmain.o : main.c defs.h\n\t     cc -c main.c\nkbd.o : kbd.c defs.h command.h\n\t    cc -c kbd.c\ncommand.o : command.c defs.h command.h\n\t        cc -c command.c\ndisplay.o : display.c defs.h buffer.h\n            cc -c display.c\ninsert.o : insert.c defs.h buffer.h\n           cc -c insert.c\nsearch.o : search.c defs.h buffer.h\n           cc -c search.c\nfiles.o : files.c defs.h buffer.h command.h\n          cc -c files.c\nutils.o : utils.c defs.h\n          cc -c utils.c\nclean :\n        rm edit $(objects)\n```\n\n于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。关于变量更多的话题，我会在后续给你一一道来。\n\n### **2.5 让make自动推导** \n\nGNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。\n\n只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。\n\nMakefile中把那些没有任何依赖只有执行动作的目标成为“伪目标”(phony targets)。\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.o search.o files.o utils.o\n\nedit : $(objects)\n       cc -o edit $(objects)\n\nmain.o : defs.h\nkbd.o : defs.h command.h\ncommand.o : defs.h command.h\ndisplay.o : defs.h buffer.h\ninsert.o : defs.h buffer.h\nsearch.o : defs.h buffer.h\nfiles.o : defs.h buffer.h command.h\nutils.o : defs.h\n\n.PHONY : clean\nclean :\n        rm edit $(objects)\n```\n\n这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。\n\n### **2.6 另类风格的makefile**  \n\n即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.o search.o files.o utils.o\n\nedit : $(objects)\n       cc -o edit $(objects)\n\n$(objects) : defs.h\nkbd.o command.o files.o : command.h\ndisplay.o insert.o search.o files.o : buffer.h\n\n.PHONY : clean\nclean :\n        rm edit $(objects)\n```\n\n这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。\n\n### **2.7 清空目标文件的规则**   \n\n每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：    \n\n```makefile\nclean:\n      rm edit $(objects)\n```\n\n更为稳健的做法是：\n\n```makefile\n.PHONY : clean\nclean :\n        -rm edit $(objects)\n```\n\n前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。\n\n## **3. Makefile 总述**\n\n### **3.1 Makefile里有什么？**\n\n**Makefile里主要包含了**五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。\n\n* 显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。\n\n* 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。\n\n* 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。\n\n* 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 \n\n* 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\\#”。\n\n**最后，还值得一提的是，**在Makefile中的命令，必须要以[Tab]键开始。**   **----------注意是tab键，不是8个空格**\n\n### **3.2 Makefile的文件名**    \n\n默认的情况下，make命令会在当前目录下按顺序找寻文件名为**“GNUmakefile”、“makefile”、“Makefile”**的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“**makefile”和“Makefile”**这两种默认文件名。   \n\n当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要**指定特定的Makefile，你可以使用make的“-f”和“--file”参数**，如：make -f Make.Linux或make --file Make.AIX。\n\n### **3.3 引用其它的Makefile**  \n\n在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：\n\n```makefile\ninclude <filename> filename\n```\n\n可以是当前操作系统Shell的文件模式（可以保含路径和通配符）   \n\n**在include前面可以有一些空字符，**但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。**举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：   **\n\n```makefile\ninclude foo.make *.mk $(bar)\n```\n\n等价于：   \n\n```makefile\ninclude foo.make a.mk b.mk c.mk e.mk f.mk\n```\n\nmake命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：\n\n* 如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。\n\n* 如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。   \n\n如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：\n\n```\n-include <filename>\n```\n\n其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。\n\n### **3.4 环境变量 MAKEFILES**   \n\n如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。\n\n但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。\n\n### **3.5 make的工作方式**\n\nGNU的make工作时的执行步骤入下：（想来其它的make也是类似）\n\n1. 读入所有的Makefile。\n\n2. 读入被include的其它Makefile。\n\n3. 初始化文件中的变量。\n\n4. 推导隐晦规则，并分析所有规则。\n\n5. 为所有的目标文件创建依赖关系链。\n\n6. 根据依赖关系，决定哪些目标要重新生成。\n\n7. 执行生成命令。   \n\n1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，\n\n**make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。\n\n## **4. Makefile书写规则**   \n\n规则包含两个部分，一个是**依赖关系**，一个是**生成目标的方法**。   \n\n**在Makefile中，规则的顺序是很重要的**，因为，**Makefile中应该****只有一个最终目标**，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。**\n\n好了，还是让我们来看一看如何书写规则。\n\n### **4.1 规则举例** \n\n```makefile\nfoo.o: foo.c defs.h               # foo模块\n       cc -c -g foo.c             # -c 表示只编译不链接， -g 表示带调试信息\n```\n\n看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令`` cc -c -g foo.c``（以Tab键开头）。这个规则告诉我们两件事：\n\n* 文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。\n* 如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）\n\n### **4.2 规则的语法**   \n\n```makefile\ntargets : prerequisites    \n\tcommand    \n\t...\n```\n\n或是这样：  \n\n```makefile\n targets : prerequisites ; command      \n \tcommand      \n \t... \n```\n\ntargets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。   \n\ncommand是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）   \n\nprerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。   \n\n如果命令太长，你可以使用反斜框（‘\\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。   \n\n一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。\n\n### **4.3 在规则中使用通配符**   \n\n如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[...]”。这是和Unix的B-Shell是相同的。*\n\n**\"~\"**   \n\n波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。\n\n**\"\\*\"**   \n\n*\\**通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\\”，如“\\*”来表示真实的“*”字符，而不是任意长度的字符串。\n\n好吧，还是先来看几个例子吧：\n\n```makefile\n clean:    \n \trm -f *.o\n```\n\n上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。\n\n```makefile\nprint: *.c    \n\tlpr -p $?    \n\ttouch print\n```\n\n上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。  \n\n`objects = *.o`上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！**objects的值就是“\\*.o”**。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：  \n\n`objects := $(wildcard *.o)`\n\n这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。\n\n### **4.4 文件搜寻**\n\n 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。   \n\nMakefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。  \n\n`VPATH = src:../headers`   \n\n上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）   \n\n另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：\n\n* vpath < pattern> < directories>       为符合模式< pattern>的文件指定搜索目录<directories>。\n\n* vpath < pattern>                                清除符合模式< pattern>的文件的搜索目录。\n\n* vpath                                                   清除所有已被设置好了的文件搜索目录。   \n\nvapth使用方法中的< pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。< pattern>指定了要搜索的文件集，而< directories>则指定了的文件集的搜索的目录。例如：  \n\n`vpath %.h ../headers`\n\n该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）\n\n我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的< pattern>，或是被重复了的< pattern>，那么，make会按照vpath语句的先后顺序来执行搜索。如：\n\n```makefile\nvpath %.c foo  \nvpath %  blish  \nvpath %.c bar\n```\n\n其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。  \n\n```makefile\nvpath %.c foo:bar  \nvpath %  blish\n```\n\n而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。\n\n### **4.5 伪目标**\n\n最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，  \n\n```makefile\nclean:      \n\t\trm *.o temp\n```\n\n正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）\n\n因为，我们并不生成“clean”这个文件。**“伪目标”并不是一个文件，只是一个标签**，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。\n\n当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 \n\n` .PHONY : clean`\n\n只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：\n\n```makefile\n .PHONY: clean  \n clean:\n \t\trm *.o temp\n```\n\n伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：\n\n```makefile\nall : prog1 prog2 prog3  \n.PHONY : all\nprog1 : prog1.o utils.o      \n\t\tcc -o prog1 prog1.o utils.o\nprog2 : prog2.o      \n\t\tcc -o prog2 prog2.o\nprog3 : prog3.o sort.o utils.o      \t\n\t\tcc -o prog3 prog3.o sort.o utils.o\n```\n\n我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。\n\n随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：  \n\n```makefile\n.PHONY: cleanall cleanobj cleandiff\n\ncleanall : cleanobj cleandiff      \n\t\trm program\ncleanobj :      \n\t\trm *.o\ncleandiff :      \n\t\trm *.diff*\n```\n\n`makeclean`将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的\n\n### **4.6 多目标**\n\nMakefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。\n\n```makefile\nbigoutput littleoutput : text.g      \n\t\tgenerate text.g -$(subst output,,$@) > $@  \n```\n\n上述规则等价于：\n\n```makefile\nbigoutput : text.g      \n\t\tgenerate text.g -big > bigoutput  \nlittleoutput : text.g      \n\t\tgenerate text.g -little > littleoutput\n```\n\n其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。\n\n### **4.7 静态模式**\n\n静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：\n\n```makefile\n<targets...>: <target-pattern>: <prereq-patterns ...>　　　\n\t\t<commands>\n\t\t...\n```\n\ntargets定义了一系列的目标文件，可以有通配符。是目标的一个集合。\n\ntarget-parrtern是指明了targets的模式，也就是的目标集模式。\n\nprereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。\n\n所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\\”进行转义，来标明真实的“%”字符。\n\n看一个例子：  \n\n```makefile\nobjects = foo.o bar.o\nall: $(objects)\n$(objects): %.o: %.c      \n\t\t$(CC) -c $(CFLAGS) $< -o $@\n```\n\n上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$<”和“$@”则是自动化变量，“$<”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：  \n\n```makefile\nfoo.o : foo.c      \n\t\t$(CC) -c $(CFLAGS) foo.c -o foo.o  \nbar.o : bar.c      \n\t\t$(CC) -c $(CFLAGS) bar.c -o bar.o\n```\n\n试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：\n\n```makefile\nfiles = foo.elc bar.o lose.o\n$(filter %.o,$(files)): %.o: %.c      \n\t\t$(CC) -c $(CFLAGS) $< -o $@  \n$(filter %.elc,$(files)): %.elc: %.el      \n\t\temacs -f batch-byte-compile $<\n```\n\n$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。\n\n### **3.8 自动生成依赖性**\n\n在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include \"defs.h\"”，那么我们的依赖关系应该是：  \n\n`main.o : main.c defs.h`\n\n但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：  \n\n`cc -M main.c`\n\n其输出是：  \n\n`main.o : main.c defs.h`\n\n于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。\n\ngcc-M main.c的输出是：  \n\n```makefile\nmain.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\\n\t/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \\\n\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \\\n\t/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \\\n\t/usr/include/bits/sched.h /usr/include/libio.h \\\n\t/usr/include/_G_config.h /usr/include/wchar.h \\\n\t/usr/include/bits/wchar.h /usr/include/gconv.h \\\n\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \\\n\t/usr/include/bits/stdio_lim.h\n```\n\ngcc-MM main.c的输出则是：  \n\n`main.o: main.c defs.h`\n\n那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。\n\n于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。\n\n这里，我们给出了一个模式规则来产生[.d]文件：\n\n```makefile\n%.d: %.c      \n\t\t@set -e; rm -f $@; \\      \n\t\t$(CC) -M $(CPPFLAGS) $< > $@.\n\t\t\n; \\      \n\t\tsed 's,\n$∗\n\\.o[ :]*,\\1.o $@ : ,g' < $@.\n\n\\> $@; \\      \n\t\trm -f $@.\n```\n\n这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm-f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$<”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，\n\n“”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。\n\n总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： \n\n`main.o : main.c defs.h`\n\n转成：\n\n`main.o main.d : main.c defs.h`\n\n于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：\n\n```makefile\nsources = foo.c bar.c\ninclude $(sources:.c=.d)\n```\n\n上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标\n\n## **5. Makefile 书写命令**   \n\n每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。\n\n### **5.1 显示命令**\n\n通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“**@**”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如： \n\n == **@符号： 不显示编译回显**==  \n\n`@echo 正在编译XXX模块......`\n\n当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出： \n\n```\necho 正在编译XXX模块......  \n正在编译XXX模块......\n```\n\n如果make执行时，带入make参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。\n\n而make参数“-s”或“--slient”则是全面禁止命令的显示。\n\n### **5.2 命令执行**\n\n当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：  \n\n示例一：    \n\n```makefile\nexec:        \n\t\tcd /home/hchen        \n\t\tpwd\n```\n\n示例二：    \n\n```makefile\nexec:        \n\t\tcd /home/hchen; pwd\n```\n\n当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。\n\n### **5.3 命令出错**   \n\n每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。\n\n有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。\n\n为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： \n\n```makefile\nclean:      \n\t\t-rm -f *.o\n```\n\n还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。\n\n还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。\n\n### **5.4 嵌套执行make**    \n\n在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。\n例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：\n\n```makefile\nsubsystem:      \n\t\tcd subdir && $(MAKE)\n```\n\n其等价于：   \n\n```makefile\nsubsystem:      \n\t\t$(MAKE) -C subdir\n```\n\n定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。\n\n如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：\n\n`export<variable ...>`\n\n如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：\n\n`unexport<variable ...>`\n\n如示例一：     \n\n`export variable = value`\n\n其等价于：     \n\n```makefile\nvariable = value    \nexport variable\n```\n\n其等价于：     \n\n`export variable := value`\n\n其等价于：\n\n```makefile\nvariable := value    \nexport variable\n```\n\n示例二：\n`export variable += value`     \n\n其等价于：\n\n```makefile\nvariable += value    \nexport variable\n```\n\n如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。\n\n需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。\n\n但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：\n\n```makefile\nsubsystem:      \n\t\tcd subdir && $(MAKE) MAKEFLAGS=\n```\n\n如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。还有一个在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：\n\n`make: Entering directory '/home/hchen/gnu/make'`\n\n而在完成下层make后离开目录时，我们会看到：\n\n`make: Leaving directory '/home/hchen/gnu/make'`\n\n当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。\n\n### **5.5 定义命令包**\n\n如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：  \n\n```makefile\ndefine run-yacc  \nyacc $(firstword $^)  \nmv y.tab.c $@  \nendef\n```\n\n这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。  \n\n```makefile\nfoo.c : foo.y      \n\t\t$(run-yacc)\n```\n\n我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。\n\n------\n\n **使用变量**————    在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$<”、“$@”等，这些是自动化变量，我会在后面介绍。\n**一、变量的基础**  变量在声明时需要给予初值，而在使用时，需要给在变量名前**加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来**。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：objects = program.o foo.o utils.oprogram : $(objects)cc -o program $(objects)$(objects) : defs.h变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：foo = cprog.o : prog.$(foo)$(foo)$(foo) -$(foo) prog.$(foo)展开后得到：prog.o : prog.ccc -c prog.c当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。\n\n**二、变量中的变量**在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：foo = $(bar)bar = $(ugh)ugh = Huh?all:echo $(foo)我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：CFLAGS = $(include_dirs) -Oinclude_dirs = -Ifoo -Ibar当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：CFLAGS = $(CFLAGS) -O或：A = $(B)B = $(A)这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：x := fooy := $(x) barx := later其等价于：y := foo barx := later值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：y := $(x) barx := foo那么，y的值是“bar”，而不是“foo bar”。上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：ifeq (0,${MAKELEVEL})cur-dir := $(shell pwd)whoami := $(shell whoami)host-type := $(shell arch)MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}endif关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：nullstring :=space := $(nullstring) # end of the linenullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：dir := /foo/bar # directory to put the frobs indir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。还有一个比较有用的操作符是“?=”，先看示例：FOO ?= bar其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：ifeq ($(origin FOO), undefined)FOO = barendif\n**三、变量高级用法**这里介绍两种变量的高级使用方法，第一种是**变量值的替换**。我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。还是看一个示例吧：foo := a.o b.o c.obar := $(foo:.o=.c)这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：foo := a.o b.o c.obar := $(foo:%.o=%.c)这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。\n第二种高级用法是——“把**变量的值再当成变量**”。先看一个例子：x = yy = za := $($(x))在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）我们还可以使用更多的层次：x = yy = zz = ua := $($($(x)))这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：x = $(y)y = zz = Helloa := $($(x))这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。再复杂一点，我们再加上函数：x = variable1variable2 := Helloy = $(subst 1,2,$(x))z = ya := $($($(z)))这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：first_second = Helloa = firstb = secondall = $($a_$b)这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。再来看看结合第一种技术的例子：a_objects := a.o b.o c.o1_objects := 1.o 2.o 3.osources := $($(a1)_objects:.o=.c)这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。再来看一个这种技术和“函数”与“条件语句”一同使用的例子：ifdef do_sortfunc := sortelsefunc := stripendifbar := a d b g q cfoo := $($(func) $(bar))这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d bg q c)，调用的就是strip函数。当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：dir = foo$(dir)_sources := $(wildcard $(dir)/*.c)define $(dir)_printlpr $($(dir)_sources)endef这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。\n**四、追加变量值**\n\n我们可以使用“+=”操作符给变量追加值，如：\n\n\nobjects = main.o foo.o bar.o utils.o\nobjects += another.o\n\n于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）\n\n使用“+=”操作符，可以模拟为下面的这种例子：\n\n\nobjects = main.o foo.o bar.o utils.o\nobjects := $(objects) another.o\n\n\n所不同的是，用“+=”更为简洁。\n\n\n如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：\n\nvariable := value\nvariable += more\n\n\n等价于：\n\n\nvariable := value\nvariable := $(variable) more\n\n\n但如果是这种情况：\n\n\nvariable = value\nvariable += more\n\n\n由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。\n\n\n**五、override 指示符**\n\n如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：\n\noverride <variable> = <value>\noverride <variable> := <value>\n\n\n当然，你还可以追加：\n\n\noverride <variable> += <more text>\n\n\n对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：\n\n\noverride define foo\nbar\nendef\n\n\n**六、多行变量**\n\n还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。\n\ndefine 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。\n\n下面的这个示例展示了define的用法：\n\n\ndefine two-lines\necho foo\necho $(bar)\nendef\n\n\n**七、环境变量**\n\nmake 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）\n\n因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。   当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）\n\n  当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。\n\n\n\n\n**八、目标变量**\n\n前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$<”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。\n\n当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。\n\n其语法是：\n\n\n<target ...> : <variable-assignment>\n\n\n<target ...> : overide <variable-assignment>\n\n\n<variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。\n\n这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：\n\nprog : CFLAGS = -g\nprog : prog.o foo.o bar.o\n$(CC) $(CFLAGS) prog.o foo.o bar.o\n\n\nprog.o : prog.c\n$(CC) $(CFLAGS) prog.c\n\n\nfoo.o : foo.c\n$(CC) $(CFLAGS) foo.c\n\n\nbar.o : bar.c\n$(CC) $(CFLAGS) bar.c\n\n\n在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”\n\n\n\n\n**九、模式变量**\n\n在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。\n\n我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：\n\n\n%.o : CFLAGS = -O\n\n\n同样，模式变量的语法和“目标变量”一样：\n\n\n<pattern ...> : <variable-assignment>\n\n\n<pattern ...> : override <variable-assignment>\n\n\noverride同样是针对于系统环境传入的变量，或是make命令行指定的变量。\n\n\n**使用条件判断**——————使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。\n\n一、示例\n\n\n下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。\n\n\nlibs_for_gcc = -lgnu\nnormal_libs =\n\n\nfoo: $(objects)\nifeq ($(CC),gcc)\n$(CC) -o foo $(objects) $(libs_for_gcc)\nelse\n$(CC) -o foo $(objects) $(normal_libs)\nendif\n\n\n可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。\n\n我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。\n\n当我们的变量$(CC)值是“gcc”时，目标foo的规则是：\n\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(libs_for_gcc)\n\n\n而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(normal_libs)\n\n\n当然，我们还可以把上面的那个例子写得更简洁一些：\n\n\nlibs_for_gcc = -lgnu\nnormal_libs =\n\n\nifeq ($(CC),gcc)\nlibs=$(libs_for_gcc)\nelse\nlibs=$(normal_libs)\nendif\n\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(libs)\n\n\n\n\n二、语法\n\n\n条件表达式的语法为：\n\n\n<conditional-directive>\n<text-if-true>\nendif\n\n\n以及：\n\n\n<conditional-directive>\n<text-if-true>\nelse\n<text-if-false>\nendif\n\n\n其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。\n\n第一个是我们前面所见过的“ifeq”\n\n\nifeq (<arg1>, <arg2> )\nifeq '<arg1>' '<arg2>'\nifeq \"<arg1>\" \"<arg2>\"\nifeq \"<arg1>\" '<arg2>'\nifeq '<arg1>' \"<arg2>\"\n\n\n比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：\n\n\nifeq ($(strip $(foo)),)\n<text-if-empty>\nendif\n\n\n这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。\n\n第二个条件关键字是“ifneq”。语法是：\n\n\nifneq (<arg1>, <arg2> )\nifneq '<arg1>' '<arg2>'\nifneq \"<arg1>\" \"<arg2>\"\nifneq \"<arg1>\" '<arg2>'\nifneq '<arg1>' \"<arg2>\"\n\n\n其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。\n\n\n\n\n第三个条件关键字是“ifdef”。语法是：\n\n\nifdef <variable-name>\n\n\n如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：\n\n\n示例一：\nbar =\nfoo = $(bar)\nifdef foo\nfrobozz = yes\nelse\nfrobozz = no\nendif\n\n\n示例二：\nfoo =\nifdef foo\nfrobozz = yes\nelse\nfrobozz = no\nendif\n\n\n第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。\n\n\n第四个条件关键字是“ifndef”。其语法是：\n\n\nifndef <variable-name>\n\n\n这个我就不多说了，和“ifdef”是相反的意思。\n\n\n在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也\n一样，只要不是以[Tab]键开始就行了。\n\n特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。\n\n而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。\n\n\n\n\n\n**使用函数****————**在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。**一、函数的调用语法**函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：\n\n\n$(<function> <arguments> )\n\n\n或是\n\n\n${<function> <arguments>}\n\n\n这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。\n\n\n还是来看一个示例：\n\n\ncomma:= ,\nempty:=\nspace:= $(empty) $(empty)\nfoo:= a b c\nbar:= $(subst $(space),$(comma),$(foo))\n\n\n在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“\na,b,c”。\n\n**二、字符串处理函数**\n\n$(subst <from>,<to>,<text> )\n\n\n名称：字符串替换函数——subst。\n功能：把字串<text>中的<from>字符串替换成<to>。\n返回：函数返回被替换过后的字符串。\n\n\n示例：\n\n\n$(subst ee,EE,feet on the street)，\n\n\n把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt\n”。\n\n\n\n\n$(patsubst <pattern>,<replacement>,<text> )\n\n\n名称：模式字符串替换函数——patsubst。\n功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。\n\n\n示例：\n\n\n$(patsubst %.c,%.o,x.c.c bar.c)\n\n\n把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”\n\n\n备注：\n\n\n这和我们前面“变量章节”说过的相关知识有点相似。如：\n\n\n“$(var:<pattern>=<replacement> )”\n相当于\n“$(patsubst <pattern>,<replacement>,$(var))”，\n\n\n而“$(var: <suffix>=<replacement> )”\n则相当于\n“$(patsubst %<suffix>,%<replacement>,$(var))”。\n\n\n例如有：objects = foo.o bar.o baz.o，\n那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。\n\n\n$(strip <string> )\n\n\n名称：去空格函数——strip。\n功能：去掉<string>字串中开头和结尾的空字符。\n返回：返回被去掉空格的字符串值。\n示例：\n\n\n$(strip a b c )\n\n\n把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。\n\n\n$(findstring <find>,<in> )\n\n\n名称：查找字符串函数——findstring。\n功能：在字串<in>中查找<find>字串。\n返回：如果找到，那么返回<find>，否则返回空字符串。\n示例：\n\n\n$(findstring a,a b c)\n$(findstring a,b c)\n\n\n第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）\n\n\n$(filter <pattern...>,<text> )\n\n\n名称：过滤函数——filter。\n功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可\n以有多个模式。\n返回：返回符合模式<pattern>的字串。\n示例：\n\n\nsources := foo.c bar.c baz.s ugh.h\nfoo: $(sources)\ncc $(filter %.c %.s,$(sources)) -o foo\n\n\n$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。\n\n\n$(filter-out <pattern...>,<text> )\n\n\n名称：反过滤函数——filter-out。\n功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可\n以有多个模式。\n返回：返回不符合模式<pattern>的字串。\n示例：\n\n\nobjects=main1.o foo.o main2.o bar.o\nmains=main1.o main2.o\n\n\n$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。\n\n\n$(sort <list> )\n\n\n名称：排序函数——sort。\n功能：给字符串<list>中的单词排序（升序）。\n返回：返回排序后的字符串。\n示例：$(sort foo bar lose)返回“bar foo lose” 。\n备注：sort函数会去掉<list>中相同的单词。\n\n\n$(word <n>,<text> )\n\n\n名称：取单词函数——word。\n功能：取字符串<text>中第<n>个单词。（从一开始）\n返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空\n字符串。\n示例：$(word 2, foo bar baz)返回值是“bar”。\n\n\n$(wordlist <s>,<e>,<text> )\n\n\n名称：取单词串函数——wordlist。\n功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。\n返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那\n么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单\n词串。\n示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。\n\n\n$(words <text> )\n\n\n名称：单词个数统计函数——words。\n功能：统计<text>中字符串中的单词个数。\n返回：返回<text>中的单词数。\n示例：$(words, foo bar baz)返回值是“3”。\n备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text>\n),<text> )。\n\n\n$(firstword <text> )\n\n\n名称：首单词函数——firstword。\n功能：取字符串<text>中的第一个单词。\n返回：返回字符串<text>的第一个单词。\n示例：$(firstword foo bar)返回值是“foo”。\n备注：这个函数可以用word函数来实现：$(word 1,<text> )。\n\n\n以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，\n举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索\n路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，\n如：\n\n\noverride CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))\n\n\n如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :\n, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数\n。\n\n\n**三、文件名操作函数**\n下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是\n一系列的文件名来对待。\n\n\n$(dir <names...> )\n\n\n名称：取目录函数——dir。\n功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之\n前的部分。如果没有反斜杠，那么返回“./”。\n返回：返回文件名序列<names>的目录部分。\n示例： $(dir src/foo.c hacks)返回值是“src/ ./”。\n\n\n$(notdir <names...> )\n\n\n名称：取文件函数——notdir。\n功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”\n）之后的部分。\n返回：返回文件名序列<names>的非目录部分。\n示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。\n\n\n$(suffix <names...> )\n\n\n名称：取后缀函数——suffix。\n功能：从文件名序列<names>中取出各个文件名的后缀。\n返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。\n示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。\n\n\n$(basename <names...> )\n\n\n名称：取前缀函数——basename。\n功能：从文件名序列<names>中取出各个文件名的前缀部分。\n返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。\n示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar h\nacks”。\n\n\n$(addsuffix <suffix>,<names...> )\n\n\n名称：加后缀函数——addsuffix。\n功能：把后缀<suffix>加到<names>中的每个单词后面。\n返回：返回加过后缀的文件名序列。\n示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。\n\n$(addprefix <prefix>,<names...> )\n\n\n名称：加前缀函数——addprefix。\n功能：把前缀<prefix>加到<names>中的每个单词后面。\n返回：返回加过前缀的文件名序列。\n示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。\n\n\n$(join <list1>,<list2> )\n\n\n名称：连接函数——join。\n功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<\nlist2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比\n<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。\n返回：返回连接过后的字符串。\n示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。\n\n\n**四、foreach 函数**\n\nforeach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的\nforeach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin\n/csh）中的foreach语句而构建的。它的语法是：\n\n$(foreach <var>,<list>,<text> )\n\n\n这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。\n\n所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>\n这个参数来依次枚举<list>中的单词。举个例子：\n\n\nnames := a b c d\n\n\nfiles := $(foreach n,$(names),$(n).o)\n\n上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(f\niles)的值是“a.o b.o c.o d.o”。\n\n\n注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。\n\n\n\n**五、if 函数**\n\nif函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：\n\n\n$(if <condition>,<then-part> )\n\n\n\n或是\n\n\n$(if <condition>,<then-part>,<else-part> )\n\n\n\n可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。\n\n而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。\n\n所以，<then-part>和<else-part>只会有一个被计算。\n\n\n\n**六、call函数**\ncall函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：\n\n\n$(call <expression>,<parm1>,<parm2>,<parm3>...)\n\n\n当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。例如：\n\nreverse = $(1) $(2)\n\nfoo = $(call reverse,a,b)\n\n\n\n那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：\n\nreverse = $(2) $(1)\nfoo = $(call reverse,a,b)\n\n此时的foo的值就是“b a”。\n\n**七、origin函数**origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：\n\n$(origin <variable> )\n\n\n注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函\n数的返回值:\n\n“undefined”\n\n\n如果<variable>从来没有定义过，origin函数返回这个值“undefined”。\n\n“default”\n\n\n如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。\n\n“environment”\n\n\n如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。\n\n\n“file”\n\n\n如果<variable>这个变量被定义在Makefile中。\n\n\n“command line”\n\n\n如果<variable>这个变量是被命令行定义的。\n\n“override”\n\n\n如果<variable>是被override指示符重新定义的。\n\n“automatic”\n\n\n如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。\n\n\n这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一\n个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是\n，在我们的Makefile中，我们可以这样写：\n\n\nifdef bletch\n\n\nifeq \"$(origin bletch)\" \"environment\"\n\n\nbletch = barf, gag, etc.\n\nendif\n\nendif\n\n当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗\n暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。\n\n\n**八、shell函数**\nshell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数\n返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：\n\n\ncontents := $(shell cat foo)\n\n\n\nfiles := $(shell echo *.c)\n\n\n注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。\n\n\n**九、控制make的函数**\n\n\nmake提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。\n\n\n$(error <text ...> )\n\n产生一个致命的错误，<text ...>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也\n是可以的。例如：\n\n示例一：\n\n\nifdef ERROR_001\n\n\n$(error error is $(ERROR_001))\n\nendif\n\n\n示例二：\n\n\nERR = $(error found an error!)\n\n\n.PHONY: err\n\n\nerr: ; $(ERR)\n\n\n示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。\n\n$(warning <text ...> )\n\n\n这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。\n\n**make 的运行**——————一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。\n**一、make的退出码**make命令执行后有三个退出码：0 —— 表示成功执行。1 —— 如果make运行时出现任何错误，其返回1。2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。Make的相关参数我们会在后续章节中讲述。\n**二、指定Makefile**\n\n前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就\n开始读取这个文件并执行。\n\n\n当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“-- makefile”参数也行）。例如，我们有个mak\nefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：\n\nmake –f hchen.mk\n\n\n如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。\n\n\n**三、指定目标**\n\n一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。\n\n有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：\n\n\nsources = foo.c bar.c\nifneq ( $(MAKECMDGOALS),clean)\ninclude $(sources:.c=.d)\nendif\n\n\n基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。\n\n使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：\n\n\n.PHONY: all\nall: prog1 prog2 prog3 prog4\n\n\n从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标\n（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。\n\n\n即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件\n发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。\n\n\n**“all”**        这个伪目标是所有目标的目标，其功能一般是编译所有的目标。**“clean”**    这个伪目标功能是删除所有被make创建的文件。**“install”**    这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。**“print”**     这个伪目标的功能是例出改变过的源文件。**“tar”**       这个伪目标功能是把源程序打包备份。也就是一个tar文件。**“dist”**      这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。**“TAGS”**     这个伪目标功能是更新所有的目标，以备完整地重编译使用。**“check”和“test”**   这两个伪目标一般用来[测试](http://lib.csdn.net/base/softwaretest)makefile的流程。\n\n​    当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。\n\n\n**四、检查规则**\n\n有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：\n\n\n“-n”\n“--just-print”\n“--dry-run”\n“--recon”\n不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。\n\n\n“-t”\n“--touch”\n这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。\n\n\n“-q”\n“--question”\n这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。\n\n\n“-W <file>”\n“--what-if=<file>”\n“--assume-new=<file>”\n“--new-file=<file>”\n这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件\n所发生的规则命令。\n\n另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。\n\n\n\n**五、make的参数**\n\n下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。\n\n\n“-b”\n“-m”\n这两个参数的作用是忽略和其它版本make的兼容性。\n\n\n“-B”\n“--always-make”\n认为所有的目标都需要更新（重编译）。\n\n\n“-C <dir>”\n“--directory=<dir>”\n指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”\n等价于“make –C ~hchen/test/prog”。\n\n\n“—debug[=<options>]”\n输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：\na —— 也就是all，输出所有的调试信息。（会非常的多）b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i —— 也就是implicit，输出所以的隐含规则。j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。\n\n“-d”\n相当于“--debug=a”。\n\n\n“-e”\n“--environment-overrides”\n指明环境变量的值覆盖makefile中定义的变量的值。\n\n\n“-f=<file>”\n“--file=<file>”\n“--makefile=<file>”\n指定需要执行的makefile。\n\n\n“-h”\n“--help”\n显示帮助信息。\n\n\n“-i”\n“--ignore-errors”\n在执行时忽略所有的错误。\n\n\n“-I <dir>”\n“--include-dir=<dir>”\n指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。\n\n\n“-j [<jobsnum>]”\n“--jobs[=<jobsnum>]”\n指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-D\nOS中是无用的）\n\n\n“-k”\n“--keep-going”\n出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。\n\n\n\n\n“-l <load>”\n“--load-average[=<load]”\n“—max-load[=<load>]”\n指定make运行命令的负载。\n\n\n“-n”\n“--just-print”\n“--dry-run”\n“--recon”\n仅输出执行过程中的命令序列，但并不执行。\n\n\n“-o <file>”\n“--old-file=<file>”\n“--assume-old=<file>”\n不重新生成的指定的<file>，即使这个目标的依赖文件新于它。\n\n\n“-p”\n“--print-data-base”\n输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -q\np”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用\n这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。\n\n“-q”\n“--question”\n不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。\n\n\n“-r”\n“--no-builtin-rules”\n禁止make使用任何隐含规则。\n\n\n“-R”\n“--no-builtin-variabes”\n禁止make使用任何作用于变量上的隐含规则。\n\n\n“-s”\n“--silent”\n“--quiet”\n在命令运行时不输出命令的输出。\n\n\n“-S”\n“--no-keep-going”\n“--stop”\n取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。\n\n\n“-t”\n“--touch”\n相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。\n\n\n“-v”\n“--version”\n输出make程序的版本、版权等关于make的信息。\n\n\n“-w”\n“--print-directory”\n输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。\n\n\n“--no-print-directory”\n禁止“-w”选项。\n\n\n“-W <file>”\n“--what-if=<file>”\n“--new-file=<file>”\n“--assume-file=<file>”\n假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时\n间为当前时间。\n\n\n“--warn-undefined-variables”\n只要make发现有未定义的变量，那么就输出警告信息。\n\n\n**隐含规则****————**\n\n\n在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。\n\n\n“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就\n不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。\n\n“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。\n\n\n我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保\n证我们Makefile的兼容性。\n我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当\n然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。\n\n\n**一、使用隐含规则**\n\n如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：\n\n\nfoo : foo.o bar.o\ncc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)\n\n\n我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成\n命令。\n\nmake 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：\n\n\nfoo.o : foo.c\ncc –c foo.c $(CFLAGS)\nbar.o : bar.c\ncc –c bar.c $(CFLAGS)\n\n\n因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。\n\n\n当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。\n\n\n还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：\n\n\nfoo.o : foo.p\n\n\n依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成f\noo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。\n\n\n**二、隐含规则一览**\n\n这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。\n\n\n当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统\n定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .\nh, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。\n\n\n还是先来看一看常用的隐含规则吧。\n\n\n1、编译C程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”\n\n\n2、编译C++程序的隐含规则。\n“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而\n不是“.C”）\n\n\n3、编译Pascal程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。\n\n\n4、编译Fortran/Ratfor程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:\n“.f” “$(FC) –c $(FFLAGS)”\n“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”\n“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”\n\n\n5、预处理Fortran/Ratfor程序的隐含规则。\n“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：\n“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”\n“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”\n\n\n6、编译Modula-2程序的隐含规则。\n“<n>.sym” 的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“<n.o>” 的目标的依赖目标会自动推导为“<n>.mod”，\n并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。\n\n\n7、汇编和汇编预处理的隐含规则。\n“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”\n，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。\n\n\n8、链接Object文件的隐含规则。\n“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对\n于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：\n\nx : y.o z.o\n\n\n并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：\n\n\ncc -c x.c -o x.o\ncc -c y.c -o y.o\ncc -c z.c -o z.o\ncc x.o y.o z.o -o x\nrm -f x.o\nrm -f y.o\nrm -f z.o\n\n\n如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。\n\n\n9、Yacc C程序时的隐含规则。\n\n“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）\n\n\n10、Lex C程序时的隐含规则。\n“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）\n\n\n11、Lex Ratfor程序时的隐含规则。\n“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX\n) $(LFALGS)”。\n\n\n12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。\n“<n>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。\n\n\n**三、隐含规则使用的变量**\n\n在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“--no– builtin-variables”参数来取消你所定义的变量\n对隐含规则的作用。\n\n例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把\n变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。\n\n\n我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数\n相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：\n\n\n**1、关于命令的变量。**\n\n\nAR  函数库打包程序。默认命令是“ar”。\nAS\n汇编语言编译程序。默认命令是“as”。\nCC\nC语言编译程序。默认命令是“cc”。\nCXX\nC++语言编译程序。默认命令是“g++”。\nCO\n从 RCS文件中扩展文件程序。默认命令是“co”。\nCPP\nC程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。\nFC\nFortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。\nGET\n从SCCS文件中扩展文件的程序。默认命令是“get”。\nLEX\nLex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。\nPC\nPascal语言编译程序。默认命令是“pc”。\nYACC\nYacc文法分析器（针对于C程序）。默认命令是“yacc”。\nYACCR\nYacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。\nMAKEINFO\n转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。\nTEX\n从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。\nTEXI2DVI\n从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。\nWEAVE\n转换Web到TeX的程序。默认命令是“weave”。\nCWEAVE\n转换C Web 到 TeX的程序。默认命令是“cweave”。\nTANGLE\n转换Web到Pascal语言的程序。默认命令是“tangle”。\nCTANGLE\n转换C Web 到 C。默认命令是“ctangle”。\nRM\n删除文件命令。默认命令是“rm –f”。\n\n\n**2、关于命令参数的变量**\n下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是\n空。\n\n\nARFLAGS\n函数库打包程序AR命令的参数。默认值是“rv”。\nASFLAGS\n汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。\nCFLAGS\nC语言编译器参数。\nCXXFLAGS\nC++语言编译器参数。\nCOFLAGS\nRCS命令参数。\nCPPFLAGS\nC预处理器参数。（ C 和 Fortran 编译器也会用到）。\nFFLAGS\nFortran语言编译器参数。\nGFLAGS\nSCCS “get”程序参数。\nLDFLAGS\n链接器参数。（如：“ld”）\nLFLAGS\nLex文法分析器参数。\nPFLAGS\nPascal语言编译器参数。\nRFLAGS\nRatfor 程序的Fortran 编译器参数。\nYFLAGS\nYacc文法分析器参数。\n\n\n\n**四、隐含规则链**\n\n有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则\n叫做“隐含规则链”。\n\n\n在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调\n用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。\n\n\n我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？\n\n在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。\n\n通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）\n\n\n你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。\n\n\n在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。\n\nMake 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规\n则就不会生成中间文件。\n\n\n\n**五、定义模式规则**\n\n你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有\"%\"字符。\"%\"的意思是表示一个或多个任意字符。在依赖目标中同样可以使用\"%\"，只是依赖目标中的\"%\"的取值，取决于其目标。\n\n有一点需要注意的是，\"%\"的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的\"%\"则发生在运行时。\n\n\n\n**1、模式规则介绍**\n\n\n模式规则中，至少在规则的目标定义中要包含\"%\"，否则，就是一般的规则。目标中的\"%\"定义表示对文件名的匹配，\"%\"表示长度任意的非空字符串。例如：\"%.c\"表示以\".c\"结尾的文件名（文件名的长度至少为3），而\"s.%.c\"则表示以\"s.\"开头，\".c\"结尾的文件名（文件名的长度至少为 5）。\n\n如果\"%\"定义在目标中，那么，目标中的\"%\"的值决定了依赖目标中的\"%\"的值，也就是说，目标中的模式的\"%\"决定了依赖目标中\"%\"的样子。例如有一个模式规则如下：\n\n\n%.o : %.c ; <command ......>\n\n\n其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是\"a.o b.o\"，那么\"%c\"就是\"a.c b.c\"。\n\n\n一旦依赖目标中的\"%\"模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。\n\n**2、模式规则示例**\n\n\n下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.\n\n\n%.o : %.c\n$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@\n\n\n其中，\"$@\"表示所有的目标的挨个值，\"$<\"表示了所有依赖目标的挨个值。这些奇怪的变\n量我们叫\"自动化变量\"，后面会详细讲述。\n\n\n下面的这个例子中有两个目标是模式的：\n\n%.tab.c %.tab.h: %.y\nbison -d $<\n\n\n这条规则告诉make把所有的[.y]文件都以\"bison -d <n>.y\"执行，然后生成\"<n>.tab.c\"和\"<n>.tab.h\"文件。（其中，\"<n>\" 表示一个任意字符串）。如果我们的执行程序\"foo\"依\n赖于文件\"parse.tab.o\"和\"scan.o\"，并且文件\"scan.o\"依赖于文件\"parse.tab.h\"，如果\"parse.y\"文件被更新了，那么根据上述的规则，\"bison -d parse.y\"就会被执行一次，于\n是，\"parse.tab.o\"和\"scan.o\"的依赖文件就齐了。（假设，\"parse.tab.o\" 由\"parse.tab.c\"生成，和\"scan.o\"由\"scan.c\"生成，而\"foo\"由\"parse.tab.o\"和\"scan.o\"链接生成，\n而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）\n\n**3、自动化变量**\n\n在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。\n\n自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。\n\n下面是所有的自动化变量及其说明：\n\n$@\n表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，\"$@\"就是匹配于目标中模式定义的集合。\n\n\n$%\n仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是\"foo.a(bar.o)\"，那么，\"$%\"就是\"bar.o\"，\"$@\"就是\"foo.a\"。如果目标不是函数库文件（Unix下是\n[.a]，Windows下是[.lib]），那么，其值为空。\n\n$<\n依赖目标中的第一个目标名字。如果依赖目标是以模式（即\"%\"）定义的，那么\"$<\"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。\n\n$?\n所有比目标新的依赖目标的集合。以空格分隔。\n\n$^\n所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。\n\n$+\n这个变量很像\"$^\"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。\n\n\n$*\n这个变量表示目标模式中\"%\"及其之前的部分。如果目标是\"dir/a.foo.b\"，并且目标的模式是\"a.%.b\"，那么，\"$*\"的值就是\"dir /a.foo\"。这个变量对于构造有关联的文件名是比\n较有较。如果目标中没有模式的定义，那么\"$*\"也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么\"$*\"就是除了后缀的那一部分。例如：如果目标是\"foo.c\"\n，因为\".c\"是make所能识别的后缀名，所以，\"$*\"的值就是\"foo\"。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用\"$*\"，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么\"$*\"就是空值。\n\n当你希望只对更新过的依赖文件进行操作时，\"$?\"在显式规则中很有用，例如，假设有一个函数库文件叫\"lib\"，其由其它几个object文件更新。那么把object文件打包的比较有效\n率的Makefile规则是：\n\n\nlib : foo.o bar.o lose.o win.o\nar r lib $?\n\n\n在上述所列出来的自动量变量中。四个变量（$@、$<、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上\"D\"或\"F\"字样。这是GNU make中老版本的特性，在新版本中，我们使用函数\"dir\"或\"notdir\"就可以做到了。\"D\"的含义就是Directory，就是目录，\"F\"的含义就是File，就是文件。\n\n\n下面是对于上面的七个变量分别加上\"D\"或是\"F\"的含义：\n\n\n$(@D)\n表示\"$@\"的目录部分（不以斜杠作为结尾），如果\"$@\"值是\"dir/foo.o\"，那么\"$(@D)\"就是\"dir\"，而如果\"$@\"中没有包含斜杠的话，其值就是\".\"（当前目录）。\n\n\n$(@F)\n表示\"$@\"的文件部分，如果\"$@\"值是\"dir/foo.o\"，那么\"$(@F)\"就是\"foo.o\"，\"$(@F)\"相当于函数\"$(notdir $@)\"。\n\n\n\"$(*D)\"\n\"$(*F)\"\n和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，\"$(*D)\"返回\"dir\"，而\"$(*F)\"返回\"foo\"\n\n\n\"$(%D)\"\n\"$(%F)\"\n分别表示了函数包文件成员的目录部分和文件部分。这对于形同\"archive(member)\"形式的目标中的\"member\"中包含了不同的目录很有用。\n\n\n\"$(<D)\"\n\"$(<F)\"\n分别表示依赖文件的目录部分和文件部分。\n\n\n\"$(^D)\"\n\"$(^F)\"\n分别表示所有依赖文件的目录部分和文件部分。（无相同的）\n\n\n\"$(+D)\"\n\"$(+F)\"\n分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）\n\n\n\"$(?D)\"\n\"$(?F)\"\n\n\n分别表示被更新的依赖文件的目录部分和文件部分。\n\n最后想提醒一下的是，对于\"$<\"，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，\"$(< )\"就要比\"$<\"要好一些。\n\n还得要注意的是，这些变量只使用在规则的命令中，而且一般都是\"显式规则\"和\"静态模式规则\"（参见前面\"书写规则\"一章）。其在隐含规则中并没有意义。\n\n\n**4、模式的匹配**\n\n一般来说，一个目标的模式有一个有前缀或是后缀的\"%\"，或是没有前后缀，直接就是一个\"%\"。因为\"%\"代表一个或多个字符，所以在定义好了的模式中，我们把\"%\"所匹配的内容叫做\"茎\"，例如\"%.c\"所匹配的文件\"test.c\"中\"test\"就是\"茎\"。因为在目标和依赖目标中同时有\"%\"时，依赖目标的\"茎\"会传给目标，当做目标中的\"茎\"。\n\n当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行\"茎\"的传递时，我们需要知道这个步骤。例如有一个模式\"e%t\"，文件\"src/eat\" 匹配于该模式，于是\"src/a\"就是其\"茎\"，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式\"c%r\"，那么，目标就是\"src/car\"。（\"茎\"被传递）\n\n**5、重载内建隐含规则**\n\n\n你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：\n\n\n%.o : %.c\n$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)\n\n\n你可以取消内建的隐含规则，只要不在后面写命令就行。如：\n\n\n%.o : %.s\n\n\n同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。\n\n\n**六、老式风格的\"后缀规则\"**\n\n后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：\"双后缀\"和\"单后缀\"。\n\n双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如\".c.o\"相当于\"%o : %c\"。单后缀规则只定义一个后缀，也就是源文件的后缀。如\".c\"相当于\"% : %.c\"。\n\n\n后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：\".c\"和\".o\"都是make所知道。因而，如果你定义了一个规则是\".c.o\"那么其就是双后缀规则，意义就是\".c\" 是源文件的后缀，\".o\"是目标文件的后缀。如下示例：\n\n\n.c.o:\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n\n后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：\n\n\n.c.o: foo.h\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n\n这个例子，就是说，文件\".c.o\"依赖于文件\"foo.h\"，而不是我们想要的这样：\n\n%.o: %.c foo.h\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n\n后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。\n\n\n而要让make知道一些特定的后缀，我们可以使用伪目标\".SUFFIXES\"来定义或是删除，如：\n\n\n.SUFFIXES: .hack .win\n\n\n把后缀.hack和.win加入后缀列表中的末尾。\n\n\n.SUFFIXES: # 删除默认的后缀\n.SUFFIXES: .c .o .h # 定义自己的后缀\n\n\n先清楚默认后缀，后定义自己的后缀列表。\n\n\nmake的参数\"-r\"或\"-no-builtin-rules\"也会使用得默认的后缀列表为空。而变量\"SUFFIXE\"被用来定义默认的后缀列表，你可以用\".SUFFIXES\"来改变后缀列表，但请不要改变变量\"SUFFIXE\"的值。\n\n\n\n**七、隐含规则搜索算法**\n比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是\"archive(member)\"的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把\"member\"当作T来搜索。\n\n\n1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是\"src/foo.o\"，那么，D就是\"src/\"，N就是\"foo.o\"）2、创建所有匹配于T或是N的模式规则列表。3、如果在模式规则列表中有匹配所有文件的模式，如\"%\"，那么从列表中移除其它的模式。4、移除列表中没有命令的规则。5、对于第一个在列表中的模式规则：\n1）推导其\"茎\"S，S应该是T或是N匹配于模式中\"%\"非空的部分。2）计算依赖文件。把依赖文件中的\"%\"都替换成\"茎\"S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫\"理当存在\"）4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该[算法](http://lib.csdn.net/base/datastructure)。6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：1）如果规则是终止规则，那就忽略它，继续下一条模式规则。2）计算依赖文件。（同第5步）3）测试所有的依赖文件是否存在或是理当存在。4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。7、如果没有隐含规则可以使用，查看\".DEFAULT\"规则，如果有，采用，把\".DEFAULT\"的命令给T使用。\n\n一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。\n\n\n\n\n**使用make更新函数库文件****———————————**\n\n\n函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令\"ar\"来完成打包工作。\n\n\n**一、函数库文件的成员**\n\n一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：\n\n\narchive(member)\n\n\n这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了\"ar\"命令来服务的。如：\n\nfoolib(hack.o) : hack.o\nar cr foolib hack.o\n\n\n如果要指定多个member，那就以空格分开，如：\n\n\nfoolib(hack.o kludge.o)\n\n\n其等价于：\n\n\nfoolib(hack.o) foolib(kludge.o)\n\n\n你还可以使用Shell的文件通配符来定义，如：\n\nfoolib(*.o)\n\n\n**二、函数库成员的隐含规则**\n\n当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是\"a(m)\"形式的，其会把目标变成\"(m)\"。于是，如果我们的成员是\"%.o\" 的模式定义，并且如果我们使用\"make foo.a(bar.o)\"的形式调用Makefile时，隐含规则会去找\"bar.o\"的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：\n\n\ncc -c bar.c -o bar.o\nar r foo.a bar.o\nrm -f bar.o\n\n\n还有一个变量要注意的是\"$%\"，这是专属函数库文件的自动化变量，有关其说明请参见\"自动化变量\"一节。\n\n\n\n**三、函数库文件的后缀规则**\n\n你可以使用\"后缀规则\"和\"隐含规则\"来生成函数库打包文件，如：\n\n\n.c.a:\n$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o\n$(AR) r $@ $*.o\n$(RM) $*.o\n\n\n其等效于：\n\n\n(%.o) : %.c\n$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o\n$(AR) r $@ $*.o\n$(RM) $*.o\n\n\n**四、注意事项**\n\n在进行函数库打包文件生成时，请小心使用make的并行机制（\"-j\"参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。\n但就目前而言，你还是应该不要尽量不要使用\"-j\"参数。\n\n\n\n**后序****——**\n\n\n终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测\"函数\"那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）\"杀伤力\"。\n\n\n对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp……等等，等等，来完成诸如\"程序打包\"、\"程序备份\"、\"制作程序安装包\"、\"提交代码\"、\"使用程序模板\"、\"合并文件\"等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如\"@@@N、###N\"奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的\"@@@N、###N\"等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的\"扩展C\"语言（即在C语言中用\"EXEC　SQL\"的样子执行SQL语句，在用 cc/gcc编译之前，需要使用\"扩展C\"的翻译程序，如cpre，把其翻译成标准C）。如果\n你在使用make时有一些更为绝妙的方法，请记得告诉我啊。\n\n回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入\"!make\"时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。\n\n\n现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的 Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。\n\n最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命——网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在“技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。我的MSN是：haoel@hotmail.com（常用），QQ是：753640（不常用）。（注：请勿给我MSN的邮箱发信，由于hotmail的垃圾\n邮件导致我拒收这个邮箱的所有来信）\n\n\n我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！\n\n\n最最后，我还想介绍一下make程序的设计开发者。\n\n首当其冲的是： Richard Stallman\n\n开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：http://www.stallman.org/ 。\n第二位是：Roland McGrath\n个人主页是：http://www.frob.com/~roland/ ，下面是他的一些事迹：\n\n1） 合作编写了并维护GNU make。2） 和Thomas Bushnell一同编写了GNU Hurd。3） 编写并维护着GNU C library。4） 合作编写并维护着部分的GNU Emacs。\n在此，向这两位开源项目的斗士致以最真切的敬意。","source":"_posts/linux_md/Makefile/Makefile基础.md","raw":"---\ntitle: Makefile基础\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 个人项目\nabbrlink: 13012\ncover: \n---\n# Makefile基础\n\n> 什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不得不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。**make是一个命令工具，是一个解释makefile中指令的命令工具**，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。\n\n------\n\n现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat **linux** 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。  在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。\n\n## **1. 关于程序的编译和链接**   \n\n在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是passical，首先要把源文件编译成**中间代码文件**，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做***\\*编译\\**（compile）**。然后再把大量的Object File合成执行文件，这个动作叫作**链接**（link）。\n\n**编译时**，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。\n\n**链接时**，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，**我们要给中间目标文件打个包**，在Windows下这种包叫“**库文件”（Library File)**，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。\n\n总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，**编译器只检测程序语法，和函数、变量是否被声明**。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.\n\n好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。\n\n## **2. Makefile 介绍**   \n\nmake命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。   首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。如果这个工程的**头文件**被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。   只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动**智能**地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。\n\n### **2.1 Makefile的规则**   \n\n在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。\n\n```makefile\ntarget... : prerequisites ...\ncommand\n...\n...\n```\n\n- **target**：目标文件，可以是**Object File**，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。\n\n* **prerequisites**：要生成那个target所需要的文件或是目标。    \n\n* **command**：make需要执行的命令。（任意的Shell命令）\n\n这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。    说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）\n\n### **2.2 一个示例**\n\n正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。\n\n```makefile\nedit : main.o kbd.o command.o display.o \\\n       insert.o search.o files.o utils.o\n       cc -o edit main.o kbd.o command.o display.o \\\n                  insert.o search.o files.o utils.o\n\nmain.o : main.c defs.h\n         cc -c main.c\nkbd.o : kbd.c defs.h command.h\n        cc -c kbd.c\ncommand.o : command.c defs.h command.h\n            cc -c command.c\ndisplay.o : display.c defs.h buffer.h\n            cc -c display.c\ninsert.o : insert.c defs.h buffer.h\n           cc -c insert.c\nsearch.o : search.c defs.h buffer.h\n           cc -c search.c\nfiles.o : files.c defs.h buffer.h command.h\n           cc -c files.c\nutils.o : utils.c defs.h\n           cc -c utils.c\nclean :\n        rm edit main.o kbd.o command.o display.o \\\n                insert.o search.o files.o utils.o\n```\n\n**反斜杠（\\）**是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。\n\n在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。*\n\n在定义好依赖关系后，后续的那一行定义了如何生成目标文件的**操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令**。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。\n\n**这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像**C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。\n\n### **2.3 make是如何工作的**\n\n在默认的方式下，也就是我们只输入make命令。那么:\n\n- make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 \n\n* 如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 \n\n* 如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 \n\n* 如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。\n\n* 当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。  \n\n这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。\n\n通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——**“make clean”，以此来清除所有的目标文件，以便重编译**。\n\n于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。\n\n### **2.4 makefile中使用变量**\n\n 在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$<”、“$@”等，这些是自动化变量，我会在后面介绍。\n\n#### 2.4.1 变量的基础\n\n变量在声明时需要给予初值，而在使用时，需要给在变量名前**加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来**。如果你要使用真实的“$”字符，那么你需要用“$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：\n\n```\nobjects = program.o foo.o utils.o\nprogram : $(objects)\ncc -o program $(objects)\n$(objects) : defs.h\n```\n\n变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：\n\n```\nfoo = c\nprog.o : prog.$(foo)\n$(foo)$(foo) -$(foo) prog.$(foo)\n```\n\n展开后得到：\n\n```makefile\nprog.o : prog.c\n\t\tcc -c prog.c\n```\n\n当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。\n\n#### 2.4.2 **变量中的变量**\n\n在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：\n\n```makefile\nfoo = $(bar)\nbar = $(ugh)\nugh = Huh?\nall:\necho $(foo)\n```\n\n我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。\n\n这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：\n\n```makefile\nCFLAGS = $(include_dirs) -O\ninclude_dirs = -Ifoo -Ibar\n```\n\n当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：\n\n`CFLAGS = $(CFLAGS) -O`\n\n或：\n\nA = $(B)\n\nB = $(A)\n\n这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。\n\n为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：\n\n```makefile\nx := foo\ny := $(x) bar\nx := later\n```\n\n其等价于：\n\n```makefile\ny := foo bar\nx := later\n```\n\n值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：\n\n```\ny := $(x) bar\nx := foo\n```\n\n那么，y的值是“bar”，而不是“foo bar”。\n\n在上面的例子中，先让我们看看edit的规则：   \n\n```makefile\nedit : main.o kbd.o command.o display.o \\\n       insert.o search.o files.o utils.o\n       cc -o edit main.o kbd.o command.o display.o \\\n       insert.o search.o files.o utils.o\n```\n\n我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成**c语言**中的宏可能会更好。\n\n比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.o search.o files.o utils.o\n```\n\n于是，我们就可以很方便地在我们的makefile中以**“$(objects)”**的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.osearch.o files.o utils.o\nedit : $(objects)\n\t   cc -o edit $(objects)\nmain.o : main.c defs.h\n\t     cc -c main.c\nkbd.o : kbd.c defs.h command.h\n\t    cc -c kbd.c\ncommand.o : command.c defs.h command.h\n\t        cc -c command.c\ndisplay.o : display.c defs.h buffer.h\n            cc -c display.c\ninsert.o : insert.c defs.h buffer.h\n           cc -c insert.c\nsearch.o : search.c defs.h buffer.h\n           cc -c search.c\nfiles.o : files.c defs.h buffer.h command.h\n          cc -c files.c\nutils.o : utils.c defs.h\n          cc -c utils.c\nclean :\n        rm edit $(objects)\n```\n\n于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。关于变量更多的话题，我会在后续给你一一道来。\n\n### **2.5 让make自动推导** \n\nGNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。\n\n只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。\n\nMakefile中把那些没有任何依赖只有执行动作的目标成为“伪目标”(phony targets)。\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.o search.o files.o utils.o\n\nedit : $(objects)\n       cc -o edit $(objects)\n\nmain.o : defs.h\nkbd.o : defs.h command.h\ncommand.o : defs.h command.h\ndisplay.o : defs.h buffer.h\ninsert.o : defs.h buffer.h\nsearch.o : defs.h buffer.h\nfiles.o : defs.h buffer.h command.h\nutils.o : defs.h\n\n.PHONY : clean\nclean :\n        rm edit $(objects)\n```\n\n这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。\n\n### **2.6 另类风格的makefile**  \n\n即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。\n\n```makefile\nobjects = main.o kbd.o command.o display.o \\\n          insert.o search.o files.o utils.o\n\nedit : $(objects)\n       cc -o edit $(objects)\n\n$(objects) : defs.h\nkbd.o command.o files.o : command.h\ndisplay.o insert.o search.o files.o : buffer.h\n\n.PHONY : clean\nclean :\n        rm edit $(objects)\n```\n\n这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。\n\n### **2.7 清空目标文件的规则**   \n\n每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：    \n\n```makefile\nclean:\n      rm edit $(objects)\n```\n\n更为稳健的做法是：\n\n```makefile\n.PHONY : clean\nclean :\n        -rm edit $(objects)\n```\n\n前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。\n\n## **3. Makefile 总述**\n\n### **3.1 Makefile里有什么？**\n\n**Makefile里主要包含了**五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。\n\n* 显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。\n\n* 隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。\n\n* 变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。\n\n* 文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 \n\n* 注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“\\#”。\n\n**最后，还值得一提的是，**在Makefile中的命令，必须要以[Tab]键开始。**   **----------注意是tab键，不是8个空格**\n\n### **3.2 Makefile的文件名**    \n\n默认的情况下，make命令会在当前目录下按顺序找寻文件名为**“GNUmakefile”、“makefile”、“Makefile”**的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“**makefile”和“Makefile”**这两种默认文件名。   \n\n当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要**指定特定的Makefile，你可以使用make的“-f”和“--file”参数**，如：make -f Make.Linux或make --file Make.AIX。\n\n### **3.3 引用其它的Makefile**  \n\n在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：\n\n```makefile\ninclude <filename> filename\n```\n\n可以是当前操作系统Shell的文件模式（可以保含路径和通配符）   \n\n**在include前面可以有一些空字符，**但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。**举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：   **\n\n```makefile\ninclude foo.make *.mk $(bar)\n```\n\n等价于：   \n\n```makefile\ninclude foo.make a.mk b.mk c.mk e.mk f.mk\n```\n\nmake命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：\n\n* 如果make执行时，有“-I”或“--include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。\n\n* 如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。   \n\n如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：\n\n```\n-include <filename>\n```\n\n其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。\n\n### **3.4 环境变量 MAKEFILES**   \n\n如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。\n\n但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。\n\n### **3.5 make的工作方式**\n\nGNU的make工作时的执行步骤入下：（想来其它的make也是类似）\n\n1. 读入所有的Makefile。\n\n2. 读入被include的其它Makefile。\n\n3. 初始化文件中的变量。\n\n4. 推导隐晦规则，并分析所有规则。\n\n5. 为所有的目标文件创建依赖关系链。\n\n6. 根据依赖关系，决定哪些目标要重新生成。\n\n7. 执行生成命令。   \n\n1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，\n\n**make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。\n\n## **4. Makefile书写规则**   \n\n规则包含两个部分，一个是**依赖关系**，一个是**生成目标的方法**。   \n\n**在Makefile中，规则的顺序是很重要的**，因为，**Makefile中应该****只有一个最终目标**，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。**\n\n好了，还是让我们来看一看如何书写规则。\n\n### **4.1 规则举例** \n\n```makefile\nfoo.o: foo.c defs.h               # foo模块\n       cc -c -g foo.c             # -c 表示只编译不链接， -g 表示带调试信息\n```\n\n看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令`` cc -c -g foo.c``（以Tab键开头）。这个规则告诉我们两件事：\n\n* 文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。\n* 如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）\n\n### **4.2 规则的语法**   \n\n```makefile\ntargets : prerequisites    \n\tcommand    \n\t...\n```\n\n或是这样：  \n\n```makefile\n targets : prerequisites ; command      \n \tcommand      \n \t... \n```\n\ntargets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。   \n\ncommand是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）   \n\nprerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。   \n\n如果命令太长，你可以使用反斜框（‘\\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。   \n\n一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。\n\n### **4.3 在规则中使用通配符**   \n\n如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“*”，“?”和“[...]”。这是和Unix的B-Shell是相同的。*\n\n**\"~\"**   \n\n波浪号（“~”）字符在文件名中也有比较特殊的用途。如果是“~/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。\n\n**\"\\*\"**   \n\n*\\**通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“*”，那么可以用转义字符“\\”，如“\\*”来表示真实的“*”字符，而不是任意长度的字符串。\n\n好吧，还是先来看几个例子吧：\n\n```makefile\n clean:    \n \trm -f *.o\n```\n\n上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。\n\n```makefile\nprint: *.c    \n\tlpr -p $?    \n\ttouch print\n```\n\n上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。  \n\n`objects = *.o`上面这个例子，表示了，通符同样可以用在变量中。并不是说[*.o]会展开，不！**objects的值就是“\\*.o”**。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：  \n\n`objects := $(wildcard *.o)`\n\n这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。\n\n### **4.4 文件搜寻**\n\n 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。   \n\nMakefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。  \n\n`VPATH = src:../headers`   \n\n上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）   \n\n另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：\n\n* vpath < pattern> < directories>       为符合模式< pattern>的文件指定搜索目录<directories>。\n\n* vpath < pattern>                                清除符合模式< pattern>的文件的搜索目录。\n\n* vpath                                                   清除所有已被设置好了的文件搜索目录。   \n\nvapth使用方法中的< pattern>需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。< pattern>指定了要搜索的文件集，而< directories>则指定了的文件集的搜索的目录。例如：  \n\n`vpath %.h ../headers`\n\n该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）\n\n我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的< pattern>，或是被重复了的< pattern>，那么，make会按照vpath语句的先后顺序来执行搜索。如：\n\n```makefile\nvpath %.c foo  \nvpath %  blish  \nvpath %.c bar\n```\n\n其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。  \n\n```makefile\nvpath %.c foo:bar  \nvpath %  blish\n```\n\n而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。\n\n### **4.5 伪目标**\n\n最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，  \n\n```makefile\nclean:      \n\t\trm *.o temp\n```\n\n正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）\n\n因为，我们并不生成“clean”这个文件。**“伪目标”并不是一个文件，只是一个标签**，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。\n\n当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 \n\n` .PHONY : clean`\n\n只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：\n\n```makefile\n .PHONY: clean  \n clean:\n \t\trm *.o temp\n```\n\n伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：\n\n```makefile\nall : prog1 prog2 prog3  \n.PHONY : all\nprog1 : prog1.o utils.o      \n\t\tcc -o prog1 prog1.o utils.o\nprog2 : prog2.o      \n\t\tcc -o prog2 prog2.o\nprog3 : prog3.o sort.o utils.o      \t\n\t\tcc -o prog3 prog3.o sort.o utils.o\n```\n\n我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。\n\n随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：  \n\n```makefile\n.PHONY: cleanall cleanobj cleandiff\n\ncleanall : cleanobj cleandiff      \n\t\trm program\ncleanobj :      \n\t\trm *.o\ncleandiff :      \n\t\trm *.diff*\n```\n\n`makeclean`将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的\n\n### **4.6 多目标**\n\nMakefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。\n\n```makefile\nbigoutput littleoutput : text.g      \n\t\tgenerate text.g -$(subst output,,$@) > $@  \n```\n\n上述规则等价于：\n\n```makefile\nbigoutput : text.g      \n\t\tgenerate text.g -big > bigoutput  \nlittleoutput : text.g      \n\t\tgenerate text.g -little > littleoutput\n```\n\n其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。\n\n### **4.7 静态模式**\n\n静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：\n\n```makefile\n<targets...>: <target-pattern>: <prereq-patterns ...>　　　\n\t\t<commands>\n\t\t...\n```\n\ntargets定义了一系列的目标文件，可以有通配符。是目标的一个集合。\n\ntarget-parrtern是指明了targets的模式，也就是的目标集模式。\n\nprereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。\n\n所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\\”进行转义，来标明真实的“%”字符。\n\n看一个例子：  \n\n```makefile\nobjects = foo.o bar.o\nall: $(objects)\n$(objects): %.o: %.c      \n\t\t$(CC) -c $(CFLAGS) $< -o $@\n```\n\n上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$<”和“$@”则是自动化变量，“$<”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：  \n\n```makefile\nfoo.o : foo.c      \n\t\t$(CC) -c $(CFLAGS) foo.c -o foo.o  \nbar.o : bar.c      \n\t\t$(CC) -c $(CFLAGS) bar.c -o bar.o\n```\n\n试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：\n\n```makefile\nfiles = foo.elc bar.o lose.o\n$(filter %.o,$(files)): %.o: %.c      \n\t\t$(CC) -c $(CFLAGS) $< -o $@  \n$(filter %.elc,$(files)): %.elc: %.el      \n\t\temacs -f batch-byte-compile $<\n```\n\n$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。\n\n### **3.8 自动生成依赖性**\n\n在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include \"defs.h\"”，那么我们的依赖关系应该是：  \n\n`main.o : main.c defs.h`\n\n但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：  \n\n`cc -M main.c`\n\n其输出是：  \n\n`main.o : main.c defs.h`\n\n于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。\n\ngcc-M main.c的输出是：  \n\n```makefile\nmain.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\\n\t/usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \\\n\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \\\n\t/usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \\\n\t/usr/include/bits/sched.h /usr/include/libio.h \\\n\t/usr/include/_G_config.h /usr/include/wchar.h \\\n\t/usr/include/bits/wchar.h /usr/include/gconv.h \\\n\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \\\n\t/usr/include/bits/stdio_lim.h\n```\n\ngcc-MM main.c的输出则是：  \n\n`main.o: main.c defs.h`\n\n那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。\n\n于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。\n\n这里，我们给出了一个模式规则来产生[.d]文件：\n\n```makefile\n%.d: %.c      \n\t\t@set -e; rm -f $@; \\      \n\t\t$(CC) -M $(CPPFLAGS) $< > $@.\n\t\t\n; \\      \n\t\tsed 's,\n$∗\n\\.o[ :]*,\\1.o $@ : ,g' < $@.\n\n\\> $@; \\      \n\t\trm -f $@.\n```\n\n这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm-f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$<”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，\n\n“”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。\n\n总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： \n\n`main.o : main.c defs.h`\n\n转成：\n\n`main.o main.d : main.c defs.h`\n\n于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：\n\n```makefile\nsources = foo.c bar.c\ninclude $(sources:.c=.d)\n```\n\n上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标\n\n## **5. Makefile 书写命令**   \n\n每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。\n\n### **5.1 显示命令**\n\n通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“**@**”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如： \n\n == **@符号： 不显示编译回显**==  \n\n`@echo 正在编译XXX模块......`\n\n当make执行时，会输出“正在编译XXX模块......”字串，但不会输出命令，如果没有“@”，那么，make将输出： \n\n```\necho 正在编译XXX模块......  \n正在编译XXX模块......\n```\n\n如果make执行时，带入make参数“-n”或“--just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。\n\n而make参数“-s”或“--slient”则是全面禁止命令的显示。\n\n### **5.2 命令执行**\n\n当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：  \n\n示例一：    \n\n```makefile\nexec:        \n\t\tcd /home/hchen        \n\t\tpwd\n```\n\n示例二：    \n\n```makefile\nexec:        \n\t\tcd /home/hchen; pwd\n```\n\n当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。\n\n### **5.3 命令出错**   \n\n每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。\n\n有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。\n\n为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： \n\n```makefile\nclean:      \n\t\t-rm -f *.o\n```\n\n还有一个全局的办法是，给make加上“-i”或是“--ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。\n\n还有一个要提一下的make的参数的是“-k”或是“--keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。\n\n### **5.4 嵌套执行make**    \n\n在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。\n例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：\n\n```makefile\nsubsystem:      \n\t\tcd subdir && $(MAKE)\n```\n\n其等价于：   \n\n```makefile\nsubsystem:      \n\t\t$(MAKE) -C subdir\n```\n\n定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。\n\n如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：\n\n`export<variable ...>`\n\n如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：\n\n`unexport<variable ...>`\n\n如示例一：     \n\n`export variable = value`\n\n其等价于：     \n\n```makefile\nvariable = value    \nexport variable\n```\n\n其等价于：     \n\n`export variable := value`\n\n其等价于：\n\n```makefile\nvariable := value    \nexport variable\n```\n\n示例二：\n`export variable += value`     \n\n其等价于：\n\n```makefile\nvariable += value    \nexport variable\n```\n\n如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。\n\n需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。\n\n但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：\n\n```makefile\nsubsystem:      \n\t\tcd subdir && $(MAKE) MAKEFLAGS=\n```\n\n如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。还有一个在“嵌套执行”中比较有用的参数，“-w”或是“--print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：\n\n`make: Entering directory '/home/hchen/gnu/make'`\n\n而在完成下层make后离开目录时，我们会看到：\n\n`make: Leaving directory '/home/hchen/gnu/make'`\n\n当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“--slient”）或是“--no-print-directory”，那么，“-w”总是失效的。\n\n### **5.5 定义命令包**\n\n如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：  \n\n```makefile\ndefine run-yacc  \nyacc $(firstword $^)  \nmv y.tab.c $@  \nendef\n```\n\n这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。  \n\n```makefile\nfoo.c : foo.y      \n\t\t$(run-yacc)\n```\n\n我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。\n\n------\n\n **使用变量**————    在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$<”、“$@”等，这些是自动化变量，我会在后面介绍。\n**一、变量的基础**  变量在声明时需要给予初值，而在使用时，需要给在变量名前**加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来**。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：objects = program.o foo.o utils.oprogram : $(objects)cc -o program $(objects)$(objects) : defs.h变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：foo = cprog.o : prog.$(foo)$(foo)$(foo) -$(foo) prog.$(foo)展开后得到：prog.o : prog.ccc -c prog.c当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。\n\n**二、变量中的变量**在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：foo = $(bar)bar = $(ugh)ugh = Huh?all:echo $(foo)我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：CFLAGS = $(include_dirs) -Oinclude_dirs = -Ifoo -Ibar当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：CFLAGS = $(CFLAGS) -O或：A = $(B)B = $(A)这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：x := fooy := $(x) barx := later其等价于：y := foo barx := later值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：y := $(x) barx := foo那么，y的值是“bar”，而不是“foo bar”。上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：ifeq (0,${MAKELEVEL})cur-dir := $(shell pwd)whoami := $(shell whoami)host-type := $(shell arch)MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}endif关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：nullstring :=space := $(nullstring) # end of the linenullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：dir := /foo/bar # directory to put the frobs indir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。还有一个比较有用的操作符是“?=”，先看示例：FOO ?= bar其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：ifeq ($(origin FOO), undefined)FOO = barendif\n**三、变量高级用法**这里介绍两种变量的高级使用方法，第一种是**变量值的替换**。我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。还是看一个示例吧：foo := a.o b.o c.obar := $(foo:.o=.c)这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：foo := a.o b.o c.obar := $(foo:%.o=%.c)这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。\n第二种高级用法是——“把**变量的值再当成变量**”。先看一个例子：x = yy = za := $($(x))在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）我们还可以使用更多的层次：x = yy = zz = ua := $($($(x)))这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：x = $(y)y = zz = Helloa := $($(x))这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。再复杂一点，我们再加上函数：x = variable1variable2 := Helloy = $(subst 1,2,$(x))z = ya := $($($(z)))这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：first_second = Helloa = firstb = secondall = $($a_$b)这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。再来看看结合第一种技术的例子：a_objects := a.o b.o c.o1_objects := 1.o 2.o 3.osources := $($(a1)_objects:.o=.c)这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。再来看一个这种技术和“函数”与“条件语句”一同使用的例子：ifdef do_sortfunc := sortelsefunc := stripendifbar := a d b g q cfoo := $($(func) $(bar))这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d bg q c)，调用的就是strip函数。当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：dir = foo$(dir)_sources := $(wildcard $(dir)/*.c)define $(dir)_printlpr $($(dir)_sources)endef这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。\n**四、追加变量值**\n\n我们可以使用“+=”操作符给变量追加值，如：\n\n\nobjects = main.o foo.o bar.o utils.o\nobjects += another.o\n\n于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）\n\n使用“+=”操作符，可以模拟为下面的这种例子：\n\n\nobjects = main.o foo.o bar.o utils.o\nobjects := $(objects) another.o\n\n\n所不同的是，用“+=”更为简洁。\n\n\n如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：\n\nvariable := value\nvariable += more\n\n\n等价于：\n\n\nvariable := value\nvariable := $(variable) more\n\n\n但如果是这种情况：\n\n\nvariable = value\nvariable += more\n\n\n由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。\n\n\n**五、override 指示符**\n\n如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：\n\noverride <variable> = <value>\noverride <variable> := <value>\n\n\n当然，你还可以追加：\n\n\noverride <variable> += <more text>\n\n\n对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：\n\n\noverride define foo\nbar\nendef\n\n\n**六、多行变量**\n\n还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。\n\ndefine 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。\n\n下面的这个示例展示了define的用法：\n\n\ndefine two-lines\necho foo\necho $(bar)\nendef\n\n\n**七、环境变量**\n\nmake 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）\n\n因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。   当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）\n\n  当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。\n\n\n\n\n**八、目标变量**\n\n前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$<”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。\n\n当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。\n\n其语法是：\n\n\n<target ...> : <variable-assignment>\n\n\n<target ...> : overide <variable-assignment>\n\n\n<variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。\n\n这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：\n\nprog : CFLAGS = -g\nprog : prog.o foo.o bar.o\n$(CC) $(CFLAGS) prog.o foo.o bar.o\n\n\nprog.o : prog.c\n$(CC) $(CFLAGS) prog.c\n\n\nfoo.o : foo.c\n$(CC) $(CFLAGS) foo.c\n\n\nbar.o : bar.c\n$(CC) $(CFLAGS) bar.c\n\n\n在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”\n\n\n\n\n**九、模式变量**\n\n在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。\n\n我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：\n\n\n%.o : CFLAGS = -O\n\n\n同样，模式变量的语法和“目标变量”一样：\n\n\n<pattern ...> : <variable-assignment>\n\n\n<pattern ...> : override <variable-assignment>\n\n\noverride同样是针对于系统环境传入的变量，或是make命令行指定的变量。\n\n\n**使用条件判断**——————使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。\n\n一、示例\n\n\n下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。\n\n\nlibs_for_gcc = -lgnu\nnormal_libs =\n\n\nfoo: $(objects)\nifeq ($(CC),gcc)\n$(CC) -o foo $(objects) $(libs_for_gcc)\nelse\n$(CC) -o foo $(objects) $(normal_libs)\nendif\n\n\n可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。\n\n我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。\n\n当我们的变量$(CC)值是“gcc”时，目标foo的规则是：\n\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(libs_for_gcc)\n\n\n而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(normal_libs)\n\n\n当然，我们还可以把上面的那个例子写得更简洁一些：\n\n\nlibs_for_gcc = -lgnu\nnormal_libs =\n\n\nifeq ($(CC),gcc)\nlibs=$(libs_for_gcc)\nelse\nlibs=$(normal_libs)\nendif\n\n\nfoo: $(objects)\n$(CC) -o foo $(objects) $(libs)\n\n\n\n\n二、语法\n\n\n条件表达式的语法为：\n\n\n<conditional-directive>\n<text-if-true>\nendif\n\n\n以及：\n\n\n<conditional-directive>\n<text-if-true>\nelse\n<text-if-false>\nendif\n\n\n其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。\n\n第一个是我们前面所见过的“ifeq”\n\n\nifeq (<arg1>, <arg2> )\nifeq '<arg1>' '<arg2>'\nifeq \"<arg1>\" \"<arg2>\"\nifeq \"<arg1>\" '<arg2>'\nifeq '<arg1>' \"<arg2>\"\n\n\n比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：\n\n\nifeq ($(strip $(foo)),)\n<text-if-empty>\nendif\n\n\n这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。\n\n第二个条件关键字是“ifneq”。语法是：\n\n\nifneq (<arg1>, <arg2> )\nifneq '<arg1>' '<arg2>'\nifneq \"<arg1>\" \"<arg2>\"\nifneq \"<arg1>\" '<arg2>'\nifneq '<arg1>' \"<arg2>\"\n\n\n其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。\n\n\n\n\n第三个条件关键字是“ifdef”。语法是：\n\n\nifdef <variable-name>\n\n\n如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：\n\n\n示例一：\nbar =\nfoo = $(bar)\nifdef foo\nfrobozz = yes\nelse\nfrobozz = no\nendif\n\n\n示例二：\nfoo =\nifdef foo\nfrobozz = yes\nelse\nfrobozz = no\nendif\n\n\n第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。\n\n\n第四个条件关键字是“ifndef”。其语法是：\n\n\nifndef <variable-name>\n\n\n这个我就不多说了，和“ifdef”是相反的意思。\n\n\n在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也\n一样，只要不是以[Tab]键开始就行了。\n\n特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。\n\n而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。\n\n\n\n\n\n**使用函数****————**在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。**一、函数的调用语法**函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：\n\n\n$(<function> <arguments> )\n\n\n或是\n\n\n${<function> <arguments>}\n\n\n这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。\n\n\n还是来看一个示例：\n\n\ncomma:= ,\nempty:=\nspace:= $(empty) $(empty)\nfoo:= a b c\nbar:= $(subst $(space),$(comma),$(foo))\n\n\n在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“\na,b,c”。\n\n**二、字符串处理函数**\n\n$(subst <from>,<to>,<text> )\n\n\n名称：字符串替换函数——subst。\n功能：把字串<text>中的<from>字符串替换成<to>。\n返回：函数返回被替换过后的字符串。\n\n\n示例：\n\n\n$(subst ee,EE,feet on the street)，\n\n\n把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt\n”。\n\n\n\n\n$(patsubst <pattern>,<replacement>,<text> )\n\n\n名称：模式字符串替换函数——patsubst。\n功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。\n\n\n示例：\n\n\n$(patsubst %.c,%.o,x.c.c bar.c)\n\n\n把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”\n\n\n备注：\n\n\n这和我们前面“变量章节”说过的相关知识有点相似。如：\n\n\n“$(var:<pattern>=<replacement> )”\n相当于\n“$(patsubst <pattern>,<replacement>,$(var))”，\n\n\n而“$(var: <suffix>=<replacement> )”\n则相当于\n“$(patsubst %<suffix>,%<replacement>,$(var))”。\n\n\n例如有：objects = foo.o bar.o baz.o，\n那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。\n\n\n$(strip <string> )\n\n\n名称：去空格函数——strip。\n功能：去掉<string>字串中开头和结尾的空字符。\n返回：返回被去掉空格的字符串值。\n示例：\n\n\n$(strip a b c )\n\n\n把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。\n\n\n$(findstring <find>,<in> )\n\n\n名称：查找字符串函数——findstring。\n功能：在字串<in>中查找<find>字串。\n返回：如果找到，那么返回<find>，否则返回空字符串。\n示例：\n\n\n$(findstring a,a b c)\n$(findstring a,b c)\n\n\n第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）\n\n\n$(filter <pattern...>,<text> )\n\n\n名称：过滤函数——filter。\n功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可\n以有多个模式。\n返回：返回符合模式<pattern>的字串。\n示例：\n\n\nsources := foo.c bar.c baz.s ugh.h\nfoo: $(sources)\ncc $(filter %.c %.s,$(sources)) -o foo\n\n\n$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。\n\n\n$(filter-out <pattern...>,<text> )\n\n\n名称：反过滤函数——filter-out。\n功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可\n以有多个模式。\n返回：返回不符合模式<pattern>的字串。\n示例：\n\n\nobjects=main1.o foo.o main2.o bar.o\nmains=main1.o main2.o\n\n\n$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。\n\n\n$(sort <list> )\n\n\n名称：排序函数——sort。\n功能：给字符串<list>中的单词排序（升序）。\n返回：返回排序后的字符串。\n示例：$(sort foo bar lose)返回“bar foo lose” 。\n备注：sort函数会去掉<list>中相同的单词。\n\n\n$(word <n>,<text> )\n\n\n名称：取单词函数——word。\n功能：取字符串<text>中第<n>个单词。（从一开始）\n返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空\n字符串。\n示例：$(word 2, foo bar baz)返回值是“bar”。\n\n\n$(wordlist <s>,<e>,<text> )\n\n\n名称：取单词串函数——wordlist。\n功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。\n返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那\n么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单\n词串。\n示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。\n\n\n$(words <text> )\n\n\n名称：单词个数统计函数——words。\n功能：统计<text>中字符串中的单词个数。\n返回：返回<text>中的单词数。\n示例：$(words, foo bar baz)返回值是“3”。\n备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text>\n),<text> )。\n\n\n$(firstword <text> )\n\n\n名称：首单词函数——firstword。\n功能：取字符串<text>中的第一个单词。\n返回：返回字符串<text>的第一个单词。\n示例：$(firstword foo bar)返回值是“foo”。\n备注：这个函数可以用word函数来实现：$(word 1,<text> )。\n\n\n以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，\n举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索\n路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，\n如：\n\n\noverride CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))\n\n\n如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :\n, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数\n。\n\n\n**三、文件名操作函数**\n下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是\n一系列的文件名来对待。\n\n\n$(dir <names...> )\n\n\n名称：取目录函数——dir。\n功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之\n前的部分。如果没有反斜杠，那么返回“./”。\n返回：返回文件名序列<names>的目录部分。\n示例： $(dir src/foo.c hacks)返回值是“src/ ./”。\n\n\n$(notdir <names...> )\n\n\n名称：取文件函数——notdir。\n功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”\n）之后的部分。\n返回：返回文件名序列<names>的非目录部分。\n示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。\n\n\n$(suffix <names...> )\n\n\n名称：取后缀函数——suffix。\n功能：从文件名序列<names>中取出各个文件名的后缀。\n返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。\n示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。\n\n\n$(basename <names...> )\n\n\n名称：取前缀函数——basename。\n功能：从文件名序列<names>中取出各个文件名的前缀部分。\n返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。\n示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar h\nacks”。\n\n\n$(addsuffix <suffix>,<names...> )\n\n\n名称：加后缀函数——addsuffix。\n功能：把后缀<suffix>加到<names>中的每个单词后面。\n返回：返回加过后缀的文件名序列。\n示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。\n\n$(addprefix <prefix>,<names...> )\n\n\n名称：加前缀函数——addprefix。\n功能：把前缀<prefix>加到<names>中的每个单词后面。\n返回：返回加过前缀的文件名序列。\n示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。\n\n\n$(join <list1>,<list2> )\n\n\n名称：连接函数——join。\n功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比<\nlist2>的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比\n<list1>多，那么，<list2>多出来的单词将被复制到<list2>中。\n返回：返回连接过后的字符串。\n示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。\n\n\n**四、foreach 函数**\n\nforeach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的\nforeach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin\n/csh）中的foreach语句而构建的。它的语法是：\n\n$(foreach <var>,<list>,<text> )\n\n\n这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。\n\n所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var>\n这个参数来依次枚举<list>中的单词。举个例子：\n\n\nnames := a b c d\n\n\nfiles := $(foreach n,$(names),$(n).o)\n\n上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(f\niles)的值是“a.o b.o c.o d.o”。\n\n\n注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。\n\n\n\n**五、if 函数**\n\nif函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：\n\n\n$(if <condition>,<then-part> )\n\n\n\n或是\n\n\n$(if <condition>,<then-part>,<else-part> )\n\n\n\n可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。\n\n而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。\n\n所以，<then-part>和<else-part>只会有一个被计算。\n\n\n\n**六、call函数**\ncall函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：\n\n\n$(call <expression>,<parm1>,<parm2>,<parm3>...)\n\n\n当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。例如：\n\nreverse = $(1) $(2)\n\nfoo = $(call reverse,a,b)\n\n\n\n那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：\n\nreverse = $(2) $(1)\nfoo = $(call reverse,a,b)\n\n此时的foo的值就是“b a”。\n\n**七、origin函数**origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：\n\n$(origin <variable> )\n\n\n注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函\n数的返回值:\n\n“undefined”\n\n\n如果<variable>从来没有定义过，origin函数返回这个值“undefined”。\n\n“default”\n\n\n如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。\n\n“environment”\n\n\n如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。\n\n\n“file”\n\n\n如果<variable>这个变量被定义在Makefile中。\n\n\n“command line”\n\n\n如果<variable>这个变量是被命令行定义的。\n\n“override”\n\n\n如果<variable>是被override指示符重新定义的。\n\n“automatic”\n\n\n如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。\n\n\n这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一\n个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是\n，在我们的Makefile中，我们可以这样写：\n\n\nifdef bletch\n\n\nifeq \"$(origin bletch)\" \"environment\"\n\n\nbletch = barf, gag, etc.\n\nendif\n\nendif\n\n当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗\n暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。\n\n\n**八、shell函数**\nshell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数\n返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：\n\n\ncontents := $(shell cat foo)\n\n\n\nfiles := $(shell echo *.c)\n\n\n注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。\n\n\n**九、控制make的函数**\n\n\nmake提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。\n\n\n$(error <text ...> )\n\n产生一个致命的错误，<text ...>是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也\n是可以的。例如：\n\n示例一：\n\n\nifdef ERROR_001\n\n\n$(error error is $(ERROR_001))\n\nendif\n\n\n示例二：\n\n\nERR = $(error found an error!)\n\n\n.PHONY: err\n\n\nerr: ; $(ERR)\n\n\n示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。\n\n$(warning <text ...> )\n\n\n这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。\n\n**make 的运行**——————一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。\n**一、make的退出码**make命令执行后有三个退出码：0 —— 表示成功执行。1 —— 如果make运行时出现任何错误，其返回1。2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。Make的相关参数我们会在后续章节中讲述。\n**二、指定Makefile**\n\n前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就\n开始读取这个文件并执行。\n\n\n当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“--file”参数（“-- makefile”参数也行）。例如，我们有个mak\nefile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：\n\nmake –f hchen.mk\n\n\n如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。\n\n\n**三、指定目标**\n\n一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。\n\n有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：\n\n\nsources = foo.c bar.c\nifneq ( $(MAKECMDGOALS),clean)\ninclude $(sources:.c=.d)\nendif\n\n\n基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。\n\n使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：\n\n\n.PHONY: all\nall: prog1 prog2 prog3 prog4\n\n\n从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标\n（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。\n\n\n即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件\n发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。\n\n\n**“all”**        这个伪目标是所有目标的目标，其功能一般是编译所有的目标。**“clean”**    这个伪目标功能是删除所有被make创建的文件。**“install”**    这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。**“print”**     这个伪目标的功能是例出改变过的源文件。**“tar”**       这个伪目标功能是把源程序打包备份。也就是一个tar文件。**“dist”**      这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。**“TAGS”**     这个伪目标功能是更新所有的目标，以备完整地重编译使用。**“check”和“test”**   这两个伪目标一般用来[测试](http://lib.csdn.net/base/softwaretest)makefile的流程。\n\n​    当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。\n\n\n**四、检查规则**\n\n有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：\n\n\n“-n”\n“--just-print”\n“--dry-run”\n“--recon”\n不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。\n\n\n“-t”\n“--touch”\n这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。\n\n\n“-q”\n“--question”\n这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。\n\n\n“-W <file>”\n“--what-if=<file>”\n“--assume-new=<file>”\n“--new-file=<file>”\n这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件\n所发生的规则命令。\n\n另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。\n\n\n\n**五、make的参数**\n\n下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。\n\n\n“-b”\n“-m”\n这两个参数的作用是忽略和其它版本make的兼容性。\n\n\n“-B”\n“--always-make”\n认为所有的目标都需要更新（重编译）。\n\n\n“-C <dir>”\n“--directory=<dir>”\n指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”\n等价于“make –C ~hchen/test/prog”。\n\n\n“—debug[=<options>]”\n输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：\na —— 也就是all，输出所有的调试信息。（会非常的多）b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i —— 也就是implicit，输出所以的隐含规则。j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。\n\n“-d”\n相当于“--debug=a”。\n\n\n“-e”\n“--environment-overrides”\n指明环境变量的值覆盖makefile中定义的变量的值。\n\n\n“-f=<file>”\n“--file=<file>”\n“--makefile=<file>”\n指定需要执行的makefile。\n\n\n“-h”\n“--help”\n显示帮助信息。\n\n\n“-i”\n“--ignore-errors”\n在执行时忽略所有的错误。\n\n\n“-I <dir>”\n“--include-dir=<dir>”\n指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。\n\n\n“-j [<jobsnum>]”\n“--jobs[=<jobsnum>]”\n指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-D\nOS中是无用的）\n\n\n“-k”\n“--keep-going”\n出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。\n\n\n\n\n“-l <load>”\n“--load-average[=<load]”\n“—max-load[=<load>]”\n指定make运行命令的负载。\n\n\n“-n”\n“--just-print”\n“--dry-run”\n“--recon”\n仅输出执行过程中的命令序列，但并不执行。\n\n\n“-o <file>”\n“--old-file=<file>”\n“--assume-old=<file>”\n不重新生成的指定的<file>，即使这个目标的依赖文件新于它。\n\n\n“-p”\n“--print-data-base”\n输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -q\np”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用\n这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。\n\n“-q”\n“--question”\n不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。\n\n\n“-r”\n“--no-builtin-rules”\n禁止make使用任何隐含规则。\n\n\n“-R”\n“--no-builtin-variabes”\n禁止make使用任何作用于变量上的隐含规则。\n\n\n“-s”\n“--silent”\n“--quiet”\n在命令运行时不输出命令的输出。\n\n\n“-S”\n“--no-keep-going”\n“--stop”\n取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。\n\n\n“-t”\n“--touch”\n相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。\n\n\n“-v”\n“--version”\n输出make程序的版本、版权等关于make的信息。\n\n\n“-w”\n“--print-directory”\n输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。\n\n\n“--no-print-directory”\n禁止“-w”选项。\n\n\n“-W <file>”\n“--what-if=<file>”\n“--new-file=<file>”\n“--assume-file=<file>”\n假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时\n间为当前时间。\n\n\n“--warn-undefined-variables”\n只要make发现有未定义的变量，那么就输出警告信息。\n\n\n**隐含规则****————**\n\n\n在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。\n\n\n“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就\n不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。\n\n“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。\n\n\n我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保\n证我们Makefile的兼容性。\n我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当\n然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。\n\n\n**一、使用隐含规则**\n\n如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：\n\n\nfoo : foo.o bar.o\ncc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)\n\n\n我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成\n命令。\n\nmake 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：\n\n\nfoo.o : foo.c\ncc –c foo.c $(CFLAGS)\nbar.o : bar.c\ncc –c bar.c $(CFLAGS)\n\n\n因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。\n\n\n当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。\n\n\n还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：\n\n\nfoo.o : foo.p\n\n\n依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成f\noo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。\n\n\n**二、隐含规则一览**\n\n这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“--no-builtin-rules”选项来取消所有的预设置的隐含规则。\n\n\n当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统\n定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .\nh, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。\n\n\n还是先来看一看常用的隐含规则吧。\n\n\n1、编译C程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”\n\n\n2、编译C++程序的隐含规则。\n“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而\n不是“.C”）\n\n\n3、编译Pascal程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。\n\n\n4、编译Fortran/Ratfor程序的隐含规则。\n“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:\n“.f” “$(FC) –c $(FFLAGS)”\n“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”\n“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”\n\n\n5、预处理Fortran/Ratfor程序的隐含规则。\n“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：\n“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”\n“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”\n\n\n6、编译Modula-2程序的隐含规则。\n“<n>.sym” 的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“<n.o>” 的目标的依赖目标会自动推导为“<n>.mod”，\n并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。\n\n\n7、汇编和汇编预处理的隐含规则。\n“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”\n，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。\n\n\n8、链接Object文件的隐含规则。\n“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对\n于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：\n\nx : y.o z.o\n\n\n并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：\n\n\ncc -c x.c -o x.o\ncc -c y.c -o y.o\ncc -c z.c -o z.o\ncc x.o y.o z.o -o x\nrm -f x.o\nrm -f y.o\nrm -f z.o\n\n\n如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。\n\n\n9、Yacc C程序时的隐含规则。\n\n“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）\n\n\n10、Lex C程序时的隐含规则。\n“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）\n\n\n11、Lex Ratfor程序时的隐含规则。\n“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX\n) $(LFALGS)”。\n\n\n12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。\n“<n>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。\n\n\n**三、隐含规则使用的变量**\n\n在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“--no– builtin-variables”参数来取消你所定义的变量\n对隐含规则的作用。\n\n例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把\n变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。\n\n\n我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数\n相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：\n\n\n**1、关于命令的变量。**\n\n\nAR  函数库打包程序。默认命令是“ar”。\nAS\n汇编语言编译程序。默认命令是“as”。\nCC\nC语言编译程序。默认命令是“cc”。\nCXX\nC++语言编译程序。默认命令是“g++”。\nCO\n从 RCS文件中扩展文件程序。默认命令是“co”。\nCPP\nC程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。\nFC\nFortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。\nGET\n从SCCS文件中扩展文件的程序。默认命令是“get”。\nLEX\nLex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。\nPC\nPascal语言编译程序。默认命令是“pc”。\nYACC\nYacc文法分析器（针对于C程序）。默认命令是“yacc”。\nYACCR\nYacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。\nMAKEINFO\n转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。\nTEX\n从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。\nTEXI2DVI\n从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。\nWEAVE\n转换Web到TeX的程序。默认命令是“weave”。\nCWEAVE\n转换C Web 到 TeX的程序。默认命令是“cweave”。\nTANGLE\n转换Web到Pascal语言的程序。默认命令是“tangle”。\nCTANGLE\n转换C Web 到 C。默认命令是“ctangle”。\nRM\n删除文件命令。默认命令是“rm –f”。\n\n\n**2、关于命令参数的变量**\n下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是\n空。\n\n\nARFLAGS\n函数库打包程序AR命令的参数。默认值是“rv”。\nASFLAGS\n汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。\nCFLAGS\nC语言编译器参数。\nCXXFLAGS\nC++语言编译器参数。\nCOFLAGS\nRCS命令参数。\nCPPFLAGS\nC预处理器参数。（ C 和 Fortran 编译器也会用到）。\nFFLAGS\nFortran语言编译器参数。\nGFLAGS\nSCCS “get”程序参数。\nLDFLAGS\n链接器参数。（如：“ld”）\nLFLAGS\nLex文法分析器参数。\nPFLAGS\nPascal语言编译器参数。\nRFLAGS\nRatfor 程序的Fortran 编译器参数。\nYFLAGS\nYacc文法分析器参数。\n\n\n\n**四、隐含规则链**\n\n有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则\n叫做“隐含规则链”。\n\n\n在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调\n用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。\n\n\n我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？\n\n在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。\n\n通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）\n\n\n你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。\n\n\n在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。\n\nMake 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规\n则就不会生成中间文件。\n\n\n\n**五、定义模式规则**\n\n你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有\"%\"字符。\"%\"的意思是表示一个或多个任意字符。在依赖目标中同样可以使用\"%\"，只是依赖目标中的\"%\"的取值，取决于其目标。\n\n有一点需要注意的是，\"%\"的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的\"%\"则发生在运行时。\n\n\n\n**1、模式规则介绍**\n\n\n模式规则中，至少在规则的目标定义中要包含\"%\"，否则，就是一般的规则。目标中的\"%\"定义表示对文件名的匹配，\"%\"表示长度任意的非空字符串。例如：\"%.c\"表示以\".c\"结尾的文件名（文件名的长度至少为3），而\"s.%.c\"则表示以\"s.\"开头，\".c\"结尾的文件名（文件名的长度至少为 5）。\n\n如果\"%\"定义在目标中，那么，目标中的\"%\"的值决定了依赖目标中的\"%\"的值，也就是说，目标中的模式的\"%\"决定了依赖目标中\"%\"的样子。例如有一个模式规则如下：\n\n\n%.o : %.c ; <command ......>\n\n\n其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是\"a.o b.o\"，那么\"%c\"就是\"a.c b.c\"。\n\n\n一旦依赖目标中的\"%\"模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。\n\n**2、模式规则示例**\n\n\n下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.\n\n\n%.o : %.c\n$(CC) -c $(CFLAGS) $(CPPFLAGS) $< -o $@\n\n\n其中，\"$@\"表示所有的目标的挨个值，\"$<\"表示了所有依赖目标的挨个值。这些奇怪的变\n量我们叫\"自动化变量\"，后面会详细讲述。\n\n\n下面的这个例子中有两个目标是模式的：\n\n%.tab.c %.tab.h: %.y\nbison -d $<\n\n\n这条规则告诉make把所有的[.y]文件都以\"bison -d <n>.y\"执行，然后生成\"<n>.tab.c\"和\"<n>.tab.h\"文件。（其中，\"<n>\" 表示一个任意字符串）。如果我们的执行程序\"foo\"依\n赖于文件\"parse.tab.o\"和\"scan.o\"，并且文件\"scan.o\"依赖于文件\"parse.tab.h\"，如果\"parse.y\"文件被更新了，那么根据上述的规则，\"bison -d parse.y\"就会被执行一次，于\n是，\"parse.tab.o\"和\"scan.o\"的依赖文件就齐了。（假设，\"parse.tab.o\" 由\"parse.tab.c\"生成，和\"scan.o\"由\"scan.c\"生成，而\"foo\"由\"parse.tab.o\"和\"scan.o\"链接生成，\n而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）\n\n**3、自动化变量**\n\n在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。\n\n自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。\n\n下面是所有的自动化变量及其说明：\n\n$@\n表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，\"$@\"就是匹配于目标中模式定义的集合。\n\n\n$%\n仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是\"foo.a(bar.o)\"，那么，\"$%\"就是\"bar.o\"，\"$@\"就是\"foo.a\"。如果目标不是函数库文件（Unix下是\n[.a]，Windows下是[.lib]），那么，其值为空。\n\n$<\n依赖目标中的第一个目标名字。如果依赖目标是以模式（即\"%\"）定义的，那么\"$<\"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。\n\n$?\n所有比目标新的依赖目标的集合。以空格分隔。\n\n$^\n所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。\n\n$+\n这个变量很像\"$^\"，也是所有依赖目标的集合。只是它不去除重复的依赖目标。\n\n\n$*\n这个变量表示目标模式中\"%\"及其之前的部分。如果目标是\"dir/a.foo.b\"，并且目标的模式是\"a.%.b\"，那么，\"$*\"的值就是\"dir /a.foo\"。这个变量对于构造有关联的文件名是比\n较有较。如果目标中没有模式的定义，那么\"$*\"也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么\"$*\"就是除了后缀的那一部分。例如：如果目标是\"foo.c\"\n，因为\".c\"是make所能识别的后缀名，所以，\"$*\"的值就是\"foo\"。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用\"$*\"，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么\"$*\"就是空值。\n\n当你希望只对更新过的依赖文件进行操作时，\"$?\"在显式规则中很有用，例如，假设有一个函数库文件叫\"lib\"，其由其它几个object文件更新。那么把object文件打包的比较有效\n率的Makefile规则是：\n\n\nlib : foo.o bar.o lose.o win.o\nar r lib $?\n\n\n在上述所列出来的自动量变量中。四个变量（$@、$<、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上\"D\"或\"F\"字样。这是GNU make中老版本的特性，在新版本中，我们使用函数\"dir\"或\"notdir\"就可以做到了。\"D\"的含义就是Directory，就是目录，\"F\"的含义就是File，就是文件。\n\n\n下面是对于上面的七个变量分别加上\"D\"或是\"F\"的含义：\n\n\n$(@D)\n表示\"$@\"的目录部分（不以斜杠作为结尾），如果\"$@\"值是\"dir/foo.o\"，那么\"$(@D)\"就是\"dir\"，而如果\"$@\"中没有包含斜杠的话，其值就是\".\"（当前目录）。\n\n\n$(@F)\n表示\"$@\"的文件部分，如果\"$@\"值是\"dir/foo.o\"，那么\"$(@F)\"就是\"foo.o\"，\"$(@F)\"相当于函数\"$(notdir $@)\"。\n\n\n\"$(*D)\"\n\"$(*F)\"\n和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，\"$(*D)\"返回\"dir\"，而\"$(*F)\"返回\"foo\"\n\n\n\"$(%D)\"\n\"$(%F)\"\n分别表示了函数包文件成员的目录部分和文件部分。这对于形同\"archive(member)\"形式的目标中的\"member\"中包含了不同的目录很有用。\n\n\n\"$(<D)\"\n\"$(<F)\"\n分别表示依赖文件的目录部分和文件部分。\n\n\n\"$(^D)\"\n\"$(^F)\"\n分别表示所有依赖文件的目录部分和文件部分。（无相同的）\n\n\n\"$(+D)\"\n\"$(+F)\"\n分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）\n\n\n\"$(?D)\"\n\"$(?F)\"\n\n\n分别表示被更新的依赖文件的目录部分和文件部分。\n\n最后想提醒一下的是，对于\"$<\"，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，\"$(< )\"就要比\"$<\"要好一些。\n\n还得要注意的是，这些变量只使用在规则的命令中，而且一般都是\"显式规则\"和\"静态模式规则\"（参见前面\"书写规则\"一章）。其在隐含规则中并没有意义。\n\n\n**4、模式的匹配**\n\n一般来说，一个目标的模式有一个有前缀或是后缀的\"%\"，或是没有前后缀，直接就是一个\"%\"。因为\"%\"代表一个或多个字符，所以在定义好了的模式中，我们把\"%\"所匹配的内容叫做\"茎\"，例如\"%.c\"所匹配的文件\"test.c\"中\"test\"就是\"茎\"。因为在目标和依赖目标中同时有\"%\"时，依赖目标的\"茎\"会传给目标，当做目标中的\"茎\"。\n\n当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行\"茎\"的传递时，我们需要知道这个步骤。例如有一个模式\"e%t\"，文件\"src/eat\" 匹配于该模式，于是\"src/a\"就是其\"茎\"，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式\"c%r\"，那么，目标就是\"src/car\"。（\"茎\"被传递）\n\n**5、重载内建隐含规则**\n\n\n你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：\n\n\n%.o : %.c\n$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)\n\n\n你可以取消内建的隐含规则，只要不在后面写命令就行。如：\n\n\n%.o : %.s\n\n\n同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。\n\n\n**六、老式风格的\"后缀规则\"**\n\n后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：\"双后缀\"和\"单后缀\"。\n\n双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如\".c.o\"相当于\"%o : %c\"。单后缀规则只定义一个后缀，也就是源文件的后缀。如\".c\"相当于\"% : %.c\"。\n\n\n后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：\".c\"和\".o\"都是make所知道。因而，如果你定义了一个规则是\".c.o\"那么其就是双后缀规则，意义就是\".c\" 是源文件的后缀，\".o\"是目标文件的后缀。如下示例：\n\n\n.c.o:\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n\n后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：\n\n\n.c.o: foo.h\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n\n这个例子，就是说，文件\".c.o\"依赖于文件\"foo.h\"，而不是我们想要的这样：\n\n%.o: %.c foo.h\n$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<\n\n\n后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。\n\n\n而要让make知道一些特定的后缀，我们可以使用伪目标\".SUFFIXES\"来定义或是删除，如：\n\n\n.SUFFIXES: .hack .win\n\n\n把后缀.hack和.win加入后缀列表中的末尾。\n\n\n.SUFFIXES: # 删除默认的后缀\n.SUFFIXES: .c .o .h # 定义自己的后缀\n\n\n先清楚默认后缀，后定义自己的后缀列表。\n\n\nmake的参数\"-r\"或\"-no-builtin-rules\"也会使用得默认的后缀列表为空。而变量\"SUFFIXE\"被用来定义默认的后缀列表，你可以用\".SUFFIXES\"来改变后缀列表，但请不要改变变量\"SUFFIXE\"的值。\n\n\n\n**七、隐含规则搜索算法**\n比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是\"archive(member)\"的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把\"member\"当作T来搜索。\n\n\n1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是\"src/foo.o\"，那么，D就是\"src/\"，N就是\"foo.o\"）2、创建所有匹配于T或是N的模式规则列表。3、如果在模式规则列表中有匹配所有文件的模式，如\"%\"，那么从列表中移除其它的模式。4、移除列表中没有命令的规则。5、对于第一个在列表中的模式规则：\n1）推导其\"茎\"S，S应该是T或是N匹配于模式中\"%\"非空的部分。2）计算依赖文件。把依赖文件中的\"%\"都替换成\"茎\"S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫\"理当存在\"）4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该[算法](http://lib.csdn.net/base/datastructure)。6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：1）如果规则是终止规则，那就忽略它，继续下一条模式规则。2）计算依赖文件。（同第5步）3）测试所有的依赖文件是否存在或是理当存在。4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。7、如果没有隐含规则可以使用，查看\".DEFAULT\"规则，如果有，采用，把\".DEFAULT\"的命令给T使用。\n\n一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。\n\n\n\n\n**使用make更新函数库文件****———————————**\n\n\n函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令\"ar\"来完成打包工作。\n\n\n**一、函数库文件的成员**\n\n一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：\n\n\narchive(member)\n\n\n这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了\"ar\"命令来服务的。如：\n\nfoolib(hack.o) : hack.o\nar cr foolib hack.o\n\n\n如果要指定多个member，那就以空格分开，如：\n\n\nfoolib(hack.o kludge.o)\n\n\n其等价于：\n\n\nfoolib(hack.o) foolib(kludge.o)\n\n\n你还可以使用Shell的文件通配符来定义，如：\n\nfoolib(*.o)\n\n\n**二、函数库成员的隐含规则**\n\n当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是\"a(m)\"形式的，其会把目标变成\"(m)\"。于是，如果我们的成员是\"%.o\" 的模式定义，并且如果我们使用\"make foo.a(bar.o)\"的形式调用Makefile时，隐含规则会去找\"bar.o\"的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：\n\n\ncc -c bar.c -o bar.o\nar r foo.a bar.o\nrm -f bar.o\n\n\n还有一个变量要注意的是\"$%\"，这是专属函数库文件的自动化变量，有关其说明请参见\"自动化变量\"一节。\n\n\n\n**三、函数库文件的后缀规则**\n\n你可以使用\"后缀规则\"和\"隐含规则\"来生成函数库打包文件，如：\n\n\n.c.a:\n$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o\n$(AR) r $@ $*.o\n$(RM) $*.o\n\n\n其等效于：\n\n\n(%.o) : %.c\n$(CC) $(CFLAGS) $(CPPFLAGS) -c $< -o $*.o\n$(AR) r $@ $*.o\n$(RM) $*.o\n\n\n**四、注意事项**\n\n在进行函数库打包文件生成时，请小心使用make的并行机制（\"-j\"参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。\n但就目前而言，你还是应该不要尽量不要使用\"-j\"参数。\n\n\n\n**后序****——**\n\n\n终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测\"函数\"那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）\"杀伤力\"。\n\n\n对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp……等等，等等，来完成诸如\"程序打包\"、\"程序备份\"、\"制作程序安装包\"、\"提交代码\"、\"使用程序模板\"、\"合并文件\"等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如\"@@@N、###N\"奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的\"@@@N、###N\"等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的\"扩展C\"语言（即在C语言中用\"EXEC　SQL\"的样子执行SQL语句，在用 cc/gcc编译之前，需要使用\"扩展C\"的翻译程序，如cpre，把其翻译成标准C）。如果\n你在使用make时有一些更为绝妙的方法，请记得告诉我啊。\n\n回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入\"!make\"时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。\n\n\n现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的 Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。\n\n最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命——网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在“技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。我的MSN是：haoel@hotmail.com（常用），QQ是：753640（不常用）。（注：请勿给我MSN的邮箱发信，由于hotmail的垃圾\n邮件导致我拒收这个邮箱的所有来信）\n\n\n我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！\n\n\n最最后，我还想介绍一下make程序的设计开发者。\n\n首当其冲的是： Richard Stallman\n\n开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：http://www.stallman.org/ 。\n第二位是：Roland McGrath\n个人主页是：http://www.frob.com/~roland/ ，下面是他的一些事迹：\n\n1） 合作编写了并维护GNU make。2） 和Thomas Bushnell一同编写了GNU Hurd。3） 编写并维护着GNU C library。4） 合作编写并维护着部分的GNU Emacs。\n在此，向这两位开源项目的斗士致以最真切的敬意。","slug":"linux_md/Makefile/Makefile基础","published":1,"updated":"2021-04-08T14:11:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr64002dw9q9ghj1byvr","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Makefile基础\"><a href=\"#Makefile基础\" class=\"headerlink\" title=\"Makefile基础\"></a>Makefile基础</h1><blockquote>\n<p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不得不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。<strong>make是一个命令工具，是一个解释makefile中指令的命令工具</strong>，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>\n</blockquote>\n<hr>\n<p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat <strong>linux</strong> 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。  在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>\n<h2 id=\"1-关于程序的编译和链接\"><a href=\"#1-关于程序的编译和链接\" class=\"headerlink\" title=\"1. 关于程序的编译和链接\"></a><strong>1. 关于程序的编译和链接</strong></h2><p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是passical，首先要把源文件编译成<strong>中间代码文件</strong>，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做*<strong>*编译\\</strong>（compile）<strong>。然后再把大量的Object File合成执行文件，这个动作叫作</strong>链接**（link）。</p>\n<p><strong>编译时</strong>，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p>\n<p><strong>链接时</strong>，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，<strong>我们要给中间目标文件打个包</strong>，在Windows下这种包叫“**库文件”（Library File)**，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>\n<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，<strong>编译器只检测程序语法，和函数、变量是否被声明</strong>。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.</p>\n<p>好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。</p>\n<h2 id=\"2-Makefile-介绍\"><a href=\"#2-Makefile-介绍\" class=\"headerlink\" title=\"2. Makefile 介绍\"></a><strong>2. Makefile 介绍</strong></h2><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。   首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。如果这个工程的<strong>头文件</strong>被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。   只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动<strong>智能</strong>地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>\n<h3 id=\"2-1-Makefile的规则\"><a href=\"#2-1-Makefile的规则\" class=\"headerlink\" title=\"2.1 Makefile的规则\"></a><strong>2.1 Makefile的规则</strong></h3><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target... : prerequisites ...</span><br><span class=\"line\">command</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>target</strong>：目标文件，可以是<strong>Object File</strong>，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li>\n</ul>\n<ul>\n<li><p><strong>prerequisites</strong>：要生成那个target所需要的文件或是目标。    </p>\n</li>\n<li><p><strong>command</strong>：make需要执行的命令。（任意的Shell命令）</p>\n</li>\n</ul>\n<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。    说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p>\n<h3 id=\"2-2-一个示例\"><a href=\"#2-2-一个示例\" class=\"headerlink\" title=\"2.2 一个示例\"></a><strong>2.2 一个示例</strong></h3><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit : main.o kbd.o command.o display.o \\</span><br><span class=\"line\">       insert.o search.o files.o utils.o</span><br><span class=\"line\">       cc -o edit main.o kbd.o command.o display.o \\</span><br><span class=\"line\">                  insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">         cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">        cc -c kbd.c</span><br><span class=\"line\">command.o : command.c defs.h command.h</span><br><span class=\"line\">            cc -c command.c</span><br><span class=\"line\">display.o : display.c defs.h buffer.h</span><br><span class=\"line\">            cc -c display.c</span><br><span class=\"line\">insert.o : insert.c defs.h buffer.h</span><br><span class=\"line\">           cc -c insert.c</span><br><span class=\"line\">search.o : search.c defs.h buffer.h</span><br><span class=\"line\">           cc -c search.c</span><br><span class=\"line\">files.o : files.c defs.h buffer.h command.h</span><br><span class=\"line\">           cc -c files.c</span><br><span class=\"line\">utils.o : utils.c defs.h</span><br><span class=\"line\">           cc -c utils.c</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit main.o kbd.o command.o display.o \\</span><br><span class=\"line\">                insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n<p><strong>反斜杠（\\）</strong>是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</p>\n<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。*</p>\n<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的<strong>操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令</strong>。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>\n<p><strong>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像</strong>C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>\n<h3 id=\"2-3-make是如何工作的\"><a href=\"#2-3-make是如何工作的\" class=\"headerlink\" title=\"2.3 make是如何工作的\"></a><strong>2.3 make是如何工作的</strong></h3><p>在默认的方式下，也就是我们只输入make命令。那么:</p>\n<ul>\n<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 </li>\n</ul>\n<ul>\n<li><p>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 </p>\n</li>\n<li><p>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 </p>\n</li>\n<li><p>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。</p>\n</li>\n<li><p>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。  </p>\n</li>\n</ul>\n<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>\n<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——<strong>“make clean”，以此来清除所有的目标文件，以便重编译</strong>。</p>\n<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>\n<h3 id=\"2-4-makefile中使用变量\"><a href=\"#2-4-makefile中使用变量\" class=\"headerlink\" title=\"2.4 makefile中使用变量\"></a><strong>2.4 makefile中使用变量</strong></h3><p> 在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。</p>\n<h4 id=\"2-4-1-变量的基础\"><a href=\"#2-4-1-变量的基础\" class=\"headerlink\" title=\"2.4.1 变量的基础\"></a>2.4.1 变量的基础</h4><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前<strong>加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来</strong>。如果你要使用真实的“$”字符，那么你需要用“$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects &#x3D; program.o foo.o utils.o</span><br><span class=\"line\">program : $(objects)</span><br><span class=\"line\">cc -o program $(objects)</span><br><span class=\"line\">$(objects) : defs.h</span><br></pre></td></tr></table></figure>\n<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo &#x3D; c</span><br><span class=\"line\">prog.o : prog.$(foo)</span><br><span class=\"line\">$(foo)$(foo) -$(foo) prog.$(foo)</span><br></pre></td></tr></table></figure>\n<p>展开后得到：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prog.o : prog.c</span><br><span class=\"line\">\t\tcc -c prog.c</span><br></pre></td></tr></table></figure>\n<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>\n<h4 id=\"2-4-2-变量中的变量\"><a href=\"#2-4-2-变量中的变量\" class=\"headerlink\" title=\"2.4.2 变量中的变量\"></a>2.4.2 <strong>变量中的变量</strong></h4><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = <span class=\"variable\">$(bar)</span></span><br><span class=\"line\">bar = <span class=\"variable\">$(ugh)</span></span><br><span class=\"line\">ugh = Huh?</span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">echo <span class=\"variable\">$(foo)</span></span><br></pre></td></tr></table></figure>\n<p>我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。</p>\n<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFLAGS = <span class=\"variable\">$(include_dirs)</span> -O</span><br><span class=\"line\">include_dirs = -Ifoo -Ibar</span><br></pre></td></tr></table></figure>\n<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：</p>\n<p><code>CFLAGS = $(CFLAGS) -O</code></p>\n<p>或：</p>\n<p>A = $(B)</p>\n<p>B = $(A)</p>\n<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>\n<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := foo</span><br><span class=\"line\">y := <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x := later</span><br></pre></td></tr></table></figure>\n<p>其等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y := foo bar</span><br><span class=\"line\">x := later</span><br></pre></td></tr></table></figure>\n<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y :&#x3D; $(x) bar</span><br><span class=\"line\">x :&#x3D; foo</span><br></pre></td></tr></table></figure>\n<p>那么，y的值是“bar”，而不是“foo bar”。</p>\n<p>在上面的例子中，先让我们看看edit的规则：   </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit : main.o kbd.o command.o display.o \\</span><br><span class=\"line\">       insert.o search.o files.o utils.o</span><br><span class=\"line\">       cc -o edit main.o kbd.o command.o display.o \\</span><br><span class=\"line\">       insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n<p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成<strong>c语言</strong>中的宏可能会更好。</p>\n<p>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n<p>于是，我们就可以很方便地在我们的makefile中以<strong>“$(objects)”</strong>的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.osearch.o files.o utils.o</span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">\t   cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">\t     cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">\t    cc -c kbd.c</span><br><span class=\"line\">command.o : command.c defs.h command.h</span><br><span class=\"line\">\t        cc -c command.c</span><br><span class=\"line\">display.o : display.c defs.h buffer.h</span><br><span class=\"line\">            cc -c display.c</span><br><span class=\"line\">insert.o : insert.c defs.h buffer.h</span><br><span class=\"line\">           cc -c insert.c</span><br><span class=\"line\">search.o : search.c defs.h buffer.h</span><br><span class=\"line\">           cc -c search.c</span><br><span class=\"line\">files.o : files.c defs.h buffer.h command.h</span><br><span class=\"line\">          cc -c files.c</span><br><span class=\"line\">utils.o : utils.c defs.h</span><br><span class=\"line\">          cc -c utils.c</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。关于变量更多的话题，我会在后续给你一一道来。</p>\n<h3 id=\"2-5-让make自动推导\"><a href=\"#2-5-让make自动推导\" class=\"headerlink\" title=\"2.5 让make自动推导\"></a><strong>2.5 让make自动推导</strong></h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>\n<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p>\n<p>Makefile中把那些没有任何依赖只有执行动作的目标成为“伪目标”(phony targets)。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">       cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\">main.o : defs.h</span><br><span class=\"line\">kbd.o : defs.h command.h</span><br><span class=\"line\">command.o : defs.h command.h</span><br><span class=\"line\">display.o : defs.h buffer.h</span><br><span class=\"line\">insert.o : defs.h buffer.h</span><br><span class=\"line\">search.o : defs.h buffer.h</span><br><span class=\"line\">files.o : defs.h buffer.h command.h</span><br><span class=\"line\">utils.o : defs.h</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。</p>\n<h3 id=\"2-6-另类风格的makefile\"><a href=\"#2-6-另类风格的makefile\" class=\"headerlink\" title=\"2.6 另类风格的makefile\"></a><strong>2.6 另类风格的makefile</strong></h3><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">       cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(objects)</span> : defs.h</span><br><span class=\"line\">kbd.o command.o files.o : command.h</span><br><span class=\"line\">display.o insert.o search.o files.o : buffer.h</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>\n<h3 id=\"2-7-清空目标文件的规则\"><a href=\"#2-7-清空目标文件的规则\" class=\"headerlink\" title=\"2.7 清空目标文件的规则\"></a><strong>2.7 清空目标文件的规则</strong></h3><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：    </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">      rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>更为稳健的做法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        -rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>\n<h2 id=\"3-Makefile-总述\"><a href=\"#3-Makefile-总述\" class=\"headerlink\" title=\"3. Makefile 总述\"></a><strong>3. Makefile 总述</strong></h2><h3 id=\"3-1-Makefile里有什么？\"><a href=\"#3-1-Makefile里有什么？\" class=\"headerlink\" title=\"3.1 Makefile里有什么？\"></a><strong>3.1 Makefile里有什么？</strong></h3><p><strong>Makefile里主要包含了</strong>五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>\n<ul>\n<li><p>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</p>\n</li>\n<li><p>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</p>\n</li>\n<li><p>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>\n</li>\n<li><p>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 </p>\n</li>\n<li><p>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。</p>\n</li>\n</ul>\n<p><strong>最后，还值得一提的是，</strong>在Makefile中的命令，必须要以[Tab]键开始。**   <strong>———-注意是tab键，不是8个空格</strong></p>\n<h3 id=\"3-2-Makefile的文件名\"><a href=\"#3-2-Makefile的文件名\" class=\"headerlink\" title=\"3.2 Makefile的文件名\"></a><strong>3.2 Makefile的文件名</strong></h3><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为<strong>“GNUmakefile”、“makefile”、“Makefile”</strong>的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“<strong>makefile”和“Makefile”</strong>这两种默认文件名。   </p>\n<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要<strong>指定特定的Makefile，你可以使用make的“-f”和“–file”参数</strong>，如：make -f Make.Linux或make –file Make.AIX。</p>\n<h3 id=\"3-3-引用其它的Makefile\"><a href=\"#3-3-引用其它的Makefile\" class=\"headerlink\" title=\"3.3 引用其它的Makefile\"></a><strong>3.3 引用其它的Makefile</strong></h3><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> &lt;filename&gt; filename</span><br></pre></td></tr></table></figure>\n<p>可以是当前操作系统Shell的文件模式（可以保含路径和通配符）   </p>\n<p><strong>在include前面可以有一些空字符，</strong>但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。**举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：   **</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> foo.make *.mk <span class=\"variable\">$(bar)</span></span><br></pre></td></tr></table></figure>\n<p>等价于：   </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure>\n<p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>\n<ul>\n<li><p>如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。</p>\n</li>\n<li><p>如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。   </p>\n</li>\n</ul>\n<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-include &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<p>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>\n<h3 id=\"3-4-环境变量-MAKEFILES\"><a href=\"#3-4-环境变量-MAKEFILES\" class=\"headerlink\" title=\"3.4 环境变量 MAKEFILES\"></a><strong>3.4 环境变量 MAKEFILES</strong></h3><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>\n<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>\n<h3 id=\"3-5-make的工作方式\"><a href=\"#3-5-make的工作方式\" class=\"headerlink\" title=\"3.5 make的工作方式\"></a><strong>3.5 make的工作方式</strong></h3><p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>\n<ol>\n<li><p>读入所有的Makefile。</p>\n</li>\n<li><p>读入被include的其它Makefile。</p>\n</li>\n<li><p>初始化文件中的变量。</p>\n</li>\n<li><p>推导隐晦规则，并分析所有规则。</p>\n</li>\n<li><p>为所有的目标文件创建依赖关系链。</p>\n</li>\n<li><p>根据依赖关系，决定哪些目标要重新生成。</p>\n</li>\n<li><p>执行生成命令。   </p>\n</li>\n</ol>\n<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，</p>\n<p>**make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>\n<h2 id=\"4-Makefile书写规则\"><a href=\"#4-Makefile书写规则\" class=\"headerlink\" title=\"4. Makefile书写规则\"></a><strong>4. Makefile书写规则</strong></h2><p>规则包含两个部分，一个是<strong>依赖关系</strong>，一个是<strong>生成目标的方法</strong>。   </p>\n<p><strong>在Makefile中，规则的顺序是很重要的</strong>，因为，<strong>Makefile中应该**</strong>只有一个最终目标<strong>，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</strong></p>\n<p>好了，还是让我们来看一看如何书写规则。</p>\n<h3 id=\"4-1-规则举例\"><a href=\"#4-1-规则举例\" class=\"headerlink\" title=\"4.1 规则举例\"></a><strong>4.1 规则举例</strong></h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">foo.o: foo.c defs.h               # foo模块</span></span><br><span class=\"line\">       cc -c -g foo.c             <span class=\"comment\"># -c 表示只编译不链接， -g 表示带调试信息</span></span><br></pre></td></tr></table></figure>\n<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令<code> cc -c -g foo.c</code>（以Tab键开头）。这个规则告诉我们两件事：</p>\n<ul>\n<li>文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。</li>\n<li>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</li>\n</ul>\n<h3 id=\"4-2-规则的语法\"><a href=\"#4-2-规则的语法\" class=\"headerlink\" title=\"4.2 规则的语法\"></a><strong>4.2 规则的语法</strong></h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites    </span><br><span class=\"line\">\tcommand    </span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>或是这样：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites ; command      </span><br><span class=\"line\">\tcommand      </span><br><span class=\"line\">\t... </span><br></pre></td></tr></table></figure>\n<p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。   </p>\n<p>command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）   </p>\n<p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。   </p>\n<p>如果命令太长，你可以使用反斜框（‘\\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。   </p>\n<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>\n<h3 id=\"4-3-在规则中使用通配符\"><a href=\"#4-3-在规则中使用通配符\" class=\"headerlink\" title=\"4.3 在规则中使用通配符\"></a><strong>4.3 在规则中使用通配符</strong></h3><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“<em>”，“?”和“[…]”。这是和Unix的B-Shell是相同的。</em></p>\n<p><strong>“~”</strong>   </p>\n<p>波浪号（“<del>”）字符在文件名中也有比较特殊的用途。如果是“</del>/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。</p>\n<p><strong>“*“</strong>   </p>\n<p><em>*</em>通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“<em>”，那么可以用转义字符“\\”，如“\\</em>”来表示真实的“*”字符，而不是任意长度的字符串。</p>\n<p>好吧，还是先来看几个例子吧：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:    </span></span><br><span class=\"line\">\trm -f *.o</span><br></pre></td></tr></table></figure>\n<p>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">print: *.c    </span></span><br><span class=\"line\">\tlpr -p <span class=\"variable\">$?</span>    </span><br><span class=\"line\">\ttouch print</span><br></pre></td></tr></table></figure>\n<p>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。  </p>\n<p><code>objects = *.o</code>上面这个例子，表示了，通符同样可以用在变量中。并不是说[<em>.o]会展开，不！**objects的值就是“\\</em>.o”**。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：  </p>\n<p><code>objects := $(wildcard *.o)</code></p>\n<p>这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。</p>\n<h3 id=\"4-4-文件搜寻\"><a href=\"#4-4-文件搜寻\" class=\"headerlink\" title=\"4.4 文件搜寻\"></a><strong>4.4 文件搜寻</strong></h3><p> 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。   </p>\n<p>Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。  </p>\n<p><code>VPATH = src:../headers</code>   </p>\n<p>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）   </p>\n<p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>\n<ul>\n<li><p>vpath &lt; pattern&gt; &lt; directories&gt;       为符合模式&lt; pattern&gt;的文件指定搜索目录<directories>。</p>\n</li>\n<li><p>vpath &lt; pattern&gt;                                清除符合模式&lt; pattern&gt;的文件的搜索目录。</p>\n</li>\n<li><p>vpath                                                   清除所有已被设置好了的文件搜索目录。   </p>\n</li>\n</ul>\n<p>vapth使用方法中的&lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt; pattern&gt;指定了要搜索的文件集，而&lt; directories&gt;则指定了的文件集的搜索的目录。例如：  </p>\n<p><code>vpath %.h ../headers</code></p>\n<p>该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）</p>\n<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt; pattern&gt;，或是被重复了的&lt; pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vpath</span> %.c foo  </span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %  blish  </span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %.c bar</span><br></pre></td></tr></table></figure>\n<p>其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vpath</span> %.c foo:bar  </span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %  blish</span><br></pre></td></tr></table></figure>\n<p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>\n<h3 id=\"4-5-伪目标\"><a href=\"#4-5-伪目标\" class=\"headerlink\" title=\"4.5 伪目标\"></a><strong>4.5 伪目标</strong></h3><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:      </span></span><br><span class=\"line\">\t\trm *.o temp</span><br></pre></td></tr></table></figure>\n<p>正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）</p>\n<p>因为，我们并不生成“clean”这个文件。<strong>“伪目标”并不是一个文件，只是一个标签</strong>，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。</p>\n<p>当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 </p>\n<p><code> .PHONY : clean</code></p>\n<p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: clean  </span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\t\trm *.o temp</span><br></pre></td></tr></table></figure>\n<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all : prog1 prog2 prog3  </span><br><span class=\"line\">.PHONY : all</span><br><span class=\"line\">prog1 : prog1.o utils.o      </span><br><span class=\"line\">\t\tcc -o prog1 prog1.o utils.o</span><br><span class=\"line\">prog2 : prog2.o      </span><br><span class=\"line\">\t\tcc -o prog2 prog2.o</span><br><span class=\"line\">prog3 : prog3.o sort.o utils.o      \t</span><br><span class=\"line\">\t\tcc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>\n<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。</p>\n<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class=\"line\"></span><br><span class=\"line\">cleanall : cleanobj cleandiff      </span><br><span class=\"line\">\t\trm program</span><br><span class=\"line\">cleanobj :      </span><br><span class=\"line\">\t\trm *.o</span><br><span class=\"line\">cleandiff :      </span><br><span class=\"line\">\t\trm *.diff*</span><br></pre></td></tr></table></figure>\n<p><code>makeclean</code>将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的</p>\n<h3 id=\"4-6-多目标\"><a href=\"#4-6-多目标\" class=\"headerlink\" title=\"4.6 多目标\"></a><strong>4.6 多目标</strong></h3><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bigoutput littleoutput : text.g      </span><br><span class=\"line\">\t\tgenerate text.g -<span class=\"variable\">$(<span class=\"built_in\">subst</span> output,,<span class=\"variable\">$@</span>)</span> &gt; <span class=\"variable\">$@</span>  </span><br></pre></td></tr></table></figure>\n<p>上述规则等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bigoutput : text.g      </span><br><span class=\"line\">\t\tgenerate text.g -big &gt; bigoutput  </span><br><span class=\"line\">littleoutput : text.g      </span><br><span class=\"line\">\t\tgenerate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>\n<p>其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。</p>\n<h3 id=\"4-7-静态模式\"><a href=\"#4-7-静态模式\" class=\"headerlink\" title=\"4.7 静态模式\"></a><strong>4.7 静态模式</strong></h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;　　　</span></span><br><span class=\"line\">\t\t&lt;commands&gt;</span><br><span class=\"line\">\t\t...</span><br></pre></td></tr></table></figure>\n<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>\n<p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p>\n<p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p>\n<p>所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\\”进行转义，来标明真实的“%”字符。</p>\n<p>看一个例子：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = foo.o bar.o</span><br><span class=\"line\"><span class=\"section\">all: <span class=\"variable\">$(objects)</span></span></span><br><span class=\"line\"><span class=\"variable\">$(objects)</span>: %.o: %.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.o : foo.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> foo.c -o foo.o  </span><br><span class=\"line\">bar.o : bar.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>\n<p>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">files = foo.elc bar.o lose.o</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span> %.o,<span class=\"variable\">$(files)</span>)</span>: %.o: %.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span>  </span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span> %.elc,<span class=\"variable\">$(files)</span>)</span>: %.elc: %.el      </span><br><span class=\"line\">\t\temacs -f batch-byte-compile <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n<p>$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>\n<h3 id=\"3-8-自动生成依赖性\"><a href=\"#3-8-自动生成依赖性\" class=\"headerlink\" title=\"3.8 自动生成依赖性\"></a><strong>3.8 自动生成依赖性</strong></h3><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include “defs.h””，那么我们的依赖关系应该是：  </p>\n<p><code>main.o : main.c defs.h</code></p>\n<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：  </p>\n<p><code>cc -M main.c</code></p>\n<p>其输出是：  </p>\n<p><code>main.o : main.c defs.h</code></p>\n<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。</p>\n<p>gcc-M main.c的输出是：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\</span></span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/sys/cdefs.h /usr/<span class=\"keyword\">include</span>/gnu/stubs.h \\</span><br><span class=\"line\">\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class=\"keyword\">include</span>/stddef.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/types.h /usr/<span class=\"keyword\">include</span>/bits/pthreadtypes.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/sched.h /usr/<span class=\"keyword\">include</span>/libio.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/_G_config.h /usr/<span class=\"keyword\">include</span>/wchar.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/wchar.h /usr/<span class=\"keyword\">include</span>/gconv.h \\</span><br><span class=\"line\">\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class=\"keyword\">include</span>/stdarg.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure>\n<p>gcc-MM main.c的输出则是：  </p>\n<p><code>main.o: main.c defs.h</code></p>\n<p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p>\n<p>于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>\n<p>这里，我们给出了一个模式规则来产生[.d]文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">%.d: %.c      </span></span><br><span class=\"line\">\t\t@set -e; rm -f <span class=\"variable\">$@</span>; \\      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -M <span class=\"variable\">$(CPPFLAGS)</span> <span class=\"variable\">$&lt;</span> &gt; <span class=\"variable\">$@</span>.</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">; \\      </span><br><span class=\"line\">\t\tsed &#x27;s,</span><br><span class=\"line\">$∗</span><br><span class=\"line\">\\.o[ :]*,\\1.o <span class=\"variable\">$@</span> : ,g&#x27; &lt; <span class=\"variable\">$@</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">\\&gt; <span class=\"variable\">$@</span>; \\      </span><br><span class=\"line\">\t\trm -f <span class=\"variable\">$@</span>.</span><br></pre></td></tr></table></figure>\n<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm-f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，</p>\n<p>“”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>\n<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： </p>\n<p><code>main.o : main.c defs.h</code></p>\n<p>转成：</p>\n<p><code>main.o main.d : main.c defs.h</code></p>\n<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sources = foo.c bar.c</span><br><span class=\"line\"><span class=\"keyword\">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>\n<p>上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标</p>\n<h2 id=\"5-Makefile-书写命令\"><a href=\"#5-Makefile-书写命令\" class=\"headerlink\" title=\"5. Makefile 书写命令\"></a><strong>5. Makefile 书写命令</strong></h2><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。</p>\n<h3 id=\"5-1-显示命令\"><a href=\"#5-1-显示命令\" class=\"headerlink\" title=\"5.1 显示命令\"></a><strong>5.1 显示命令</strong></h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“**@**”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如： </p>\n<p> == <strong>@符号： 不显示编译回显</strong>==  </p>\n<p><code>@echo 正在编译XXX模块......</code></p>\n<p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 正在编译XXX模块......  </span><br><span class=\"line\">正在编译XXX模块......</span><br></pre></td></tr></table></figure>\n<p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>\n<p>而make参数“-s”或“–slient”则是全面禁止命令的显示。</p>\n<h3 id=\"5-2-命令执行\"><a href=\"#5-2-命令执行\" class=\"headerlink\" title=\"5.2 命令执行\"></a><strong>5.2 命令执行</strong></h3><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：  </p>\n<p>示例一：    </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">exec:        </span></span><br><span class=\"line\">\t\tcd /home/hchen        </span><br><span class=\"line\">\t\tpwd</span><br></pre></td></tr></table></figure>\n<p>示例二：    </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">exec:        </span></span><br><span class=\"line\">\t\tcd /home/hchen; pwd</span><br></pre></td></tr></table></figure>\n<p>当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>\n<h3 id=\"5-3-命令出错\"><a href=\"#5-3-命令出错\" class=\"headerlink\" title=\"5.3 命令出错\"></a><strong>5.3 命令出错</strong></h3><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>\n<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>\n<p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:      </span></span><br><span class=\"line\">\t\t-rm -f *.o</span><br></pre></td></tr></table></figure>\n<p>还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>\n<p>还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>\n<h3 id=\"5-4-嵌套执行make\"><a href=\"#5-4-嵌套执行make\" class=\"headerlink\" title=\"5.4 嵌套执行make\"></a><strong>5.4 嵌套执行make</strong></h3><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。<br>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:      </span></span><br><span class=\"line\">\t\tcd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span></span><br></pre></td></tr></table></figure>\n<p>其等价于：   </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:      </span></span><br><span class=\"line\">\t\t<span class=\"variable\">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>\n<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</p>\n<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</p>\n<p><code>export&lt;variable ...&gt;</code></p>\n<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：</p>\n<p><code>unexport&lt;variable ...&gt;</code></p>\n<p>如示例一：     </p>\n<p><code>export variable = value</code></p>\n<p>其等价于：     </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable = value    </span><br><span class=\"line\"><span class=\"keyword\">export</span> variable</span><br></pre></td></tr></table></figure>\n<p>其等价于：     </p>\n<p><code>export variable := value</code></p>\n<p>其等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable := value    </span><br><span class=\"line\"><span class=\"keyword\">export</span> variable</span><br></pre></td></tr></table></figure>\n<p>示例二：<br><code>export variable += value</code>     </p>\n<p>其等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable += value    </span><br><span class=\"line\"><span class=\"keyword\">export</span> variable</span><br></pre></td></tr></table></figure>\n<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p>\n<p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>\n<p>但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:      </span></span><br><span class=\"line\">\t\tcd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>\n<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。还有一个在“嵌套执行”中比较有用的参数，“-w”或是“–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：</p>\n<p><code>make: Entering directory &#39;/home/hchen/gnu/make&#39;</code></p>\n<p>而在完成下层make后离开目录时，我们会看到：</p>\n<p><code>make: Leaving directory &#39;/home/hchen/gnu/make&#39;</code></p>\n<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“–slient”）或是“–no-print-directory”，那么，“-w”总是失效的。</p>\n<h3 id=\"5-5-定义命令包\"><a href=\"#5-5-定义命令包\" class=\"headerlink\" title=\"5.5 定义命令包\"></a><strong>5.5 定义命令包</strong></h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">define</span> run-yacc  </span><br><span class=\"line\">yacc <span class=\"variable\">$(<span class=\"built_in\">firstword</span> <span class=\"variable\">$^</span>)</span>  </span><br><span class=\"line\">mv y.tab.c <span class=\"variable\">$@</span>  </span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br></pre></td></tr></table></figure>\n<p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.c : foo.y      </span><br><span class=\"line\">\t\t$(run-yacc)</span><br></pre></td></tr></table></figure>\n<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>\n<hr>\n<p> <strong>使用变量</strong>————    在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。<br><strong>一、变量的基础</strong>  变量在声明时需要给予初值，而在使用时，需要给在变量名前<strong>加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来</strong>。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：objects = program.o foo.o utils.oprogram : $(objects)cc -o program $(objects)$(objects) : defs.h变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：foo = cprog.o : prog.$(foo)$(foo)$(foo) -$(foo) prog.$(foo)展开后得到：prog.o : prog.ccc -c prog.c当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>\n<p><strong>二、变量中的变量</strong>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：foo = $(bar)bar = $(ugh)ugh = Huh?all:echo $(foo)我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：CFLAGS = $(include_dirs) -Oinclude_dirs = -Ifoo -Ibar当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：CFLAGS = $(CFLAGS) -O或：A = $(B)B = $(A)这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：x := fooy := $(x) barx := later其等价于：y := foo barx := later值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：y := $(x) barx := foo那么，y的值是“bar”，而不是“foo bar”。上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：ifeq (0,${MAKELEVEL})cur-dir := $(shell pwd)whoami := $(shell whoami)host-type := $(shell arch)MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}endif关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：nullstring :=space := $(nullstring) # end of the linenullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：dir := /foo/bar # directory to put the frobs indir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。还有一个比较有用的操作符是“?=”，先看示例：FOO ?= bar其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：ifeq ($(origin FOO), undefined)FOO = barendif<br><strong>三、变量高级用法</strong>这里介绍两种变量的高级使用方法，第一种是<strong>变量值的替换</strong>。我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。还是看一个示例吧：foo := a.o b.o c.obar := $(foo:.o=.c)这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：foo := a.o b.o c.obar := $(foo:%.o=%.c)这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。<br>第二种高级用法是——“把<strong>变量的值再当成变量</strong>”。先看一个例子：x = yy = za := $($(x))在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）我们还可以使用更多的层次：x = yy = zz = ua := $($($(x)))这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：x = $(y)y = zz = Helloa := $($(x))这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。再复杂一点，我们再加上函数：x = variable1variable2 := Helloy = $(subst 1,2,$(x))z = ya := $($($(z)))这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：first_second = Helloa = firstb = secondall = $($a_$b)这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。再来看看结合第一种技术的例子：a_objects := a.o b.o c.o1_objects := 1.o 2.o 3.osources := $($(a1)_objects:.o=.c)这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。再来看一个这种技术和“函数”与“条件语句”一同使用的例子：ifdef do_sortfunc := sortelsefunc := stripendifbar := a d b g q cfoo := $($(func) $(bar))这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d bg q c)，调用的就是strip函数。当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：dir = foo$(dir)_sources := $(wildcard $(dir)/*.c)define $(dir)_printlpr $($(dir)_sources)endef这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。<br><strong>四、追加变量值</strong></p>\n<p>我们可以使用“+=”操作符给变量追加值，如：</p>\n<p>objects = main.o foo.o bar.o utils.o<br>objects += another.o</p>\n<p>于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p>\n<p>使用“+=”操作符，可以模拟为下面的这种例子：</p>\n<p>objects = main.o foo.o bar.o utils.o<br>objects := $(objects) another.o</p>\n<p>所不同的是，用“+=”更为简洁。</p>\n<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p>\n<p>variable := value<br>variable += more</p>\n<p>等价于：</p>\n<p>variable := value<br>variable := $(variable) more</p>\n<p>但如果是这种情况：</p>\n<p>variable = value<br>variable += more</p>\n<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>\n<p><strong>五、override 指示符</strong></p>\n<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>\n<p>override <variable> = <value><br>override <variable> := <value></p>\n<p>当然，你还可以追加：</p>\n<p>override <variable> += <more text></p>\n<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：</p>\n<p>override define foo<br>bar<br>endef</p>\n<p><strong>六、多行变量</strong></p>\n<p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>\n<p>define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>\n<p>下面的这个示例展示了define的用法：</p>\n<p>define two-lines<br>echo foo<br>echo $(bar)<br>endef</p>\n<p><strong>七、环境变量</strong></p>\n<p>make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>\n<p>因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。   当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>\n<p>  当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>\n<p><strong>八、目标变量</strong></p>\n<p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>\n<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>\n<p>其语法是：</p>\n<p>&lt;target …&gt; : <variable-assignment></p>\n<p>&lt;target …&gt; : overide <variable-assignment></p>\n<p><variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>\n<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>\n<p>prog : CFLAGS = -g<br>prog : prog.o foo.o bar.o<br>$(CC) $(CFLAGS) prog.o foo.o bar.o</p>\n<p>prog.o : prog.c<br>$(CC) $(CFLAGS) prog.c</p>\n<p>foo.o : foo.c<br>$(CC) $(CFLAGS) foo.c</p>\n<p>bar.o : bar.c<br>$(CC) $(CFLAGS) bar.c</p>\n<p>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”</p>\n<p><strong>九、模式变量</strong></p>\n<p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>\n<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>\n<p>%.o : CFLAGS = -O</p>\n<p>同样，模式变量的语法和“目标变量”一样：</p>\n<p>&lt;pattern …&gt; : <variable-assignment></p>\n<p>&lt;pattern …&gt; : override <variable-assignment></p>\n<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>\n<p><strong>使用条件判断</strong>——————使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>\n<p>一、示例</p>\n<p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>\n<p>libs_for_gcc = -lgnu<br>normal_libs =</p>\n<p>foo: $(objects)<br>ifeq ($(CC),gcc)<br>$(CC) -o foo $(objects) $(libs_for_gcc)<br>else<br>$(CC) -o foo $(objects) $(normal_libs)<br>endif</p>\n<p>可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。</p>\n<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>\n<p>当我们的变量$(CC)值是“gcc”时，目标foo的规则是：</p>\n<p>foo: $(objects)<br>$(CC) -o foo $(objects) $(libs_for_gcc)</p>\n<p>而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：</p>\n<p>foo: $(objects)<br>$(CC) -o foo $(objects) $(normal_libs)</p>\n<p>当然，我们还可以把上面的那个例子写得更简洁一些：</p>\n<p>libs_for_gcc = -lgnu<br>normal_libs =</p>\n<p>ifeq ($(CC),gcc)<br>libs=$(libs_for_gcc)<br>else<br>libs=$(normal_libs)<br>endif</p>\n<p>foo: $(objects)<br>$(CC) -o foo $(objects) $(libs)</p>\n<p>二、语法</p>\n<p>条件表达式的语法为：</p>\n<conditional-directive>\n<text-if-true>\nendif\n\n\n<p>以及：</p>\n<conditional-directive>\n<text-if-true>\nelse\n<text-if-false>\nendif\n\n\n<p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。</p>\n<p>第一个是我们前面所见过的“ifeq”</p>\n<p>ifeq (<arg1>, <arg2> )<br>ifeq ‘<arg1>‘ ‘<arg2>‘<br>ifeq “<arg1>“ “<arg2>“<br>ifeq “<arg1>“ ‘<arg2>‘<br>ifeq ‘<arg1>‘ “<arg2>“</p>\n<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>\n<p>ifeq ($(strip $(foo)),)<br><text-if-empty><br>endif</p>\n<p>这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。</p>\n<p>第二个条件关键字是“ifneq”。语法是：</p>\n<p>ifneq (<arg1>, <arg2> )<br>ifneq ‘<arg1>‘ ‘<arg2>‘<br>ifneq “<arg1>“ “<arg2>“<br>ifneq “<arg1>“ ‘<arg2>‘<br>ifneq ‘<arg1>‘ “<arg2>“</p>\n<p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p>\n<p>第三个条件关键字是“ifdef”。语法是：</p>\n<p>ifdef <variable-name></p>\n<p>如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p>\n<p>示例一：<br>bar =<br>foo = $(bar)<br>ifdef foo<br>frobozz = yes<br>else<br>frobozz = no<br>endif</p>\n<p>示例二：<br>foo =<br>ifdef foo<br>frobozz = yes<br>else<br>frobozz = no<br>endif</p>\n<p>第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。</p>\n<p>第四个条件关键字是“ifndef”。其语法是：</p>\n<p>ifndef <variable-name></p>\n<p>这个我就不多说了，和“ifdef”是相反的意思。</p>\n<p>在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也<br>一样，只要不是以[Tab]键开始就行了。</p>\n<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>\n<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>\n<p><strong>使用函数**</strong>————<strong>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</strong>一、函数的调用语法**函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>\n<p>$(<function> <arguments> )</p>\n<p>或是</p>\n<p>${<function> <arguments>}</p>\n<p>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>\n<p>还是来看一个示例：</p>\n<p>comma:= ,<br>empty:=<br>space:= $(empty) $(empty)<br>foo:= a b c<br>bar:= $(subst $(space),$(comma),$(foo))</p>\n<p>在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“<br>a,b,c”。</p>\n<p><strong>二、字符串处理函数</strong></p>\n<p>$(subst <from>,<to>,<text> )</p>\n<p>名称：字符串替换函数——subst。<br>功能：把字串<text>中的<from>字符串替换成<to>。<br>返回：函数返回被替换过后的字符串。</p>\n<p>示例：</p>\n<p>$(subst ee,EE,feet on the street)，</p>\n<p>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt<br>”。</p>\n<p>$(patsubst <pattern>,<replacement>,<text> )</p>\n<p>名称：模式字符串替换函数——patsubst。<br>功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\\”来转义，以“%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。</p>\n<p>示例：</p>\n<p>$(patsubst %.c,%.o,x.c.c bar.c)</p>\n<p>把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</p>\n<p>备注：</p>\n<p>这和我们前面“变量章节”说过的相关知识有点相似。如：</p>\n<p>“$(var:<pattern>=<replacement> )”<br>相当于<br>“$(patsubst <pattern>,<replacement>,$(var))”，</p>\n<p>而“$(var: <suffix>=<replacement> )”<br>则相当于<br>“$(patsubst %<suffix>,%<replacement>,$(var))”。</p>\n<p>例如有：objects = foo.o bar.o baz.o，<br>那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。</p>\n<p>$(strip <string> )</p>\n<p>名称：去空格函数——strip。<br>功能：去掉<string>字串中开头和结尾的空字符。<br>返回：返回被去掉空格的字符串值。<br>示例：</p>\n<p>$(strip a b c )</p>\n<p>把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p>\n<p>$(findstring <find>,<in> )</p>\n<p>名称：查找字符串函数——findstring。<br>功能：在字串<in>中查找<find>字串。<br>返回：如果找到，那么返回<find>，否则返回空字符串。<br>示例：</p>\n<p>$(findstring a,a b c)<br>$(findstring a,b c)</p>\n<p>第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</p>\n<p>$(filter &lt;pattern…&gt;,<text> )</p>\n<p>名称：过滤函数——filter。<br>功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可<br>以有多个模式。<br>返回：返回符合模式<pattern>的字串。<br>示例：</p>\n<p>sources := foo.c bar.c baz.s ugh.h<br>foo: $(sources)<br>cc $(filter %.c %.s,$(sources)) -o foo</p>\n<p>$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。</p>\n<p>$(filter-out &lt;pattern…&gt;,<text> )</p>\n<p>名称：反过滤函数——filter-out。<br>功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可<br>以有多个模式。<br>返回：返回不符合模式<pattern>的字串。<br>示例：</p>\n<p>objects=main1.o foo.o main2.o bar.o<br>mains=main1.o main2.o</p>\n<p>$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。</p>\n<p>$(sort <list> )</p>\n<p>名称：排序函数——sort。<br>功能：给字符串<list>中的单词排序（升序）。<br>返回：返回排序后的字符串。<br>示例：$(sort foo bar lose)返回“bar foo lose” 。<br>备注：sort函数会去掉<list>中相同的单词。</p>\n<p>$(word <n>,<text> )</p>\n<p>名称：取单词函数——word。<br>功能：取字符串<text>中第<n>个单词。（从一开始）<br>返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空<br>字符串。<br>示例：$(word 2, foo bar baz)返回值是“bar”。</p>\n<p>$(wordlist <s>,<e>,<text> )</p>\n<p>名称：取单词串函数——wordlist。<br>功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。<br>返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那<br>么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单<br>词串。<br>示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</p>\n<p>$(words <text> )</p>\n<p>名称：单词个数统计函数——words。<br>功能：统计<text>中字符串中的单词个数。<br>返回：返回<text>中的单词数。<br>示例：$(words, foo bar baz)返回值是“3”。<br>备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text><br>),<text> )。</p>\n<p>$(firstword <text> )</p>\n<p>名称：首单词函数——firstword。<br>功能：取字符串<text>中的第一个单词。<br>返回：返回字符串<text>的第一个单词。<br>示例：$(firstword foo bar)返回值是“foo”。<br>备注：这个函数可以用word函数来实现：$(word 1,<text> )。</p>\n<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，<br>举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索<br>路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，<br>如：</p>\n<p>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))</p>\n<p>如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :<br>, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数<br>。</p>\n<p><strong>三、文件名操作函数</strong><br>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是<br>一系列的文件名来对待。</p>\n<p>$(dir &lt;names…&gt; )</p>\n<p>名称：取目录函数——dir。<br>功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之<br>前的部分。如果没有反斜杠，那么返回“./”。<br>返回：返回文件名序列<names>的目录部分。<br>示例： $(dir src/foo.c hacks)返回值是“src/ ./”。</p>\n<p>$(notdir &lt;names…&gt; )</p>\n<p>名称：取文件函数——notdir。<br>功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”<br>）之后的部分。<br>返回：返回文件名序列<names>的非目录部分。<br>示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。</p>\n<p>$(suffix &lt;names…&gt; )</p>\n<p>名称：取后缀函数——suffix。<br>功能：从文件名序列<names>中取出各个文件名的后缀。<br>返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。<br>示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</p>\n<p>$(basename &lt;names…&gt; )</p>\n<p>名称：取前缀函数——basename。<br>功能：从文件名序列<names>中取出各个文件名的前缀部分。<br>返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。<br>示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar h<br>acks”。</p>\n<p>$(addsuffix <suffix>,&lt;names…&gt; )</p>\n<p>名称：加后缀函数——addsuffix。<br>功能：把后缀<suffix>加到<names>中的每个单词后面。<br>返回：返回加过后缀的文件名序列。<br>示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。</p>\n<p>$(addprefix <prefix>,&lt;names…&gt; )</p>\n<p>名称：加前缀函数——addprefix。<br>功能：把前缀<prefix>加到<names>中的每个单词后面。<br>返回：返回加过前缀的文件名序列。<br>示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。</p>\n<p>$(join <list1>,<list2> )</p>\n<p>名称：连接函数——join。<br>功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比&lt;<br>list2&gt;的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比<br><list1>多，那么，<list2>多出来的单词将被复制到<list2>中。<br>返回：返回连接过后的字符串。<br>示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</p>\n<p><strong>四、foreach 函数</strong></p>\n<p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的<br>foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin<br>/csh）中的foreach语句而构建的。它的语法是：</p>\n<p>$(foreach <var>,<list>,<text> )</p>\n<p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>\n<p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var><br>这个参数来依次枚举<list>中的单词。举个例子：</p>\n<p>names := a b c d</p>\n<p>files := $(foreach n,$(names),$(n).o)</p>\n<p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(f<br>iles)的值是“a.o b.o c.o d.o”。</p>\n<p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</p>\n<p><strong>五、if 函数</strong></p>\n<p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>\n<p>$(if <condition>,<then-part> )</p>\n<p>或是</p>\n<p>$(if <condition>,<then-part>,<else-part> )</p>\n<p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。</p>\n<p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</p>\n<p>所以，<then-part>和<else-part>只会有一个被计算。</p>\n<p><strong>六、call函数</strong><br>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>\n<p>$(call <expression>,<parm1>,<parm2>,<parm3>…)</p>\n<p>当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。例如：</p>\n<p>reverse = $(1) $(2)</p>\n<p>foo = $(call reverse,a,b)</p>\n<p>那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>\n<p>reverse = $(2) $(1)<br>foo = $(call reverse,a,b)</p>\n<p>此时的foo的值就是“b a”。</p>\n<p><strong>七、origin函数</strong>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>\n<p>$(origin <variable> )</p>\n<p>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函<br>数的返回值:</p>\n<p>“undefined”</p>\n<p>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</p>\n<p>“default”</p>\n<p>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p>\n<p>“environment”</p>\n<p>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</p>\n<p>“file”</p>\n<p>如果<variable>这个变量被定义在Makefile中。</p>\n<p>“command line”</p>\n<p>如果<variable>这个变量是被命令行定义的。</p>\n<p>“override”</p>\n<p>如果<variable>是被override指示符重新定义的。</p>\n<p>“automatic”</p>\n<p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>\n<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一<br>个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是<br>，在我们的Makefile中，我们可以这样写：</p>\n<p>ifdef bletch</p>\n<p>ifeq “$(origin bletch)” “environment”</p>\n<p>bletch = barf, gag, etc.</p>\n<p>endif</p>\n<p>endif</p>\n<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗<br>暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>\n<p><strong>八、shell函数</strong><br>shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数<br>返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>\n<p>contents := $(shell cat foo)</p>\n<p>files := $(shell echo *.c)</p>\n<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>\n<p><strong>九、控制make的函数</strong></p>\n<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>\n<p>$(error &lt;text …&gt; )</p>\n<p>产生一个致命的错误，&lt;text …&gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也<br>是可以的。例如：</p>\n<p>示例一：</p>\n<p>ifdef ERROR_001</p>\n<p>$(error error is $(ERROR_001))</p>\n<p>endif</p>\n<p>示例二：</p>\n<p>ERR = $(error found an error!)</p>\n<p>.PHONY: err</p>\n<p>err: ; $(ERR)</p>\n<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>\n<p>$(warning &lt;text …&gt; )</p>\n<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>\n<p><strong>make 的运行</strong>——————一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。<br><strong>一、make的退出码</strong>make命令执行后有三个退出码：0 —— 表示成功执行。1 —— 如果make运行时出现任何错误，其返回1。2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。Make的相关参数我们会在后续章节中讲述。<br><strong>二、指定Makefile</strong></p>\n<p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就<br>开始读取这个文件并执行。</p>\n<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“– makefile”参数也行）。例如，我们有个mak<br>efile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p>\n<p>make –f hchen.mk</p>\n<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>\n<p><strong>三、指定目标</strong></p>\n<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>\n<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>\n<p>sources = foo.c bar.c<br>ifneq ( $(MAKECMDGOALS),clean)<br>include $(sources:.c=.d)<br>endif</p>\n<p>基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>\n<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>\n<p>.PHONY: all<br>all: prog1 prog2 prog3 prog4</p>\n<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标<br>（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。</p>\n<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件<br>发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>\n<p><strong>“all”</strong>        这个伪目标是所有目标的目标，其功能一般是编译所有的目标。<strong>“clean”</strong>    这个伪目标功能是删除所有被make创建的文件。<strong>“install”</strong>    这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。<strong>“print”</strong>     这个伪目标的功能是例出改变过的源文件。<strong>“tar”</strong>       这个伪目标功能是把源程序打包备份。也就是一个tar文件。<strong>“dist”</strong>      这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。<strong>“TAGS”</strong>     这个伪目标功能是更新所有的目标，以备完整地重编译使用。<strong>“check”和“test”</strong>   这两个伪目标一般用来<a href=\"http://lib.csdn.net/base/softwaretest\">测试</a>makefile的流程。</p>\n<p>​    当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>\n<p><strong>四、检查规则</strong></p>\n<p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>\n<p>“-n”<br>“–just-print”<br>“–dry-run”<br>“–recon”<br>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>\n<p>“-t”<br>“–touch”<br>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>\n<p>“-q”<br>“–question”<br>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>\n<p>“-W <file>”<br>“–what-if=<file>”<br>“–assume-new=<file>”<br>“–new-file=<file>”<br>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件<br>所发生的规则命令。</p>\n<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>\n<p><strong>五、make的参数</strong></p>\n<p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>\n<p>“-b”<br>“-m”<br>这两个参数的作用是忽略和其它版本make的兼容性。</p>\n<p>“-B”<br>“–always-make”<br>认为所有的目标都需要更新（重编译）。</p>\n<p>“-C <dir>”<br>“–directory=<dir>”<br>指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”<br>等价于“make –C ~hchen/test/prog”。</p>\n<p>“—debug[=<options>]”<br>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：<br>a —— 也就是all，输出所有的调试信息。（会非常的多）b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i —— 也就是implicit，输出所以的隐含规则。j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p>\n<p>“-d”<br>相当于“–debug=a”。</p>\n<p>“-e”<br>“–environment-overrides”<br>指明环境变量的值覆盖makefile中定义的变量的值。</p>\n<p>“-f=<file>”<br>“–file=<file>”<br>“–makefile=<file>”<br>指定需要执行的makefile。</p>\n<p>“-h”<br>“–help”<br>显示帮助信息。</p>\n<p>“-i”<br>“–ignore-errors”<br>在执行时忽略所有的错误。</p>\n<p>“-I <dir>”<br>“–include-dir=<dir>”<br>指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p>\n<p>“-j [<jobsnum>]”<br>“–jobs[=<jobsnum>]”<br>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-D<br>OS中是无用的）</p>\n<p>“-k”<br>“–keep-going”<br>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>\n<p>“-l <load>”<br>“–load-average[=&lt;load]”<br>“—max-load[=<load>]”<br>指定make运行命令的负载。</p>\n<p>“-n”<br>“–just-print”<br>“–dry-run”<br>“–recon”<br>仅输出执行过程中的命令序列，但并不执行。</p>\n<p>“-o <file>”<br>“–old-file=<file>”<br>“–assume-old=<file>”<br>不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p>\n<p>“-p”<br>“–print-data-base”<br>输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -q<br>p”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用<br>这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>\n<p>“-q”<br>“–question”<br>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>\n<p>“-r”<br>“–no-builtin-rules”<br>禁止make使用任何隐含规则。</p>\n<p>“-R”<br>“–no-builtin-variabes”<br>禁止make使用任何作用于变量上的隐含规则。</p>\n<p>“-s”<br>“–silent”<br>“–quiet”<br>在命令运行时不输出命令的输出。</p>\n<p>“-S”<br>“–no-keep-going”<br>“–stop”<br>取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>\n<p>“-t”<br>“–touch”<br>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>\n<p>“-v”<br>“–version”<br>输出make程序的版本、版权等关于make的信息。</p>\n<p>“-w”<br>“–print-directory”<br>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>\n<p>“–no-print-directory”<br>禁止“-w”选项。</p>\n<p>“-W <file>”<br>“–what-if=<file>”<br>“–new-file=<file>”<br>“–assume-file=<file>”<br>假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时<br>间为当前时间。</p>\n<p>“–warn-undefined-variables”<br>只要make发现有未定义的变量，那么就输出警告信息。</p>\n<p><strong>隐含规则**</strong>————**</p>\n<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>\n<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就<br>不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>\n<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>\n<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保<br>证我们Makefile的兼容性。<br>我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当<br>然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>\n<p><strong>一、使用隐含规则</strong></p>\n<p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>\n<p>foo : foo.o bar.o<br>cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</p>\n<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成<br>命令。</p>\n<p>make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>\n<p>foo.o : foo.c<br>cc –c foo.c $(CFLAGS)<br>bar.o : bar.c<br>cc –c bar.c $(CFLAGS)</p>\n<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>\n<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>\n<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>\n<p>foo.o : foo.p</p>\n<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成f<br>oo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>\n<p><strong>二、隐含规则一览</strong></p>\n<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>\n<p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统<br>定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .<br>h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。</p>\n<p>还是先来看一看常用的隐含规则吧。</p>\n<p>1、编译C程序的隐含规则。<br>“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”</p>\n<p>2、编译C++程序的隐含规则。<br>“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而<br>不是“.C”）</p>\n<p>3、编译Pascal程序的隐含规则。<br>“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。</p>\n<p>4、编译Fortran/Ratfor程序的隐含规则。<br>“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:<br>“.f” “$(FC) –c $(FFLAGS)”<br>“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”<br>“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”</p>\n<p>5、预处理Fortran/Ratfor程序的隐含规则。<br>“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br>“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”<br>“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”</p>\n<p>6、编译Modula-2程序的隐含规则。<br>“<n>.sym” 的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“<n>.mod”，<br>并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。</p>\n<p>7、汇编和汇编预处理的隐含规则。<br>“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”<br>，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。</p>\n<p>8、链接Object文件的隐含规则。<br>“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对<br>于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>\n<p>x : y.o z.o</p>\n<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>\n<p>cc -c x.c -o x.o<br>cc -c y.c -o y.o<br>cc -c z.c -o z.o<br>cc x.o y.o z.o -o x<br>rm -f x.o<br>rm -f y.o<br>rm -f z.o</p>\n<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>\n<p>9、Yacc C程序时的隐含规则。</p>\n<p>“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>\n<p>10、Lex C程序时的隐含规则。<br>“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）</p>\n<p>11、Lex Ratfor程序时的隐含规则。<br>“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX<br>) $(LFALGS)”。</p>\n<p>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。<br>“<n>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。</p>\n<p><strong>三、隐含规则使用的变量</strong></p>\n<p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量<br>对隐含规则的作用。</p>\n<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把<br>变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。</p>\n<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数<br>相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>\n<p><strong>1、关于命令的变量。</strong></p>\n<p>AR  函数库打包程序。默认命令是“ar”。<br>AS<br>汇编语言编译程序。默认命令是“as”。<br>CC<br>C语言编译程序。默认命令是“cc”。<br>CXX<br>C++语言编译程序。默认命令是“g++”。<br>CO<br>从 RCS文件中扩展文件程序。默认命令是“co”。<br>CPP<br>C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。<br>FC<br>Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。<br>GET<br>从SCCS文件中扩展文件的程序。默认命令是“get”。<br>LEX<br>Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。<br>PC<br>Pascal语言编译程序。默认命令是“pc”。<br>YACC<br>Yacc文法分析器（针对于C程序）。默认命令是“yacc”。<br>YACCR<br>Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。<br>MAKEINFO<br>转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。<br>TEX<br>从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。<br>TEXI2DVI<br>从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。<br>WEAVE<br>转换Web到TeX的程序。默认命令是“weave”。<br>CWEAVE<br>转换C Web 到 TeX的程序。默认命令是“cweave”。<br>TANGLE<br>转换Web到Pascal语言的程序。默认命令是“tangle”。<br>CTANGLE<br>转换C Web 到 C。默认命令是“ctangle”。<br>RM<br>删除文件命令。默认命令是“rm –f”。</p>\n<p><strong>2、关于命令参数的变量</strong><br>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是<br>空。</p>\n<p>ARFLAGS<br>函数库打包程序AR命令的参数。默认值是“rv”。<br>ASFLAGS<br>汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。<br>CFLAGS<br>C语言编译器参数。<br>CXXFLAGS<br>C++语言编译器参数。<br>COFLAGS<br>RCS命令参数。<br>CPPFLAGS<br>C预处理器参数。（ C 和 Fortran 编译器也会用到）。<br>FFLAGS<br>Fortran语言编译器参数。<br>GFLAGS<br>SCCS “get”程序参数。<br>LDFLAGS<br>链接器参数。（如：“ld”）<br>LFLAGS<br>Lex文法分析器参数。<br>PFLAGS<br>Pascal语言编译器参数。<br>RFLAGS<br>Ratfor 程序的Fortran 编译器参数。<br>YFLAGS<br>Yacc文法分析器参数。</p>\n<p><strong>四、隐含规则链</strong></p>\n<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则<br>叫做“隐含规则链”。</p>\n<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调<br>用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>\n<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>\n<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p>\n<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）</p>\n<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>\n<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>\n<p>Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规<br>则就不会生成中间文件。</p>\n<p><strong>五、定义模式规则</strong></p>\n<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p>\n<p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p>\n<p><strong>1、模式规则介绍</strong></p>\n<p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为 5）。</p>\n<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：</p>\n<p>%.o : %.c ; &lt;command ……&gt;</p>\n<p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是”a.o b.o”，那么”%c”就是”a.c b.c”。</p>\n<p>一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>\n<p><strong>2、模式规则示例</strong></p>\n<p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.</p>\n<p>%.o : %.c<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</p>\n<p>其中，”$@”表示所有的目标的挨个值，”$&lt;”表示了所有依赖目标的挨个值。这些奇怪的变<br>量我们叫”自动化变量”，后面会详细讲述。</p>\n<p>下面的这个例子中有两个目标是模式的：</p>\n<p>%.tab.c %.tab.h: %.y<br>bison -d $&lt;</p>\n<p>这条规则告诉make把所有的[.y]文件都以”bison -d <n>.y”执行，然后生成”<n>.tab.c”和”<n>.tab.h”文件。（其中，”<n>“ 表示一个任意字符串）。如果我们的执行程序”foo”依<br>赖于文件”parse.tab.o”和”scan.o”，并且文件”scan.o”依赖于文件”parse.tab.h”，如果”parse.y”文件被更新了，那么根据上述的规则，”bison -d parse.y”就会被执行一次，于<br>是，”parse.tab.o”和”scan.o”的依赖文件就齐了。（假设，”parse.tab.o” 由”parse.tab.c”生成，和”scan.o”由”scan.c”生成，而”foo”由”parse.tab.o”和”scan.o”链接生成，<br>而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>\n<p><strong>3、自动化变量</strong></p>\n<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>\n<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>\n<p>下面是所有的自动化变量及其说明：</p>\n<p>$@<br>表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</p>\n<p>$%<br>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是<br>[.a]，Windows下是[.lib]），那么，其值为空。</p>\n<p>$&lt;<br>依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>\n<p>$?<br>所有比目标新的依赖目标的集合。以空格分隔。</p>\n<p>$^<br>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>\n<p>$+<br>这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>\n<p>$*<br>这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，”$<em>“的值就是”dir /a.foo”。这个变量对于构造有关联的文件名是比<br>较有较。如果目标中没有模式的定义，那么”$</em>“也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么”$<em>“就是除了后缀的那一部分。例如：如果目标是”foo.c”<br>，因为”.c”是make所能识别的后缀名，所以，”$</em>“的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用”$<em>“，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么”$</em>“就是空值。</p>\n<p>当你希望只对更新过的依赖文件进行操作时，”$?”在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效<br>率的Makefile规则是：</p>\n<p>lib : foo.o bar.o lose.o win.o<br>ar r lib $?</p>\n<p>在上述所列出来的自动量变量中。四个变量（$@、$&lt;、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNU make中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。</p>\n<p>下面是对于上面的七个变量分别加上”D”或是”F”的含义：</p>\n<p>$(@D)<br>表示”$@”的目录部分（不以斜杠作为结尾），如果”$@”值是”dir/foo.o”，那么”$(@D)”就是”dir”，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。</p>\n<p>$(@F)<br>表示”$@”的文件部分，如果”$@”值是”dir/foo.o”，那么”$(@F)”就是”foo.o”，”$(@F)”相当于函数”$(notdir $@)”。</p>\n<p>“$(*D)”<br>“$(*F)”<br>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，”$(*D)”返回”dir”，而”$(*F)”返回”foo”</p>\n<p>“$(%D)”<br>“$(%F)”<br>分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。</p>\n<p>“$(&lt;D)”<br>“$(&lt;F)”<br>分别表示依赖文件的目录部分和文件部分。</p>\n<p>“$(^D)”<br>“$(^F)”<br>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p>\n<p>“$(+D)”<br>“$(+F)”<br>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p>\n<p>“$(?D)”<br>“$(?F)”</p>\n<p>分别表示被更新的依赖文件的目录部分和文件部分。</p>\n<p>最后想提醒一下的是，对于”$&lt;”，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，”$(&lt; )”就要比”$&lt;”要好一些。</p>\n<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。</p>\n<p><strong>4、模式的匹配</strong></p>\n<p>一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p>\n<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat” 匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）</p>\n<p><strong>5、重载内建隐含规则</strong></p>\n<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>\n<p>%.o : %.c<br>$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)</p>\n<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>\n<p>%.o : %.s</p>\n<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>\n<p><strong>六、老式风格的”后缀规则”</strong></p>\n<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p>\n<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o : %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”% : %.c”。</p>\n<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c” 是源文件的后缀，”.o”是目标文件的后缀。如下示例：</p>\n<p>.c.o:<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>\n<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>\n<p>.c.o: foo.h<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>\n<p>这个例子，就是说，文件”.c.o”依赖于文件”foo.h”，而不是我们想要的这样：</p>\n<p>%.o: %.c foo.h<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>\n<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>\n<p>而要让make知道一些特定的后缀，我们可以使用伪目标”.SUFFIXES”来定义或是删除，如：</p>\n<p>.SUFFIXES: .hack .win</p>\n<p>把后缀.hack和.win加入后缀列表中的末尾。</p>\n<p>.SUFFIXES: # 删除默认的后缀<br>.SUFFIXES: .c .o .h # 定义自己的后缀</p>\n<p>先清楚默认后缀，后定义自己的后缀列表。</p>\n<p>make的参数”-r”或”-no-builtin-rules”也会使用得默认的后缀列表为空。而变量”SUFFIXE”被用来定义默认的后缀列表，你可以用”.SUFFIXES”来改变后缀列表，但请不要改变变量”SUFFIXE”的值。</p>\n<p><strong>七、隐含规则搜索算法</strong><br>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是”archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把”member”当作T来搜索。</p>\n<p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）2、创建所有匹配于T或是N的模式规则列表。3、如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。4、移除列表中没有命令的规则。5、对于第一个在列表中的模式规则：<br>1）推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。2）计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该<a href=\"http://lib.csdn.net/base/datastructure\">算法</a>。6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：1）如果规则是终止规则，那就忽略它，继续下一条模式规则。2）计算依赖文件。（同第5步）3）测试所有的依赖文件是否存在或是理当存在。4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。7、如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</p>\n<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>\n<p><strong>使用make更新函数库文件**</strong>———————————**</p>\n<p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p>\n<p><strong>一、函数库文件的成员</strong></p>\n<p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p>\n<p>archive(member)</p>\n<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：</p>\n<p>foolib(hack.o) : hack.o<br>ar cr foolib hack.o</p>\n<p>如果要指定多个member，那就以空格分开，如：</p>\n<p>foolib(hack.o kludge.o)</p>\n<p>其等价于：</p>\n<p>foolib(hack.o) foolib(kludge.o)</p>\n<p>你还可以使用Shell的文件通配符来定义，如：</p>\n<p>foolib(*.o)</p>\n<p><strong>二、函数库成员的隐含规则</strong></p>\n<p>当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o” 的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>\n<p>cc -c bar.c -o bar.o<br>ar r foo.a bar.o<br>rm -f bar.o</p>\n<p>还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。</p>\n<p><strong>三、函数库文件的后缀规则</strong></p>\n<p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：</p>\n<p>.c.a:<br>$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o<br>$(AR) r $@ $</em>.o<br>$(RM) $*.o</p>\n<p>其等效于：</p>\n<p>(%.o) : %.c<br>$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o<br>$(AR) r $@ $</em>.o<br>$(RM) $*.o</p>\n<p><strong>四、注意事项</strong></p>\n<p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。<br>但就目前而言，你还是应该不要尽量不要使用”-j”参数。</p>\n<p><strong>后序**</strong>——**</p>\n<p>终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测”函数”那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）”杀伤力”。</p>\n<p>对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp……等等，等等，来完成诸如”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如”@@@N、###N”奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的”@@@N、###N”等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的”扩展C”语言（即在C语言中用”EXEC　SQL”的样子执行SQL语句，在用 cc/gcc编译之前，需要使用”扩展C”的翻译程序，如cpre，把其翻译成标准C）。如果<br>你在使用make时有一些更为绝妙的方法，请记得告诉我啊。</p>\n<p>回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入”!make”时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。</p>\n<p>现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的 Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。</p>\n<p>最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命——网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在“技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。我的MSN是：<a href=\"mailto:&#104;&#x61;&#111;&#101;&#108;&#x40;&#104;&#x6f;&#116;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;\">&#104;&#x61;&#111;&#101;&#108;&#x40;&#104;&#x6f;&#116;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>（常用），QQ是：753640（不常用）。（注：请勿给我MSN的邮箱发信，由于hotmail的垃圾<br>邮件导致我拒收这个邮箱的所有来信）</p>\n<p>我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！</p>\n<p>最最后，我还想介绍一下make程序的设计开发者。</p>\n<p>首当其冲的是： Richard Stallman</p>\n<p>开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：<a href=\"http://www.stallman.org/\">http://www.stallman.org/</a> 。<br>第二位是：Roland McGrath<br>个人主页是：<a href=\"http://www.frob.com/~roland/\">http://www.frob.com/~roland/</a> ，下面是他的一些事迹：</p>\n<p>1） 合作编写了并维护GNU make。2） 和Thomas Bushnell一同编写了GNU Hurd。3） 编写并维护着GNU C library。4） 合作编写并维护着部分的GNU Emacs。<br>在此，向这两位开源项目的斗士致以最真切的敬意。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Makefile基础\"><a href=\"#Makefile基础\" class=\"headerlink\" title=\"Makefile基础\"></a>Makefile基础</h1><blockquote>\n<p>什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不得不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计其数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。<strong>make是一个命令工具，是一个解释makefile中指令的命令工具</strong>，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p>\n</blockquote>\n<hr>\n<p>现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat <strong>linux</strong> 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。  在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p>\n<h2 id=\"1-关于程序的编译和链接\"><a href=\"#1-关于程序的编译和链接\" class=\"headerlink\" title=\"1. 关于程序的编译和链接\"></a><strong>1. 关于程序的编译和链接</strong></h2><p>在此，我想多说关于程序编译的一些规范和方法，一般来说，无论是C、C++、还是passical，首先要把源文件编译成<strong>中间代码文件</strong>，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做*<strong>*编译\\</strong>（compile）<strong>。然后再把大量的Object File合成执行文件，这个动作叫作</strong>链接**（link）。</p>\n<p><strong>编译时</strong>，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。</p>\n<p><strong>链接时</strong>，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，<strong>我们要给中间目标文件打个包</strong>，在Windows下这种包叫“**库文件”（Library File)**，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p>\n<p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，<strong>编译器只检测程序语法，和函数、变量是否被声明</strong>。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.</p>\n<p>好，言归正传，GNU的make有许多的内容，闲言少叙，还是让我们开始吧。</p>\n<h2 id=\"2-Makefile-介绍\"><a href=\"#2-Makefile-介绍\" class=\"headerlink\" title=\"2. Makefile 介绍\"></a><strong>2. Makefile 介绍</strong></h2><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。   首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感兴认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。如果这个工程的<strong>头文件</strong>被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。   只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动<strong>智能</strong>地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p>\n<h3 id=\"2-1-Makefile的规则\"><a href=\"#2-1-Makefile的规则\" class=\"headerlink\" title=\"2.1 Makefile的规则\"></a><strong>2.1 Makefile的规则</strong></h3><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">target... : prerequisites ...</span><br><span class=\"line\">command</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>target</strong>：目标文件，可以是<strong>Object File</strong>，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li>\n</ul>\n<ul>\n<li><p><strong>prerequisites</strong>：要生成那个target所需要的文件或是目标。    </p>\n</li>\n<li><p><strong>command</strong>：make需要执行的命令。（任意的Shell命令）</p>\n</li>\n</ul>\n<p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。    说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p>\n<h3 id=\"2-2-一个示例\"><a href=\"#2-2-一个示例\" class=\"headerlink\" title=\"2.2 一个示例\"></a><strong>2.2 一个示例</strong></h3><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit : main.o kbd.o command.o display.o \\</span><br><span class=\"line\">       insert.o search.o files.o utils.o</span><br><span class=\"line\">       cc -o edit main.o kbd.o command.o display.o \\</span><br><span class=\"line\">                  insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">         cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">        cc -c kbd.c</span><br><span class=\"line\">command.o : command.c defs.h command.h</span><br><span class=\"line\">            cc -c command.c</span><br><span class=\"line\">display.o : display.c defs.h buffer.h</span><br><span class=\"line\">            cc -c display.c</span><br><span class=\"line\">insert.o : insert.c defs.h buffer.h</span><br><span class=\"line\">           cc -c insert.c</span><br><span class=\"line\">search.o : search.c defs.h buffer.h</span><br><span class=\"line\">           cc -c search.c</span><br><span class=\"line\">files.o : files.c defs.h buffer.h command.h</span><br><span class=\"line\">           cc -c files.c</span><br><span class=\"line\">utils.o : utils.c defs.h</span><br><span class=\"line\">           cc -c utils.c</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit main.o kbd.o command.o display.o \\</span><br><span class=\"line\">                insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n<p><strong>反斜杠（\\）</strong>是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</p>\n<p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。*</p>\n<p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的<strong>操作系统命令，一定要以一个Tab键作为开头。记住，make并不管命令是怎么工作的，他只管执行所定义的命令</strong>。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p>\n<p><strong>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像</strong>C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>\n<h3 id=\"2-3-make是如何工作的\"><a href=\"#2-3-make是如何工作的\" class=\"headerlink\" title=\"2.3 make是如何工作的\"></a><strong>2.3 make是如何工作的</strong></h3><p>在默认的方式下，也就是我们只输入make命令。那么:</p>\n<ul>\n<li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。 </li>\n</ul>\n<ul>\n<li><p>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。 </p>\n</li>\n<li><p>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。 </p>\n</li>\n<li><p>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。</p>\n</li>\n<li><p>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。  </p>\n</li>\n</ul>\n<p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p>\n<p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——<strong>“make clean”，以此来清除所有的目标文件，以便重编译</strong>。</p>\n<p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p>\n<h3 id=\"2-4-makefile中使用变量\"><a href=\"#2-4-makefile中使用变量\" class=\"headerlink\" title=\"2.4 makefile中使用变量\"></a><strong>2.4 makefile中使用变量</strong></h3><p> 在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。</p>\n<h4 id=\"2-4-1-变量的基础\"><a href=\"#2-4-1-变量的基础\" class=\"headerlink\" title=\"2.4.1 变量的基础\"></a>2.4.1 变量的基础</h4><p>变量在声明时需要给予初值，而在使用时，需要给在变量名前<strong>加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来</strong>。如果你要使用真实的“$”字符，那么你需要用“$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects &#x3D; program.o foo.o utils.o</span><br><span class=\"line\">program : $(objects)</span><br><span class=\"line\">cc -o program $(objects)</span><br><span class=\"line\">$(objects) : defs.h</span><br></pre></td></tr></table></figure>\n<p>变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo &#x3D; c</span><br><span class=\"line\">prog.o : prog.$(foo)</span><br><span class=\"line\">$(foo)$(foo) -$(foo) prog.$(foo)</span><br></pre></td></tr></table></figure>\n<p>展开后得到：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">prog.o : prog.c</span><br><span class=\"line\">\t\tcc -c prog.c</span><br></pre></td></tr></table></figure>\n<p>当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>\n<h4 id=\"2-4-2-变量中的变量\"><a href=\"#2-4-2-变量中的变量\" class=\"headerlink\" title=\"2.4.2 变量中的变量\"></a>2.4.2 <strong>变量中的变量</strong></h4><p>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo = <span class=\"variable\">$(bar)</span></span><br><span class=\"line\">bar = <span class=\"variable\">$(ugh)</span></span><br><span class=\"line\">ugh = Huh?</span><br><span class=\"line\"><span class=\"section\">all:</span></span><br><span class=\"line\">echo <span class=\"variable\">$(foo)</span></span><br></pre></td></tr></table></figure>\n<p>我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。</p>\n<p>这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CFLAGS = <span class=\"variable\">$(include_dirs)</span> -O</span><br><span class=\"line\">include_dirs = -Ifoo -Ibar</span><br></pre></td></tr></table></figure>\n<p>当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：</p>\n<p><code>CFLAGS = $(CFLAGS) -O</code></p>\n<p>或：</p>\n<p>A = $(B)</p>\n<p>B = $(A)</p>\n<p>这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。</p>\n<p>为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x := foo</span><br><span class=\"line\">y := <span class=\"variable\">$(x)</span> bar</span><br><span class=\"line\">x := later</span><br></pre></td></tr></table></figure>\n<p>其等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y := foo bar</span><br><span class=\"line\">x := later</span><br></pre></td></tr></table></figure>\n<p>值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y :&#x3D; $(x) bar</span><br><span class=\"line\">x :&#x3D; foo</span><br></pre></td></tr></table></figure>\n<p>那么，y的值是“bar”，而不是“foo bar”。</p>\n<p>在上面的例子中，先让我们看看edit的规则：   </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">edit : main.o kbd.o command.o display.o \\</span><br><span class=\"line\">       insert.o search.o files.o utils.o</span><br><span class=\"line\">       cc -o edit main.o kbd.o command.o display.o \\</span><br><span class=\"line\">       insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n<p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成<strong>c语言</strong>中的宏可能会更好。</p>\n<p>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n<p>于是，我们就可以很方便地在我们的makefile中以<strong>“$(objects)”</strong>的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.osearch.o files.o utils.o</span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">\t   cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">\t     cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">\t    cc -c kbd.c</span><br><span class=\"line\">command.o : command.c defs.h command.h</span><br><span class=\"line\">\t        cc -c command.c</span><br><span class=\"line\">display.o : display.c defs.h buffer.h</span><br><span class=\"line\">            cc -c display.c</span><br><span class=\"line\">insert.o : insert.c defs.h buffer.h</span><br><span class=\"line\">           cc -c insert.c</span><br><span class=\"line\">search.o : search.c defs.h buffer.h</span><br><span class=\"line\">           cc -c search.c</span><br><span class=\"line\">files.o : files.c defs.h buffer.h command.h</span><br><span class=\"line\">          cc -c files.c</span><br><span class=\"line\">utils.o : utils.c defs.h</span><br><span class=\"line\">          cc -c utils.c</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。关于变量更多的话题，我会在后续给你一一道来。</p>\n<h3 id=\"2-5-让make自动推导\"><a href=\"#2-5-让make自动推导\" class=\"headerlink\" title=\"2.5 让make自动推导\"></a><strong>2.5 让make自动推导</strong></h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>\n<p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p>\n<p>Makefile中把那些没有任何依赖只有执行动作的目标成为“伪目标”(phony targets)。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">       cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\">main.o : defs.h</span><br><span class=\"line\">kbd.o : defs.h command.h</span><br><span class=\"line\">command.o : defs.h command.h</span><br><span class=\"line\">display.o : defs.h buffer.h</span><br><span class=\"line\">insert.o : defs.h buffer.h</span><br><span class=\"line\">search.o : defs.h buffer.h</span><br><span class=\"line\">files.o : defs.h buffer.h command.h</span><br><span class=\"line\">utils.o : defs.h</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。</p>\n<h3 id=\"2-6-另类风格的makefile\"><a href=\"#2-6-另类风格的makefile\" class=\"headerlink\" title=\"2.6 另类风格的makefile\"></a><strong>2.6 另类风格的makefile</strong></h3><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o \\</span><br><span class=\"line\">          insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">       cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable\">$(objects)</span> : defs.h</span><br><span class=\"line\">kbd.o command.o files.o : command.h</span><br><span class=\"line\">display.o insert.o search.o files.o : buffer.h</span><br><span class=\"line\"></span><br><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p>\n<h3 id=\"2-7-清空目标文件的规则\"><a href=\"#2-7-清空目标文件的规则\" class=\"headerlink\" title=\"2.7 清空目标文件的规则\"></a><strong>2.7 清空目标文件的规则</strong></h3><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：    </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">      rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>更为稳健的做法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">        -rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n<p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p>\n<h2 id=\"3-Makefile-总述\"><a href=\"#3-Makefile-总述\" class=\"headerlink\" title=\"3. Makefile 总述\"></a><strong>3. Makefile 总述</strong></h2><h3 id=\"3-1-Makefile里有什么？\"><a href=\"#3-1-Makefile里有什么？\" class=\"headerlink\" title=\"3.1 Makefile里有什么？\"></a><strong>3.1 Makefile里有什么？</strong></h3><p><strong>Makefile里主要包含了</strong>五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p>\n<ul>\n<li><p>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</p>\n</li>\n<li><p>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</p>\n</li>\n<li><p>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</p>\n</li>\n<li><p>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 </p>\n</li>\n<li><p>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。</p>\n</li>\n</ul>\n<p><strong>最后，还值得一提的是，</strong>在Makefile中的命令，必须要以[Tab]键开始。**   <strong>———-注意是tab键，不是8个空格</strong></p>\n<h3 id=\"3-2-Makefile的文件名\"><a href=\"#3-2-Makefile的文件名\" class=\"headerlink\" title=\"3.2 Makefile的文件名\"></a><strong>3.2 Makefile的文件名</strong></h3><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为<strong>“GNUmakefile”、“makefile”、“Makefile”</strong>的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“<strong>makefile”和“Makefile”</strong>这两种默认文件名。   </p>\n<p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要<strong>指定特定的Makefile，你可以使用make的“-f”和“–file”参数</strong>，如：make -f Make.Linux或make –file Make.AIX。</p>\n<h3 id=\"3-3-引用其它的Makefile\"><a href=\"#3-3-引用其它的Makefile\" class=\"headerlink\" title=\"3.3 引用其它的Makefile\"></a><strong>3.3 引用其它的Makefile</strong></h3><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> &lt;filename&gt; filename</span><br></pre></td></tr></table></figure>\n<p>可以是当前操作系统Shell的文件模式（可以保含路径和通配符）   </p>\n<p><strong>在include前面可以有一些空字符，</strong>但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。**举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：   **</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> foo.make *.mk <span class=\"variable\">$(bar)</span></span><br></pre></td></tr></table></figure>\n<p>等价于：   </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure>\n<p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p>\n<ul>\n<li><p>如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。</p>\n</li>\n<li><p>如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。   </p>\n</li>\n</ul>\n<p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-include &lt;filename&gt;</span><br></pre></td></tr></table></figure>\n<p>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>\n<h3 id=\"3-4-环境变量-MAKEFILES\"><a href=\"#3-4-环境变量-MAKEFILES\" class=\"headerlink\" title=\"3.4 环境变量 MAKEFILES\"></a><strong>3.4 环境变量 MAKEFILES</strong></h3><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p>\n<p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p>\n<h3 id=\"3-5-make的工作方式\"><a href=\"#3-5-make的工作方式\" class=\"headerlink\" title=\"3.5 make的工作方式\"></a><strong>3.5 make的工作方式</strong></h3><p>GNU的make工作时的执行步骤入下：（想来其它的make也是类似）</p>\n<ol>\n<li><p>读入所有的Makefile。</p>\n</li>\n<li><p>读入被include的其它Makefile。</p>\n</li>\n<li><p>初始化文件中的变量。</p>\n</li>\n<li><p>推导隐晦规则，并分析所有规则。</p>\n</li>\n<li><p>为所有的目标文件创建依赖关系链。</p>\n</li>\n<li><p>根据依赖关系，决定哪些目标要重新生成。</p>\n</li>\n<li><p>执行生成命令。   </p>\n</li>\n</ol>\n<p>1-5步为第一个阶段，6-7为第二个阶段。第一个阶段中，如果定义的变量被使用了，那么，make会把其展开在使用的位置。但make并不会完全马上展开，</p>\n<p>**make使用的是拖延战术，如果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展开。当然，这个工作方式你不一定要清楚，但是知道这个方式你也会对make更为熟悉。有了这个基础，后续部分也就容易看懂了。</p>\n<h2 id=\"4-Makefile书写规则\"><a href=\"#4-Makefile书写规则\" class=\"headerlink\" title=\"4. Makefile书写规则\"></a><strong>4. Makefile书写规则</strong></h2><p>规则包含两个部分，一个是<strong>依赖关系</strong>，一个是<strong>生成目标的方法</strong>。   </p>\n<p><strong>在Makefile中，规则的顺序是很重要的</strong>，因为，<strong>Makefile中应该**</strong>只有一个最终目标<strong>，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</strong></p>\n<p>好了，还是让我们来看一看如何书写规则。</p>\n<h3 id=\"4-1-规则举例\"><a href=\"#4-1-规则举例\" class=\"headerlink\" title=\"4.1 规则举例\"></a><strong>4.1 规则举例</strong></h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">foo.o: foo.c defs.h               # foo模块</span></span><br><span class=\"line\">       cc -c -g foo.c             <span class=\"comment\"># -c 表示只编译不链接， -g 表示带调试信息</span></span><br></pre></td></tr></table></figure>\n<p>看到这个例子，各位应该不是很陌生了，前面也已说过，foo.o是我们的目标，foo.c和defs.h是目标所依赖的源文件，而只有一个命令<code> cc -c -g foo.c</code>（以Tab键开头）。这个规则告诉我们两件事：</p>\n<ul>\n<li>文件的依赖关系，foo.o依赖于foo.c和defs.h的文件，如果foo.c和defs.h的文件日期要比foo.o文件日期要新，或是foo.o不存在，那么依赖关系发生。</li>\n<li>如果生成（或更新）foo.o文件。也就是那个cc命令，其说明了，如何生成foo.o这个文件。（当然foo.c文件include了defs.h文件）</li>\n</ul>\n<h3 id=\"4-2-规则的语法\"><a href=\"#4-2-规则的语法\" class=\"headerlink\" title=\"4.2 规则的语法\"></a><strong>4.2 规则的语法</strong></h3><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites    </span><br><span class=\"line\">\tcommand    </span><br><span class=\"line\">\t...</span><br></pre></td></tr></table></figure>\n<p>或是这样：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">targets : prerequisites ; command      </span><br><span class=\"line\">\tcommand      </span><br><span class=\"line\">\t... </span><br></pre></td></tr></table></figure>\n<p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。   </p>\n<p>command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以[Tab键]开头，如果和prerequisites在一行，那么可以用分号做为分隔。（见上）   </p>\n<p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。这个在前面已经讲过了。   </p>\n<p>如果命令太长，你可以使用反斜框（‘\\’）作为换行符。make对一行上有多少个字符没有限制。规则告诉make两件事，文件的依赖关系和如何成成目标文件。   </p>\n<p>一般来说，make会以UNIX的标准Shell，也就是/bin/sh来执行命令。</p>\n<h3 id=\"4-3-在规则中使用通配符\"><a href=\"#4-3-在规则中使用通配符\" class=\"headerlink\" title=\"4.3 在规则中使用通配符\"></a><strong>4.3 在规则中使用通配符</strong></h3><p>如果我们想定义一系列比较类似的文件，我们很自然地就想起使用通配符。make支持三各通配符：“<em>”，“?”和“[…]”。这是和Unix的B-Shell是相同的。</em></p>\n<p><strong>“~”</strong>   </p>\n<p>波浪号（“<del>”）字符在文件名中也有比较特殊的用途。如果是“</del>/test”，这就表示当前用户的$HOME目录下的test目录。而“~hchen/test”则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“HOME”而定。</p>\n<p><strong>“*“</strong>   </p>\n<p><em>*</em>通配符代替了你一系列的文件，如“*.c”表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：“<em>”，那么可以用转义字符“\\”，如“\\</em>”来表示真实的“*”字符，而不是任意长度的字符串。</p>\n<p>好吧，还是先来看几个例子吧：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:    </span></span><br><span class=\"line\">\trm -f *.o</span><br></pre></td></tr></table></figure>\n<p>上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">print: *.c    </span></span><br><span class=\"line\">\tlpr -p <span class=\"variable\">$?</span>    </span><br><span class=\"line\">\ttouch print</span><br></pre></td></tr></table></figure>\n<p>上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的[.c]文件。其中的“$?”是一个自动化变量，我会在后面给你讲述。  </p>\n<p><code>objects = *.o</code>上面这个例子，表示了，通符同样可以用在变量中。并不是说[<em>.o]会展开，不！**objects的值就是“\\</em>.o”**。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有[.o]的文件名的集合，那么，你可以这样：  </p>\n<p><code>objects := $(wildcard *.o)</code></p>\n<p>这种用法由关键字“wildcard”指出，关于Makefile的关键字，我们将在后面讨论。</p>\n<h3 id=\"4-4-文件搜寻\"><a href=\"#4-4-文件搜寻\" class=\"headerlink\" title=\"4.4 文件搜寻\"></a><strong>4.4 文件搜寻</strong></h3><p> 在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。   </p>\n<p>Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。  </p>\n<p><code>VPATH = src:../headers</code>   </p>\n<p>上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）   </p>\n<p>另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p>\n<ul>\n<li><p>vpath &lt; pattern&gt; &lt; directories&gt;       为符合模式&lt; pattern&gt;的文件指定搜索目录<directories>。</p>\n</li>\n<li><p>vpath &lt; pattern&gt;                                清除符合模式&lt; pattern&gt;的文件的搜索目录。</p>\n</li>\n<li><p>vpath                                                   清除所有已被设置好了的文件搜索目录。   </p>\n</li>\n</ul>\n<p>vapth使用方法中的&lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt; pattern&gt;指定了要搜索的文件集，而&lt; directories&gt;则指定了的文件集的搜索的目录。例如：  </p>\n<p><code>vpath %.h ../headers</code></p>\n<p>该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）</p>\n<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt; pattern&gt;，或是被重复了的&lt; pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vpath</span> %.c foo  </span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %  blish  </span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %.c bar</span><br></pre></td></tr></table></figure>\n<p>其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">vpath</span> %.c foo:bar  </span><br><span class=\"line\"><span class=\"keyword\">vpath</span> %  blish</span><br></pre></td></tr></table></figure>\n<p>而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>\n<h3 id=\"4-5-伪目标\"><a href=\"#4-5-伪目标\" class=\"headerlink\" title=\"4.5 伪目标\"></a><strong>4.5 伪目标</strong></h3><p>最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”，  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:      </span></span><br><span class=\"line\">\t\trm *.o temp</span><br></pre></td></tr></table></figure>\n<p>正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）</p>\n<p>因为，我们并不生成“clean”这个文件。<strong>“伪目标”并不是一个文件，只是一个标签</strong>，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。</p>\n<p>当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 </p>\n<p><code> .PHONY : clean</code></p>\n<p>只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: clean  </span></span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">\t\trm *.o temp</span><br></pre></td></tr></table></figure>\n<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">all : prog1 prog2 prog3  </span><br><span class=\"line\">.PHONY : all</span><br><span class=\"line\">prog1 : prog1.o utils.o      </span><br><span class=\"line\">\t\tcc -o prog1 prog1.o utils.o</span><br><span class=\"line\">prog2 : prog2.o      </span><br><span class=\"line\">\t\tcc -o prog2 prog2.o</span><br><span class=\"line\">prog3 : prog3.o sort.o utils.o      \t</span><br><span class=\"line\">\t\tcc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>\n<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。</p>\n<p>随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"><span class=\"meta-keyword\">.PHONY</span>: cleanall cleanobj cleandiff</span></span><br><span class=\"line\"></span><br><span class=\"line\">cleanall : cleanobj cleandiff      </span><br><span class=\"line\">\t\trm program</span><br><span class=\"line\">cleanobj :      </span><br><span class=\"line\">\t\trm *.o</span><br><span class=\"line\">cleandiff :      </span><br><span class=\"line\">\t\trm *.diff*</span><br></pre></td></tr></table></figure>\n<p><code>makeclean</code>将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的</p>\n<h3 id=\"4-6-多目标\"><a href=\"#4-6-多目标\" class=\"headerlink\" title=\"4.6 多目标\"></a><strong>4.6 多目标</strong></h3><p>Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bigoutput littleoutput : text.g      </span><br><span class=\"line\">\t\tgenerate text.g -<span class=\"variable\">$(<span class=\"built_in\">subst</span> output,,<span class=\"variable\">$@</span>)</span> &gt; <span class=\"variable\">$@</span>  </span><br></pre></td></tr></table></figure>\n<p>上述规则等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bigoutput : text.g      </span><br><span class=\"line\">\t\tgenerate text.g -big &gt; bigoutput  </span><br><span class=\"line\">littleoutput : text.g      </span><br><span class=\"line\">\t\tgenerate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>\n<p>其中，-$(subst output,,$@)中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。</p>\n<h3 id=\"4-7-静态模式\"><a href=\"#4-7-静态模式\" class=\"headerlink\" title=\"4.7 静态模式\"></a><strong>4.7 静态模式</strong></h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">&lt;targets...&gt;: &lt;target-pattern&gt;: &lt;prereq-patterns ...&gt;　　　</span></span><br><span class=\"line\">\t\t&lt;commands&gt;</span><br><span class=\"line\">\t\t...</span><br></pre></td></tr></table></figure>\n<p>targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。</p>\n<p>target-parrtern是指明了targets的模式，也就是的目标集模式。</p>\n<p>prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的<target-parrtern>定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的<prereq-parrterns>定义成“%.c”，意思是对<target-parrtern>所形成的目标集进行二次定义，其计算方法是，取<target-parrtern>模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。</p>\n<p>所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\\”进行转义，来标明真实的“%”字符。</p>\n<p>看一个例子：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = foo.o bar.o</span><br><span class=\"line\"><span class=\"section\">all: <span class=\"variable\">$(objects)</span></span></span><br><span class=\"line\"><span class=\"variable\">$(objects)</span>: %.o: %.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span></span><br></pre></td></tr></table></figure>\n<p>上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.o : foo.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> foo.c -o foo.o  </span><br><span class=\"line\">bar.o : bar.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>\n<p>试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">files = foo.elc bar.o lose.o</span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span> %.o,<span class=\"variable\">$(files)</span>)</span>: %.o: %.c      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -c <span class=\"variable\">$(CFLAGS)</span> <span class=\"variable\">$&lt;</span> -o <span class=\"variable\">$@</span>  </span><br><span class=\"line\"><span class=\"variable\">$(<span class=\"built_in\">filter</span> %.elc,<span class=\"variable\">$(files)</span>)</span>: %.elc: %.el      </span><br><span class=\"line\">\t\temacs -f batch-byte-compile <span class=\"variable\">$&lt;</span></span><br></pre></td></tr></table></figure>\n<p>$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。</p>\n<h3 id=\"3-8-自动生成依赖性\"><a href=\"#3-8-自动生成依赖性\" class=\"headerlink\" title=\"3.8 自动生成依赖性\"></a><strong>3.8 自动生成依赖性</strong></h3><p>在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include “defs.h””，那么我们的依赖关系应该是：  </p>\n<p><code>main.o : main.c defs.h</code></p>\n<p>但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令：  </p>\n<p><code>cc -M main.c</code></p>\n<p>其输出是：  </p>\n<p><code>main.o : main.c defs.h</code></p>\n<p>于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。</p>\n<p>gcc-M main.c的输出是：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\</span></span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/sys/cdefs.h /usr/<span class=\"keyword\">include</span>/gnu/stubs.h \\</span><br><span class=\"line\">\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class=\"keyword\">include</span>/stddef.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/types.h /usr/<span class=\"keyword\">include</span>/bits/pthreadtypes.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/sched.h /usr/<span class=\"keyword\">include</span>/libio.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/_G_config.h /usr/<span class=\"keyword\">include</span>/wchar.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/wchar.h /usr/<span class=\"keyword\">include</span>/gconv.h \\</span><br><span class=\"line\">\t/usr/lib/gcc-lib/i486-suse-linux/2.95.3/<span class=\"keyword\">include</span>/stdarg.h \\</span><br><span class=\"line\">\t/usr/<span class=\"keyword\">include</span>/bits/stdio_lim.h</span><br></pre></td></tr></table></figure>\n<p>gcc-MM main.c的输出则是：  </p>\n<p><code>main.o: main.c defs.h</code></p>\n<p>那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。</p>\n<p>于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。</p>\n<p>这里，我们给出了一个模式规则来产生[.d]文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">%.d: %.c      </span></span><br><span class=\"line\">\t\t@set -e; rm -f <span class=\"variable\">$@</span>; \\      </span><br><span class=\"line\">\t\t<span class=\"variable\">$(CC)</span> -M <span class=\"variable\">$(CPPFLAGS)</span> <span class=\"variable\">$&lt;</span> &gt; <span class=\"variable\">$@</span>.</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">; \\      </span><br><span class=\"line\">\t\tsed &#x27;s,</span><br><span class=\"line\">$∗</span><br><span class=\"line\">\\.o[ :]*,\\1.o <span class=\"variable\">$@</span> : ,g&#x27; &lt; <span class=\"variable\">$@</span>.</span><br><span class=\"line\"></span><br><span class=\"line\">\\&gt; <span class=\"variable\">$@</span>; \\      </span><br><span class=\"line\">\t\trm -f <span class=\"variable\">$@</span>.</span><br></pre></td></tr></table></figure>\n<p>这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm-f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，</p>\n<p>“”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。</p>\n<p>总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： </p>\n<p><code>main.o : main.c defs.h</code></p>\n<p>转成：</p>\n<p><code>main.o main.d : main.c defs.h</code></p>\n<p>于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sources = foo.c bar.c</span><br><span class=\"line\"><span class=\"keyword\">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>\n<p>上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标</p>\n<h2 id=\"5-Makefile-书写命令\"><a href=\"#5-Makefile-书写命令\" class=\"headerlink\" title=\"5. Makefile 书写命令\"></a><strong>5. Makefile 书写命令</strong></h2><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会一按顺序一条一条的执行命令，每条命令的开头必须以[Tab]键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。我们在UNIX下可能会使用不同的Shell，但是make的命令默认是被“/bin/sh”——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中，“#”是注释符，很像C/C++中的“//”，其后的本行字符都被注释。</p>\n<h3 id=\"5-1-显示命令\"><a href=\"#5-1-显示命令\" class=\"headerlink\" title=\"5.1 显示命令\"></a><strong>5.1 显示命令</strong></h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用“**@**”字符在命令行前，那么，这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来像屏幕显示一些信息。如： </p>\n<p> == <strong>@符号： 不显示编译回显</strong>==  </p>\n<p><code>@echo 正在编译XXX模块......</code></p>\n<p>当make执行时，会输出“正在编译XXX模块……”字串，但不会输出命令，如果没有“@”，那么，make将输出： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo 正在编译XXX模块......  </span><br><span class=\"line\">正在编译XXX模块......</span><br></pre></td></tr></table></figure>\n<p>如果make执行时，带入make参数“-n”或“–just-print”，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>\n<p>而make参数“-s”或“–slient”则是全面禁止命令的显示。</p>\n<h3 id=\"5-2-命令执行\"><a href=\"#5-2-命令执行\" class=\"headerlink\" title=\"5.2 命令执行\"></a><strong>5.2 命令执行</strong></h3><p>当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而应该把这两条命令写在一行上，用分号分隔。如：  </p>\n<p>示例一：    </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">exec:        </span></span><br><span class=\"line\">\t\tcd /home/hchen        </span><br><span class=\"line\">\t\tpwd</span><br></pre></td></tr></table></figure>\n<p>示例二：    </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">exec:        </span></span><br><span class=\"line\">\t\tcd /home/hchen; pwd</span><br></pre></td></tr></table></figure>\n<p>当我们执行“make exec”时，第一个例子中的cd没有作用，pwd会打印出当前的Makefile目录，而第二个例子中，cd就起作用了，pwd会打印出“/home/hchen”。make一般是使用环境变量SHELL中所定义的系统Shell来执行命令，默认情况下使用UNIX的标准Shell——/bin/sh来执行命令。但在MS-DOS下有点特殊，因为MS-DOS下没有SHELL环境变量，当然你也可以指定。如果你指定了UNIX风格的目录形式，首先，make会在SHELL所指定的路径中找寻命令解释器，如果找不到，其会在当前盘符中的当前目录中寻找，如果再找不到，其会在PATH环境变量中所定义的所有路径中寻找。MS-DOS中，如果你定义的命令解释器没有找到，其会给你的命令解释器加上诸如“.exe”、“.com”、“.bat”、“.sh”等后缀。</p>\n<h3 id=\"5-3-命令出错\"><a href=\"#5-3-命令出错\" class=\"headerlink\" title=\"5.3 命令出错\"></a><strong>5.3 命令出错</strong></h3><p>每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。</p>\n<p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>\n<p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号“-”（在Tab键之后），标记为不管命令出不出错都认为是成功的。如： </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">clean:      </span></span><br><span class=\"line\">\t\t-rm -f *.o</span><br></pre></td></tr></table></figure>\n<p>还有一个全局的办法是，给make加上“-i”或是“–ignore-errors”参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以“.IGNORE”作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>\n<p>还有一个要提一下的make的参数的是“-k”或是“–keep-going”，这个参数的意思是，如果某规则中的命令出错了，那么就终目该规则的执行，但继续执行其它规则。</p>\n<h3 id=\"5-4-嵌套执行make\"><a href=\"#5-4-嵌套执行make\" class=\"headerlink\" title=\"5.4 嵌套执行make\"></a><strong>5.4 嵌套执行make</strong></h3><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。<br>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:      </span></span><br><span class=\"line\">\t\tcd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span></span><br></pre></td></tr></table></figure>\n<p>其等价于：   </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:      </span></span><br><span class=\"line\">\t\t<span class=\"variable\">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>\n<p>定义$(MAKE)宏变量的意思是，也许我们的make需要一些参数，所以定义成一个变量比较利于维护。这两个例子的意思都是先进入“subdir”目录，然后执行make命令。我们把这个Makefile叫做“总控Makefile”，总控Makefile的变量可以传递到下级的Makefile中（如果你显示的声明），但是不会覆盖下层的Makefile中所定义的变量，除非指定了“-e”参数。</p>\n<p>如果你要传递变量到下级Makefile中，那么你可以使用这样的声明：</p>\n<p><code>export&lt;variable ...&gt;</code></p>\n<p>如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明：</p>\n<p><code>unexport&lt;variable ...&gt;</code></p>\n<p>如示例一：     </p>\n<p><code>export variable = value</code></p>\n<p>其等价于：     </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable = value    </span><br><span class=\"line\"><span class=\"keyword\">export</span> variable</span><br></pre></td></tr></table></figure>\n<p>其等价于：     </p>\n<p><code>export variable := value</code></p>\n<p>其等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable := value    </span><br><span class=\"line\"><span class=\"keyword\">export</span> variable</span><br></pre></td></tr></table></figure>\n<p>示例二：<br><code>export variable += value</code>     </p>\n<p>其等价于：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">variable += value    </span><br><span class=\"line\"><span class=\"keyword\">export</span> variable</span><br></pre></td></tr></table></figure>\n<p>如果你要传递所有的变量，那么，只要一个export就行了。后面什么也不用跟，表示传递所有的变量。</p>\n<p>需要注意的是，有两个变量，一个是SHELL，一个是MAKEFLAGS，这两个变量不管你是否export，其总是要传递到下层Makefile中，特别是MAKEFILES变量，其中包含了make的参数信息，如果我们执行“总控Makefile”时有make参数或是在上层Makefile中定义了这个变量，那么MAKEFILES变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。</p>\n<p>但是make命令中的有几个参数并不往下传递，它们是“-C”,“-f”,“-h”“-o”和“-W”（有关Makefile参数的细节将在后面说明），如果你不想往下层传递参数，那么，你可以这样来：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">subsystem:      </span></span><br><span class=\"line\">\t\tcd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure>\n<p>如果你定义了环境变量MAKEFLAGS，那么你得确信其中的选项是大家都会用到的，如果其中有“-t”,“-n”,和“-q”参数，那么将会有让你意想不到的结果，或许会让你异常地恐慌。还有一个在“嵌套执行”中比较有用的参数，“-w”或是“–print-directory”会在make的过程中输出一些信息，让你看到目前的工作目录。比如，如果我们的下级make目录是“/home/hchen/gnu/make”，如果我们使用“make -w”来执行，那么当进入该目录时，我们会看到：</p>\n<p><code>make: Entering directory &#39;/home/hchen/gnu/make&#39;</code></p>\n<p>而在完成下层make后离开目录时，我们会看到：</p>\n<p><code>make: Leaving directory &#39;/home/hchen/gnu/make&#39;</code></p>\n<p>当你使用“-C”参数来指定make下层Makefile时，“-w”会被自动打开的。如果参数中有“-s”（“–slient”）或是“–no-print-directory”，那么，“-w”总是失效的。</p>\n<h3 id=\"5-5-定义命令包\"><a href=\"#5-5-定义命令包\" class=\"headerlink\" title=\"5.5 定义命令包\"></a><strong>5.5 定义命令包</strong></h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以“define”开始，以“endef”结束，如：  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">define</span> run-yacc  </span><br><span class=\"line\">yacc <span class=\"variable\">$(<span class=\"built_in\">firstword</span> <span class=\"variable\">$^</span>)</span>  </span><br><span class=\"line\">mv y.tab.c <span class=\"variable\">$@</span>  </span><br><span class=\"line\"><span class=\"keyword\">endef</span></span><br></pre></td></tr></table></figure>\n<p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在“define”和“endef”中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。  </p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo.c : foo.y      </span><br><span class=\"line\">\t\t$(run-yacc)</span><br></pre></td></tr></table></figure>\n<p>我们可以看见，要使用这个命令包，我们就好像使用变量一样。在这个命令包的使用中，命令包“run-yacc”中的“$^”就是“foo.y”，“$@”就是“foo.c”（有关这种以“$”开头的特殊变量，我们会在后面介绍），make在执行命令包时，命令包中的每个命令会被依次独立执行。</p>\n<hr>\n<p> <strong>使用变量</strong>————    在 Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”，“命令”或是 Makefile的其它部分中。变量的命名字可以包含字符、数字，下划线（可以是数字开头），但不应该含有“:”、“#”、“=”或是空字符（空格、回车等）。变量是大小写敏感的，“foo”、“Foo”和“FOO”是三个不同的变量名。传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。有一些变量是很奇怪字串，如“$&lt;”、“$@”等，这些是自动化变量，我会在后面介绍。<br><strong>一、变量的基础</strong>  变量在声明时需要给予初值，而在使用时，需要给在变量名前<strong>加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来</strong>。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。先看一个例子：objects = program.o foo.o utils.oprogram : $(objects)cc -o program $(objects)$(objects) : defs.h变量会在使用它的地方精确地展开，就像C/C++中的宏一样，例如：foo = cprog.o : prog.$(foo)$(foo)$(foo) -$(foo) prog.$(foo)展开后得到：prog.o : prog.ccc -c prog.c当然，千万不要在你的Makefile中这样干，这里只是举个例子来表明Makefile中的变量在使用处展开的真实样子。可见其就是一个“替代”的原理。另外，给变量加上括号完全是为了更加安全地使用这个变量，在上面的例子中，如果你不想给变量加上括号，那也可以，但我还是强烈建议你给变量加上括号。</p>\n<p><strong>二、变量中的变量</strong>在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值。先看第一种方式，也就是简单的使用“=”号，在“=”左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。如：foo = $(bar)bar = $(ugh)ugh = Huh?all:echo $(foo)我们执行“make all”将会打出变量$(foo)的值是“Huh?”（ $(foo)的值是$(bar)，$(bar)的值是$(ugh)，$(ugh)的值是“Huh?”）可见，变量是可以使用后面的变量来定义的。这个功能有好的地方，也有不好的地方，好的地方是，我们可以把变量的真实值推到后面来定义，如：CFLAGS = $(include_dirs) -Oinclude_dirs = -Ifoo -Ibar当“CFLAGS”在命令中被展开时，会是“-Ifoo -Ibar -O”。但这种形式也有不好的地方，那就是递归定义，如：CFLAGS = $(CFLAGS) -O或：A = $(B)B = $(A)这会让make陷入无限的变量展开过程中去，当然，我们的make是有能力检测这样的定义，并会报错。还有就是如果在变量中使用函数，那么，这种方式会让我们的make运行时非常慢，更糟糕的是，他会使用得两个make的函数“wildcard”和“shell”发生不可预知的错误。因为你不会知道这两个函数会被调用多少次。为了避免上面的这种方法，我们可以使用make中的另一种用变量来定义变量的方法。这种方法使用的是“:=”操作符，如：x := fooy := $(x) barx := later其等价于：y := foo barx := later值得一提的是，这种方法，前面的变量不能使用后面的变量，只能使用前面已定义好了的变量。如果是这样：y := $(x) barx := foo那么，y的值是“bar”，而不是“foo bar”。上面都是一些比较简单的变量使用了，让我们来看一个复杂的例子，其中包括了make的函数、条件表达式和一个系统变量“MAKELEVEL”的使用：ifeq (0,${MAKELEVEL})cur-dir := $(shell pwd)whoami := $(shell whoami)host-type := $(shell arch)MAKE := ${MAKE} host-type=${host-type} whoami=${whoami}endif关于条件表达式和函数，我们在后面再说，对于系统变量“MAKELEVEL”，其意思是，如果我们的make有一个嵌套执行的动作（参见前面的“嵌套使用make”），那么，这个变量会记录了我们的当前Makefile的调用层数。下面再介绍两个定义变量时我们需要知道的，请先看一个例子，如果我们要定义一个变量，其值是一个空格，那么我们可以这样来：nullstring :=space := $(nullstring) # end of the linenullstring 是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个 Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意，如果我们这样定义一个变量：dir := /foo/bar # directory to put the frobs indir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。还有一个比较有用的操作符是“?=”，先看示例：FOO ?= bar其含义是，如果FOO没有被定义过，那么变量FOO的值就是“bar”，如果FOO先前被定义过，那么这条语将什么也不做，其等价于：ifeq ($(origin FOO), undefined)FOO = barendif<br><strong>三、变量高级用法</strong>这里介绍两种变量的高级使用方法，第一种是<strong>变量值的替换</strong>。我们可以替换变量中的共有的部分，其格式是“$(var:a=b)”或是“${var:a=b}”，其意思是，把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。还是看一个示例吧：foo := a.o b.o c.obar := $(foo:.o=.c)这个示例中，我们先定义了一个“$(foo)”变量，而第二行的意思是把“$(foo)”中所有以“.o”字串“结尾”全部替换成“.c”，所以我们的“$(bar)”的值就是“a.c b.c c.c”。另外一种变量替换的技术是以“静态模式”（参见前面章节）定义的，如：foo := a.o b.o c.obar := $(foo:%.o=%.c)这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c”。<br>第二种高级用法是——“把<strong>变量的值再当成变量</strong>”。先看一个例子：x = yy = za := $($(x))在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”）我们还可以使用更多的层次：x = yy = zz = ua := $($($(x)))这里的$(a)的值是“u”，相关的推导留给读者自己去做吧。让我们再复杂一点，使用上“在变量定义中使用变量”的第一个方式，来看一个例子：x = $(y)y = zz = Helloa := $($(x))这里的$($(x))被替换成了$($(y))，因为$(y)值是“z”，所以，最终结果是：a:=$(z)，也就是“Hello”。再复杂一点，我们再加上函数：x = variable1variable2 := Helloy = $(subst 1,2,$(x))z = ya := $($($(z)))这个例子中，“$($($(z)))”扩展为“$($(y))”，而其再次被扩展为“$($(subst 1,2,$(x)))”。$(x)的值是“variable1”，subst函数把“variable1”中的所有“1”字串替换成“2”字串，于是，“variable1”变成“variable2”，再取其值，所以，最终，$(a)的值就是$(variable2)的值—— “Hello”。（喔，好不容易）在这种方式中，或要可以使用多个变量来组成一个变量的名字，然后再取其值：first_second = Helloa = firstb = secondall = $($a_$b)这里的“$a_$b”组成了“first_second”，于是，$(all)的值就是“Hello”。再来看看结合第一种技术的例子：a_objects := a.o b.o c.o1_objects := 1.o 2.o 3.osources := $($(a1)_objects:.o=.c)这个例子中，如果$(a1)的值是“a”的话，那么，$(sources)的值就是“a.c b.c c.c”；如果$(a1)的值是“1”，那么$(sources)的值是“1.c 2.c 3.c”。再来看一个这种技术和“函数”与“条件语句”一同使用的例子：ifdef do_sortfunc := sortelsefunc := stripendifbar := a d b g q cfoo := $($(func) $(bar))这个示例中，如果定义了“do_sort”，那么：foo := $(sort a d b g q c)，于是$(foo)的值就是“a b c d g q”，而如果没有定义“do_sort”，那么：foo := $(sort a d bg q c)，调用的就是strip函数。当然，“把变量的值再当成变量”这种技术，同样可以用在操作符的左边：dir = foo$(dir)_sources := $(wildcard $(dir)/*.c)define $(dir)_printlpr $($(dir)_sources)endef这个例子中定义了三个变量：“dir”，“foo_sources”和“foo_print”。<br><strong>四、追加变量值</strong></p>\n<p>我们可以使用“+=”操作符给变量追加值，如：</p>\n<p>objects = main.o foo.o bar.o utils.o<br>objects += another.o</p>\n<p>于是，我们的$(objects)值变成：“main.o foo.o bar.o utils.o another.o”（another.o被追加进去了）</p>\n<p>使用“+=”操作符，可以模拟为下面的这种例子：</p>\n<p>objects = main.o foo.o bar.o utils.o<br>objects := $(objects) another.o</p>\n<p>所不同的是，用“+=”更为简洁。</p>\n<p>如果变量之前没有定义过，那么，“+=”会自动变成“=”，如果前面有变量定义，那么“+=”会继承于前次操作的赋值符。如果前一次的是“:=”，那么“+=”会以“:=”作为其赋值符，如：</p>\n<p>variable := value<br>variable += more</p>\n<p>等价于：</p>\n<p>variable := value<br>variable := $(variable) more</p>\n<p>但如果是这种情况：</p>\n<p>variable = value<br>variable += more</p>\n<p>由于前次的赋值符是“=”，所以“+=”也会以“=”来做为赋值，那么岂不会发生变量的递补归定义，这是很不好的，所以make会自动为我们解决这个问题，我们不必担心这个问题。</p>\n<p><strong>五、override 指示符</strong></p>\n<p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：</p>\n<p>override <variable> = <value><br>override <variable> := <value></p>\n<p>当然，你还可以追加：</p>\n<p>override <variable> += <more text></p>\n<p>对于多行的变量定义，我们用define指示符，在define指示符前，也同样可以使用ovveride指示符，如：</p>\n<p>override define foo<br>bar<br>endef</p>\n<p><strong>六、多行变量</strong></p>\n<p>还有一种设置变量值的方法是使用define关键字。使用define关键字设置变量的值可以有换行，这有利于定义一系列的命令（前面我们讲过“命令包”的技术就是利用这个关键字）。</p>\n<p>define 指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef关键字结束。其工作方式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以[Tab]键开头，那么make就不会把其认为是命令。</p>\n<p>下面的这个示例展示了define的用法：</p>\n<p>define two-lines<br>echo foo<br>echo $(bar)<br>endef</p>\n<p><strong>七、环境变量</strong></p>\n<p>make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中，但是如果Makefile中已定义了这个变量，或是这个变量由make命令行带入，那么系统的环境变量的值将被覆盖。（如果make指定了“-e”参数，那么，系统环境变量将覆盖Makefile中定义的变量）</p>\n<p>因此，如果我们在环境变量中设置了“CFLAGS”环境变量，那么我们就可以在所有的Makefile中使用这个变量了。这对于我们使用统一的编译参数有比较大的好处。如果Makefile中定义了CFLAGS，那么则会使用Makefile中的这个变量，如果没有定义则使用系统环境变量的值，一个共性和个性的统一，很像“全局变量”和“局部变量”的特性。   当make嵌套调用时（参见前面的“嵌套调用”章节），上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中。当然，默认情况下，只有通过命令行设置的变量会被传递。而定义在文件中的变量，如果要向下层 Makefile传递，则需要使用exprot关键字来声明。（参见前面章节）</p>\n<p>  当然，我并不推荐把许多的变量都定义在系统环境中，这样，在我们执行不用的Makefile时，拥有的是同一套系统变量，这可能会带来更多的麻烦。</p>\n<p><strong>八、目标变量</strong></p>\n<p>前面我们所讲的在Makefile中定义的变量都是“全局变量”，在整个文件，我们都可以访问这些变量。当然，“自动化变量”除外，如“$&lt;”等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义。</p>\n<p>当然，我样同样可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值。</p>\n<p>其语法是：</p>\n<p>&lt;target …&gt; : <variable-assignment></p>\n<p>&lt;target …&gt; : overide <variable-assignment></p>\n<p><variable-assignment>可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p>\n<p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p>\n<p>prog : CFLAGS = -g<br>prog : prog.o foo.o bar.o<br>$(CC) $(CFLAGS) prog.o foo.o bar.o</p>\n<p>prog.o : prog.c<br>$(CC) $(CFLAGS) prog.c</p>\n<p>foo.o : foo.c<br>$(CC) $(CFLAGS) foo.c</p>\n<p>bar.o : bar.c<br>$(CC) $(CFLAGS) bar.c</p>\n<p>在这个示例中，不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g”</p>\n<p><strong>九、模式变量</strong></p>\n<p>在GNU的make中，还支持模式变量（Pattern-specific Variable），通过上面的目标变量中，我们知道，变量可以定义在某个目标上。模式变量的好处就是，我们可以给定一种“模式”，可以把变量定义在符合这种模式的所有目标上。</p>\n<p>我们知道，make的“模式”一般是至少含有一个“%”的，所以，我们可以以如下方式给所有以[.o]结尾的目标定义目标变量：</p>\n<p>%.o : CFLAGS = -O</p>\n<p>同样，模式变量的语法和“目标变量”一样：</p>\n<p>&lt;pattern …&gt; : <variable-assignment></p>\n<p>&lt;pattern …&gt; : override <variable-assignment></p>\n<p>override同样是针对于系统环境传入的变量，或是make命令行指定的变量。</p>\n<p><strong>使用条件判断</strong>——————使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值，或是比较变量和常量的值。</p>\n<p>一、示例</p>\n<p>下面的例子，判断$(CC)变量是否“gcc”，如果是的话，则使用GNU函数编译目标。</p>\n<p>libs_for_gcc = -lgnu<br>normal_libs =</p>\n<p>foo: $(objects)<br>ifeq ($(CC),gcc)<br>$(CC) -o foo $(objects) $(libs_for_gcc)<br>else<br>$(CC) -o foo $(objects) $(normal_libs)<br>endif</p>\n<p>可见，在上面示例的这个规则中，目标“foo”可以根据变量“$(CC)”值来选取不同的函数库来编译程序。</p>\n<p>我们可以从上面的示例中看到三个关键字：ifeq、else和endif。ifeq的意思表示条件语句的开始，并指定一个条件表达式，表达式包含两个参数，以逗号分隔，表达式以圆括号括起。else表示条件表达式为假的情况。endif表示一个条件语句的结束，任何一个条件表达式都应该以endif结束。</p>\n<p>当我们的变量$(CC)值是“gcc”时，目标foo的规则是：</p>\n<p>foo: $(objects)<br>$(CC) -o foo $(objects) $(libs_for_gcc)</p>\n<p>而当我们的变量$(CC)值不是“gcc”时（比如“cc”），目标foo的规则是：</p>\n<p>foo: $(objects)<br>$(CC) -o foo $(objects) $(normal_libs)</p>\n<p>当然，我们还可以把上面的那个例子写得更简洁一些：</p>\n<p>libs_for_gcc = -lgnu<br>normal_libs =</p>\n<p>ifeq ($(CC),gcc)<br>libs=$(libs_for_gcc)<br>else<br>libs=$(normal_libs)<br>endif</p>\n<p>foo: $(objects)<br>$(CC) -o foo $(objects) $(libs)</p>\n<p>二、语法</p>\n<p>条件表达式的语法为：</p>\n<conditional-directive>\n<text-if-true>\nendif\n\n\n<p>以及：</p>\n<conditional-directive>\n<text-if-true>\nelse\n<text-if-false>\nendif\n\n\n<p>其中<conditional-directive>表示条件关键字，如“ifeq”。这个关键字有四个。</p>\n<p>第一个是我们前面所见过的“ifeq”</p>\n<p>ifeq (<arg1>, <arg2> )<br>ifeq ‘<arg1>‘ ‘<arg2>‘<br>ifeq “<arg1>“ “<arg2>“<br>ifeq “<arg1>“ ‘<arg2>‘<br>ifeq ‘<arg1>‘ “<arg2>“</p>\n<p>比较参数“arg1”和“arg2”的值是否相同。当然，参数中我们还可以使用make的函数。如：</p>\n<p>ifeq ($(strip $(foo)),)<br><text-if-empty><br>endif</p>\n<p>这个示例中使用了“strip”函数，如果这个函数的返回值是空（Empty），那么<text-if-empty>就生效。</p>\n<p>第二个条件关键字是“ifneq”。语法是：</p>\n<p>ifneq (<arg1>, <arg2> )<br>ifneq ‘<arg1>‘ ‘<arg2>‘<br>ifneq “<arg1>“ “<arg2>“<br>ifneq “<arg1>“ ‘<arg2>‘<br>ifneq ‘<arg1>‘ “<arg2>“</p>\n<p>其比较参数“arg1”和“arg2”的值是否相同，如果不同，则为真。和“ifeq”类似。</p>\n<p>第三个条件关键字是“ifdef”。语法是：</p>\n<p>ifdef <variable-name></p>\n<p>如果变量<variable-name>的值非空，那到表达式为真。否则，表达式为假。当然，<variable-name>同样可以是一个函数的返回值。注意，ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。还是来看两个例子：</p>\n<p>示例一：<br>bar =<br>foo = $(bar)<br>ifdef foo<br>frobozz = yes<br>else<br>frobozz = no<br>endif</p>\n<p>示例二：<br>foo =<br>ifdef foo<br>frobozz = yes<br>else<br>frobozz = no<br>endif</p>\n<p>第一个例子中，“$(frobozz)”值是“yes”，第二个则是“no”。</p>\n<p>第四个条件关键字是“ifndef”。其语法是：</p>\n<p>ifndef <variable-name></p>\n<p>这个我就不多说了，和“ifdef”是相反的意思。</p>\n<p>在<conditional-directive>这一行上，多余的空格是被允许的，但是不能以[Tab]键做为开始（不然就被认为是命令）。而注释符“#”同样也是安全的。“else”和“endif”也<br>一样，只要不是以[Tab]键开始就行了。</p>\n<p>特别注意的是，make是在读取Makefile时就计算条件表达式的值，并根据条件表达式的值来选择语句，所以，你最好不要把自动化变量（如“$@”等）放入条件表达式中，因为自动化变量是在运行时才有的。</p>\n<p>而且，为了避免混乱，make不允许把整个条件语句分成两部分放在不同的文件中。</p>\n<p><strong>使用函数**</strong>————<strong>在Makefile中可以使用函数来处理变量，从而让我们的命令或是规则更为的灵活和具有智能。make所支持的函数也不算很多，不过已经足够我们的操作了。函数调用后，函数的返回值可以当做变量来使用。</strong>一、函数的调用语法**函数调用，很像变量的使用，也是以“$”来标识的，其语法如下：</p>\n<p>$(<function> <arguments> )</p>\n<p>或是</p>\n<p>${<function> <arguments>}</p>\n<p>这里，<function>就是函数名，make支持的函数不多。<arguments>是函数的参数，参数间以逗号“,”分隔，而函数名和参数之间以“空格”分隔。函数调用以“$”开头，以圆括号或花括号把函数名和参数括起。感觉很像一个变量，是不是？函数中的参数可以使用变量，为了风格的统一，函数和变量的括号最好一样，如使用“$(subst a,b,$(x))”这样的形式，而不是“$(subst a,b,${x})”的形式。因为统一会更清楚，也会减少一些不必要的麻烦。</p>\n<p>还是来看一个示例：</p>\n<p>comma:= ,<br>empty:=<br>space:= $(empty) $(empty)<br>foo:= a b c<br>bar:= $(subst $(space),$(comma),$(foo))</p>\n<p>在这个示例中，$(comma)的值是一个逗号。$(space)使用了$(empty)定义了一个空格，$(foo)的值是“a b c”，$(bar)的定义用，调用了函数“subst”，这是一个替换函数，这个函数有三个参数，第一个参数是被替换字串，第二个参数是替换字串，第三个参数是替换操作作用的字串。这个函数也就是把$(foo)中的空格替换成逗号，所以$(bar)的值是“<br>a,b,c”。</p>\n<p><strong>二、字符串处理函数</strong></p>\n<p>$(subst <from>,<to>,<text> )</p>\n<p>名称：字符串替换函数——subst。<br>功能：把字串<text>中的<from>字符串替换成<to>。<br>返回：函数返回被替换过后的字符串。</p>\n<p>示例：</p>\n<p>$(subst ee,EE,feet on the street)，</p>\n<p>把“feet on the street”中的“ee”替换成“EE”，返回结果是“fEEt on the strEEt<br>”。</p>\n<p>$(patsubst <pattern>,<replacement>,<text> )</p>\n<p>名称：模式字符串替换函数——patsubst。<br>功能：查找<text>中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。这里，<pattern>可以包括通配符“%”，表示任意长度的字串。如果<replacement>中也包含“%”，那么，<replacement>中的这个“%”将是<pattern>中的那个“%”所代表的字串。（可以用“\\”来转义，以“%”来表示真实含义的“%”字符）返回：函数返回被替换过后的字符串。</p>\n<p>示例：</p>\n<p>$(patsubst %.c,%.o,x.c.c bar.c)</p>\n<p>把字串“x.c.c bar.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“x.c.o bar.o”</p>\n<p>备注：</p>\n<p>这和我们前面“变量章节”说过的相关知识有点相似。如：</p>\n<p>“$(var:<pattern>=<replacement> )”<br>相当于<br>“$(patsubst <pattern>,<replacement>,$(var))”，</p>\n<p>而“$(var: <suffix>=<replacement> )”<br>则相当于<br>“$(patsubst %<suffix>,%<replacement>,$(var))”。</p>\n<p>例如有：objects = foo.o bar.o baz.o，<br>那么，“$(objects:.o=.c)”和“$(patsubst %.o,%.c,$(objects))”是一样的。</p>\n<p>$(strip <string> )</p>\n<p>名称：去空格函数——strip。<br>功能：去掉<string>字串中开头和结尾的空字符。<br>返回：返回被去掉空格的字符串值。<br>示例：</p>\n<p>$(strip a b c )</p>\n<p>把字串“a b c ”去到开头和结尾的空格，结果是“a b c”。</p>\n<p>$(findstring <find>,<in> )</p>\n<p>名称：查找字符串函数——findstring。<br>功能：在字串<in>中查找<find>字串。<br>返回：如果找到，那么返回<find>，否则返回空字符串。<br>示例：</p>\n<p>$(findstring a,a b c)<br>$(findstring a,b c)</p>\n<p>第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）</p>\n<p>$(filter &lt;pattern…&gt;,<text> )</p>\n<p>名称：过滤函数——filter。<br>功能：以<pattern>模式过滤<text>字符串中的单词，保留符合模式<pattern>的单词。可<br>以有多个模式。<br>返回：返回符合模式<pattern>的字串。<br>示例：</p>\n<p>sources := foo.c bar.c baz.s ugh.h<br>foo: $(sources)<br>cc $(filter %.c %.s,$(sources)) -o foo</p>\n<p>$(filter %.c %.s,$(sources))返回的值是“foo.c bar.c baz.s”。</p>\n<p>$(filter-out &lt;pattern…&gt;,<text> )</p>\n<p>名称：反过滤函数——filter-out。<br>功能：以<pattern>模式过滤<text>字符串中的单词，去除符合模式<pattern>的单词。可<br>以有多个模式。<br>返回：返回不符合模式<pattern>的字串。<br>示例：</p>\n<p>objects=main1.o foo.o main2.o bar.o<br>mains=main1.o main2.o</p>\n<p>$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”。</p>\n<p>$(sort <list> )</p>\n<p>名称：排序函数——sort。<br>功能：给字符串<list>中的单词排序（升序）。<br>返回：返回排序后的字符串。<br>示例：$(sort foo bar lose)返回“bar foo lose” 。<br>备注：sort函数会去掉<list>中相同的单词。</p>\n<p>$(word <n>,<text> )</p>\n<p>名称：取单词函数——word。<br>功能：取字符串<text>中第<n>个单词。（从一开始）<br>返回：返回字符串<text>中第<n>个单词。如果<n>比<text>中的单词数要大，那么返回空<br>字符串。<br>示例：$(word 2, foo bar baz)返回值是“bar”。</p>\n<p>$(wordlist <s>,<e>,<text> )</p>\n<p>名称：取单词串函数——wordlist。<br>功能：从字符串<text>中取从<s>开始到<e>的单词串。<s>和<e>是一个数字。<br>返回：返回字符串<text>中从<s>到<e>的单词字串。如果<s>比<text>中的单词数要大，那<br>么返回空字符串。如果<e>大于<text>的单词数，那么返回从<s>开始，到<text>结束的单<br>词串。<br>示例： $(wordlist 2, 3, foo bar baz)返回值是“bar baz”。</p>\n<p>$(words <text> )</p>\n<p>名称：单词个数统计函数——words。<br>功能：统计<text>中字符串中的单词个数。<br>返回：返回<text>中的单词数。<br>示例：$(words, foo bar baz)返回值是“3”。<br>备注：如果我们要取<text>中最后的一个单词，我们可以这样：$(word $(words <text><br>),<text> )。</p>\n<p>$(firstword <text> )</p>\n<p>名称：首单词函数——firstword。<br>功能：取字符串<text>中的第一个单词。<br>返回：返回字符串<text>的第一个单词。<br>示例：$(firstword foo bar)返回值是“foo”。<br>备注：这个函数可以用word函数来实现：$(word 1,<text> )。</p>\n<p>以上，是所有的字符串操作函数，如果搭配混合使用，可以完成比较复杂的功能。这里，<br>举一个现实中应用的例子。我们知道，make使用“VPATH”变量来指定“依赖文件”的搜索<br>路径。于是，我们可以利用这个搜索路径来指定编译器对头文件的搜索路径参数CFLAGS，<br>如：</p>\n<p>override CFLAGS += $(patsubst %,-I%,$(subst :, ,$(VPATH)))</p>\n<p>如果我们的“$(VPATH)”值是“src:../headers”，那么“$(patsubst %,-I%,$(subst :<br>, ,$(VPATH)))”将返回“-Isrc -I../headers”，这正是cc或gcc搜索头文件路径的参数<br>。</p>\n<p><strong>三、文件名操作函数</strong><br>下面我们要介绍的函数主要是处理文件名的。每个函数的参数字符串都会被当做一个或是<br>一系列的文件名来对待。</p>\n<p>$(dir &lt;names…&gt; )</p>\n<p>名称：取目录函数——dir。<br>功能：从文件名序列<names>中取出目录部分。目录部分是指最后一个反斜杠（“/”）之<br>前的部分。如果没有反斜杠，那么返回“./”。<br>返回：返回文件名序列<names>的目录部分。<br>示例： $(dir src/foo.c hacks)返回值是“src/ ./”。</p>\n<p>$(notdir &lt;names…&gt; )</p>\n<p>名称：取文件函数——notdir。<br>功能：从文件名序列<names>中取出非目录部分。非目录部分是指最后一个反斜杠（“/”<br>）之后的部分。<br>返回：返回文件名序列<names>的非目录部分。<br>示例： $(notdir src/foo.c hacks)返回值是“foo.c hacks”。</p>\n<p>$(suffix &lt;names…&gt; )</p>\n<p>名称：取后缀函数——suffix。<br>功能：从文件名序列<names>中取出各个文件名的后缀。<br>返回：返回文件名序列<names>的后缀序列，如果文件没有后缀，则返回空字串。<br>示例：$(suffix src/foo.c src-1.0/bar.c hacks)返回值是“.c .c”。</p>\n<p>$(basename &lt;names…&gt; )</p>\n<p>名称：取前缀函数——basename。<br>功能：从文件名序列<names>中取出各个文件名的前缀部分。<br>返回：返回文件名序列<names>的前缀序列，如果文件没有前缀，则返回空字串。<br>示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar h<br>acks”。</p>\n<p>$(addsuffix <suffix>,&lt;names…&gt; )</p>\n<p>名称：加后缀函数——addsuffix。<br>功能：把后缀<suffix>加到<names>中的每个单词后面。<br>返回：返回加过后缀的文件名序列。<br>示例：$(addsuffix .c,foo bar)返回值是“foo.c bar.c”。</p>\n<p>$(addprefix <prefix>,&lt;names…&gt; )</p>\n<p>名称：加前缀函数——addprefix。<br>功能：把前缀<prefix>加到<names>中的每个单词后面。<br>返回：返回加过前缀的文件名序列。<br>示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar”。</p>\n<p>$(join <list1>,<list2> )</p>\n<p>名称：连接函数——join。<br>功能：把<list2>中的单词对应地加到<list1>的单词后面。如果<list1>的单词个数要比&lt;<br>list2&gt;的多，那么，<list1>中的多出来的单词将保持原样。如果<list2>的单词个数要比<br><list1>多，那么，<list2>多出来的单词将被复制到<list2>中。<br>返回：返回连接过后的字符串。<br>示例：$(join aaa bbb , 111 222 333)返回值是“aaa111 bbb222 333”。</p>\n<p><strong>四、foreach 函数</strong></p>\n<p>foreach 函数和别的函数非常的不一样。因为这个函数是用来做循环用的，Makefile中的<br>foreach函数几乎是仿照于Unix标准Shell（/bin /sh）中的for语句，或是C-Shell（/bin<br>/csh）中的foreach语句而构建的。它的语法是：</p>\n<p>$(foreach <var>,<list>,<text> )</p>\n<p>这个函数的意思是，把参数<list>中的单词逐一取出放到参数<var>所指定的变量中，然后再执行<text>所包含的表达式。每一次<text>会返回一个字符串，循环过程中，<text>的所返回的每个字符串会以空格分隔，最后当整个循环结束时，<text>所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。</p>\n<p>所以，<var>最好是一个变量名，<list>可以是一个表达式，而<text>中一般会使用<var><br>这个参数来依次枚举<list>中的单词。举个例子：</p>\n<p>names := a b c d</p>\n<p>files := $(foreach n,$(names),$(n).o)</p>\n<p>上面的例子中，$(name)中的单词会被挨个取出，并存到变量“n”中，“$(n).o”每次根据“$(n)”计算出一个值，这些值以空格分隔，最后作为foreach函数的返回，所以，$(f<br>iles)的值是“a.o b.o c.o d.o”。</p>\n<p>注意，foreach中的<var>参数是一个临时的局部变量，foreach函数执行完后，参数<var>的变量将不在作用，其作用域只在foreach函数当中。</p>\n<p><strong>五、if 函数</strong></p>\n<p>if函数很像GNU的make所支持的条件语句——ifeq（参见前面所述的章节），if函数的语法是：</p>\n<p>$(if <condition>,<then-part> )</p>\n<p>或是</p>\n<p>$(if <condition>,<then-part>,<else-part> )</p>\n<p>可见，if函数可以包含“else”部分，或是不含。即if函数的参数可以是两个，也可以是三个。<condition>参数是if的表达式，如果其返回的为非空字符串，那么这个表达式就相当于返回真，于是，<then-part>会被计算，否则<else-part> 会被计算。</p>\n<p>而if函数的返回值是，如果<condition>为真（非空字符串），那个<then- part>会是整个函数的返回值，如果<condition>为假（空字符串），那么<else-part>会是整个函数的返回值，此时如果<else-part>没有被定义，那么，整个函数返回空字串。</p>\n<p>所以，<then-part>和<else-part>只会有一个被计算。</p>\n<p><strong>六、call函数</strong><br>call函数是唯一一个可以用来创建新的参数化的函数。你可以写一个非常复杂的表达式，这个表达式中，你可以定义许多参数，然后你可以用call函数来向这个表达式传递参数。其语法是：</p>\n<p>$(call <expression>,<parm1>,<parm2>,<parm3>…)</p>\n<p>当 make执行这个函数时，<expression>参数中的变量，如$(1)，$(2)，$(3)等，会被参数<parm1>，<parm2>，<parm3>依次取代。而<expression>的返回值就是 call函数的返回值。例如：</p>\n<p>reverse = $(1) $(2)</p>\n<p>foo = $(call reverse,a,b)</p>\n<p>那么，foo的值就是“a b”。当然，参数的次序是可以自定义的，不一定是顺序的，如：</p>\n<p>reverse = $(2) $(1)<br>foo = $(call reverse,a,b)</p>\n<p>此时的foo的值就是“b a”。</p>\n<p><strong>七、origin函数</strong>origin函数不像其它的函数，他并不操作变量的值，他只是告诉你你的这个变量是哪里来的？其语法是：</p>\n<p>$(origin <variable> )</p>\n<p>注意，<variable>是变量的名字，不应该是引用。所以你最好不要在<variable>中使用“$”字符。Origin函数会以其返回值来告诉你这个变量的“出生情况”，下面，是origin函<br>数的返回值:</p>\n<p>“undefined”</p>\n<p>如果<variable>从来没有定义过，origin函数返回这个值“undefined”。</p>\n<p>“default”</p>\n<p>如果<variable>是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。</p>\n<p>“environment”</p>\n<p>如果<variable>是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开。</p>\n<p>“file”</p>\n<p>如果<variable>这个变量被定义在Makefile中。</p>\n<p>“command line”</p>\n<p>如果<variable>这个变量是被命令行定义的。</p>\n<p>“override”</p>\n<p>如果<variable>是被override指示符重新定义的。</p>\n<p>“automatic”</p>\n<p>如果<variable>是一个命令运行中的自动化变量。关于自动化变量将在后面讲述。</p>\n<p>这些信息对于我们编写Makefile是非常有用的，例如，假设我们有一个Makefile其包了一个定义文件Make.def，在Make.def中定义了一个变量“bletch”，而我们的环境中也有一<br>个环境变量“bletch”，此时，我们想判断一下，如果变量来源于环境，那么我们就把之重定义了，如果来源于Make.def或是命令行等非环境的，那么我们就不重新定义它。于是<br>，在我们的Makefile中，我们可以这样写：</p>\n<p>ifdef bletch</p>\n<p>ifeq “$(origin bletch)” “environment”</p>\n<p>bletch = barf, gag, etc.</p>\n<p>endif</p>\n<p>endif</p>\n<p>当然，你也许会说，使用override关键字不就可以重新定义环境中的变量了吗？为什么需要使用这样的步骤？是的，我们用override是可以达到这样的效果，可是override过于粗<br>暴，它同时会把从命令行定义的变量也覆盖了，而我们只想重新定义环境传来的，而不想重新定义命令行传来的。</p>\n<p><strong>八、shell函数</strong><br>shell 函数也不像其它的函数。顾名思义，它的参数应该就是操作系统Shell的命令。它和反引号“`”是相同的功能。这就是说，shell函数把执行操作系统命令后的输出作为函数<br>返回。于是，我们可以用操作系统命令以及字符串处理命令awk，sed等等命令来生成一个变量，如：</p>\n<p>contents := $(shell cat foo)</p>\n<p>files := $(shell echo *.c)</p>\n<p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。</p>\n<p><strong>九、控制make的函数</strong></p>\n<p>make提供了一些函数来控制make的运行。通常，你需要检测一些运行Makefile时的运行时信息，并且根据这些信息来决定，你是让make继续执行，还是停止。</p>\n<p>$(error &lt;text …&gt; )</p>\n<p>产生一个致命的错误，&lt;text …&gt;是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也<br>是可以的。例如：</p>\n<p>示例一：</p>\n<p>ifdef ERROR_001</p>\n<p>$(error error is $(ERROR_001))</p>\n<p>endif</p>\n<p>示例二：</p>\n<p>ERR = $(error found an error!)</p>\n<p>.PHONY: err</p>\n<p>err: ; $(ERR)</p>\n<p>示例一会在变量ERROR_001定义了后执行时产生error调用，而示例二则在目录err被执行时才发生error调用。</p>\n<p>$(warning &lt;text …&gt; )</p>\n<p>这个函数很像error函数，只是它并不会让make退出，只是输出一段警告信息，而make继续执行。</p>\n<p><strong>make 的运行</strong>——————一般来说，最简单的就是直接在命令行下输入make命令，make命令会找当前目录的makefile来执行，一切都是自动的。但也有时你也许只想让 make重编译某些文件，而不是整个工程，而又有的时候你有几套编译规则，你想在不同的时候使用不同的编译规则，等等。本章节就是讲述如何使用make命令的。<br><strong>一、make的退出码</strong>make命令执行后有三个退出码：0 —— 表示成功执行。1 —— 如果make运行时出现任何错误，其返回1。2 —— 如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。Make的相关参数我们会在后续章节中讲述。<br><strong>二、指定Makefile</strong></p>\n<p>前面我们说过，GNU make找寻默认的Makefile的规则是在当前目录下依次找三个文件——“GNUmakefile”、“makefile”和“Makefile”。其按顺序找这三个文件，一旦找到，就<br>开始读取这个文件并执行。</p>\n<p>当前，我们也可以给make命令指定一个特殊名字的Makefile。要达到这个功能，我们要使用make的“-f”或是“–file”参数（“– makefile”参数也行）。例如，我们有个mak<br>efile的名字是“hchen.mk”，那么，我们可以这样来让make来执行这个文件：</p>\n<p>make –f hchen.mk</p>\n<p>如果在make的命令行是，你不只一次地使用了“-f”参数，那么，所有指定的makefile将会被连在一起传递给make执行。</p>\n<p><strong>三、指定目标</strong></p>\n<p>一般来说，make的最终目标是makefile中的第一个目标，而其它目标一般是由这个目标连带出来的。这是make的默认行为。当然，一般来说，你的 makefile中的第一个目标是由许多个目标组成，你可以指示make，让其完成你所指定的目标。要达到这一目的很简单，需在make命令后直接跟目标的名字就可以完成（如前面提到的“make clean”形式）任何在makefile中的目标都可以被指定成终极目标，但是除了以“- ”打头，或是包含了“=”的目标，因为有这些字符的目标，会被解析成命令行参数或是变量。甚至没有被我们明确写出来的目标也可以成为make的终极目标，也就是说，只要make可以找到其隐含规则推导规则，那么这个隐含目标同样可以被指定成终极目标。</p>\n<p>有一个make的环境变量叫“MAKECMDGOALS”，这个变量中会存放你所指定的终极目标的列表，如果在命令行上，你没有指定目标，那么，这个变量是空值。这个变量可以让你使用在一些比较特殊的情形下。比如下面的例子：</p>\n<p>sources = foo.c bar.c<br>ifneq ( $(MAKECMDGOALS),clean)<br>include $(sources:.c=.d)<br>endif</p>\n<p>基于上面的这个例子，只要我们输入的命令不是“make clean”，那么makefile会自动包含“foo.d”和“bar.d”这两个makefile。</p>\n<p>使用指定终极目标的方法可以很方便地让我们编译我们的程序，例如下面这个例子：</p>\n<p>.PHONY: all<br>all: prog1 prog2 prog3 prog4</p>\n<p>从这个例子中，我们可以看到，这个makefile中有四个需要编译的程序——“prog1”， “prog2”， “prog3”和 “prog4”，我们可以使用“make all”命令来编译所有的目标<br>（如果把all置成第一个目标，那么只需执行“make”），我们也可以使用“make prog2”来单独编译目标“prog2”。</p>\n<p>即然make可以指定所有makefile中的目标，那么也包括“伪目标”，于是我们可以根据这种性质来让我们的makefile根据指定的不同的目标来完成不同的事。在Unix世界中，软件<br>发布时，特别是GNU这种开源软件的发布时，其 makefile都包含了编译、安装、打包等功能。我们可以参照这种规则来书写我们的makefile中的目标。</p>\n<p><strong>“all”</strong>        这个伪目标是所有目标的目标，其功能一般是编译所有的目标。<strong>“clean”</strong>    这个伪目标功能是删除所有被make创建的文件。<strong>“install”</strong>    这个伪目标功能是安装已编译好的程序，其实就是把目标执行文件拷贝到指定的目标中去。<strong>“print”</strong>     这个伪目标的功能是例出改变过的源文件。<strong>“tar”</strong>       这个伪目标功能是把源程序打包备份。也就是一个tar文件。<strong>“dist”</strong>      这个伪目标功能是创建一个压缩文件，一般是把tar文件压成Z文件。或是gz文件。<strong>“TAGS”</strong>     这个伪目标功能是更新所有的目标，以备完整地重编译使用。<strong>“check”和“test”</strong>   这两个伪目标一般用来<a href=\"http://lib.csdn.net/base/softwaretest\">测试</a>makefile的流程。</p>\n<p>​    当然一个项目的makefile中也不一定要书写这样的目标，这些东西都是GNU的东西，但是我想，GNU搞出这些东西一定有其可取之处（等你的UNIX下的程序文件一多时你就会发现这些功能很有用了），这里只不过是说明了，如果你要书写这种功能，最好使用这种名字命名你的目标，这样规范一些，规范的好处就是——不用解释，大家都明白。而且如果你的makefile中有这些功能，一是很实用，二是可以显得你的makefile很专业（不是那种初学者的作品）。</p>\n<p><strong>四、检查规则</strong></p>\n<p>有时候，我们不想让我们的makefile中的规则执行起来，我们只想检查一下我们的命令，或是执行的序列。于是我们可以使用make命令的下述参数：</p>\n<p>“-n”<br>“–just-print”<br>“–dry-run”<br>“–recon”<br>不执行参数，这些参数只是打印命令，不管目标是否更新，把规则和连带规则下的命令打印出来，但不执行，这些参数对于我们调试makefile很有用处。</p>\n<p>“-t”<br>“–touch”<br>这个参数的意思就是把目标文件的时间更新，但不更改目标文件。也就是说，make假装编译目标，但不是真正的编译目标，只是把目标变成已编译过的状态。</p>\n<p>“-q”<br>“–question”<br>这个参数的行为是找目标的意思，也就是说，如果目标存在，那么其什么也不会输出，当然也不会执行编译，如果目标不存在，其会打印出一条出错信息。</p>\n<p>“-W <file>”<br>“–what-if=<file>”<br>“–assume-new=<file>”<br>“–new-file=<file>”<br>这个参数需要指定一个文件。一般是是源文件（或依赖文件），Make会根据规则推导来运行依赖于这个文件的命令，一般来说，可以和“-n”参数一同使用，来查看这个依赖文件<br>所发生的规则命令。</p>\n<p>另外一个很有意思的用法是结合“-p”和“-v”来输出makefile被执行时的信息（这个将在后面讲述）。</p>\n<p><strong>五、make的参数</strong></p>\n<p>下面列举了所有GNU make 3.80版的参数定义。其它版本和产商的make大同小异，不过其它产商的make的具体参数还是请参考各自的产品文档。</p>\n<p>“-b”<br>“-m”<br>这两个参数的作用是忽略和其它版本make的兼容性。</p>\n<p>“-B”<br>“–always-make”<br>认为所有的目标都需要更新（重编译）。</p>\n<p>“-C <dir>”<br>“–directory=<dir>”<br>指定读取makefile的目录。如果有多个“-C”参数，make的解释是后面的路径以前面的作为相对路径，并以最后的目录作为被指定目录。如：“make –C ~hchen/test –C prog”<br>等价于“make –C ~hchen/test/prog”。</p>\n<p>“—debug[=<options>]”<br>输出make的调试信息。它有几种不同的级别可供选择，如果没有参数，那就是输出最简单的调试信息。下面是<options>的取值：<br>a —— 也就是all，输出所有的调试信息。（会非常的多）b —— 也就是basic，只输出简单的调试信息。即输出不需要重编译的目标。v —— 也就是verbose，在b选项的级别之上。输出的信息包括哪个makefile被解析，不需要被重编译的依赖文件（或是依赖目标）等。i —— 也就是implicit，输出所以的隐含规则。j —— 也就是jobs，输出执行规则中命令的详细信息，如命令的PID、返回码等。m —— 也就是makefile，输出make读取makefile，更新makefile，执行makefile的信息。</p>\n<p>“-d”<br>相当于“–debug=a”。</p>\n<p>“-e”<br>“–environment-overrides”<br>指明环境变量的值覆盖makefile中定义的变量的值。</p>\n<p>“-f=<file>”<br>“–file=<file>”<br>“–makefile=<file>”<br>指定需要执行的makefile。</p>\n<p>“-h”<br>“–help”<br>显示帮助信息。</p>\n<p>“-i”<br>“–ignore-errors”<br>在执行时忽略所有的错误。</p>\n<p>“-I <dir>”<br>“–include-dir=<dir>”<br>指定一个被包含makefile的搜索目标。可以使用多个“-I”参数来指定多个目录。</p>\n<p>“-j [<jobsnum>]”<br>“–jobs[=<jobsnum>]”<br>指同时运行命令的个数。如果没有这个参数，make运行命令时能运行多少就运行多少。如果有一个以上的“-j”参数，那么仅最后一个“-j”才是有效的。（注意这个参数在MS-D<br>OS中是无用的）</p>\n<p>“-k”<br>“–keep-going”<br>出错也不停止运行。如果生成一个目标失败了，那么依赖于其上的目标就不会被执行了。</p>\n<p>“-l <load>”<br>“–load-average[=&lt;load]”<br>“—max-load[=<load>]”<br>指定make运行命令的负载。</p>\n<p>“-n”<br>“–just-print”<br>“–dry-run”<br>“–recon”<br>仅输出执行过程中的命令序列，但并不执行。</p>\n<p>“-o <file>”<br>“–old-file=<file>”<br>“–assume-old=<file>”<br>不重新生成的指定的<file>，即使这个目标的依赖文件新于它。</p>\n<p>“-p”<br>“–print-data-base”<br>输出makefile中的所有数据，包括所有的规则和变量。这个参数会让一个简单的makefile都会输出一堆信息。如果你只是想输出信息而不想执行 makefile，你可以使用“make -q<br>p”命令。如果你想查看执行makefile前的预设变量和规则，你可以使用“make –p –f /dev/null”。这个参数输出的信息会包含着你的makefile文件的文件名和行号，所以，用<br>这个参数来调试你的makefile会是很有用的，特别是当你的环境变量很复杂的时候。</p>\n<p>“-q”<br>“–question”<br>不运行命令，也不输出。仅仅是检查所指定的目标是否需要更新。如果是0则说明要更新，如果是2则说明有错误发生。</p>\n<p>“-r”<br>“–no-builtin-rules”<br>禁止make使用任何隐含规则。</p>\n<p>“-R”<br>“–no-builtin-variabes”<br>禁止make使用任何作用于变量上的隐含规则。</p>\n<p>“-s”<br>“–silent”<br>“–quiet”<br>在命令运行时不输出命令的输出。</p>\n<p>“-S”<br>“–no-keep-going”<br>“–stop”<br>取消“-k”选项的作用。因为有些时候，make的选项是从环境变量“MAKEFLAGS”中继承下来的。所以你可以在命令行中使用这个参数来让环境变量中的“-k”选项失效。</p>\n<p>“-t”<br>“–touch”<br>相当于UNIX的touch命令，只是把目标的修改日期变成最新的，也就是阻止生成目标的命令运行。</p>\n<p>“-v”<br>“–version”<br>输出make程序的版本、版权等关于make的信息。</p>\n<p>“-w”<br>“–print-directory”<br>输出运行makefile之前和之后的信息。这个参数对于跟踪嵌套式调用make时很有用。</p>\n<p>“–no-print-directory”<br>禁止“-w”选项。</p>\n<p>“-W <file>”<br>“–what-if=<file>”<br>“–new-file=<file>”<br>“–assume-file=<file>”<br>假定目标<file>需要更新，如果和“-n”选项使用，那么这个参数会输出该目标更新时的运行动作。如果没有“-n”那么就像运行UNIX的“touch”命令一样，使得<file>的修改时<br>间为当前时间。</p>\n<p>“–warn-undefined-variables”<br>只要make发现有未定义的变量，那么就输出警告信息。</p>\n<p><strong>隐含规则**</strong>————**</p>\n<p>在我们使用Makefile时，有一些我们会经常使用，而且使用频率非常高的东西，比如，我们编译C/C++的源程序为中间目标文件（Unix下是[.o] 文件，Windows下是[.obj]文件）。本章讲述的就是一些在Makefile中的“隐含的”，早先约定了的，不需要我们再写出来的规则。</p>\n<p>“隐含规则”也就是一种惯例，make会按照这种“惯例”心照不喧地来运行，那怕我们的Makefile中没有书写这样的规则。例如，把[.c]文件编译成[.o]文件这一规则，你根本就<br>不用写出来，make会自动推导出这种规则，并生成我们需要的[.o]文件。</p>\n<p>“隐含规则”会使用一些我们系统变量，我们可以改变这些系统变量的值来定制隐含规则的运行时的参数。如系统变量“CFLAGS”可以控制编译时的编译器参数。</p>\n<p>我们还可以通过“模式规则”的方式写下自己的隐含规则。用“后缀规则”来定义隐含规则会有许多的限制。使用“模式规则”会更回得智能和清楚，但“后缀规则”可以用来保<br>证我们Makefile的兼容性。<br>我们了解了“隐含规则”，可以让其为我们更好的服务，也会让我们知道一些“约定俗成”了的东西，而不至于使得我们在运行Makefile时出现一些我们觉得莫名其妙的东西。当<br>然，任何事物都是矛盾的，水能载舟，亦可覆舟，所以，有时候“隐含规则”也会给我们造成不小的麻烦。只有了解了它，我们才能更好地使用它。</p>\n<p><strong>一、使用隐含规则</strong></p>\n<p>如果要使用隐含规则生成你需要的目标，你所需要做的就是不要写出这个目标的规则。那么，make会试图去自动推导产生这个目标的规则和命令，如果make可以自动推导生成这个目标的规则和命令，那么这个行为就是隐含规则的自动推导。当然，隐含规则是make事先约定好的一些东西。例如，我们有下面的一个Makefile：</p>\n<p>foo : foo.o bar.o<br>cc –o foo foo.o bar.o $(CFLAGS) $(LDFLAGS)</p>\n<p>我们可以注意到，这个Makefile中并没有写下如何生成foo.o和bar.o这两目标的规则和命令。因为make的“隐含规则”功能会自动为我们自动去推导这两个目标的依赖目标和生成<br>命令。</p>\n<p>make 会在自己的“隐含规则”库中寻找可以用的规则，如果找到，那么就会使用。如果找不到，那么就会报错。在上面的那个例子中，make调用的隐含规则是，把 [.o]的目标的依赖文件置成[.c]，并使用C的编译命令“cc –c $(CFLAGS) [.c]”来生成[.o]的目标。也就是说，我们完全没有必要写下下面的两条规则：</p>\n<p>foo.o : foo.c<br>cc –c foo.c $(CFLAGS)<br>bar.o : bar.c<br>cc –c bar.c $(CFLAGS)</p>\n<p>因为，这已经是“约定”好了的事了，make和我们约定好了用C编译器“cc”生成[.o]文件的规则，这就是隐含规则。</p>\n<p>当然，如果我们为[.o]文件书写了自己的规则，那么make就不会自动推导并调用隐含规则，它会按照我们写好的规则忠实地执行。</p>\n<p>还有，在make的“隐含规则库”中，每一条隐含规则都在库中有其顺序，越靠前的则是越被经常使用的，所以，这会导致我们有些时候即使我们显示地指定了目标依赖，make也不会管。如下面这条规则（没有命令）：</p>\n<p>foo.o : foo.p</p>\n<p>依赖文件“foo.p”（Pascal程序的源文件）有可能变得没有意义。如果目录下存在了“foo.c”文件，那么我们的隐含规则一样会生效，并会通过 “foo.c”调用C的编译器生成f<br>oo.o文件。因为，在隐含规则中，Pascal的规则出现在C的规则之后，所以，make找到可以生成foo.o的 C的规则就不再寻找下一条规则了。如果你确实不希望任何隐含规则推导，那么，你就不要只写出“依赖规则”，而不写命令。</p>\n<p><strong>二、隐含规则一览</strong></p>\n<p>这里我们将讲述所有预先设置（也就是make内建）的隐含规则，如果我们不明确地写下规则，那么，make就会在这些规则中寻找所需要规则和命令。当然，我们也可以使用make的参数“-r”或“–no-builtin-rules”选项来取消所有的预设置的隐含规则。</p>\n<p>当然，即使是我们指定了“-r”参数，某些隐含规则还是会生效，因为有许多的隐含规则都是使用了“后缀规则”来定义的，所以，只要隐含规则中有“后缀列表 ”（也就一系统<br>定义在目标.SUFFIXES的依赖目标），那么隐含规则就会生效。默认的后缀列表是：.out,.a, .ln, .o, .c, .cc, .C, .p, .f, .F, .r, .y, .l, .s, .S, .mod, .sym, .def, .<br>h, .info, .dvi, .tex, .texinfo, .texi, .txinfo, .w, .ch .web, .sh, .elc, .el。具体的细节，我们会在后面讲述。</p>\n<p>还是先来看一看常用的隐含规则吧。</p>\n<p>1、编译C程序的隐含规则。<br>“<n>.o”的目标的依赖目标会自动推导为“<n>.c”，并且其生成命令是“$(CC) –c $(CPPFLAGS) $(CFLAGS)”</p>\n<p>2、编译C++程序的隐含规则。<br>“<n>.o” 的目标的依赖目标会自动推导为“<n>.cc”或是“<n>.C”，并且其生成命令是“$(CXX) –c $(CPPFLAGS) $(CFLAGS)”。（建议使用“.cc”作为C++源文件的后缀，而<br>不是“.C”）</p>\n<p>3、编译Pascal程序的隐含规则。<br>“<n>.o”的目标的依赖目标会自动推导为“<n>.p”，并且其生成命令是“$(PC) –c $(PFLAGS)”。</p>\n<p>4、编译Fortran/Ratfor程序的隐含规则。<br>“<n>.o”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”或“<n>.f”，并且其生成命令是:<br>“.f” “$(FC) –c $(FFLAGS)”<br>“.F” “$(FC) –c $(FFLAGS) $(CPPFLAGS)”<br>“.f” “$(FC) –c $(FFLAGS) $(RFLAGS)”</p>\n<p>5、预处理Fortran/Ratfor程序的隐含规则。<br>“<n>.f”的目标的依赖目标会自动推导为“<n>.r”或“<n>.F”。这个规则只是转换Ratfor或有预处理的Fortran程序到一个标准的Fortran程序。其使用的命令是：<br>“.F” “$(FC) –F $(CPPFLAGS) $(FFLAGS)”<br>“.r” “$(FC) –F $(FFLAGS) $(RFLAGS)”</p>\n<p>6、编译Modula-2程序的隐含规则。<br>“<n>.sym” 的目标的依赖目标会自动推导为“<n>.def”，并且其生成命令是：“$(M2C) $(M2FLAGS) $(DEFFLAGS)”。“&lt;n.o&gt;” 的目标的依赖目标会自动推导为“<n>.mod”，<br>并且其生成命令是：“$(M2C) $(M2FLAGS) $(MODFLAGS)”。</p>\n<p>7、汇编和汇编预处理的隐含规则。<br>“<n>.o” 的目标的依赖目标会自动推导为“<n>.s”，默认使用编译品“as”，并且其生成命令是：“$(AS) $(ASFLAGS)”。“<n>.s” 的目标的依赖目标会自动推导为“<n>.S”<br>，默认使用C预编译器“cpp”，并且其生成命令是：“$(AS) $(ASFLAGS)”。</p>\n<p>8、链接Object文件的隐含规则。<br>“<n>” 目标依赖于“<n>.o”，通过运行C的编译器来运行链接程序生成（一般是“ld”），其生成命令是：“$(CC) $(LDFLAGS) <n>.o $(LOADLIBES) $(LDLIBS)”。这个规则对<br>于只有一个源文件的工程有效，同时也对多个Object文件（由不同的源文件生成）的也有效。例如如下规则：</p>\n<p>x : y.o z.o</p>\n<p>并且“x.c”、“y.c”和“z.c”都存在时，隐含规则将执行如下命令：</p>\n<p>cc -c x.c -o x.o<br>cc -c y.c -o y.o<br>cc -c z.c -o z.o<br>cc x.o y.o z.o -o x<br>rm -f x.o<br>rm -f y.o<br>rm -f z.o</p>\n<p>如果没有一个源文件（如上例中的x.c）和你的目标名字（如上例中的x）相关联，那么，你最好写出自己的生成规则，不然，隐含规则会报错的。</p>\n<p>9、Yacc C程序时的隐含规则。</p>\n<p>“<n>.c”的依赖文件被自动推导为“n.y”（Yacc生成的文件），其生成命令是：“$(YACC) $(YFALGS)”。（“Yacc”是一个语法分析器，关于其细节请查看相关资料）</p>\n<p>10、Lex C程序时的隐含规则。<br>“<n>.c”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX) $(LFALGS)”。（关于“Lex”的细节请查看相关资料）</p>\n<p>11、Lex Ratfor程序时的隐含规则。<br>“<n>.r”的依赖文件被自动推导为“n.l”（Lex生成的文件），其生成命令是：“$(LEX<br>) $(LFALGS)”。</p>\n<p>12、从C程序、Yacc文件或Lex文件创建Lint库的隐含规则。<br>“<n>.ln” （lint生成的文件）的依赖文件被自动推导为“n.c”，其生成命令是：“$(LINT) $(LINTFALGS) $(CPPFLAGS) -i”。对于“<n>.y”和“<n>.l”也是同样的规则。</p>\n<p><strong>三、隐含规则使用的变量</strong></p>\n<p>在隐含规则中的命令中，基本上都是使用了一些预先设置的变量。你可以在你的makefile中改变这些变量的值，或是在make的命令行中传入这些值，或是在你的环境变量中设置这些值，无论怎么样，只要设置了这些特定的变量，那么其就会对隐含规则起作用。当然，你也可以利用make的“-R”或“–no– builtin-variables”参数来取消你所定义的变量<br>对隐含规则的作用。</p>\n<p>例如，第一条隐含规则——编译C程序的隐含规则的命令是“$(CC) –c $(CFLAGS) $(CPPFLAGS)”。Make默认的编译命令是“cc”，如果你把变量“$(CC)”重定义成“gcc”，把<br>变量“$(CFLAGS)”重定义成 “-g”，那么，隐含规则中的命令全部会以“gcc –c -g $(CPPFLAGS)”的样子来执行了。</p>\n<p>我们可以把隐含规则中使用的变量分成两种：一种是命令相关的，如“CC”；一种是参数<br>相的关，如“CFLAGS”。下面是所有隐含规则中会用到的变量：</p>\n<p><strong>1、关于命令的变量。</strong></p>\n<p>AR  函数库打包程序。默认命令是“ar”。<br>AS<br>汇编语言编译程序。默认命令是“as”。<br>CC<br>C语言编译程序。默认命令是“cc”。<br>CXX<br>C++语言编译程序。默认命令是“g++”。<br>CO<br>从 RCS文件中扩展文件程序。默认命令是“co”。<br>CPP<br>C程序的预处理器（输出是标准输出设备）。默认命令是“$(CC) –E”。<br>FC<br>Fortran 和 Ratfor 的编译器和预处理程序。默认命令是“f77”。<br>GET<br>从SCCS文件中扩展文件的程序。默认命令是“get”。<br>LEX<br>Lex方法分析器程序（针对于C或Ratfor）。默认命令是“lex”。<br>PC<br>Pascal语言编译程序。默认命令是“pc”。<br>YACC<br>Yacc文法分析器（针对于C程序）。默认命令是“yacc”。<br>YACCR<br>Yacc文法分析器（针对于Ratfor程序）。默认命令是“yacc –r”。<br>MAKEINFO<br>转换Texinfo源文件（.texi）到Info文件程序。默认命令是“makeinfo”。<br>TEX<br>从TeX源文件创建TeX DVI文件的程序。默认命令是“tex”。<br>TEXI2DVI<br>从Texinfo源文件创建军TeX DVI 文件的程序。默认命令是“texi2dvi”。<br>WEAVE<br>转换Web到TeX的程序。默认命令是“weave”。<br>CWEAVE<br>转换C Web 到 TeX的程序。默认命令是“cweave”。<br>TANGLE<br>转换Web到Pascal语言的程序。默认命令是“tangle”。<br>CTANGLE<br>转换C Web 到 C。默认命令是“ctangle”。<br>RM<br>删除文件命令。默认命令是“rm –f”。</p>\n<p><strong>2、关于命令参数的变量</strong><br>下面的这些变量都是相关上面的命令的参数。如果没有指明其默认值，那么其默认值都是<br>空。</p>\n<p>ARFLAGS<br>函数库打包程序AR命令的参数。默认值是“rv”。<br>ASFLAGS<br>汇编语言编译器参数。（当明显地调用“.s”或“.S”文件时）。<br>CFLAGS<br>C语言编译器参数。<br>CXXFLAGS<br>C++语言编译器参数。<br>COFLAGS<br>RCS命令参数。<br>CPPFLAGS<br>C预处理器参数。（ C 和 Fortran 编译器也会用到）。<br>FFLAGS<br>Fortran语言编译器参数。<br>GFLAGS<br>SCCS “get”程序参数。<br>LDFLAGS<br>链接器参数。（如：“ld”）<br>LFLAGS<br>Lex文法分析器参数。<br>PFLAGS<br>Pascal语言编译器参数。<br>RFLAGS<br>Ratfor 程序的Fortran 编译器参数。<br>YFLAGS<br>Yacc文法分析器参数。</p>\n<p><strong>四、隐含规则链</strong></p>\n<p>有些时候，一个目标可能被一系列的隐含规则所作用。例如，一个[.o]的文件生成，可能会是先被Yacc的[.y]文件先成[.c]，然后再被C的编译器生成。我们把这一系列的隐含规则<br>叫做“隐含规则链”。</p>\n<p>在上面的例子中，如果文件[.c]存在，那么就直接调用C的编译器的隐含规则，如果没有[.c]文件，但有一个[.y]文件，那么Yacc的隐含规则会被调用，生成[.c]文件，然后，再调<br>用C编译的隐含规则最终由[.c]生成[.o]文件，达到目标。</p>\n<p>我们把这种[.c]的文件（或是目标），叫做中间目标。不管怎么样，make会努力自动推导生成目标的一切方法，不管中间目标有多少，其都会执着地把所有的隐含规则和你书写的规则全部合起来分析，努力达到目标，所以，有些时候，可能会让你觉得奇怪，怎么我的目标会这样生成？怎么我的makefile发疯了？</p>\n<p>在默认情况下，对于中间目标，它和一般的目标有两个地方所不同：第一个不同是除非中间的目标不存在，才会引发中间规则。第二个不同的是，只要目标成功产生，那么，产生最终目标过程中，所产生的中间目标文件会被以“rm -f”删除。</p>\n<p>通常，一个被makefile指定成目标或是依赖目标的文件不能被当作中介。然而，你可以明显地说明一个文件或是目标是中介目标，你可以使用伪目标“.INTERMEDIATE”来强制声明。（如：.INTERMEDIATE ： mid ）</p>\n<p>你也可以阻止make自动删除中间目标，要做到这一点，你可以使用伪目标“.SECONDARY”来强制声明（如：.SECONDARY : sec）。你还可以把你的目标，以模式的方式来指定（如：%.o）成伪目标“.PRECIOUS”的依赖目标，以保存被隐含规则所生成的中间文件。</p>\n<p>在“隐含规则链”中，禁止同一个目标出现两次或两次以上，这样一来，就可防止在make自动推导时出现无限递归的情况。</p>\n<p>Make 会优化一些特殊的隐含规则，而不生成中间文件。如，从文件“foo.c”生成目标程序“foo”，按道理，make会编译生成中间文件“foo.o”，然后链接成“foo”，但在实际情况下，这一动作可以被一条“cc”的命令完成（cc –o foo foo.c），于是优化过的规<br>则就不会生成中间文件。</p>\n<p><strong>五、定义模式规则</strong></p>\n<p>你可以使用模式规则来定义一个隐含规则。一个模式规则就好像一个一般的规则，只是在规则中，目标的定义需要有”%”字符。”%”的意思是表示一个或多个任意字符。在依赖目标中同样可以使用”%”，只是依赖目标中的”%”的取值，取决于其目标。</p>\n<p>有一点需要注意的是，”%”的展开发生在变量和函数的展开之后，变量和函数的展开发生在make载入Makefile时，而模式规则中的”%”则发生在运行时。</p>\n<p><strong>1、模式规则介绍</strong></p>\n<p>模式规则中，至少在规则的目标定义中要包含”%”，否则，就是一般的规则。目标中的”%”定义表示对文件名的匹配，”%”表示长度任意的非空字符串。例如：”%.c”表示以”.c”结尾的文件名（文件名的长度至少为3），而”s.%.c”则表示以”s.”开头，”.c”结尾的文件名（文件名的长度至少为 5）。</p>\n<p>如果”%”定义在目标中，那么，目标中的”%”的值决定了依赖目标中的”%”的值，也就是说，目标中的模式的”%”决定了依赖目标中”%”的样子。例如有一个模式规则如下：</p>\n<p>%.o : %.c ; &lt;command ……&gt;</p>\n<p>其含义是，指出了怎么从所有的[.c]文件生成相应的[.o]文件的规则。如果要生成的目标是”a.o b.o”，那么”%c”就是”a.c b.c”。</p>\n<p>一旦依赖目标中的”%”模式被确定，那么，make会被要求去匹配当前目录下所有的文件名，一旦找到，make就会规则下的命令，所以，在模式规则中，目标可能会是多个的，如果有模式匹配出多个目标，make就会产生所有的模式目标，此时，make关心的是依赖的文件名和生成目标的命令这两件事。</p>\n<p><strong>2、模式规则示例</strong></p>\n<p>下面这个例子表示了,把所有的[.c]文件都编译成[.o]文件.</p>\n<p>%.o : %.c<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) $&lt; -o $@</p>\n<p>其中，”$@”表示所有的目标的挨个值，”$&lt;”表示了所有依赖目标的挨个值。这些奇怪的变<br>量我们叫”自动化变量”，后面会详细讲述。</p>\n<p>下面的这个例子中有两个目标是模式的：</p>\n<p>%.tab.c %.tab.h: %.y<br>bison -d $&lt;</p>\n<p>这条规则告诉make把所有的[.y]文件都以”bison -d <n>.y”执行，然后生成”<n>.tab.c”和”<n>.tab.h”文件。（其中，”<n>“ 表示一个任意字符串）。如果我们的执行程序”foo”依<br>赖于文件”parse.tab.o”和”scan.o”，并且文件”scan.o”依赖于文件”parse.tab.h”，如果”parse.y”文件被更新了，那么根据上述的规则，”bison -d parse.y”就会被执行一次，于<br>是，”parse.tab.o”和”scan.o”的依赖文件就齐了。（假设，”parse.tab.o” 由”parse.tab.c”生成，和”scan.o”由”scan.c”生成，而”foo”由”parse.tab.o”和”scan.o”链接生成，<br>而且foo和其[.o]文件的依赖关系也写好，那么，所有的目标都会得到满足）</p>\n<p><strong>3、自动化变量</strong></p>\n<p>在上述的模式规则中，目标和依赖文件都是一系例的文件，那么我们如何书写一个命令来完成从不同的依赖文件生成相应的目标？因为在每一次的对模式规则的解析时，都会是不同的目标和依赖文件。</p>\n<p>自动化变量就是完成这个功能的。在前面，我们已经对自动化变量有所提涉，相信你看到这里已对它有一个感性认识了。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，直至所有的符合模式的文件都取完了。这种自动化变量只应出现在规则的命令中。</p>\n<p>下面是所有的自动化变量及其说明：</p>\n<p>$@<br>表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，”$@”就是匹配于目标中模式定义的集合。</p>\n<p>$%<br>仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是”foo.a(bar.o)”，那么，”$%”就是”bar.o”，”$@”就是”foo.a”。如果目标不是函数库文件（Unix下是<br>[.a]，Windows下是[.lib]），那么，其值为空。</p>\n<p>$&lt;<br>依赖目标中的第一个目标名字。如果依赖目标是以模式（即”%”）定义的，那么”$&lt;”将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</p>\n<p>$?<br>所有比目标新的依赖目标的集合。以空格分隔。</p>\n<p>$^<br>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</p>\n<p>$+<br>这个变量很像”$^”，也是所有依赖目标的集合。只是它不去除重复的依赖目标。</p>\n<p>$*<br>这个变量表示目标模式中”%”及其之前的部分。如果目标是”dir/a.foo.b”，并且目标的模式是”a.%.b”，那么，”$<em>“的值就是”dir /a.foo”。这个变量对于构造有关联的文件名是比<br>较有较。如果目标中没有模式的定义，那么”$</em>“也就不能被推导出，但是，如果目标文件的后缀是 make所识别的，那么”$<em>“就是除了后缀的那一部分。例如：如果目标是”foo.c”<br>，因为”.c”是make所能识别的后缀名，所以，”$</em>“的值就是”foo”。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用”$<em>“，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么”$</em>“就是空值。</p>\n<p>当你希望只对更新过的依赖文件进行操作时，”$?”在显式规则中很有用，例如，假设有一个函数库文件叫”lib”，其由其它几个object文件更新。那么把object文件打包的比较有效<br>率的Makefile规则是：</p>\n<p>lib : foo.o bar.o lose.o win.o<br>ar r lib $?</p>\n<p>在上述所列出来的自动量变量中。四个变量（$@、$&lt;、$%、$*）在扩展时只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前目录下的符合模式的文件名，只需要搭配上”D”或”F”字样。这是GNU make中老版本的特性，在新版本中，我们使用函数”dir”或”notdir”就可以做到了。”D”的含义就是Directory，就是目录，”F”的含义就是File，就是文件。</p>\n<p>下面是对于上面的七个变量分别加上”D”或是”F”的含义：</p>\n<p>$(@D)<br>表示”$@”的目录部分（不以斜杠作为结尾），如果”$@”值是”dir/foo.o”，那么”$(@D)”就是”dir”，而如果”$@”中没有包含斜杠的话，其值就是”.”（当前目录）。</p>\n<p>$(@F)<br>表示”$@”的文件部分，如果”$@”值是”dir/foo.o”，那么”$(@F)”就是”foo.o”，”$(@F)”相当于函数”$(notdir $@)”。</p>\n<p>“$(*D)”<br>“$(*F)”<br>和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子，”$(*D)”返回”dir”，而”$(*F)”返回”foo”</p>\n<p>“$(%D)”<br>“$(%F)”<br>分别表示了函数包文件成员的目录部分和文件部分。这对于形同”archive(member)”形式的目标中的”member”中包含了不同的目录很有用。</p>\n<p>“$(&lt;D)”<br>“$(&lt;F)”<br>分别表示依赖文件的目录部分和文件部分。</p>\n<p>“$(^D)”<br>“$(^F)”<br>分别表示所有依赖文件的目录部分和文件部分。（无相同的）</p>\n<p>“$(+D)”<br>“$(+F)”<br>分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）</p>\n<p>“$(?D)”<br>“$(?F)”</p>\n<p>分别表示被更新的依赖文件的目录部分和文件部分。</p>\n<p>最后想提醒一下的是，对于”$&lt;”，为了避免产生不必要的麻烦，我们最好给$后面的那个特定字符都加上圆括号，比如，”$(&lt; )”就要比”$&lt;”要好一些。</p>\n<p>还得要注意的是，这些变量只使用在规则的命令中，而且一般都是”显式规则”和”静态模式规则”（参见前面”书写规则”一章）。其在隐含规则中并没有意义。</p>\n<p><strong>4、模式的匹配</strong></p>\n<p>一般来说，一个目标的模式有一个有前缀或是后缀的”%”，或是没有前后缀，直接就是一个”%”。因为”%”代表一个或多个字符，所以在定义好了的模式中，我们把”%”所匹配的内容叫做”茎”，例如”%.c”所匹配的文件”test.c”中”test”就是”茎”。因为在目标和依赖目标中同时有”%”时，依赖目标的”茎”会传给目标，当做目标中的”茎”。</p>\n<p>当一个模式匹配包含有斜杠（实际也不经常包含）的文件时，那么在进行模式匹配时，目录部分会首先被移开，然后进行匹配，成功后，再把目录加回去。在进行”茎”的传递时，我们需要知道这个步骤。例如有一个模式”e%t”，文件”src/eat” 匹配于该模式，于是”src/a”就是其”茎”，如果这个模式定义在依赖目标中，而被依赖于这个模式的目标中又有个模式”c%r”，那么，目标就是”src/car”。（”茎”被传递）</p>\n<p><strong>5、重载内建隐含规则</strong></p>\n<p>你可以重载内建的隐含规则（或是定义一个全新的），例如你可以重新构造和内建隐含规则不同的命令，如：</p>\n<p>%.o : %.c<br>$(CC) -c $(CPPFLAGS) $(CFLAGS) -D$(date)</p>\n<p>你可以取消内建的隐含规则，只要不在后面写命令就行。如：</p>\n<p>%.o : %.s</p>\n<p>同样，你也可以重新定义一个全新的隐含规则，其在隐含规则中的位置取决于你在哪里写下这个规则。朝前的位置就靠前。</p>\n<p><strong>六、老式风格的”后缀规则”</strong></p>\n<p>后缀规则是一个比较老式的定义隐含规则的方法。后缀规则会被模式规则逐步地取代。因为模式规则更强更清晰。为了和老版本的Makefile兼容，GNU make同样兼容于这些东西。后缀规则有两种方式：”双后缀”和”单后缀”。</p>\n<p>双后缀规则定义了一对后缀：目标文件的后缀和依赖目标（源文件）的后缀。如”.c.o”相当于”%o : %c”。单后缀规则只定义一个后缀，也就是源文件的后缀。如”.c”相当于”% : %.c”。</p>\n<p>后缀规则中所定义的后缀应该是make所认识的，如果一个后缀是make所认识的，那么这个规则就是单后缀规则，而如果两个连在一起的后缀都被make所认识，那就是双后缀规则。例如：”.c”和”.o”都是make所知道。因而，如果你定义了一个规则是”.c.o”那么其就是双后缀规则，意义就是”.c” 是源文件的后缀，”.o”是目标文件的后缀。如下示例：</p>\n<p>.c.o:<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>\n<p>后缀规则不允许任何的依赖文件，如果有依赖文件的话，那就不是后缀规则，那些后缀统统被认为是文件名，如：</p>\n<p>.c.o: foo.h<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>\n<p>这个例子，就是说，文件”.c.o”依赖于文件”foo.h”，而不是我们想要的这样：</p>\n<p>%.o: %.c foo.h<br>$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $&lt;</p>\n<p>后缀规则中，如果没有命令，那是毫无意义的。因为他也不会移去内建的隐含规则。</p>\n<p>而要让make知道一些特定的后缀，我们可以使用伪目标”.SUFFIXES”来定义或是删除，如：</p>\n<p>.SUFFIXES: .hack .win</p>\n<p>把后缀.hack和.win加入后缀列表中的末尾。</p>\n<p>.SUFFIXES: # 删除默认的后缀<br>.SUFFIXES: .c .o .h # 定义自己的后缀</p>\n<p>先清楚默认后缀，后定义自己的后缀列表。</p>\n<p>make的参数”-r”或”-no-builtin-rules”也会使用得默认的后缀列表为空。而变量”SUFFIXE”被用来定义默认的后缀列表，你可以用”.SUFFIXES”来改变后缀列表，但请不要改变变量”SUFFIXE”的值。</p>\n<p><strong>七、隐含规则搜索算法</strong><br>比如我们有一个目标叫 T。下面是搜索目标T的规则的算法。请注意，在下面，我们没有提到后缀规则，原因是，所有的后缀规则在Makefile被载入内存时，会被转换成模式规则。如果目标是”archive(member)”的函数库文件模式，那么这个算法会被运行两次，第一次是找目标T，如果没有找到的话，那么进入第二次，第二次会把”member”当作T来搜索。</p>\n<p>1、把T的目录部分分离出来。叫D，而剩余部分叫N。（如：如果T是”src/foo.o”，那么，D就是”src/“，N就是”foo.o”）2、创建所有匹配于T或是N的模式规则列表。3、如果在模式规则列表中有匹配所有文件的模式，如”%”，那么从列表中移除其它的模式。4、移除列表中没有命令的规则。5、对于第一个在列表中的模式规则：<br>1）推导其”茎”S，S应该是T或是N匹配于模式中”%”非空的部分。2）计算依赖文件。把依赖文件中的”%”都替换成”茎”S。如果目标模式中没有包含斜框字符，而把D加在第一个依赖文件的开头。3）测试是否所有的依赖文件都存在或是理当存在。（如果有一个文件被定义成另外一个规则的目标文件，或者是一个显式规则的依赖文件，那么这个文件就叫”理当存在”）4）如果所有的依赖文件存在或是理当存在，或是就没有依赖文件。那么这条规则将被采用，退出该<a href=\"http://lib.csdn.net/base/datastructure\">算法</a>。6、如果经过第5步，没有模式规则被找到，那么就做更进一步的搜索。对于存在于列表中的第一个模式规则：1）如果规则是终止规则，那就忽略它，继续下一条模式规则。2）计算依赖文件。（同第5步）3）测试所有的依赖文件是否存在或是理当存在。4）对于不存在的依赖文件，递归调用这个算法查找他是否可以被隐含规则找到。5）如果所有的依赖文件存在或是理当存在，或是就根本没有依赖文件。那么这条规则被采用，退出该算法。7、如果没有隐含规则可以使用，查看”.DEFAULT”规则，如果有，采用，把”.DEFAULT”的命令给T使用。</p>\n<p>一旦规则被找到，就会执行其相当的命令，而此时，我们的自动化变量的值才会生成。</p>\n<p><strong>使用make更新函数库文件**</strong>———————————**</p>\n<p>函数库文件也就是对Object文件（程序编译的中间文件）的打包文件。在Unix下，一般是由命令”ar”来完成打包工作。</p>\n<p><strong>一、函数库文件的成员</strong></p>\n<p>一个函数库文件由多个文件组成。你可以以如下格式指定函数库文件及其组成：</p>\n<p>archive(member)</p>\n<p>这个不是一个命令，而一个目标和依赖的定义。一般来说，这种用法基本上就是为了”ar”命令来服务的。如：</p>\n<p>foolib(hack.o) : hack.o<br>ar cr foolib hack.o</p>\n<p>如果要指定多个member，那就以空格分开，如：</p>\n<p>foolib(hack.o kludge.o)</p>\n<p>其等价于：</p>\n<p>foolib(hack.o) foolib(kludge.o)</p>\n<p>你还可以使用Shell的文件通配符来定义，如：</p>\n<p>foolib(*.o)</p>\n<p><strong>二、函数库成员的隐含规则</strong></p>\n<p>当 make搜索一个目标的隐含规则时，一个特殊的特性是，如果这个目标是”a(m)”形式的，其会把目标变成”(m)”。于是，如果我们的成员是”%.o” 的模式定义，并且如果我们使用”make foo.a(bar.o)”的形式调用Makefile时，隐含规则会去找”bar.o”的规则，如果没有定义bar.o的规则，那么内建隐含规则生效，make会去找bar.c文件来生成bar.o，如果找得到的话，make执行的命令大致如下：</p>\n<p>cc -c bar.c -o bar.o<br>ar r foo.a bar.o<br>rm -f bar.o</p>\n<p>还有一个变量要注意的是”$%”，这是专属函数库文件的自动化变量，有关其说明请参见”自动化变量”一节。</p>\n<p><strong>三、函数库文件的后缀规则</strong></p>\n<p>你可以使用”后缀规则”和”隐含规则”来生成函数库打包文件，如：</p>\n<p>.c.a:<br>$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o<br>$(AR) r $@ $</em>.o<br>$(RM) $*.o</p>\n<p>其等效于：</p>\n<p>(%.o) : %.c<br>$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt; -o $<em>.o<br>$(AR) r $@ $</em>.o<br>$(RM) $*.o</p>\n<p><strong>四、注意事项</strong></p>\n<p>在进行函数库打包文件生成时，请小心使用make的并行机制（”-j”参数）。如果多个ar命令在同一时间运行在同一个函数库打包文件上，就很有可以损坏这个函数库文件。所以，在make未来的版本中，应该提供一种机制来避免并行操作发生在函数打包文件上。<br>但就目前而言，你还是应该不要尽量不要使用”-j”参数。</p>\n<p><strong>后序**</strong>——**</p>\n<p>终于到写结束语的时候了，以上基本上就是GNU make的Makefile的所有细节了。其它的产商的make基本上也就是这样的，无论什么样的make，都是以文件的依赖性为基础的，其基本是都是遵循一个标准的。这篇文档中80%的技术细节都适用于任何的make，我猜测”函数”那一章的内容可能不是其它make所支持的，而隐含规则方面，我想不同的make会有不同的实现，我没有精力来查看GNU的make和VC的nmake、BCB的make，或是别的UNIX下的make有些什么样的差别，一是时间精力不够，二是因为我基本上都是在Unix下使用make，以前在SCO Unix和IBM的AIX，现在在Linux、Solaris、HP-UX、AIX和Alpha下使用，Linux和Solaris下更多一点。不过，我可以肯定的是，在Unix下的make，无论是哪种平台，几乎都使用了Richard Stallman开发的make和cc/gcc的编译器，而且，基本上都是GNU的make（公司里所有的UNIX机器上都被装上了GNU的东西，所以，使用GNU的程序也就多了一些）。GNU的东西还是很不错的，特别是使用得深了以后，越来越觉得GNU的软件的强大，也越来越觉得GNU的在操作系统中（主要是Unix，甚至Windows）”杀伤力”。</p>\n<p>对于上述所有的make的细节，我们不但可以利用make这个工具来编译我们的程序，还可以利用make来完成其它的工作，因为规则中的命令可以是任何Shell之下的命令，所以，在Unix下，你不一定只是使用程序语言的编译器，你还可以在Makefile中书写其它的命令，如：tar、awk、mail、sed、cvs、compress、ls、rm、yacc、rpm、 ftp……等等，等等，来完成诸如”程序打包”、”程序备份”、”制作程序安装包”、”提交代码”、”使用程序模板”、”合并文件”等等五花八门的功能，文件操作，文件管理，编程开发设计，或是其它一些异想天开的东西。比如，以前在书写银行交易程序时，由于银行的交易程序基本一样，就见到有人书写了一些交易的通用程序模板，在该模板中把一些网络通讯、数据库操作的、业务操作共性的东西写在一个文件中，在这些文件中用些诸如”@@@N、###N”奇怪字串标注一些位置，然后书写交易时，只需按照一种特定的规则书写特定的处理，最后在make时，使用awk和sed，把模板中的”@@@N、###N”等字串替代成特定的程序，形成C文件，然后再编译。这个动作很像数据库的”扩展C”语言（即在C语言中用”EXEC　SQL”的样子执行SQL语句，在用 cc/gcc编译之前，需要使用”扩展C”的翻译程序，如cpre，把其翻译成标准C）。如果<br>你在使用make时有一些更为绝妙的方法，请记得告诉我啊。</p>\n<p>回头看看整篇文档，不觉记起几年前刚刚开始在Unix下做开发的时候，有人问我会不会写Makefile时，我两眼发直，根本不知道在说什么。一开始看到别人在vi中写完程序后输入”!make”时，还以为是vi的功能，后来才知道有一个Makefile在作怪，于是上网查啊查，那时又不愿意看英文，发现就根本没有中文的文档介绍Makefile，只得看别人写的Makefile，自己瞎碰瞎搞才积累了一点知识，但在很多地方完全是知其然不知所以然。后来开始从事UNIX下产品软件的开发，看到一个400人年，近200万行代码的大工程，发现要编译这样一个庞然大物，如果没有Makefile，那会是多么恐怖的一样事啊。于是横下心来，狠命地读了一堆英文文档，才觉得对其掌握了。但发现目前网上对Makefile介绍的文章还是少得那么的可怜，所以想写这样一篇文章，共享给大家，希望能对各位有所帮助。</p>\n<p>现在我终于写完了，看了看文件的创建时间，这篇技术文档也写了两个多月了。发现，自己知道是一回事，要写下来，跟别人讲述又是另外一回事，而且，现在越来越没有时间专研技术细节，所以在写作时，发现在阐述一些细节问题时很难做到严谨和精练，而且对先讲什么后讲什么不是很清楚，所以，还是参考了一些国外站点上的资料和题纲，以及一些技术书籍的语言风格，才得以完成。整篇文档的提纲是基于GNU的 Makefile技术手册的提纲来书写的，并结合了自己的工作经验，以及自己的学习历程。因为从来没有写过这么长，这么细的文档，所以一定会有很多地方存在表达问题，语言歧义或是错误。因些，我迫切地得等待各位给我指证和建议，以及任何的反馈。</p>\n<p>最后，还是利用这个后序，介绍一下自己。我目前从事于所有Unix平台下的软件研发，主要是做分布式计算/网格计算方面的系统产品软件，并且我对于下一代的计算机革命——网格计算非常地感兴趣，对于分布式计算、P2P、Web Service、J2EE技术方向也很感兴趣，同时，对于项目实施、团队管理、项目管理也小有心得，希望同样和我战斗在“技术和管理并重”的阵线上的年轻一代，能够和我多多地交流。我的MSN是：<a href=\"mailto:&#104;&#x61;&#111;&#101;&#108;&#x40;&#104;&#x6f;&#116;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;\">&#104;&#x61;&#111;&#101;&#108;&#x40;&#104;&#x6f;&#116;&#x6d;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a>（常用），QQ是：753640（不常用）。（注：请勿给我MSN的邮箱发信，由于hotmail的垃圾<br>邮件导致我拒收这个邮箱的所有来信）</p>\n<p>我欢迎任何形式的交流，无论是讨论技术还是管理，或是其它海阔天空的东西。除了政治和娱乐新闻我不关心，其它只要积极向上的东西我都欢迎！</p>\n<p>最最后，我还想介绍一下make程序的设计开发者。</p>\n<p>首当其冲的是： Richard Stallman</p>\n<p>开源软件的领袖和先驱，从来没有领过一天工资，从来没有使用过Windows操作系统。对于他的事迹和他的软件以及他的思想，我无需说过多的话，相信大家对这个人并不比我陌生，这是他的主页：<a href=\"http://www.stallman.org/\">http://www.stallman.org/</a> 。<br>第二位是：Roland McGrath<br>个人主页是：<a href=\"http://www.frob.com/~roland/\">http://www.frob.com/~roland/</a> ，下面是他的一些事迹：</p>\n<p>1） 合作编写了并维护GNU make。2） 和Thomas Bushnell一同编写了GNU Hurd。3） 编写并维护着GNU C library。4） 合作编写并维护着部分的GNU Emacs。<br>在此，向这两位开源项目的斗士致以最真切的敬意。</p>\n"},{"title":"About pkg-config","date":"2020-12-31T15:59:00.000Z","abbrlink":13013,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"# About pkg-config\n\nhttps://zh.wikipedia.org/wiki/Pkg-config\n\n","source":"_posts/linux_md/Makefile/pkg-config基础.md","raw":"---\ntitle: About pkg-config\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 个人项目\nabbrlink: 13013\ncover: \n---\n# About pkg-config\n\nhttps://zh.wikipedia.org/wiki/Pkg-config\n\n","slug":"linux_md/Makefile/pkg-config基础","published":1,"updated":"2021-04-08T14:11:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr65002hw9q9awi17cam","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"About-pkg-config\"><a href=\"#About-pkg-config\" class=\"headerlink\" title=\"About pkg-config\"></a>About pkg-config</h1><p><a href=\"https://zh.wikipedia.org/wiki/Pkg-config\">https://zh.wikipedia.org/wiki/Pkg-config</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"About-pkg-config\"><a href=\"#About-pkg-config\" class=\"headerlink\" title=\"About pkg-config\"></a>About pkg-config</h1><p><a href=\"https://zh.wikipedia.org/wiki/Pkg-config\">https://zh.wikipedia.org/wiki/Pkg-config</a></p>\n"},{"abbrlink":2,"_content":"# 《图解编译原理》读书笔记\n\n## 第一章 运行时结构及编译过程\n\n### 1.1 一个简单的C程序\n\n代码如下：\n\n```c\nint fun(int a, int b);\nint m = 10;\nint main()\n{\n  int i = 4;\n  int j = 5;\n  m = fun(i, j);\n  return 0;\n}\n\nint fun(int a, int b)\n{\n  int c = 0;\n  c = a + b;\n  return c;\n}\n```\n\n#### 程序运行之前\n\n执行程序之前，我们需要对程序进行编译。\n\n编译分为以下几个步骤：\n\n| 1. 预处理： 宏定义展开、头文件展开、条件编译、在这里并不会检查语法。 |\n| :----------------------------------------------------------- |\n| 2. 编译： 检查语法，将预处理后的文件编译生成汇编文件         |\n| 3. 汇编： 将汇编文件生成目标文件(二进制文件)                 |\n| 4. 链接： 将目标文件链接为可执行文件                         |\n\n编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况：\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103194803509.png\" alt=\"image-20201103194803509\" style=\"zoom:50%;\" />\n\n通过上图可以得知，在程序没有运行前，也就是说程序没有加载到内存前，可执行程序的内部已经分好了3段信息，分别为代码区(text)，数据区(data)和未初始化数据区(bss) 3个部分。\n\n<!--data和objc又合称为静态区或者全局区。-->\t\n\n程序开始执行前，动态数据区没有数据。只有程序开始执行后，在指令的驱动下，这一区域才会产生数据。压栈和清栈多的工作就是在这一区域完成的。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103204628715.png\" alt=\"image-20201103204628715\" style=\"zoom:50%;\" />\n\n#### 程序的初始化\n\n初始情景是这样的，eip 指向 main 函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp 和 esp 指向的位置是程序加载时内核设置的。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210051065.png\" alt=\"image-20201103210051065\" style=\"zoom:50%;\" />\n\n#### 程序的执行\n\n* 程序开始执行 main 函数第一条指令，eip 自动指向下一条指令。第一条指令的执行，致使 ebp 的地址值被保存在栈中。\n\n<!--保存的目的是本程序执行完毕后，ebp还能返回现在的位置，复原现在的栈。-->\n\n* 随着 ebp 地址值的 压栈，esp 自动向栈顶方向移动，它将永远指向栈顶。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210746239.png\" alt=\"image-20201103210746239\" style=\"zoom:50%;\" />\n\n* 程序继续执行，开始构建 main 函数自己的栈，ebp 原来指向的地址值已经被保存了，它被腾出来了，用来看管 main 函数的栈底，此时它和 esp 是重叠的\n\n* 程序继续执行，eip 指向下一条指令，此次执行的是局部变量 i 的初始化，初始值 4 被存储在栈中，esp 自动向栈顶方向移动。\n* 继续执行下一条指令，局部变量 j 的初始值 5 也被压栈\n* 接下来调用 fun 函数时压栈的数据虽然也保存在 main 函数的栈中， 但它们都是供 fun 函数用的。 可以说 fun 函数的数据， 一半在 fun 函数中， 一半在主调函数中， 下面来 看函数调用时留在 main 函数中的那一半数据。\n  * 先执行传参的指令，此时参数入栈的顺序和代码中传参的书写顺序正好相反，**参数 b 先入栈**，数值是 main 函数中局部变量 j 的数值 5。\n  * 程序继续执行，参数 a 被压入栈中，数值是局部变量 i 的数值 4\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211138499.png\" alt=\"image-20201103211138499\" style=\"zoom:50%;\" />\n\n* 程序继续执行， 此次压入的是 fun 函数返回值， 将来 fun 函数返回之后， 这里的值会传递给 m\n* 还剩最后一步，跳转到 fun 函数去执行。\n  * 一部分是把 fun 函数执行后的返回地址压入栈中，以便 fun 函数执行完毕后能返回到 main 函数中继续执行\n  * 另一部分就是跳转到被调用的函数的第一条指令去执行\n* fun 函数开始执行，第一件事就是保存 ebp 指向的地址值，此时 ebp 指向的是 main 函数的栈底，保存的目 的是在返回时恢复 main 函数栈底的位置，这和前面 main 函数刚开始执行时第一步就保存 ebp 的地址值的目的 是一样的\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211526043.png\" alt=\"image-20201103211526043\" style=\"zoom:50%;\" />\n\n* 执行几个运算指令\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211648452.png\" alt=\"image-20201103211648452\" style=\"zoom:50%;\" />\n\n* 恢复现场以后，把 fun 函数返回值传递给 m\n* 该处理 fun 函数调用时的传参和返回值设置了，这两者已经没有存在的必要了，全部清栈\n* 剩下就是 main 函数的内容了，main 函数执行完毕以后，栈也全部清掉。清栈的方式与 fun 函数执行完后采用的清栈方式一致\n\n#### 运行之后\n\n<!--程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。-->\n\n程序在加载到内存前，**代码区和全局区(data和bss)的大小就是固定的**，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。\n\n| 代码区                  | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| **代码区(TEXT)**        | 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。 |\n| **未初始化数据区(BSS)** | 加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 |\n| **静态数据区(DATA)**    | 加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 |\n| **栈区(stack)**         | 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 |\n| **堆区(heap)**          | 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 |\n\n常见的类型以及存储位置：\n\n| 类型           | 作用域   | 生命周期       | 存储位置                          |\n| -------------- | -------- | -------------- | --------------------------------- |\n| auto变量       | {}内     | 当前函数       | 栈区                              |\n| static局部变量 | {}内     | 整个程序运行期 | 初始化在data段，未初始化在BSS段   |\n| extern变量     | 整个程序 | 整个程序运行期 | 初始化在data段，未初始化在BSS段   |\n| static全局变量 | 当前文件 | 整个程序运行期 | 初始化在data段，未初始化在BSS段   |\n| extern函数     | 整个程序 | 整个程序运行期 | 代码区                            |\n| static函数     | 当前文件 | 整个程序运行期 | 代码区                            |\n| register变量   | {}内     | 当前函数       | 运行时存储在CPU寄存器             |\n| 字符串常量     | 当前文件 | 整个程序运行期 | data段                            |\n| const全局变量  | 当前文件 | 整个程序运行期 | 初始化放在data段，未初始化在BSS段 |\n| const局部变量  | {}内     | 当前函数       | 栈区                              |\n\n#### CPU中的三个寄存器\n\n* eip：eip永远指向代码区将要执行的下一条指令。\n  * 顺序执行：程序执行完一条指令后自动指向下一条执行\n  * 跳转：执行完一条跳转指令后跳转到指定位置\n* ebp：管控栈空间，指向栈底\n* esp：管控栈空间，指向栈顶\n\n<!--栈中数据存储和释放的原则是后进先出-->\n\n### 1.2 更为复杂的C语言运行结构\n\n代码如下：\n\n```C\n#include <stdio.h>\n#include <string.h>\n\nvoid fun1()\n{\n  int m = 10;\n  char num[4];\n  strcpy(num, \"bbbbbbbbbbbbb\\x0F\\x10\\x40\\x00\");\n}\n\nvoid fun2()\n{\n  printf(\"you were attacked!!!\\n\");\n}\n\nint main()\n{\n  fun1();\n  return 0;\n}\n```\n\n<!--栈底地址值被覆盖了，ebp会得到一个乱值，不再指向main函数的栈底-->\n\n在C语言中，栈的方向是从**高地址向低地址**延伸，而**数组中数据在栈中的存储方向**与此正好相反。\n\n字符串拷贝等数组操作是不对数据长度做审核的，如果实际的数据长度超过了栈中预留的空间，就会将栈中其他数据覆盖，这种现象被称为“栈溢出”。栈溢出可能导致一个不可预期的错误，也可能导致一个精心策划的执行流程发生改变。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104213741370.png\" alt=\"image-20201104213741370\" style=\"zoom:50%;\" />\n\n### 1.3 编译过程概述\n\n#### 1.3.1 词法分析\n\n<!--编译的第一阶段是词法分析-->\n\n词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号(token)流。\n\n#### 1.3.2 语法分析\n\n语法分析的作用是从词法分析识别出的符号流中识别出符合C语言语法的语句。\n\n#### 1.3.3 语法书->中间代码->目标代码\n\n中间代码的设计思想： 计算机存在多种CPU硬件平台，要考虑到程序在不同CPU之间的移植性。先转换成通用的、抽象的CPU指令。\n\n语法树是二维结构。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215246865.png\" alt=\"image-20201104215246865\" style=\"zoom:50%;\" />\n\n中间代码是准一维结构。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215312619.png\" alt=\"image-20201104215312619\" style=\"zoom:50%;\" />\n\n选定具体的 CPU、操作系统后， 中间代码就可以转换为目标代码——汇编代码\n\n最后链接器把一个或多个目标文件（库文件本质上也是目标文件）链接成符合选定操作系统指定格式的可 执行文件。\n\n## 第二章 词法分析\n\n### 2.1 总体结构图\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215858679.png\" alt=\"image-20201104215858679\" style=\"zoom: 67%;\" /> ","source":"_posts/cplus_md/C Baisc/《图解编译原理》读书笔记.md","raw":"---\nabbrlink: 2\n---\n# 《图解编译原理》读书笔记\n\n## 第一章 运行时结构及编译过程\n\n### 1.1 一个简单的C程序\n\n代码如下：\n\n```c\nint fun(int a, int b);\nint m = 10;\nint main()\n{\n  int i = 4;\n  int j = 5;\n  m = fun(i, j);\n  return 0;\n}\n\nint fun(int a, int b)\n{\n  int c = 0;\n  c = a + b;\n  return c;\n}\n```\n\n#### 程序运行之前\n\n执行程序之前，我们需要对程序进行编译。\n\n编译分为以下几个步骤：\n\n| 1. 预处理： 宏定义展开、头文件展开、条件编译、在这里并不会检查语法。 |\n| :----------------------------------------------------------- |\n| 2. 编译： 检查语法，将预处理后的文件编译生成汇编文件         |\n| 3. 汇编： 将汇编文件生成目标文件(二进制文件)                 |\n| 4. 链接： 将目标文件链接为可执行文件                         |\n\n编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况：\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103194803509.png\" alt=\"image-20201103194803509\" style=\"zoom:50%;\" />\n\n通过上图可以得知，在程序没有运行前，也就是说程序没有加载到内存前，可执行程序的内部已经分好了3段信息，分别为代码区(text)，数据区(data)和未初始化数据区(bss) 3个部分。\n\n<!--data和objc又合称为静态区或者全局区。-->\t\n\n程序开始执行前，动态数据区没有数据。只有程序开始执行后，在指令的驱动下，这一区域才会产生数据。压栈和清栈多的工作就是在这一区域完成的。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103204628715.png\" alt=\"image-20201103204628715\" style=\"zoom:50%;\" />\n\n#### 程序的初始化\n\n初始情景是这样的，eip 指向 main 函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp 和 esp 指向的位置是程序加载时内核设置的。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210051065.png\" alt=\"image-20201103210051065\" style=\"zoom:50%;\" />\n\n#### 程序的执行\n\n* 程序开始执行 main 函数第一条指令，eip 自动指向下一条指令。第一条指令的执行，致使 ebp 的地址值被保存在栈中。\n\n<!--保存的目的是本程序执行完毕后，ebp还能返回现在的位置，复原现在的栈。-->\n\n* 随着 ebp 地址值的 压栈，esp 自动向栈顶方向移动，它将永远指向栈顶。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210746239.png\" alt=\"image-20201103210746239\" style=\"zoom:50%;\" />\n\n* 程序继续执行，开始构建 main 函数自己的栈，ebp 原来指向的地址值已经被保存了，它被腾出来了，用来看管 main 函数的栈底，此时它和 esp 是重叠的\n\n* 程序继续执行，eip 指向下一条指令，此次执行的是局部变量 i 的初始化，初始值 4 被存储在栈中，esp 自动向栈顶方向移动。\n* 继续执行下一条指令，局部变量 j 的初始值 5 也被压栈\n* 接下来调用 fun 函数时压栈的数据虽然也保存在 main 函数的栈中， 但它们都是供 fun 函数用的。 可以说 fun 函数的数据， 一半在 fun 函数中， 一半在主调函数中， 下面来 看函数调用时留在 main 函数中的那一半数据。\n  * 先执行传参的指令，此时参数入栈的顺序和代码中传参的书写顺序正好相反，**参数 b 先入栈**，数值是 main 函数中局部变量 j 的数值 5。\n  * 程序继续执行，参数 a 被压入栈中，数值是局部变量 i 的数值 4\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211138499.png\" alt=\"image-20201103211138499\" style=\"zoom:50%;\" />\n\n* 程序继续执行， 此次压入的是 fun 函数返回值， 将来 fun 函数返回之后， 这里的值会传递给 m\n* 还剩最后一步，跳转到 fun 函数去执行。\n  * 一部分是把 fun 函数执行后的返回地址压入栈中，以便 fun 函数执行完毕后能返回到 main 函数中继续执行\n  * 另一部分就是跳转到被调用的函数的第一条指令去执行\n* fun 函数开始执行，第一件事就是保存 ebp 指向的地址值，此时 ebp 指向的是 main 函数的栈底，保存的目 的是在返回时恢复 main 函数栈底的位置，这和前面 main 函数刚开始执行时第一步就保存 ebp 的地址值的目的 是一样的\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211526043.png\" alt=\"image-20201103211526043\" style=\"zoom:50%;\" />\n\n* 执行几个运算指令\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211648452.png\" alt=\"image-20201103211648452\" style=\"zoom:50%;\" />\n\n* 恢复现场以后，把 fun 函数返回值传递给 m\n* 该处理 fun 函数调用时的传参和返回值设置了，这两者已经没有存在的必要了，全部清栈\n* 剩下就是 main 函数的内容了，main 函数执行完毕以后，栈也全部清掉。清栈的方式与 fun 函数执行完后采用的清栈方式一致\n\n#### 运行之后\n\n<!--程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。-->\n\n程序在加载到内存前，**代码区和全局区(data和bss)的大小就是固定的**，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。\n\n| 代码区                  | 描述                                                         |\n| ----------------------- | ------------------------------------------------------------ |\n| **代码区(TEXT)**        | 加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。 |\n| **未初始化数据区(BSS)** | 加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。 |\n| **静态数据区(DATA)**    | 加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。 |\n| **栈区(stack)**         | 栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。 |\n| **堆区(heap)**          | 堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。 |\n\n常见的类型以及存储位置：\n\n| 类型           | 作用域   | 生命周期       | 存储位置                          |\n| -------------- | -------- | -------------- | --------------------------------- |\n| auto变量       | {}内     | 当前函数       | 栈区                              |\n| static局部变量 | {}内     | 整个程序运行期 | 初始化在data段，未初始化在BSS段   |\n| extern变量     | 整个程序 | 整个程序运行期 | 初始化在data段，未初始化在BSS段   |\n| static全局变量 | 当前文件 | 整个程序运行期 | 初始化在data段，未初始化在BSS段   |\n| extern函数     | 整个程序 | 整个程序运行期 | 代码区                            |\n| static函数     | 当前文件 | 整个程序运行期 | 代码区                            |\n| register变量   | {}内     | 当前函数       | 运行时存储在CPU寄存器             |\n| 字符串常量     | 当前文件 | 整个程序运行期 | data段                            |\n| const全局变量  | 当前文件 | 整个程序运行期 | 初始化放在data段，未初始化在BSS段 |\n| const局部变量  | {}内     | 当前函数       | 栈区                              |\n\n#### CPU中的三个寄存器\n\n* eip：eip永远指向代码区将要执行的下一条指令。\n  * 顺序执行：程序执行完一条指令后自动指向下一条执行\n  * 跳转：执行完一条跳转指令后跳转到指定位置\n* ebp：管控栈空间，指向栈底\n* esp：管控栈空间，指向栈顶\n\n<!--栈中数据存储和释放的原则是后进先出-->\n\n### 1.2 更为复杂的C语言运行结构\n\n代码如下：\n\n```C\n#include <stdio.h>\n#include <string.h>\n\nvoid fun1()\n{\n  int m = 10;\n  char num[4];\n  strcpy(num, \"bbbbbbbbbbbbb\\x0F\\x10\\x40\\x00\");\n}\n\nvoid fun2()\n{\n  printf(\"you were attacked!!!\\n\");\n}\n\nint main()\n{\n  fun1();\n  return 0;\n}\n```\n\n<!--栈底地址值被覆盖了，ebp会得到一个乱值，不再指向main函数的栈底-->\n\n在C语言中，栈的方向是从**高地址向低地址**延伸，而**数组中数据在栈中的存储方向**与此正好相反。\n\n字符串拷贝等数组操作是不对数据长度做审核的，如果实际的数据长度超过了栈中预留的空间，就会将栈中其他数据覆盖，这种现象被称为“栈溢出”。栈溢出可能导致一个不可预期的错误，也可能导致一个精心策划的执行流程发生改变。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104213741370.png\" alt=\"image-20201104213741370\" style=\"zoom:50%;\" />\n\n### 1.3 编译过程概述\n\n#### 1.3.1 词法分析\n\n<!--编译的第一阶段是词法分析-->\n\n词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号(token)流。\n\n#### 1.3.2 语法分析\n\n语法分析的作用是从词法分析识别出的符号流中识别出符合C语言语法的语句。\n\n#### 1.3.3 语法书->中间代码->目标代码\n\n中间代码的设计思想： 计算机存在多种CPU硬件平台，要考虑到程序在不同CPU之间的移植性。先转换成通用的、抽象的CPU指令。\n\n语法树是二维结构。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215246865.png\" alt=\"image-20201104215246865\" style=\"zoom:50%;\" />\n\n中间代码是准一维结构。\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215312619.png\" alt=\"image-20201104215312619\" style=\"zoom:50%;\" />\n\n选定具体的 CPU、操作系统后， 中间代码就可以转换为目标代码——汇编代码\n\n最后链接器把一个或多个目标文件（库文件本质上也是目标文件）链接成符合选定操作系统指定格式的可 执行文件。\n\n## 第二章 词法分析\n\n### 2.1 总体结构图\n\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215858679.png\" alt=\"image-20201104215858679\" style=\"zoom: 67%;\" /> ","slug":"cplus_md/C Baisc/《图解编译原理》读书笔记","published":1,"date":"2020-11-04T13:59:14.000Z","updated":"2021-04-20T13:07:34.653Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6a003sw9q935tdc1sy","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"《图解编译原理》读书笔记\"><a href=\"#《图解编译原理》读书笔记\" class=\"headerlink\" title=\"《图解编译原理》读书笔记\"></a>《图解编译原理》读书笔记</h1><h2 id=\"第一章-运行时结构及编译过程\"><a href=\"#第一章-运行时结构及编译过程\" class=\"headerlink\" title=\"第一章 运行时结构及编译过程\"></a>第一章 运行时结构及编译过程</h2><h3 id=\"1-1-一个简单的C程序\"><a href=\"#1-1-一个简单的C程序\" class=\"headerlink\" title=\"1.1 一个简单的C程序\"></a>1.1 一个简单的C程序</h3><p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> j = <span class=\"number\">5</span>;</span><br><span class=\"line\">  m = fun(i, j);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"程序运行之前\"><a href=\"#程序运行之前\" class=\"headerlink\" title=\"程序运行之前\"></a>程序运行之前</h4><p>执行程序之前，我们需要对程序进行编译。</p>\n<p>编译分为以下几个步骤：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">1. 预处理： 宏定义展开、头文件展开、条件编译、在这里并不会检查语法。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2. 编译： 检查语法，将预处理后的文件编译生成汇编文件</td>\n</tr>\n<tr>\n<td align=\"left\">3. 汇编： 将汇编文件生成目标文件(二进制文件)</td>\n</tr>\n<tr>\n<td align=\"left\">4. 链接： 将目标文件链接为可执行文件</td>\n</tr>\n</tbody></table>\n<p>编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况：</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103194803509.png\" alt=\"image-20201103194803509\" style=\"zoom:50%;\" />\n\n<p>通过上图可以得知，在程序没有运行前，也就是说程序没有加载到内存前，可执行程序的内部已经分好了3段信息，分别为代码区(text)，数据区(data)和未初始化数据区(bss) 3个部分。</p>\n<!--data和objc又合称为静态区或者全局区。-->    \n\n<p>程序开始执行前，动态数据区没有数据。只有程序开始执行后，在指令的驱动下，这一区域才会产生数据。压栈和清栈多的工作就是在这一区域完成的。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103204628715.png\" alt=\"image-20201103204628715\" style=\"zoom:50%;\" />\n\n<h4 id=\"程序的初始化\"><a href=\"#程序的初始化\" class=\"headerlink\" title=\"程序的初始化\"></a>程序的初始化</h4><p>初始情景是这样的，eip 指向 main 函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp 和 esp 指向的位置是程序加载时内核设置的。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210051065.png\" alt=\"image-20201103210051065\" style=\"zoom:50%;\" />\n\n<h4 id=\"程序的执行\"><a href=\"#程序的执行\" class=\"headerlink\" title=\"程序的执行\"></a>程序的执行</h4><ul>\n<li>程序开始执行 main 函数第一条指令，eip 自动指向下一条指令。第一条指令的执行，致使 ebp 的地址值被保存在栈中。</li>\n</ul>\n<!--保存的目的是本程序执行完毕后，ebp还能返回现在的位置，复原现在的栈。-->\n\n<ul>\n<li>随着 ebp 地址值的 压栈，esp 自动向栈顶方向移动，它将永远指向栈顶。</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210746239.png\" alt=\"image-20201103210746239\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>程序继续执行，开始构建 main 函数自己的栈，ebp 原来指向的地址值已经被保存了，它被腾出来了，用来看管 main 函数的栈底，此时它和 esp 是重叠的</p>\n</li>\n<li><p>程序继续执行，eip 指向下一条指令，此次执行的是局部变量 i 的初始化，初始值 4 被存储在栈中，esp 自动向栈顶方向移动。</p>\n</li>\n<li><p>继续执行下一条指令，局部变量 j 的初始值 5 也被压栈</p>\n</li>\n<li><p>接下来调用 fun 函数时压栈的数据虽然也保存在 main 函数的栈中， 但它们都是供 fun 函数用的。 可以说 fun 函数的数据， 一半在 fun 函数中， 一半在主调函数中， 下面来 看函数调用时留在 main 函数中的那一半数据。</p>\n<ul>\n<li>先执行传参的指令，此时参数入栈的顺序和代码中传参的书写顺序正好相反，<strong>参数 b 先入栈</strong>，数值是 main 函数中局部变量 j 的数值 5。</li>\n<li>程序继续执行，参数 a 被压入栈中，数值是局部变量 i 的数值 4</li>\n</ul>\n</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211138499.png\" alt=\"image-20201103211138499\" style=\"zoom:50%;\" />\n\n<ul>\n<li>程序继续执行， 此次压入的是 fun 函数返回值， 将来 fun 函数返回之后， 这里的值会传递给 m</li>\n<li>还剩最后一步，跳转到 fun 函数去执行。<ul>\n<li>一部分是把 fun 函数执行后的返回地址压入栈中，以便 fun 函数执行完毕后能返回到 main 函数中继续执行</li>\n<li>另一部分就是跳转到被调用的函数的第一条指令去执行</li>\n</ul>\n</li>\n<li>fun 函数开始执行，第一件事就是保存 ebp 指向的地址值，此时 ebp 指向的是 main 函数的栈底，保存的目 的是在返回时恢复 main 函数栈底的位置，这和前面 main 函数刚开始执行时第一步就保存 ebp 的地址值的目的 是一样的</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211526043.png\" alt=\"image-20201103211526043\" style=\"zoom:50%;\" />\n\n<ul>\n<li>执行几个运算指令</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211648452.png\" alt=\"image-20201103211648452\" style=\"zoom:50%;\" />\n\n<ul>\n<li>恢复现场以后，把 fun 函数返回值传递给 m</li>\n<li>该处理 fun 函数调用时的传参和返回值设置了，这两者已经没有存在的必要了，全部清栈</li>\n<li>剩下就是 main 函数的内容了，main 函数执行完毕以后，栈也全部清掉。清栈的方式与 fun 函数执行完后采用的清栈方式一致</li>\n</ul>\n<h4 id=\"运行之后\"><a href=\"#运行之后\" class=\"headerlink\" title=\"运行之后\"></a>运行之后</h4><!--程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。-->\n\n<p>程序在加载到内存前，<strong>代码区和全局区(data和bss)的大小就是固定的</strong>，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。</p>\n<table>\n<thead>\n<tr>\n<th>代码区</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>代码区(TEXT)</strong></td>\n<td>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。</td>\n</tr>\n<tr>\n<td><strong>未初始化数据区(BSS)</strong></td>\n<td>加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</td>\n</tr>\n<tr>\n<td><strong>静态数据区(DATA)</strong></td>\n<td>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</td>\n</tr>\n<tr>\n<td><strong>栈区(stack)</strong></td>\n<td>栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。</td>\n</tr>\n<tr>\n<td><strong>堆区(heap)</strong></td>\n<td>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</td>\n</tr>\n</tbody></table>\n<p>常见的类型以及存储位置：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>作用域</th>\n<th>生命周期</th>\n<th>存储位置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>auto变量</td>\n<td>{}内</td>\n<td>当前函数</td>\n<td>栈区</td>\n</tr>\n<tr>\n<td>static局部变量</td>\n<td>{}内</td>\n<td>整个程序运行期</td>\n<td>初始化在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>extern变量</td>\n<td>整个程序</td>\n<td>整个程序运行期</td>\n<td>初始化在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>static全局变量</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>初始化在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>extern函数</td>\n<td>整个程序</td>\n<td>整个程序运行期</td>\n<td>代码区</td>\n</tr>\n<tr>\n<td>static函数</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>代码区</td>\n</tr>\n<tr>\n<td>register变量</td>\n<td>{}内</td>\n<td>当前函数</td>\n<td>运行时存储在CPU寄存器</td>\n</tr>\n<tr>\n<td>字符串常量</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>data段</td>\n</tr>\n<tr>\n<td>const全局变量</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>初始化放在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>const局部变量</td>\n<td>{}内</td>\n<td>当前函数</td>\n<td>栈区</td>\n</tr>\n</tbody></table>\n<h4 id=\"CPU中的三个寄存器\"><a href=\"#CPU中的三个寄存器\" class=\"headerlink\" title=\"CPU中的三个寄存器\"></a>CPU中的三个寄存器</h4><ul>\n<li>eip：eip永远指向代码区将要执行的下一条指令。<ul>\n<li>顺序执行：程序执行完一条指令后自动指向下一条执行</li>\n<li>跳转：执行完一条跳转指令后跳转到指定位置</li>\n</ul>\n</li>\n<li>ebp：管控栈空间，指向栈底</li>\n<li>esp：管控栈空间，指向栈顶</li>\n</ul>\n<!--栈中数据存储和释放的原则是后进先出-->\n\n<h3 id=\"1-2-更为复杂的C语言运行结构\"><a href=\"#1-2-更为复杂的C语言运行结构\" class=\"headerlink\" title=\"1.2 更为复杂的C语言运行结构\"></a>1.2 更为复杂的C语言运行结构</h3><p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> m = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> num[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(num, <span class=\"string\">&quot;bbbbbbbbbbbbb\\x0F\\x10\\x40\\x00&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;you were attacked!!!\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  fun1();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<!--栈底地址值被覆盖了，ebp会得到一个乱值，不再指向main函数的栈底-->\n\n<p>在C语言中，栈的方向是从<strong>高地址向低地址</strong>延伸，而<strong>数组中数据在栈中的存储方向</strong>与此正好相反。</p>\n<p>字符串拷贝等数组操作是不对数据长度做审核的，如果实际的数据长度超过了栈中预留的空间，就会将栈中其他数据覆盖，这种现象被称为“栈溢出”。栈溢出可能导致一个不可预期的错误，也可能导致一个精心策划的执行流程发生改变。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104213741370.png\" alt=\"image-20201104213741370\" style=\"zoom:50%;\" />\n\n<h3 id=\"1-3-编译过程概述\"><a href=\"#1-3-编译过程概述\" class=\"headerlink\" title=\"1.3 编译过程概述\"></a>1.3 编译过程概述</h3><h4 id=\"1-3-1-词法分析\"><a href=\"#1-3-1-词法分析\" class=\"headerlink\" title=\"1.3.1 词法分析\"></a>1.3.1 词法分析</h4><!--编译的第一阶段是词法分析-->\n\n<p>词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号(token)流。</p>\n<h4 id=\"1-3-2-语法分析\"><a href=\"#1-3-2-语法分析\" class=\"headerlink\" title=\"1.3.2 语法分析\"></a>1.3.2 语法分析</h4><p>语法分析的作用是从词法分析识别出的符号流中识别出符合C语言语法的语句。</p>\n<h4 id=\"1-3-3-语法书-gt-中间代码-gt-目标代码\"><a href=\"#1-3-3-语法书-gt-中间代码-gt-目标代码\" class=\"headerlink\" title=\"1.3.3 语法书-&gt;中间代码-&gt;目标代码\"></a>1.3.3 语法书-&gt;中间代码-&gt;目标代码</h4><p>中间代码的设计思想： 计算机存在多种CPU硬件平台，要考虑到程序在不同CPU之间的移植性。先转换成通用的、抽象的CPU指令。</p>\n<p>语法树是二维结构。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215246865.png\" alt=\"image-20201104215246865\" style=\"zoom:50%;\" />\n\n<p>中间代码是准一维结构。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215312619.png\" alt=\"image-20201104215312619\" style=\"zoom:50%;\" />\n\n<p>选定具体的 CPU、操作系统后， 中间代码就可以转换为目标代码——汇编代码</p>\n<p>最后链接器把一个或多个目标文件（库文件本质上也是目标文件）链接成符合选定操作系统指定格式的可 执行文件。</p>\n<h2 id=\"第二章-词法分析\"><a href=\"#第二章-词法分析\" class=\"headerlink\" title=\"第二章 词法分析\"></a>第二章 词法分析</h2><h3 id=\"2-1-总体结构图\"><a href=\"#2-1-总体结构图\" class=\"headerlink\" title=\"2.1 总体结构图\"></a>2.1 总体结构图</h3><img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215858679.png\" alt=\"image-20201104215858679\" style=\"zoom: 67%;\" /> ","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"《图解编译原理》读书笔记\"><a href=\"#《图解编译原理》读书笔记\" class=\"headerlink\" title=\"《图解编译原理》读书笔记\"></a>《图解编译原理》读书笔记</h1><h2 id=\"第一章-运行时结构及编译过程\"><a href=\"#第一章-运行时结构及编译过程\" class=\"headerlink\" title=\"第一章 运行时结构及编译过程\"></a>第一章 运行时结构及编译过程</h2><h3 id=\"1-1-一个简单的C程序\"><a href=\"#1-1-一个简单的C程序\" class=\"headerlink\" title=\"1.1 一个简单的C程序\"></a>1.1 一个简单的C程序</h3><p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> j = <span class=\"number\">5</span>;</span><br><span class=\"line\">  m = fun(i, j);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> c = <span class=\"number\">0</span>;</span><br><span class=\"line\">  c = a + b;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"程序运行之前\"><a href=\"#程序运行之前\" class=\"headerlink\" title=\"程序运行之前\"></a>程序运行之前</h4><p>执行程序之前，我们需要对程序进行编译。</p>\n<p>编译分为以下几个步骤：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">1. 预处理： 宏定义展开、头文件展开、条件编译、在这里并不会检查语法。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">2. 编译： 检查语法，将预处理后的文件编译生成汇编文件</td>\n</tr>\n<tr>\n<td align=\"left\">3. 汇编： 将汇编文件生成目标文件(二进制文件)</td>\n</tr>\n<tr>\n<td align=\"left\">4. 链接： 将目标文件链接为可执行文件</td>\n</tr>\n</tbody></table>\n<p>编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况：</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103194803509.png\" alt=\"image-20201103194803509\" style=\"zoom:50%;\" />\n\n<p>通过上图可以得知，在程序没有运行前，也就是说程序没有加载到内存前，可执行程序的内部已经分好了3段信息，分别为代码区(text)，数据区(data)和未初始化数据区(bss) 3个部分。</p>\n<!--data和objc又合称为静态区或者全局区。-->    \n\n<p>程序开始执行前，动态数据区没有数据。只有程序开始执行后，在指令的驱动下，这一区域才会产生数据。压栈和清栈多的工作就是在这一区域完成的。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103204628715.png\" alt=\"image-20201103204628715\" style=\"zoom:50%;\" />\n\n<h4 id=\"程序的初始化\"><a href=\"#程序的初始化\" class=\"headerlink\" title=\"程序的初始化\"></a>程序的初始化</h4><p>初始情景是这样的，eip 指向 main 函数的第一条指令，此时程序还没有运行，栈空间里还没有数据，ebp 和 esp 指向的位置是程序加载时内核设置的。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210051065.png\" alt=\"image-20201103210051065\" style=\"zoom:50%;\" />\n\n<h4 id=\"程序的执行\"><a href=\"#程序的执行\" class=\"headerlink\" title=\"程序的执行\"></a>程序的执行</h4><ul>\n<li>程序开始执行 main 函数第一条指令，eip 自动指向下一条指令。第一条指令的执行，致使 ebp 的地址值被保存在栈中。</li>\n</ul>\n<!--保存的目的是本程序执行完毕后，ebp还能返回现在的位置，复原现在的栈。-->\n\n<ul>\n<li>随着 ebp 地址值的 压栈，esp 自动向栈顶方向移动，它将永远指向栈顶。</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103210746239.png\" alt=\"image-20201103210746239\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>程序继续执行，开始构建 main 函数自己的栈，ebp 原来指向的地址值已经被保存了，它被腾出来了，用来看管 main 函数的栈底，此时它和 esp 是重叠的</p>\n</li>\n<li><p>程序继续执行，eip 指向下一条指令，此次执行的是局部变量 i 的初始化，初始值 4 被存储在栈中，esp 自动向栈顶方向移动。</p>\n</li>\n<li><p>继续执行下一条指令，局部变量 j 的初始值 5 也被压栈</p>\n</li>\n<li><p>接下来调用 fun 函数时压栈的数据虽然也保存在 main 函数的栈中， 但它们都是供 fun 函数用的。 可以说 fun 函数的数据， 一半在 fun 函数中， 一半在主调函数中， 下面来 看函数调用时留在 main 函数中的那一半数据。</p>\n<ul>\n<li>先执行传参的指令，此时参数入栈的顺序和代码中传参的书写顺序正好相反，<strong>参数 b 先入栈</strong>，数值是 main 函数中局部变量 j 的数值 5。</li>\n<li>程序继续执行，参数 a 被压入栈中，数值是局部变量 i 的数值 4</li>\n</ul>\n</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211138499.png\" alt=\"image-20201103211138499\" style=\"zoom:50%;\" />\n\n<ul>\n<li>程序继续执行， 此次压入的是 fun 函数返回值， 将来 fun 函数返回之后， 这里的值会传递给 m</li>\n<li>还剩最后一步，跳转到 fun 函数去执行。<ul>\n<li>一部分是把 fun 函数执行后的返回地址压入栈中，以便 fun 函数执行完毕后能返回到 main 函数中继续执行</li>\n<li>另一部分就是跳转到被调用的函数的第一条指令去执行</li>\n</ul>\n</li>\n<li>fun 函数开始执行，第一件事就是保存 ebp 指向的地址值，此时 ebp 指向的是 main 函数的栈底，保存的目 的是在返回时恢复 main 函数栈底的位置，这和前面 main 函数刚开始执行时第一步就保存 ebp 的地址值的目的 是一样的</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211526043.png\" alt=\"image-20201103211526043\" style=\"zoom:50%;\" />\n\n<ul>\n<li>执行几个运算指令</li>\n</ul>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201103211648452.png\" alt=\"image-20201103211648452\" style=\"zoom:50%;\" />\n\n<ul>\n<li>恢复现场以后，把 fun 函数返回值传递给 m</li>\n<li>该处理 fun 函数调用时的传参和返回值设置了，这两者已经没有存在的必要了，全部清栈</li>\n<li>剩下就是 main 函数的内容了，main 函数执行完毕以后，栈也全部清掉。清栈的方式与 fun 函数执行完后采用的清栈方式一致</li>\n</ul>\n<h4 id=\"运行之后\"><a href=\"#运行之后\" class=\"headerlink\" title=\"运行之后\"></a>运行之后</h4><!--程序执行的本质就是代码区的指令不断执行，驱使动态数据区和静态数据区产生数据变化。-->\n\n<p>程序在加载到内存前，<strong>代码区和全局区(data和bss)的大小就是固定的</strong>，程序运行期间不能改变。然后，运行可执行程序，操作系统把物理硬盘程序load(加载)到内存，除了根据可执行程序的信息分出代码区（text）、数据区（data）和未初始化数据区（bss）之外，还额外增加了栈区、堆区。</p>\n<table>\n<thead>\n<tr>\n<th>代码区</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>代码区(TEXT)</strong></td>\n<td>加载的是可执行文件代码段，所有的可执行代码都加载到代码区，这块内存是不可以在运行期间修改的。</td>\n</tr>\n<tr>\n<td><strong>未初始化数据区(BSS)</strong></td>\n<td>加载的是可执行文件BSS段，位置可以分开亦可以紧靠数据段，存储于数据段的数据（全局未初始化，静态未初始化数据）的生存周期为整个程序运行过程。</td>\n</tr>\n<tr>\n<td><strong>静态数据区(DATA)</strong></td>\n<td>加载的是可执行文件数据段，存储于数据段（全局初始化，静态初始化数据，文字常量(只读)）的数据的生存周期为整个程序运行过程。</td>\n</tr>\n<tr>\n<td><strong>栈区(stack)</strong></td>\n<td>栈是一种先进后出的内存结构，由编译器自动分配释放，存放函数的参数值、返回值、局部变量等。在程序运行过程中实时加载和释放，因此，局部变量的生存周期为申请到释放该段栈空间。</td>\n</tr>\n<tr>\n<td><strong>堆区(heap)</strong></td>\n<td>堆是一个大容器，它的容量要远远大于栈，但没有栈那样先进后出的顺序。用于动态内存分配。堆在内存中位于BSS区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</td>\n</tr>\n</tbody></table>\n<p>常见的类型以及存储位置：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>作用域</th>\n<th>生命周期</th>\n<th>存储位置</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>auto变量</td>\n<td>{}内</td>\n<td>当前函数</td>\n<td>栈区</td>\n</tr>\n<tr>\n<td>static局部变量</td>\n<td>{}内</td>\n<td>整个程序运行期</td>\n<td>初始化在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>extern变量</td>\n<td>整个程序</td>\n<td>整个程序运行期</td>\n<td>初始化在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>static全局变量</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>初始化在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>extern函数</td>\n<td>整个程序</td>\n<td>整个程序运行期</td>\n<td>代码区</td>\n</tr>\n<tr>\n<td>static函数</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>代码区</td>\n</tr>\n<tr>\n<td>register变量</td>\n<td>{}内</td>\n<td>当前函数</td>\n<td>运行时存储在CPU寄存器</td>\n</tr>\n<tr>\n<td>字符串常量</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>data段</td>\n</tr>\n<tr>\n<td>const全局变量</td>\n<td>当前文件</td>\n<td>整个程序运行期</td>\n<td>初始化放在data段，未初始化在BSS段</td>\n</tr>\n<tr>\n<td>const局部变量</td>\n<td>{}内</td>\n<td>当前函数</td>\n<td>栈区</td>\n</tr>\n</tbody></table>\n<h4 id=\"CPU中的三个寄存器\"><a href=\"#CPU中的三个寄存器\" class=\"headerlink\" title=\"CPU中的三个寄存器\"></a>CPU中的三个寄存器</h4><ul>\n<li>eip：eip永远指向代码区将要执行的下一条指令。<ul>\n<li>顺序执行：程序执行完一条指令后自动指向下一条执行</li>\n<li>跳转：执行完一条跳转指令后跳转到指定位置</li>\n</ul>\n</li>\n<li>ebp：管控栈空间，指向栈底</li>\n<li>esp：管控栈空间，指向栈顶</li>\n</ul>\n<!--栈中数据存储和释放的原则是后进先出-->\n\n<h3 id=\"1-2-更为复杂的C语言运行结构\"><a href=\"#1-2-更为复杂的C语言运行结构\" class=\"headerlink\" title=\"1.2 更为复杂的C语言运行结构\"></a>1.2 更为复杂的C语言运行结构</h3><p>代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun1</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> m = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> num[<span class=\"number\">4</span>];</span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(num, <span class=\"string\">&quot;bbbbbbbbbbbbb\\x0F\\x10\\x40\\x00&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;you were attacked!!!\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  fun1();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<!--栈底地址值被覆盖了，ebp会得到一个乱值，不再指向main函数的栈底-->\n\n<p>在C语言中，栈的方向是从<strong>高地址向低地址</strong>延伸，而<strong>数组中数据在栈中的存储方向</strong>与此正好相反。</p>\n<p>字符串拷贝等数组操作是不对数据长度做审核的，如果实际的数据长度超过了栈中预留的空间，就会将栈中其他数据覆盖，这种现象被称为“栈溢出”。栈溢出可能导致一个不可预期的错误，也可能导致一个精心策划的执行流程发生改变。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104213741370.png\" alt=\"image-20201104213741370\" style=\"zoom:50%;\" />\n\n<h3 id=\"1-3-编译过程概述\"><a href=\"#1-3-编译过程概述\" class=\"headerlink\" title=\"1.3 编译过程概述\"></a>1.3 编译过程概述</h3><h4 id=\"1-3-1-词法分析\"><a href=\"#1-3-1-词法分析\" class=\"headerlink\" title=\"1.3.1 词法分析\"></a>1.3.1 词法分析</h4><!--编译的第一阶段是词法分析-->\n\n<p>词法分析的作用是从连续的字符中识别出标识符、关键字、数字、运算符并存储为符号(token)流。</p>\n<h4 id=\"1-3-2-语法分析\"><a href=\"#1-3-2-语法分析\" class=\"headerlink\" title=\"1.3.2 语法分析\"></a>1.3.2 语法分析</h4><p>语法分析的作用是从词法分析识别出的符号流中识别出符合C语言语法的语句。</p>\n<h4 id=\"1-3-3-语法书-gt-中间代码-gt-目标代码\"><a href=\"#1-3-3-语法书-gt-中间代码-gt-目标代码\" class=\"headerlink\" title=\"1.3.3 语法书-&gt;中间代码-&gt;目标代码\"></a>1.3.3 语法书-&gt;中间代码-&gt;目标代码</h4><p>中间代码的设计思想： 计算机存在多种CPU硬件平台，要考虑到程序在不同CPU之间的移植性。先转换成通用的、抽象的CPU指令。</p>\n<p>语法树是二维结构。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215246865.png\" alt=\"image-20201104215246865\" style=\"zoom:50%;\" />\n\n<p>中间代码是准一维结构。</p>\n<img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215312619.png\" alt=\"image-20201104215312619\" style=\"zoom:50%;\" />\n\n<p>选定具体的 CPU、操作系统后， 中间代码就可以转换为目标代码——汇编代码</p>\n<p>最后链接器把一个或多个目标文件（库文件本质上也是目标文件）链接成符合选定操作系统指定格式的可 执行文件。</p>\n<h2 id=\"第二章-词法分析\"><a href=\"#第二章-词法分析\" class=\"headerlink\" title=\"第二章 词法分析\"></a>第二章 词法分析</h2><h3 id=\"2-1-总体结构图\"><a href=\"#2-1-总体结构图\" class=\"headerlink\" title=\"2.1 总体结构图\"></a>2.1 总体结构图</h3><img src=\"/Users/Evan/Documents/C_Study/《图解编译原理》读书笔记.assets/image-20201104215858679.png\" alt=\"image-20201104215858679\" style=\"zoom: 67%;\" /> "},{"title":"C语言宏的特殊用法和几个坑","date":"2020-12-31T15:59:00.000Z","abbrlink":13000,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"\n# C语言宏的特殊用法和几个坑\n\n总结一下C语言中宏的一些特殊用法和几个容易踩的坑。由于本文主要参考GCC文档，某些细节（如宏参数中的空格是否处理之类）在别的编译器可能有细微差别，请参考相应文档。\n\n## 宏基础\n\n宏仅仅是在C预处理阶段的一种文本替换工具，编译完之后对二进制代码不可见。基本用法如下：\n\n### 1. 标示符别名\n\n```c\n#define BUFFER_SIZE 1024\n```\n\n预处理阶段，`foo = (char *) malloc (BUFFER_SIZE);`会被替换成`foo = (char *) malloc (1024);`\n\n宏体换行需要在行末加反斜杠\\\n\n```c\n#define NUMBERS 1, \\\n                2, \\\n                3\n```\n\n\n\n预处理阶段`int x[] = { NUMBERS };`会被扩展成`int x[] = { 1, 2, 3 };`\n\n### 2. 宏函数\n\n宏名之后带括号的宏被认为是宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。\n\n```c\n#define min(X, Y)  ((X) < (Y) ? (X) : (Y))\n```\n\ny = min(1, 2);`会被扩展成`y = ((1) < (2) ? (1) : (2));\n\n------\n\n## 宏特殊用法\n\n### 1. 字符串化(Stringification)\n\n在宏体中，如果宏参数前加个`#`，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：\n\n```c\n#define WARN_IF(EXP) \\\n     do { if (EXP) \\\n             fprintf (stderr, \"Warning: \" #EXP \"\\n\"); } \\\n     while (0)\n```\n\n`WARN_IF (x == 0);`会被扩展成：\n\n```c\ndo { if (x == 0)\n    fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); }\nwhile (0);\n```\n\n这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中\n\n### 2. 连接(Concatenation)\n\n在宏体中，如果宏体所在标示符中有`##`，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：\n\n```c\n#define COMMAND(NAME)  { #NAME, NAME ## _command }\n\nstruct command\n{\n    char *name;\n    void (*function) (void);\n};\n```\n\n在宏扩展的时候\n\n```c\nstruct command commands[] =\n{\n    COMMAND (quit),\n    COMMAND (help),\n    ...\n};\n```\n\n会被扩展成：\n\n```c\nstruct command commands[] =\n{\n    { \"quit\", quit_command },\n    { \"help\", help_command },\n    ...\n};\n```\n\n这样就节省了大量时间，提高效率。\n\n------\n\n## 几个坑\n\n### 1. 语法问题\n\n由于是纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号神马的预处理器是不管的。这里要格外小心，由此可能引出各种奇葩的问题，一下还很难找到根源。\n\n### 2. 算符优先级问题\n\n不仅宏体是纯文本替换，宏参数也是纯文本替换。有以下一段简单的宏，实现乘法：\n\n```c\n#define MULTIPLY(x, y) x * y\n```\n\n`MULTIPLY(1, 2)`没问题，会正常展开成`1 * 2`。有问题的是这种表达式`MULTIPLY(1+2, 3)`，展开后成了`1+2 * 3`，显然优先级错了。\n\n在宏体中，给引用的参数加个括号就能避免这问题。\n\n```c\n#define MULTIPLY(x, y) (x) * (y)\n```\n\n`MULTIPLY(1+2, 3)`就会被展开成`(1+2) * (3)`，优先级正常了。\n\n其实这个问题和下面要说到的某些问题都属于由于纯文本替换而导致的语义破坏问题，要格外小心。\n\n### 3. 分号吞噬问题\n\n有如下宏定义：\n\n```c\n#define SKIP_SPACES(p, limit)  \\\n     { char *lim = (limit);         \\\n       while (p < lim) {            \\\n         if (*p++ != ' ') {         \\\n           p--; break; }}}\n```\n\n假设有如下一段代码：\n\n```c\nif (*p != 0)\n   SKIP_SPACES (p, lim);\nelse ...\n```\n\n一编译，GCC报`error: ‘else’ without a previous ‘if’`。原来这个看似是一个函数的宏被展开后是一段大括号括起来的代码块，加上分号之后这个if逻辑块就结束了，所以编译器发现这个else没有对应的if。\n\n这个问题一般用`do ... while(0)`的形式来解决：\n\n```c\n#define SKIP_SPACES(p, limit)     \\\n     do { char *lim = (limit);         \\\n          while (p < lim) {            \\\n            if (*p++ != ' ') {         \\\n              p--; break; }}}          \\\n     while (0)\n```\n\n展开后就成了\n\n```c\nif (*p != 0)\n    do ... while(0);\nelse ...\n```\n\n这样就消除了分号吞噬问题。\n\n这个技巧在Linux内核源码里很常见，比如这个置位宏`#define SET_REG_BIT(reg, bit) do { (reg |= (1 << (bit))); } while (0)`(位于arch/mips/include/asm/mach-pnx833x/gpio.h)\n\n### 4. 宏参数重复调用\n\n有如下宏定义：\n\n```c\n#define min(X, Y)  ((X) < (Y) ? (X) : (Y))\n```\n\n当有如下调用时`next = min (x + y, foo (z));`，宏体被展开成`next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));`，可以看到，`foo(z)`被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。\n\n所以，尽量不要在宏参数中传入函数调用。\n\n### 5. 对自身的递归引用\n\n有如下宏定义：\n\n```c\n#define foo (4 + foo)\n```\n\n按前面的理解，`(4 + foo)`会展开成`(4 + (4 + foo))`，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是***只展开一次***。也就是说，`foo`只会展开成`(4 + foo)`，而展开之后`foo`的含义就要根据上下文来确定了。\n\n对于以下的交叉引用，宏体也只会展开一次。\n\n```c\n#define x (4 + y)\n#define y (2 * x)\n```\n\n`x`展开成`(4 + y) -> (4 + (2 * x))`，`y`展开成`(2 * x) -> (2 * (4 + y))`。\n\n**注意，这是极不推荐的写法，程序可读性极差。**\n\n### 6. 宏参数预处理\n\n宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有`#`或`##`。\n\n有如下宏定义：\n\n```c\n#define AFTERX(x) X_ ## x\n#define XAFTERX(x) AFTERX(x)\n#define TABLESIZE 1024\n#define BUFSIZE TABLESIZE\n```\n\n- `AFTERX(BUFSIZE)`会被展开成`X_BUFSIZE`。因为宏体中含有`##`，宏参数直接代入宏体。\n- `XAFTERX(BUFSIZE)`会被展开成`X_1024`。因为`XAFTERX(x)`的宏体是`AFTERX(x)`，并没有`#`或`##`，所以`BUFSIZE`在代入前会被完全展开成`1024`，然后才代入宏体，变成`X_1024`。\n\n-EOF-\n\n------\n\n参考资料：\n\nhttp://gcc.gnu.org/onlinedocs/cpp/Macros.html","source":"_posts/cplus_md/C Baisc/C语言宏的特殊用法和几个坑.md","raw":"---\ntitle: C语言宏的特殊用法和几个坑\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 博客搭建\nabbrlink: 13000\ncover: \n---\n\n# C语言宏的特殊用法和几个坑\n\n总结一下C语言中宏的一些特殊用法和几个容易踩的坑。由于本文主要参考GCC文档，某些细节（如宏参数中的空格是否处理之类）在别的编译器可能有细微差别，请参考相应文档。\n\n## 宏基础\n\n宏仅仅是在C预处理阶段的一种文本替换工具，编译完之后对二进制代码不可见。基本用法如下：\n\n### 1. 标示符别名\n\n```c\n#define BUFFER_SIZE 1024\n```\n\n预处理阶段，`foo = (char *) malloc (BUFFER_SIZE);`会被替换成`foo = (char *) malloc (1024);`\n\n宏体换行需要在行末加反斜杠\\\n\n```c\n#define NUMBERS 1, \\\n                2, \\\n                3\n```\n\n\n\n预处理阶段`int x[] = { NUMBERS };`会被扩展成`int x[] = { 1, 2, 3 };`\n\n### 2. 宏函数\n\n宏名之后带括号的宏被认为是宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。\n\n```c\n#define min(X, Y)  ((X) < (Y) ? (X) : (Y))\n```\n\ny = min(1, 2);`会被扩展成`y = ((1) < (2) ? (1) : (2));\n\n------\n\n## 宏特殊用法\n\n### 1. 字符串化(Stringification)\n\n在宏体中，如果宏参数前加个`#`，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：\n\n```c\n#define WARN_IF(EXP) \\\n     do { if (EXP) \\\n             fprintf (stderr, \"Warning: \" #EXP \"\\n\"); } \\\n     while (0)\n```\n\n`WARN_IF (x == 0);`会被扩展成：\n\n```c\ndo { if (x == 0)\n    fprintf (stderr, \"Warning: \" \"x == 0\" \"\\n\"); }\nwhile (0);\n```\n\n这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中\n\n### 2. 连接(Concatenation)\n\n在宏体中，如果宏体所在标示符中有`##`，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：\n\n```c\n#define COMMAND(NAME)  { #NAME, NAME ## _command }\n\nstruct command\n{\n    char *name;\n    void (*function) (void);\n};\n```\n\n在宏扩展的时候\n\n```c\nstruct command commands[] =\n{\n    COMMAND (quit),\n    COMMAND (help),\n    ...\n};\n```\n\n会被扩展成：\n\n```c\nstruct command commands[] =\n{\n    { \"quit\", quit_command },\n    { \"help\", help_command },\n    ...\n};\n```\n\n这样就节省了大量时间，提高效率。\n\n------\n\n## 几个坑\n\n### 1. 语法问题\n\n由于是纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号神马的预处理器是不管的。这里要格外小心，由此可能引出各种奇葩的问题，一下还很难找到根源。\n\n### 2. 算符优先级问题\n\n不仅宏体是纯文本替换，宏参数也是纯文本替换。有以下一段简单的宏，实现乘法：\n\n```c\n#define MULTIPLY(x, y) x * y\n```\n\n`MULTIPLY(1, 2)`没问题，会正常展开成`1 * 2`。有问题的是这种表达式`MULTIPLY(1+2, 3)`，展开后成了`1+2 * 3`，显然优先级错了。\n\n在宏体中，给引用的参数加个括号就能避免这问题。\n\n```c\n#define MULTIPLY(x, y) (x) * (y)\n```\n\n`MULTIPLY(1+2, 3)`就会被展开成`(1+2) * (3)`，优先级正常了。\n\n其实这个问题和下面要说到的某些问题都属于由于纯文本替换而导致的语义破坏问题，要格外小心。\n\n### 3. 分号吞噬问题\n\n有如下宏定义：\n\n```c\n#define SKIP_SPACES(p, limit)  \\\n     { char *lim = (limit);         \\\n       while (p < lim) {            \\\n         if (*p++ != ' ') {         \\\n           p--; break; }}}\n```\n\n假设有如下一段代码：\n\n```c\nif (*p != 0)\n   SKIP_SPACES (p, lim);\nelse ...\n```\n\n一编译，GCC报`error: ‘else’ without a previous ‘if’`。原来这个看似是一个函数的宏被展开后是一段大括号括起来的代码块，加上分号之后这个if逻辑块就结束了，所以编译器发现这个else没有对应的if。\n\n这个问题一般用`do ... while(0)`的形式来解决：\n\n```c\n#define SKIP_SPACES(p, limit)     \\\n     do { char *lim = (limit);         \\\n          while (p < lim) {            \\\n            if (*p++ != ' ') {         \\\n              p--; break; }}}          \\\n     while (0)\n```\n\n展开后就成了\n\n```c\nif (*p != 0)\n    do ... while(0);\nelse ...\n```\n\n这样就消除了分号吞噬问题。\n\n这个技巧在Linux内核源码里很常见，比如这个置位宏`#define SET_REG_BIT(reg, bit) do { (reg |= (1 << (bit))); } while (0)`(位于arch/mips/include/asm/mach-pnx833x/gpio.h)\n\n### 4. 宏参数重复调用\n\n有如下宏定义：\n\n```c\n#define min(X, Y)  ((X) < (Y) ? (X) : (Y))\n```\n\n当有如下调用时`next = min (x + y, foo (z));`，宏体被展开成`next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));`，可以看到，`foo(z)`被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。\n\n所以，尽量不要在宏参数中传入函数调用。\n\n### 5. 对自身的递归引用\n\n有如下宏定义：\n\n```c\n#define foo (4 + foo)\n```\n\n按前面的理解，`(4 + foo)`会展开成`(4 + (4 + foo))`，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是***只展开一次***。也就是说，`foo`只会展开成`(4 + foo)`，而展开之后`foo`的含义就要根据上下文来确定了。\n\n对于以下的交叉引用，宏体也只会展开一次。\n\n```c\n#define x (4 + y)\n#define y (2 * x)\n```\n\n`x`展开成`(4 + y) -> (4 + (2 * x))`，`y`展开成`(2 * x) -> (2 * (4 + y))`。\n\n**注意，这是极不推荐的写法，程序可读性极差。**\n\n### 6. 宏参数预处理\n\n宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有`#`或`##`。\n\n有如下宏定义：\n\n```c\n#define AFTERX(x) X_ ## x\n#define XAFTERX(x) AFTERX(x)\n#define TABLESIZE 1024\n#define BUFSIZE TABLESIZE\n```\n\n- `AFTERX(BUFSIZE)`会被展开成`X_BUFSIZE`。因为宏体中含有`##`，宏参数直接代入宏体。\n- `XAFTERX(BUFSIZE)`会被展开成`X_1024`。因为`XAFTERX(x)`的宏体是`AFTERX(x)`，并没有`#`或`##`，所以`BUFSIZE`在代入前会被完全展开成`1024`，然后才代入宏体，变成`X_1024`。\n\n-EOF-\n\n------\n\n参考资料：\n\nhttp://gcc.gnu.org/onlinedocs/cpp/Macros.html","slug":"cplus_md/C Baisc/C语言宏的特殊用法和几个坑","published":1,"updated":"2021-04-09T12:51:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6b003tw9q953sz4im4","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"C语言宏的特殊用法和几个坑\"><a href=\"#C语言宏的特殊用法和几个坑\" class=\"headerlink\" title=\"C语言宏的特殊用法和几个坑\"></a>C语言宏的特殊用法和几个坑</h1><p>总结一下C语言中宏的一些特殊用法和几个容易踩的坑。由于本文主要参考GCC文档，某些细节（如宏参数中的空格是否处理之类）在别的编译器可能有细微差别，请参考相应文档。</p>\n<h2 id=\"宏基础\"><a href=\"#宏基础\" class=\"headerlink\" title=\"宏基础\"></a>宏基础</h2><p>宏仅仅是在C预处理阶段的一种文本替换工具，编译完之后对二进制代码不可见。基本用法如下：</p>\n<h3 id=\"1-标示符别名\"><a href=\"#1-标示符别名\" class=\"headerlink\" title=\"1. 标示符别名\"></a>1. 标示符别名</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_SIZE 1024</span></span><br></pre></td></tr></table></figure>\n<p>预处理阶段，<code>foo = (char *) malloc (BUFFER_SIZE);</code>会被替换成<code>foo = (char *) malloc (1024);</code></p>\n<p>宏体换行需要在行末加反斜杠\\</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMBERS 1, \\</span></span><br><span class=\"line\">                <span class=\"number\">2</span>, \\</span><br><span class=\"line\">                <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n\n<p>预处理阶段<code>int x[] = &#123; NUMBERS &#125;;</code>会被扩展成<code>int x[] = &#123; 1, 2, 3 &#125;;</code></p>\n<h3 id=\"2-宏函数\"><a href=\"#2-宏函数\" class=\"headerlink\" title=\"2. 宏函数\"></a>2. 宏函数</h3><p>宏名之后带括号的宏被认为是宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span></span><br></pre></td></tr></table></figure>\n<p>y = min(1, 2);<code>会被扩展成</code>y = ((1) &lt; (2) ? (1) : (2));</p>\n<hr>\n<h2 id=\"宏特殊用法\"><a href=\"#宏特殊用法\" class=\"headerlink\" title=\"宏特殊用法\"></a>宏特殊用法</h2><h3 id=\"1-字符串化-Stringification\"><a href=\"#1-字符串化-Stringification\" class=\"headerlink\" title=\"1. 字符串化(Stringification)\"></a>1. 字符串化(Stringification)</h3><p>在宏体中，如果宏参数前加个<code>#</code>，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WARN_IF(EXP) \\</span></span><br><span class=\"line\">     <span class=\"keyword\">do</span> &#123; <span class=\"keyword\">if</span> (EXP) \\</span><br><span class=\"line\">             <span class=\"built_in\">fprintf</span> (<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Warning: &quot;</span> #EXP <span class=\"string\">&quot;\\n&quot;</span>); &#125; \\</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p><code>WARN_IF (x == 0);</code>会被扩展成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123; <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span> (<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Warning: &quot;</span> <span class=\"string\">&quot;x == 0&quot;</span> <span class=\"string\">&quot;\\n&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中</p>\n<h3 id=\"2-连接-Concatenation\"><a href=\"#2-连接-Concatenation\" class=\"headerlink\" title=\"2. 连接(Concatenation)\"></a>2. 连接(Concatenation)</h3><p>在宏体中，如果宏体所在标示符中有<code>##</code>，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COMMAND(NAME)  &#123; #NAME, NAME ## _command &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">command</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*function) (<span class=\"keyword\">void</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在宏扩展的时候</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">command</span> <span class=\"title\">commands</span>[] =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    COMMAND (quit),</span><br><span class=\"line\">    COMMAND (help),</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>会被扩展成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">command</span> <span class=\"title\">commands</span>[] =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;quit&quot;</span>, quit_command &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;help&quot;</span>, help_command &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样就节省了大量时间，提高效率。</p>\n<hr>\n<h2 id=\"几个坑\"><a href=\"#几个坑\" class=\"headerlink\" title=\"几个坑\"></a>几个坑</h2><h3 id=\"1-语法问题\"><a href=\"#1-语法问题\" class=\"headerlink\" title=\"1. 语法问题\"></a>1. 语法问题</h3><p>由于是纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号神马的预处理器是不管的。这里要格外小心，由此可能引出各种奇葩的问题，一下还很难找到根源。</p>\n<h3 id=\"2-算符优先级问题\"><a href=\"#2-算符优先级问题\" class=\"headerlink\" title=\"2. 算符优先级问题\"></a>2. 算符优先级问题</h3><p>不仅宏体是纯文本替换，宏参数也是纯文本替换。有以下一段简单的宏，实现乘法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MULTIPLY(x, y) x * y</span></span><br></pre></td></tr></table></figure>\n<p><code>MULTIPLY(1, 2)</code>没问题，会正常展开成<code>1 * 2</code>。有问题的是这种表达式<code>MULTIPLY(1+2, 3)</code>，展开后成了<code>1+2 * 3</code>，显然优先级错了。</p>\n<p>在宏体中，给引用的参数加个括号就能避免这问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MULTIPLY(x, y) (x) * (y)</span></span><br></pre></td></tr></table></figure>\n<p><code>MULTIPLY(1+2, 3)</code>就会被展开成<code>(1+2) * (3)</code>，优先级正常了。</p>\n<p>其实这个问题和下面要说到的某些问题都属于由于纯文本替换而导致的语义破坏问题，要格外小心。</p>\n<h3 id=\"3-分号吞噬问题\"><a href=\"#3-分号吞噬问题\" class=\"headerlink\" title=\"3. 分号吞噬问题\"></a>3. 分号吞噬问题</h3><p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SKIP_SPACES(p, limit)  \\</span></span><br><span class=\"line\">     &#123; <span class=\"keyword\">char</span> *lim = (limit);         \\</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (p &lt; lim) &#123;            \\</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (*p++ != <span class=\"string\">&#x27; &#x27;</span>) &#123;         \\</span><br><span class=\"line\">           p--; <span class=\"keyword\">break</span>; &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>假设有如下一段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (*p != <span class=\"number\">0</span>)</span><br><span class=\"line\">   SKIP_SPACES (p, lim);</span><br><span class=\"line\"><span class=\"keyword\">else</span> ...</span><br></pre></td></tr></table></figure>\n<p>一编译，GCC报<code>error: ‘else’ without a previous ‘if’</code>。原来这个看似是一个函数的宏被展开后是一段大括号括起来的代码块，加上分号之后这个if逻辑块就结束了，所以编译器发现这个else没有对应的if。</p>\n<p>这个问题一般用<code>do ... while(0)</code>的形式来解决：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SKIP_SPACES(p, limit)     \\</span></span><br><span class=\"line\">     <span class=\"keyword\">do</span> &#123; <span class=\"keyword\">char</span> *lim = (limit);         \\</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (p &lt; lim) &#123;            \\</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*p++ != <span class=\"string\">&#x27; &#x27;</span>) &#123;         \\</span><br><span class=\"line\">              p--; <span class=\"keyword\">break</span>; &#125;&#125;&#125;          \\</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>展开后就成了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (*p != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">do</span> ... <span class=\"keyword\">while</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span> ...</span><br></pre></td></tr></table></figure>\n<p>这样就消除了分号吞噬问题。</p>\n<p>这个技巧在Linux内核源码里很常见，比如这个置位宏<code>#define SET_REG_BIT(reg, bit) do &#123; (reg |= (1 &lt;&lt; (bit))); &#125; while (0)</code>(位于arch/mips/include/asm/mach-pnx833x/gpio.h)</p>\n<h3 id=\"4-宏参数重复调用\"><a href=\"#4-宏参数重复调用\" class=\"headerlink\" title=\"4. 宏参数重复调用\"></a>4. 宏参数重复调用</h3><p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span></span><br></pre></td></tr></table></figure>\n<p>当有如下调用时<code>next = min (x + y, foo (z));</code>，宏体被展开成<code>next = ((x + y) &lt; (foo (z)) ? (x + y) : (foo (z)));</code>，可以看到，<code>foo(z)</code>被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。</p>\n<p>所以，尽量不要在宏参数中传入函数调用。</p>\n<h3 id=\"5-对自身的递归引用\"><a href=\"#5-对自身的递归引用\" class=\"headerlink\" title=\"5. 对自身的递归引用\"></a>5. 对自身的递归引用</h3><p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> foo (4 + foo)</span></span><br></pre></td></tr></table></figure>\n<p>按前面的理解，<code>(4 + foo)</code>会展开成<code>(4 + (4 + foo))</code>，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是**<em>只展开一次**</em>。也就是说，<code>foo</code>只会展开成<code>(4 + foo)</code>，而展开之后<code>foo</code>的含义就要根据上下文来确定了。</p>\n<p>对于以下的交叉引用，宏体也只会展开一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> x (4 + y)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> y (2 * x)</span></span><br></pre></td></tr></table></figure>\n<p><code>x</code>展开成<code>(4 + y) -&gt; (4 + (2 * x))</code>，<code>y</code>展开成<code>(2 * x) -&gt; (2 * (4 + y))</code>。</p>\n<p><strong>注意，这是极不推荐的写法，程序可读性极差。</strong></p>\n<h3 id=\"6-宏参数预处理\"><a href=\"#6-宏参数预处理\" class=\"headerlink\" title=\"6. 宏参数预处理\"></a>6. 宏参数预处理</h3><p>宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有<code>#</code>或<code>##</code>。</p>\n<p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AFTERX(x) X_ ## x</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> XAFTERX(x) AFTERX(x)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TABLESIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFSIZE TABLESIZE</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>AFTERX(BUFSIZE)</code>会被展开成<code>X_BUFSIZE</code>。因为宏体中含有<code>##</code>，宏参数直接代入宏体。</li>\n<li><code>XAFTERX(BUFSIZE)</code>会被展开成<code>X_1024</code>。因为<code>XAFTERX(x)</code>的宏体是<code>AFTERX(x)</code>，并没有<code>#</code>或<code>##</code>，所以<code>BUFSIZE</code>在代入前会被完全展开成<code>1024</code>，然后才代入宏体，变成<code>X_1024</code>。</li>\n</ul>\n<p>-EOF-</p>\n<hr>\n<p>参考资料：</p>\n<p><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Macros.html\">http://gcc.gnu.org/onlinedocs/cpp/Macros.html</a></p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"C语言宏的特殊用法和几个坑\"><a href=\"#C语言宏的特殊用法和几个坑\" class=\"headerlink\" title=\"C语言宏的特殊用法和几个坑\"></a>C语言宏的特殊用法和几个坑</h1><p>总结一下C语言中宏的一些特殊用法和几个容易踩的坑。由于本文主要参考GCC文档，某些细节（如宏参数中的空格是否处理之类）在别的编译器可能有细微差别，请参考相应文档。</p>\n<h2 id=\"宏基础\"><a href=\"#宏基础\" class=\"headerlink\" title=\"宏基础\"></a>宏基础</h2><p>宏仅仅是在C预处理阶段的一种文本替换工具，编译完之后对二进制代码不可见。基本用法如下：</p>\n<h3 id=\"1-标示符别名\"><a href=\"#1-标示符别名\" class=\"headerlink\" title=\"1. 标示符别名\"></a>1. 标示符别名</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFER_SIZE 1024</span></span><br></pre></td></tr></table></figure>\n<p>预处理阶段，<code>foo = (char *) malloc (BUFFER_SIZE);</code>会被替换成<code>foo = (char *) malloc (1024);</code></p>\n<p>宏体换行需要在行末加反斜杠\\</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NUMBERS 1, \\</span></span><br><span class=\"line\">                <span class=\"number\">2</span>, \\</span><br><span class=\"line\">                <span class=\"number\">3</span></span><br></pre></td></tr></table></figure>\n\n\n<p>预处理阶段<code>int x[] = &#123; NUMBERS &#125;;</code>会被扩展成<code>int x[] = &#123; 1, 2, 3 &#125;;</code></p>\n<h3 id=\"2-宏函数\"><a href=\"#2-宏函数\" class=\"headerlink\" title=\"2. 宏函数\"></a>2. 宏函数</h3><p>宏名之后带括号的宏被认为是宏函数。用法和普通函数一样，只不过在预处理阶段，宏函数会被展开。优点是没有普通函数保存寄存器和参数传递的开销，展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span></span><br></pre></td></tr></table></figure>\n<p>y = min(1, 2);<code>会被扩展成</code>y = ((1) &lt; (2) ? (1) : (2));</p>\n<hr>\n<h2 id=\"宏特殊用法\"><a href=\"#宏特殊用法\" class=\"headerlink\" title=\"宏特殊用法\"></a>宏特殊用法</h2><h3 id=\"1-字符串化-Stringification\"><a href=\"#1-字符串化-Stringification\" class=\"headerlink\" title=\"1. 字符串化(Stringification)\"></a>1. 字符串化(Stringification)</h3><p>在宏体中，如果宏参数前加个<code>#</code>，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WARN_IF(EXP) \\</span></span><br><span class=\"line\">     <span class=\"keyword\">do</span> &#123; <span class=\"keyword\">if</span> (EXP) \\</span><br><span class=\"line\">             <span class=\"built_in\">fprintf</span> (<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Warning: &quot;</span> #EXP <span class=\"string\">&quot;\\n&quot;</span>); &#125; \\</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p><code>WARN_IF (x == 0);</code>会被扩展成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123; <span class=\"keyword\">if</span> (x == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span> (<span class=\"built_in\">stderr</span>, <span class=\"string\">&quot;Warning: &quot;</span> <span class=\"string\">&quot;x == 0&quot;</span> <span class=\"string\">&quot;\\n&quot;</span>); &#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>这种用法可以用在assert中，如果断言失败，可以将失败的语句输出到反馈信息中</p>\n<h3 id=\"2-连接-Concatenation\"><a href=\"#2-连接-Concatenation\" class=\"headerlink\" title=\"2. 连接(Concatenation)\"></a>2. 连接(Concatenation)</h3><p>在宏体中，如果宏体所在标示符中有<code>##</code>，那么在宏体扩展的时候，宏参数会被直接替换到标示符中。如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> COMMAND(NAME)  &#123; #NAME, NAME ## _command &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">command</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> (*function) (<span class=\"keyword\">void</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在宏扩展的时候</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">command</span> <span class=\"title\">commands</span>[] =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    COMMAND (quit),</span><br><span class=\"line\">    COMMAND (help),</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>会被扩展成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">command</span> <span class=\"title\">commands</span>[] =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;quit&quot;</span>, quit_command &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;help&quot;</span>, help_command &#125;,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样就节省了大量时间，提高效率。</p>\n<hr>\n<h2 id=\"几个坑\"><a href=\"#几个坑\" class=\"headerlink\" title=\"几个坑\"></a>几个坑</h2><h3 id=\"1-语法问题\"><a href=\"#1-语法问题\" class=\"headerlink\" title=\"1. 语法问题\"></a>1. 语法问题</h3><p>由于是纯文本替换，C预处理器不对宏体做任何语法检查，像缺个括号、少个分号神马的预处理器是不管的。这里要格外小心，由此可能引出各种奇葩的问题，一下还很难找到根源。</p>\n<h3 id=\"2-算符优先级问题\"><a href=\"#2-算符优先级问题\" class=\"headerlink\" title=\"2. 算符优先级问题\"></a>2. 算符优先级问题</h3><p>不仅宏体是纯文本替换，宏参数也是纯文本替换。有以下一段简单的宏，实现乘法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MULTIPLY(x, y) x * y</span></span><br></pre></td></tr></table></figure>\n<p><code>MULTIPLY(1, 2)</code>没问题，会正常展开成<code>1 * 2</code>。有问题的是这种表达式<code>MULTIPLY(1+2, 3)</code>，展开后成了<code>1+2 * 3</code>，显然优先级错了。</p>\n<p>在宏体中，给引用的参数加个括号就能避免这问题。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MULTIPLY(x, y) (x) * (y)</span></span><br></pre></td></tr></table></figure>\n<p><code>MULTIPLY(1+2, 3)</code>就会被展开成<code>(1+2) * (3)</code>，优先级正常了。</p>\n<p>其实这个问题和下面要说到的某些问题都属于由于纯文本替换而导致的语义破坏问题，要格外小心。</p>\n<h3 id=\"3-分号吞噬问题\"><a href=\"#3-分号吞噬问题\" class=\"headerlink\" title=\"3. 分号吞噬问题\"></a>3. 分号吞噬问题</h3><p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SKIP_SPACES(p, limit)  \\</span></span><br><span class=\"line\">     &#123; <span class=\"keyword\">char</span> *lim = (limit);         \\</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (p &lt; lim) &#123;            \\</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (*p++ != <span class=\"string\">&#x27; &#x27;</span>) &#123;         \\</span><br><span class=\"line\">           p--; <span class=\"keyword\">break</span>; &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>假设有如下一段代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (*p != <span class=\"number\">0</span>)</span><br><span class=\"line\">   SKIP_SPACES (p, lim);</span><br><span class=\"line\"><span class=\"keyword\">else</span> ...</span><br></pre></td></tr></table></figure>\n<p>一编译，GCC报<code>error: ‘else’ without a previous ‘if’</code>。原来这个看似是一个函数的宏被展开后是一段大括号括起来的代码块，加上分号之后这个if逻辑块就结束了，所以编译器发现这个else没有对应的if。</p>\n<p>这个问题一般用<code>do ... while(0)</code>的形式来解决：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SKIP_SPACES(p, limit)     \\</span></span><br><span class=\"line\">     <span class=\"keyword\">do</span> &#123; <span class=\"keyword\">char</span> *lim = (limit);         \\</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (p &lt; lim) &#123;            \\</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (*p++ != <span class=\"string\">&#x27; &#x27;</span>) &#123;         \\</span><br><span class=\"line\">              p--; <span class=\"keyword\">break</span>; &#125;&#125;&#125;          \\</span><br><span class=\"line\">     <span class=\"keyword\">while</span> (<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p>展开后就成了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (*p != <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">do</span> ... <span class=\"keyword\">while</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">else</span> ...</span><br></pre></td></tr></table></figure>\n<p>这样就消除了分号吞噬问题。</p>\n<p>这个技巧在Linux内核源码里很常见，比如这个置位宏<code>#define SET_REG_BIT(reg, bit) do &#123; (reg |= (1 &lt;&lt; (bit))); &#125; while (0)</code>(位于arch/mips/include/asm/mach-pnx833x/gpio.h)</p>\n<h3 id=\"4-宏参数重复调用\"><a href=\"#4-宏参数重复调用\" class=\"headerlink\" title=\"4. 宏参数重复调用\"></a>4. 宏参数重复调用</h3><p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(X, Y)  ((X) &lt; (Y) ? (X) : (Y))</span></span><br></pre></td></tr></table></figure>\n<p>当有如下调用时<code>next = min (x + y, foo (z));</code>，宏体被展开成<code>next = ((x + y) &lt; (foo (z)) ? (x + y) : (foo (z)));</code>，可以看到，<code>foo(z)</code>被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。</p>\n<p>所以，尽量不要在宏参数中传入函数调用。</p>\n<h3 id=\"5-对自身的递归引用\"><a href=\"#5-对自身的递归引用\" class=\"headerlink\" title=\"5. 对自身的递归引用\"></a>5. 对自身的递归引用</h3><p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> foo (4 + foo)</span></span><br></pre></td></tr></table></figure>\n<p>按前面的理解，<code>(4 + foo)</code>会展开成<code>(4 + (4 + foo))</code>，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是**<em>只展开一次**</em>。也就是说，<code>foo</code>只会展开成<code>(4 + foo)</code>，而展开之后<code>foo</code>的含义就要根据上下文来确定了。</p>\n<p>对于以下的交叉引用，宏体也只会展开一次。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> x (4 + y)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> y (2 * x)</span></span><br></pre></td></tr></table></figure>\n<p><code>x</code>展开成<code>(4 + y) -&gt; (4 + (2 * x))</code>，<code>y</code>展开成<code>(2 * x) -&gt; (2 * (4 + y))</code>。</p>\n<p><strong>注意，这是极不推荐的写法，程序可读性极差。</strong></p>\n<h3 id=\"6-宏参数预处理\"><a href=\"#6-宏参数预处理\" class=\"headerlink\" title=\"6. 宏参数预处理\"></a>6. 宏参数预处理</h3><p>宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有<code>#</code>或<code>##</code>。</p>\n<p>有如下宏定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> AFTERX(x) X_ ## x</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> XAFTERX(x) AFTERX(x)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TABLESIZE 1024</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFSIZE TABLESIZE</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>AFTERX(BUFSIZE)</code>会被展开成<code>X_BUFSIZE</code>。因为宏体中含有<code>##</code>，宏参数直接代入宏体。</li>\n<li><code>XAFTERX(BUFSIZE)</code>会被展开成<code>X_1024</code>。因为<code>XAFTERX(x)</code>的宏体是<code>AFTERX(x)</code>，并没有<code>#</code>或<code>##</code>，所以<code>BUFSIZE</code>在代入前会被完全展开成<code>1024</code>，然后才代入宏体，变成<code>X_1024</code>。</li>\n</ul>\n<p>-EOF-</p>\n<hr>\n<p>参考资料：</p>\n<p><a href=\"http://gcc.gnu.org/onlinedocs/cpp/Macros.html\">http://gcc.gnu.org/onlinedocs/cpp/Macros.html</a></p>\n"},{"title":"SPEC文件基础知识","date":"2020-12-31T15:59:00.000Z","abbrlink":13014,"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","_content":"# SPEC **文件基础知识**\n\n制作 rpm 软件包并不是一件复杂的工作，其中的关键在于编写软件包的 spec 描述文件。要想制作一个 rpm 软件包就必须写一个软件包描述文件 spec。这个文件中包含了软件包的诸多信息，如：软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。在实际过程中，最关键的地方是要清楚虚拟路径的位置，以及宏的定义。\n\n**Mandatory parameters to be present in SPEC file to build and generate RPM**\n\nBelow options are mandatory to be present in SPEC file\n\nName, Version, Release, Summary, License, description, install and files\n\n```makefile\nName:           test-dev\nVersion:        %{_version}\nRelease:        %{_release}\nSummary:        <update details>\nLicense:        Nokia License\n%description\n<update your description>\n%install\nmake -C %{buildroot}/.. install DESTDIR=\"%{buildroot}\"\n%files\n%{_bindir}\n```\n\n## 1. **文件头**\n\n语法：`TagName: value`，比如`Version: 2.1.0`，tag名大小写**不敏感**。\n\nspec支持定义宏，要定义宏，使用：`%define testMacro 2`，这里定义了一个宏，名称为testMacro，值为2，要使用这个宏，使用`%{testMacro}`或者`%testMacro`。\n\n这个区域定义的 `Name`、`Version` 这些字段对应的值可以在后面通过 `%{name}`,`%{version}` 这样的方式来引用，类似于 C 语言中的宏：\n\n- `Summary`：用一句话概括该软件s包尽量多的信息。\n\n- `Name`：软件包的名字，最终 rpm 软件包是用该名字与版本号（`Version`）、释出号(`Release`）及体系号来命名软件包的，后面可使用 `%{name}` 的方式引用\n\n- `Version`：软件版本号。仅当软件包比以前有较大改变时才增加版本号，后面可使用`%{version}`引用\n\n- `Release`：软件包释出号/发行号。一般我们对该软件包做了一些小的补丁的时候就应该把释出号加 1，后面可使用 `%{release}` 引用\n\n- `Packager`：打包的人（一般喜欢写个人邮箱）\n\n- `Vendor`：软件开发者的名字，发行商或打包组织的信息，例如`RedFlagCo,Ltd`\n\n- `License`：软件授权方式，通常是GPL（自由软件）或GPLv2,BSD\n\n- `Copyright`：软件包所采用的版权规则。具体有：\n\n    - `GPL（自由软件）`，\n\n    - `BSD`，\n\n    - `MIT`，\n\n    - `Public Domain（公共域）`，\n\n    - `Distributable（贡献）`，\n\n    - `commercial（商业）`，\n\n    - `Share（共享）`\n\n        一般的开发都写 `GPL`。\n\n- `Group`：软件包所属类别\n  \n    - Development/System （开发/系统）\n- System Environment/Daemons （系统环境/守护）\n  \n- `Source0`：源程序软件包的名字/源代码包的名字，如 `stardict-2.0.tar.gz`。可以带多个用 `Source1`、`Source2` 等源，后面也可以用 `%{source1}`、`%{source2}` 引用\n\n```makefile\nCopy\nSource0: %{name}-boost-%{version}.tar.gz    ← 源码包名称(可以使用URL)，可以用SourceN指定多个，如配置文件\n#Patch0: some-bugs0.patch                    ← 如果需要打补丁，则依次填写\n#Patch1: some-bugs1.patch                    ← 如果需要打补丁，则依次填写\n```\n\n## 2. 依赖关系\n\n依赖关系定义了一个包正常工作需要依赖的其他包，RPM在升级、安装和删除的时候会确保依赖关系得到满足。\n\n- `BuildRequires`: 制作过程中用到的软件包，构建依赖\n\n- `Requires`: 安装时所需软件包\n    - `Requires(pre)`: 指定不同阶段的依赖\n    \n- `BuildRoot`: 这个是安装或编译时使用的「虚拟目录」，打包时会用到该目录下文件，可查看安装后文件路径，例如：`BuildRoot: %_topdir/BUILDROOT`。\n\n- `Prefix: %{_prefix}` 这个主要是为了解决今后安装 rpm 包时，并不一定把软件安装到 rpm 中打包的目录的情况。这样，必须在这里定义该标识，并在编写 `%install` 脚本的时候引用，才能实现 rpm 安装时重新指定位置的功能\n\n- `BuildArch`: 指编译的目标处理器架构，`noarch` 标识不指定，但通常都是以 `/usr/lib/rpm/marcros` 中的内容为默认值\n\n- `%description`：软件包详细说明，可写在多个行上。这样任何人使用 `rpm -qi`查询您的软件包时都可以看到它。您可以解释这个软件包做什么，描述任何警告或附加的配置指令，等等。\n\n- `URL`：软件的主页\n\n### 2.1 **RPM 包信息查看**\n\n- 我通过命令查看了 nginx 包的信息，如下：\n\n    ```bash\n    Copy\n    # 查看头部信息\n    \n    $ rpm -qpi ./nginx-1.12.2-2.el7.x86_64.rpm\n    Name        : nginx\n    Epoch       : 1\n    Version     : 1.12.2\n    Release     : 2.el7\n    Architecture: x86_64\n    Install Date: (not installed)\n    Group       : System Environment/Daemons\n    Size        : 1574949\n    License     : BSD\n    Signature   : RSA/SHA256, Tue 06 Mar 2018 05:44:06 PM CST, Key ID 6a2faea2352c64e5\n    Source RPM  : nginx-1.12.2-2.el7.src.rpm\n    Build Date  : Tue 06 Mar 2018 05:27:44 PM CST\n    Build Host  : buildhw-02.phx2.fedoraproject.org\n    Relocations : (not relocatable)\n    Packager    : Fedora Project\n    Vendor      : Fedora Project\n    URL         : <http://nginx.org/>\n    Bug URL     : <https://bugz.fedoraproject.org/nginx>\n    Summary     : A high performance web server and reverse proxy server\n    Description :\n    Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and\n    IMAP protocols, with a strong focus on high concurrency, performance and low\n    memory usage.\n    \n    # 查看脚本内容\n    \n    $ rpm --scripts -qp ./nginx-1.12.2-2.el7.x86_64.rpm\n    postinstall scriptlet (using /bin/sh):\n    \n    if [ $1 -eq 1 ] ; then\n            # Initial installation\n            systemctl preset nginx.service >/dev/null 2>&1 || :\n    fi\n    preuninstall scriptlet (using /bin/sh):\n    \n    if [ $1 -eq 0 ] ; then\n            # Package removal, not upgrade\n            systemctl --no-reload disable nginx.service > /dev/null 2>&1 || :\n            systemctl stop nginx.service > /dev/null 2>&1 || :\n    fi\n    postuninstall scriptlet (using /bin/sh):\n    \n    systemctl daemon-reload >/dev/null 2>&1 || :\n    \n    if [ $1 -ge 1 ]; then\n        /usr/bin/nginx-upgrade >/dev/null 2>&1 || :\n    fi\n    ```\n\n### 2.2 **BuildRequires**\n\n定义构建时依赖的软件包，在构建机器编译 rpm 包时需要的辅助工具，以逗号分隔。\n\n假如，要求编译 `myapp` 时，gcc 的版本至少为 4.4.2，则可以写成 `gcc >=4.2.2`\n\n### 2.3 **Requires**\n\n定义安装时的依赖包，该 rpm 包所依赖的软件包名称，就是指编译好的 rpm 软件在其他机器上安装时，需要依赖的其他软件包。\n\n可以用 `>=` 或 `<=` 表示大于或小于某一特定版本。 `>=` 号两边需用空格隔开，而不同软件名称也用空格分开。\n\n格式：\n\n```\nCopy\nRequires:       libpng-devel >= 1.0.20 zlib\n```\n\n其它写法例如：\n\n```\nCopy\nRequires: bzip2 = %{version}, bzip2-libs =%{version}\n```\n\n还有例如`PreReq`、`Requires(pre)`、`Requires(post)`、`Requires(preun)`、`Requires(postun)`、`BuildRequires`等都是针对不同阶段的依赖指定。\n\n关于`pre`、`post`、`preun`、`postun`含义理解，感觉`post`有一种“完成”的意思：\n\n```\nCopy\n# 安装前执行的脚本，语法和shell脚本的语法相同\n%pre\n# 安装后执行的脚本\n%post\n# 卸载前执行的脚本\n%preun\n# 卸载完成后执行的脚本\n%postun\n# 清理阶段，在制作完成后删除安装的内容\n```\n\n例如：\n\n```\nCopy\nPreReq: capability>=version      #capability包必须先安装\nConflicts:bash>=2.0              #该包和所有不小于2.0的bash包有冲突\n```\n\n![image-20210315162108826](SPEC%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210315162108826.png)\n\n### 2.4 **BuildRoot**\n\n该参数非常重要，因为在生成 rpm 的过程中，执行 `make install` 时就会把软件安装到上述的路径中，在打包的时候，同样依赖“虚拟目录”为“根目录”进行操作。后面可使用 `$RPM_BUILD_ROOT` 方式引用。\n\n考虑到多用户的环境，一般定义为：\n\n```\nCopy\n%{_tmppath}/%{name}-%{version}-%{release}-root\n# OR\n%{_tmppath}/%{name}-%{version}-%{release}-buildroot-%(%{__id_u} -n}\n```\n\n## 3. 预处理 %prep\n\n这个阶段是「预处理」，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备。\n\n`%prep` 和下面的 `%build`，`%install` 段一样，除了可以执行 rpm 所定义的宏命令（以`%`开头）以外，还可以执行 `SHELL` 命令，命令可以有很多行，如我们常写的 `tar` 解包命令。功能上类似于 `./configure`。\n\n`%prep` 阶段进行实际的打包准备工作，它是使用节前缀 `%prep` 表示的。主要功能有：\n\n- 将文件 ( `SOURCES/`) 解压到构建目录 (`BUILD/`)\n- 应用 `Patch`（打补丁） (`SOURCES/ => BUILD/`)\n- 描述 `rm -rf $RPM_BUILD_ROOT`\n- 描述或编辑本部分用到的命令到 `PreReq`\n- 通过 `b .XXX` 描述补丁备份\n\n它一般包含 `%setup` 与 `%patch` 两个命令。`%setup` 用于将软件包打开，执行 `%patch` 可将补丁文件加入解开的源程序中。\n\n示例：\n\n```bash\nCopy\n%prep\n%setup -q                                     ← 宏的作用是解压并切换到目录\n#%patch0 -p1                                  ← 如果需要打补丁，则依次写\n#%patch1 -p1                                  ← 如果需要打补丁，则依次写\n```\n\n### 3.1 宏 **%setup**\n\n这个宏解压源代码，将当前目录改为源代码解压之后产生的目录。这个宏还有一些选项可以用。例如，在解压后，`%setup` 宏假设产生的目录是 `%{name}-%{version}`\n\n```\nCopy\n%setup -n %{name}-%{version} #把源码包解压并放好\n```\n\n主要的用途就是将 `%sourcedir` 目录下的源代码解压到 `%builddir` 目录下，也就是将`~/rpmbuild/SOURCES` 里的包解压到 `~/rpmbuild/BUILD/%{name}-%{version}` 中。一般用 `%setup -c` 就可以了，但有两种情况：\n\n- 一就是同时编译多个源码包，\n- 二就是源码的 tar 包的名称与解压出来的目录不一致，此时，就需要使用 `n` 参数指定一下。\n\n```yaml\nCopy\n%setup 不加任何选项，仅将软件包打开。\n%setup -a 切换目录前，解压指定 Source 文件，例如 `-a 0` 表示解压 `Source0`\n%setup -n newdir 将软件包解压在newdir目录。\n%setup -c 解压缩之前先产生目录。\n%setup -b num 将第 num 个 source 文件解压缩。\n%setup -D 解压前不删除目录\n%setup -T 不使用default的解压缩操作。\n%setup -T -b 0 将第 0 个源代码文件解压缩。\n%setup -c -n newdir 指定目录名称 newdir，并在此目录产生 rpm 套件。\n%patch 最简单的补丁方式，自动指定patch level。\n%patch 0 使用第0个补丁文件，相当于%patch ?p 0。\n%patch -s 不显示打补丁时的信息。\n%patch -T 将所有打补丁时产生的输出文件删除\n```\n\n应该 `-q` 参数给 `%setup` 宏。这会显著减少编译日志文件的输出，尤其是源代码包会解压出一堆文件的时候。\n\n在 `~/rmpbuild/BUILD/%{name}-%{version}` 目录中进行 ，使用标准写法，会引用`/usr/lib/rpm/marcros` 中定义的参数。\n\n### 3.2 宏 **%patch**\n\n这个宏将头部定义的补丁应用于源代码。如果定义了多个补丁，它可以用一个数字的参数来指示应用哪个补丁文件。它也接受 `-b extension` 参数，指示 RPM 在打补丁之前，将文件备份为扩展名是 `extension` 的文件。\n\n通常补丁都会一起在源码 `tar.gz` 包中，或放到 `SOURCES` 目录下。一般参数为：\n\n- `%patch -p1` 使用前面定义的 `Patch` 补丁进行，`p1`是忽略 `patch` 的第一层目录\n- `%Patch2 -p1 -b xxx.patch`打上指定的补丁，`b`是指生成备份文件\n\n### 3.3 **%build 阶段**\n\n本段是「构建」阶段，这个阶段会在 `%_builddir` 目录下执行源码包的编译。一般是执行执行常见的 `configure` 和 `make` 操作。\n\n该阶段一般由多个 `make` 命令组成。与 `%prep` 段落一样，这些命令可以是 `shell` 命令，也可以是宏。\n\n记住两点：\n\n1. `%build` 和 `%install` 的过程中，都必须把编译和安装的文件定义到“虚拟根目录” 中\n2. `%file` 中必须明白，用的是相对目录\n\n这个阶段我们最常见只有两条指令：\n\n```\nCopy\n%configure\nmake %{?_smp_mflags} OPTIMIZE=\"%{optflags}\"           ← 多核则并行编译\n```\n\n`%configure` 这个不是关键字，而是 rpm 定义的标准宏命令。意思是执行源代码的`configure`配置。会自动将 `prefix` 设置成 `/usr`。\n\n这个 `%{?_smp_mflags} %{optflags}` 是什么意思呢？\n\n```go\nCopy\n$ rpm --eval \"%{?_smp_mflags}\"\n-j4\n$ rpm --eval \"%{optflags}\"\n-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches   -m64 -mtune=generic\n```\n\n所以，上面那个命令就是 `make -j4`。问题又来了，`make -j4` 表示什么意思？\n\n> 都是一些优化参数\n\n- [Linux kernel 笔记 （26）——利用“make -j”提高编译`kernel`速度](https://nanxiao.me/linux-kernel-note-26-make-j/)\n- [CSDB-make -j4是什么意思](https://bbs.csdn.net/topics/380072770)\n\n### 3.4 **%install 阶段**\n\n「安装」阶段，就是执行 `make install` 命令操作。开始把软件安装到虚拟的根目录中。这个阶段会在 `%buildrootdir` 目录里建好目录结构，然后将需要打包到 rpm 软件包里的文件从 `%builddir` 里拷贝到 `%_buildrootdir` 里对应的目录里。\n\n在 `~/rpmbuild/BUILD/%{name}-%{version}` 目录中进行 `make install` 的操作。`%install` 很重要，因为如果这里的路径不对的话，则下面 `%file` 中寻找文件的时候就会失败。\n\n特别需要注意的是：`%install` 部分使用的是绝对路径，而 `%file` 部分使用则是相对路径，虽然其描述的是同一个地方。千万不要写错。\n\n将已编译的软件安装到虚拟的目录结构中，从而可以打包成一个 RPM。当用户最终用 `rpm -ivh name-version.rpm` 安装软件包时，这些文件会安装到用户系统中相应的目录里。\n\n```yaml\nCopy\n%install\nif [-d %{buildroot}]; then\n   rm -rf %{buildroot}                      ← 清空下安装目录，实际会自动清除\nfi\nmake install DESTDIR=%{buildroot}           ← 安装到buildroot目录下\n%{__install} -Dp -m0755 contrib/init.d %{buildroot}%{_initrddir}/foobar\n%{__install} -d %{buildroot}%{_sysconfdir}/foobar.d/\n```\n\n「翻译」一下：\n\n```yaml\nCopy\nmake install DESTDIR=/root/rpmbuild/BUILDROOT/%{name}-%{version}-%{release}.x86_64\nmake install DESTDIR=/root/rpmbuild/BUILDROOT/%{name}-%{version}-%{release}.x86_64\n/usr/bin/install -d /root/rpmbuild/BUILDROOT/%{name}-%{version}-%{release}.x86_64/etc/foobar.d/\n```\n\n需要说明的是，这里的 `%install` 主要就是为了后面的 `%file` 服务的。所以，还可以使用常规的系统命令：\n\n```yaml\nCopy\ninstall -d $RPM_BUILD_ROOT/\ncp -a * $RPM_BUILD_ROOT/\n```\n\n其中 `%{buildroot}` 和 `$RPMBUILDROOT` 是等价的， `%{buildroot}`必须全部用小写，不然要报错。\n\n注意区分 `$RPM_BUILD_ROOT`和 `$RPM_BUILD_DIR`：\n\n- `$RPM_BUILD_ROOT` 是指开头定义的 `BuildRoot`，是 `%file` 需要的。\n- `$RPM_BUILD_DIR` 通常就是指 `~/rpmbuild/BUILD`\n\n**scripts section 没必要可以不填[#](https://www.cnblogs.com/michael-xiang/p/10480809.html#3715799303)**\n\n- `%pre` 安装前执行的脚本\n- `%post` 安装后执行的脚本\n- `%preun` 卸载前执行的脚本\n- `%postun` 卸载后执行的脚本\n- `%pretrans` 在事务开始时执行脚本\n- `%posttrans` 在事务结束时执行脚本\n\n`%preun` `%postun` 的区别是什么呢？\n\n- 前者在升级的时候会执行，后者在升级 rpm 包的时候不会执行\n\n### 3.5 **%files 阶段**\n\n任何打包的文件，都需要在这个包的详细的文件列表中，如果是目录，包的所有者的全部目录都在中间, %dir 来指定空目录，可以用 %files -f /tmp/dyanmic_filelist 来指定一个文件列表。\n\n默认 %config 会替换掉配置，给原来的配置修改名字为 .rpmorig ,如果不想修改的话，就用%config(noreplace) 就会给新的配置文件名字命名为 .rpmnew.\n\n本段是文件段，主要用来说明会将 `%{buildroot}` 目录下的哪些文件和目录最终打包到rpm包里。定义软件包所包含的文件，分为三类：\n\n- 说明文档（doc）\n- 配置文件（config）\n- 执行程序\n\n具体一点，包含如下场景：\n\n**1. 一个文件没有被%config或%config(noreplace)指令配置**\n\n此时，不管该文件在安装完成后，有没有在本地被修改过，当升级该rpm包时，该文件会被这个新的rpm包的里的同名文件替换,（旧文件被删除）。\n\n**2. 一个文件被%config指令配置**\n\n此时包含如下情况：\n\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换掉掉旧的文件，旧的文件会被保存为xx**.rpmsave**，如/etc/redis/redis.conf.rpmsave\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换掉旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。\n\n**3. 一个文件被%config(noreplace)指令配置**\n\n此时包含如下情况：\n\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，旧文件保持不变，新rpm包里的该文件并重命名为xx**.rpmnew**,例如/etc/redis/redis.conf.rpmnew\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。\n\n[Config总结](https://www.notion.so/4842b64880d6417c89d52d92b0c4d488)\n\n| 文件标记           | 在update包中是否更新 | 本地磁盘没有被修改 | 本地磁盘被修改过                            |\n| ------------------ | -------------------- | ------------------ | ------------------------------------------- |\n| 无                 | 没更新               | 替换(旧文件删除)   | 替换(旧文件删除)                            |\n| 无                 | 更新                 | 替换(旧文件删除)   | 替换(旧文件删除)                            |\n| %config            | 没更新               | 替换(旧文件删除)   | 保留修改过的文件，不替换                    |\n| %config            | 更新                 | 替换(旧文件删除)   | 旧文件被保存为xxx.rpmsave，新文件替换旧文件 |\n| %config(noreplace) | 没更新               | 替换(旧文件删除)   | 保留修改过的文件，不替换                    |\n| %config(noreplace) | 更新                 | 替换(旧文件删除)   | 旧文件保持不变，新文件重命名为xxx.rpmnew    |\n\n[当rpm包中该文件的标记方法发生改变的两个场景：](https://www.notion.so/a35c511b8d9e460f9a2e108a20a9f345)\n\n| 文件标记                                | 在update包中是否更新 | 本地磁盘被修改过                                     |\n| --------------------------------------- | -------------------- | ---------------------------------------------------- |\n| 之前是%config(noreplace)，现在是%config | 更新                 | 文件被替换，旧文件被保存为xxx.rpmsave                |\n| 之前是%config，现在是%config(noreplace) | 更新                 | 旧文件保持不变，update包中的新文件重命名为xxx.rpmnew |\n\n[常用变量](https://www.notion.so/d9928d592b604f0990f4fe3401a645a8)\n\n| macro                | definition                | comment                                     |\n| :------------------- | :------------------------ | :------------------------------------------ |\n| `%{_sysconfdir}`     | `/etc`                    |                                             |\n| `%{_prefix}`         | `/usr`                    | can be defined to `/app` for flatpak builds |\n| `%{_exec_prefix}`    | `%{_prefix}`              | default: `/usr`                             |\n| `%{_includedir}`     | `%{_prefix}/include`      | default: `/usr/include`                     |\n| `%{_bindir}`         | `%{_exec_prefix}/bin`     | default: `/usr/bin`                         |\n| `%{_libdir}`         | `%{_exec_prefix}/%{_lib}` | default: `/usr/%{_lib}`                     |\n| `%{_libexecdir}`     | `%{_exec_prefix}/libexec` | default: `/usr/libexec`                     |\n| `%{_sbindir}`        | `%{_exec_prefix}/sbin`    | default: `/usr/sbin`                        |\n| `%{_datadir}`        | `%{_datarootdir}`         | default: `/usr/share`                       |\n| `%{_infodir}`        | `%{_datarootdir}/info`    | default: `/usr/share/info`                  |\n| `%{_mandir}`         | `%{_datarootdir}/man`     | default: `/usr/share/man`                   |\n| `%{_docdir}`         | `%{_datadir}/doc`         | default: `/usr/share/doc`                   |\n| `%{_rundir}`         | `/run`                    |                                             |\n| `%{_localstatedir}`  | `/var`                    |                                             |\n| `%{_sharedstatedir}` | `/var/lib`                |                                             |\n| `%{_lib}`            | `lib64`                   | `lib` on 32bit platforms                    |\n\n还可定义文件存取权限，拥有者及组别。\n\n这里会在虚拟根目录下进行，千万不要写绝对路径，而应用宏或变量表示相对路径。\n\n在 `%files` 阶段的第一条命令的语法是：\n\n```makefile\nCopy\n%defattr(文件权限,用户名,组名,目录权限)\n```\n\n注意点：同时需要在 `%install` 中安装。\n\n```makefile\nCopy\n%files\n%defattr (-,root,root,0755)                         ← 设定默认权限\n%config(noreplace) /etc/my.cnf                      ← 表明是配置文件，noplace表示替换文件\n%doc %{src_dir}/Docs/ChangeLog                      ← 表明这个是文档\n%attr(644, root, root) %{_mandir}/man8/mysqld.8*    ← 分别是权限，属主，属组\n%attr(755, root, root) %{_sbindir}/mysqld\n```\n\n`%exclude` 列出不想打包到 rpm 中的文件。注意：如果 `%exclude` 指定的文件不存在，也会出错的。\n\n在安装 rpm 时，会将可执行的二进制文件放在 `/usr/bin` 目录下，动态库放在 `/usr/lib` 或者 `/usr/lib64` 目录下，配置文件放在 `/etc` 目录下，并且多次安装时新的配置文件不会覆盖以前已经存在的同名配置文件。\n\n关于 `%files` 阶段有两个特性：\n\n1. `%{buildroot}` 里的所有文件都要明确被指定是否要被打包到 rpm里。什么意思呢？假如，`%{buildroot}` 目录下有 4 个目录 a、b、c和d，在 `%files` 里仅指定 a 和 b 要打包到 rpm 里，如果不把 c 和 d 用 `exclude` 声明是要报错的；\n2. 如果声明了 `%{buildroot}` 里不存在的文件或者目录也会报错。\n\n关于 `%doc` 宏，所有跟在这个宏后面的文件都来自 `%{_builddir}` 目录，当用户安装 rpm 时，由这个宏所指定的文件都会安装到 `/usr/share/doc/name-version/` 目录里。\n\n## **%clean**\n\n清理段，可以通过 `--clean` 删除 `BUILD`\n\n编译完成后一些清理工作，主要包括对 `%{buildroot}` 目录的清空(这不是必须的)，通常执行诸如 `make clean` 之类的命令。\n\n## **%changelog**\n\n本段是修改日志段，记录 spec 的修改日志段。你可以将软件的每次修改记录到这里，保存到发布的软件包中，以便查询之用。\n\n每一个修改日志都有这样一种格式：\n\n- 第一行是：`星期 月 日 年 修改人 电子信箱`。其中：星期、月份均用英文形式的前 3 个字母，用中文会报错。\n- 接下来的行写的是修改了什么地方，可写多行。一般以减号开始，便于后续的查阅。\n\n```\nCopy\n%changelog\n* Fri Dec 29 2012 foobar <foobar@kidding.com> - 1.0.0-1\n- Initial version\n```\n\n## **宏**\n\n在定义文件的安装路径时，通常会使用类似 `%_sharedstatedir` 的宏，这些宏一般会在 `/usr/lib/rpm/macros` 中定义。关于宏的语法，可以查看 [Macro syntax](https://rpm.org/user_doc/macros.html)\n\nRPM 内建宏定义在 `/usr/lib/rpm/redhat/macros` 文件中，这些宏基本上定义了目录路径或体系结构等等；同时也包含了一组用于调试 spec 文件的宏。\n\n所有宏都可以在 `/usr/lib/rpm/macros` 找到，附录一些常见的宏：\n\n```\nCopy\n%{_sysconfdir}        /etc\n%{_prefix}            /usr\n%{_exec_prefix}       %{_prefix}\n%{_bindir}            %{_exec_prefix}/bin\n%{_lib}               lib (lib64 on 64bit systems)\n%{_libdir}            %{_exec_prefix}/%{_lib}\n%{_libexecdir}        %{_exec_prefix}/libexec\n%{_sbindir}           %{_exec_prefix}/sbin\n%{_sharedstatedir}    /var/lib\n%{_datadir}           %{_prefix}/share\n%{_includedir}        %{_prefix}/include\n%{_oldincludedir}     /usr/include\n%{_infodir}           /usr/share/info\n%{_mandir}            /usr/share/man\n%{_localstatedir}     /var\n%{_initddir}          %{_sysconfdir}/rc.d/init.d\n%{_topdir}            %{getenv:HOME}/rpmbuild\n%{_builddir}          %{_topdir}/BUILD\n%{_rpmdir}            %{_topdir}/RPMS\n%{_sourcedir}         %{_topdir}/SOURCES\n%{_specdir}           %{_topdir}/SPECS\n%{_srcrpmdir}         %{_topdir}/SRPMS\n%{_buildrootdir}      %{_topdir}/BUILDROOT\n%{_var}               /var\n%{_tmppath}           %{_var}/tmp\n%{_usr}               /usr\n%{_usrsrc}            %{_usr}/src\n%{_docdir}            %{_datadir}/doc\n%{buildroot}          %{_buildrootdir}/%{name}-%{version}-%{release}.%{_arch}\n$RPM_BUILD_ROOT       %{buildroot}\n```\n\n利用 rpmbuild 构建 rpm 安装包时，通过命令 `rpm --showrc|grep prefix` 查看。\n\n通过 `rpm --eval \"%{macro}\"` 来查看具体对应路径。\n\n比如我们要查看 `%{_bindir}` 的路径，就可以使用命令 `rpm --eval \"%{ _bindir}\"` 来查看。\n\n```\nCopy\n%{_topdir}            %{getenv:HOME}/rpmbuild\n%{_builddir}          %{_topdir}/BUILD\n%{_rpmdir}            %{_topdir}/RPMS\n%{_sourcedir}         %{_topdir}/SOURCES\n%{_specdir}           %{_topdir}/SPECS\n%{_srcrpmdir}         %{_topdir}/SRPMS\n%{_buildrootdir}      %{_topdir}/BUILDROOT\n\nNote: On releases older than Fedora 10 (and EPEL), %{_buildrootdir} does not exist.\nBuild flags macros\n\n%{_global_cflags}     -O2 -g -pipe\n%{_optflags}          %{__global_cflags} -m32 -march=i386 -mtune=pentium4 # if redhat-rpm-config is installed\n```\n\n## **变量**\n\n`define` 定义的变量类似于局部变量，只在 `%{!?foo: ... }` 区间有效，不过 SPEC 并不会自动清除该变量，只有再次遇到 `%{}` 时才会清除\n\n### **define vs. global**\n\n两者都可以用来进行变量定义，不过在细节上有些许差别，简单列举如下：\n\n- `define` 用来定义宏，`global` 用来定义变量；\n- 如果定义带参数的宏 (类似于函数)，必须要使用 `define`；\n- 在 `%{}` 内部，必须要使用 `global` 而非 `define`；\n- `define` 在使用时计算其值，而 `global` 则在定义时就计算其值；\n\n可以简单参考如下的示例。\n\n```\nCopy\n#--- %prep之前的参数是必须要有的\nName:           mysql\nVersion:        5.7.17\nRelease:        1%{?dist}\nSummary:        MySQL from FooBar.\nLicense:        GPLv2+ and BSD\n\n%description\nIt is a MySQL from FooBar.\n\n%prep\n#--- 带参数时，必须使用%define定义\n%define myecho() echo %1 %2\n%{!?bar: %define bar defined}\n\necho 1: %{bar}\n%{myecho 2: %{bar}}\necho 3: %{bar}\n\n# 如下是输出内容\n#1: defined\n#2: defined\n#3: %{bar}\n```\n\n3 的输出是不符合预期的，可以将 `%define` 修改为 `global` 即可\n\n### **%{?dist} 表示什么含义？**\n\n不加问号，如果 `dist` 有定义，那么就会用定义的值替换，否则就会保 `%{dist}`;加问好，如果 `dist` 有定义，那么也是会用定义的值替换，否则就直接移除这个tag `%{?dist}`\n\n举例：\n\n```\nCopy\n$ rpm -E 'foo:%{foo}'$'\\\\n''bar:%{?bar}'\nfoo:%{foo}\nbar:\n\n$ rpm -D'foo foov' -E 'foo:%{foo}'$'\\\\n''bar:%{?bar}'\nfoo:foov\nbar:\n\n$ rpm -D'foo foov' -D'bar barv' -E 'foo:%{foo}'$'\\\\n''bar:%{?bar}'\nfoo:foov\nbar:barv\n```","source":"_posts/linux_md/Makefile/SPEC 基础知识.md","raw":"---\ntitle: SPEC文件基础知识\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 个人项目\nabbrlink: 13014\ncover: \n---\n# SPEC **文件基础知识**\n\n制作 rpm 软件包并不是一件复杂的工作，其中的关键在于编写软件包的 spec 描述文件。要想制作一个 rpm 软件包就必须写一个软件包描述文件 spec。这个文件中包含了软件包的诸多信息，如：软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。在实际过程中，最关键的地方是要清楚虚拟路径的位置，以及宏的定义。\n\n**Mandatory parameters to be present in SPEC file to build and generate RPM**\n\nBelow options are mandatory to be present in SPEC file\n\nName, Version, Release, Summary, License, description, install and files\n\n```makefile\nName:           test-dev\nVersion:        %{_version}\nRelease:        %{_release}\nSummary:        <update details>\nLicense:        Nokia License\n%description\n<update your description>\n%install\nmake -C %{buildroot}/.. install DESTDIR=\"%{buildroot}\"\n%files\n%{_bindir}\n```\n\n## 1. **文件头**\n\n语法：`TagName: value`，比如`Version: 2.1.0`，tag名大小写**不敏感**。\n\nspec支持定义宏，要定义宏，使用：`%define testMacro 2`，这里定义了一个宏，名称为testMacro，值为2，要使用这个宏，使用`%{testMacro}`或者`%testMacro`。\n\n这个区域定义的 `Name`、`Version` 这些字段对应的值可以在后面通过 `%{name}`,`%{version}` 这样的方式来引用，类似于 C 语言中的宏：\n\n- `Summary`：用一句话概括该软件s包尽量多的信息。\n\n- `Name`：软件包的名字，最终 rpm 软件包是用该名字与版本号（`Version`）、释出号(`Release`）及体系号来命名软件包的，后面可使用 `%{name}` 的方式引用\n\n- `Version`：软件版本号。仅当软件包比以前有较大改变时才增加版本号，后面可使用`%{version}`引用\n\n- `Release`：软件包释出号/发行号。一般我们对该软件包做了一些小的补丁的时候就应该把释出号加 1，后面可使用 `%{release}` 引用\n\n- `Packager`：打包的人（一般喜欢写个人邮箱）\n\n- `Vendor`：软件开发者的名字，发行商或打包组织的信息，例如`RedFlagCo,Ltd`\n\n- `License`：软件授权方式，通常是GPL（自由软件）或GPLv2,BSD\n\n- `Copyright`：软件包所采用的版权规则。具体有：\n\n    - `GPL（自由软件）`，\n\n    - `BSD`，\n\n    - `MIT`，\n\n    - `Public Domain（公共域）`，\n\n    - `Distributable（贡献）`，\n\n    - `commercial（商业）`，\n\n    - `Share（共享）`\n\n        一般的开发都写 `GPL`。\n\n- `Group`：软件包所属类别\n  \n    - Development/System （开发/系统）\n- System Environment/Daemons （系统环境/守护）\n  \n- `Source0`：源程序软件包的名字/源代码包的名字，如 `stardict-2.0.tar.gz`。可以带多个用 `Source1`、`Source2` 等源，后面也可以用 `%{source1}`、`%{source2}` 引用\n\n```makefile\nCopy\nSource0: %{name}-boost-%{version}.tar.gz    ← 源码包名称(可以使用URL)，可以用SourceN指定多个，如配置文件\n#Patch0: some-bugs0.patch                    ← 如果需要打补丁，则依次填写\n#Patch1: some-bugs1.patch                    ← 如果需要打补丁，则依次填写\n```\n\n## 2. 依赖关系\n\n依赖关系定义了一个包正常工作需要依赖的其他包，RPM在升级、安装和删除的时候会确保依赖关系得到满足。\n\n- `BuildRequires`: 制作过程中用到的软件包，构建依赖\n\n- `Requires`: 安装时所需软件包\n    - `Requires(pre)`: 指定不同阶段的依赖\n    \n- `BuildRoot`: 这个是安装或编译时使用的「虚拟目录」，打包时会用到该目录下文件，可查看安装后文件路径，例如：`BuildRoot: %_topdir/BUILDROOT`。\n\n- `Prefix: %{_prefix}` 这个主要是为了解决今后安装 rpm 包时，并不一定把软件安装到 rpm 中打包的目录的情况。这样，必须在这里定义该标识，并在编写 `%install` 脚本的时候引用，才能实现 rpm 安装时重新指定位置的功能\n\n- `BuildArch`: 指编译的目标处理器架构，`noarch` 标识不指定，但通常都是以 `/usr/lib/rpm/marcros` 中的内容为默认值\n\n- `%description`：软件包详细说明，可写在多个行上。这样任何人使用 `rpm -qi`查询您的软件包时都可以看到它。您可以解释这个软件包做什么，描述任何警告或附加的配置指令，等等。\n\n- `URL`：软件的主页\n\n### 2.1 **RPM 包信息查看**\n\n- 我通过命令查看了 nginx 包的信息，如下：\n\n    ```bash\n    Copy\n    # 查看头部信息\n    \n    $ rpm -qpi ./nginx-1.12.2-2.el7.x86_64.rpm\n    Name        : nginx\n    Epoch       : 1\n    Version     : 1.12.2\n    Release     : 2.el7\n    Architecture: x86_64\n    Install Date: (not installed)\n    Group       : System Environment/Daemons\n    Size        : 1574949\n    License     : BSD\n    Signature   : RSA/SHA256, Tue 06 Mar 2018 05:44:06 PM CST, Key ID 6a2faea2352c64e5\n    Source RPM  : nginx-1.12.2-2.el7.src.rpm\n    Build Date  : Tue 06 Mar 2018 05:27:44 PM CST\n    Build Host  : buildhw-02.phx2.fedoraproject.org\n    Relocations : (not relocatable)\n    Packager    : Fedora Project\n    Vendor      : Fedora Project\n    URL         : <http://nginx.org/>\n    Bug URL     : <https://bugz.fedoraproject.org/nginx>\n    Summary     : A high performance web server and reverse proxy server\n    Description :\n    Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and\n    IMAP protocols, with a strong focus on high concurrency, performance and low\n    memory usage.\n    \n    # 查看脚本内容\n    \n    $ rpm --scripts -qp ./nginx-1.12.2-2.el7.x86_64.rpm\n    postinstall scriptlet (using /bin/sh):\n    \n    if [ $1 -eq 1 ] ; then\n            # Initial installation\n            systemctl preset nginx.service >/dev/null 2>&1 || :\n    fi\n    preuninstall scriptlet (using /bin/sh):\n    \n    if [ $1 -eq 0 ] ; then\n            # Package removal, not upgrade\n            systemctl --no-reload disable nginx.service > /dev/null 2>&1 || :\n            systemctl stop nginx.service > /dev/null 2>&1 || :\n    fi\n    postuninstall scriptlet (using /bin/sh):\n    \n    systemctl daemon-reload >/dev/null 2>&1 || :\n    \n    if [ $1 -ge 1 ]; then\n        /usr/bin/nginx-upgrade >/dev/null 2>&1 || :\n    fi\n    ```\n\n### 2.2 **BuildRequires**\n\n定义构建时依赖的软件包，在构建机器编译 rpm 包时需要的辅助工具，以逗号分隔。\n\n假如，要求编译 `myapp` 时，gcc 的版本至少为 4.4.2，则可以写成 `gcc >=4.2.2`\n\n### 2.3 **Requires**\n\n定义安装时的依赖包，该 rpm 包所依赖的软件包名称，就是指编译好的 rpm 软件在其他机器上安装时，需要依赖的其他软件包。\n\n可以用 `>=` 或 `<=` 表示大于或小于某一特定版本。 `>=` 号两边需用空格隔开，而不同软件名称也用空格分开。\n\n格式：\n\n```\nCopy\nRequires:       libpng-devel >= 1.0.20 zlib\n```\n\n其它写法例如：\n\n```\nCopy\nRequires: bzip2 = %{version}, bzip2-libs =%{version}\n```\n\n还有例如`PreReq`、`Requires(pre)`、`Requires(post)`、`Requires(preun)`、`Requires(postun)`、`BuildRequires`等都是针对不同阶段的依赖指定。\n\n关于`pre`、`post`、`preun`、`postun`含义理解，感觉`post`有一种“完成”的意思：\n\n```\nCopy\n# 安装前执行的脚本，语法和shell脚本的语法相同\n%pre\n# 安装后执行的脚本\n%post\n# 卸载前执行的脚本\n%preun\n# 卸载完成后执行的脚本\n%postun\n# 清理阶段，在制作完成后删除安装的内容\n```\n\n例如：\n\n```\nCopy\nPreReq: capability>=version      #capability包必须先安装\nConflicts:bash>=2.0              #该包和所有不小于2.0的bash包有冲突\n```\n\n![image-20210315162108826](SPEC%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210315162108826.png)\n\n### 2.4 **BuildRoot**\n\n该参数非常重要，因为在生成 rpm 的过程中，执行 `make install` 时就会把软件安装到上述的路径中，在打包的时候，同样依赖“虚拟目录”为“根目录”进行操作。后面可使用 `$RPM_BUILD_ROOT` 方式引用。\n\n考虑到多用户的环境，一般定义为：\n\n```\nCopy\n%{_tmppath}/%{name}-%{version}-%{release}-root\n# OR\n%{_tmppath}/%{name}-%{version}-%{release}-buildroot-%(%{__id_u} -n}\n```\n\n## 3. 预处理 %prep\n\n这个阶段是「预处理」，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备。\n\n`%prep` 和下面的 `%build`，`%install` 段一样，除了可以执行 rpm 所定义的宏命令（以`%`开头）以外，还可以执行 `SHELL` 命令，命令可以有很多行，如我们常写的 `tar` 解包命令。功能上类似于 `./configure`。\n\n`%prep` 阶段进行实际的打包准备工作，它是使用节前缀 `%prep` 表示的。主要功能有：\n\n- 将文件 ( `SOURCES/`) 解压到构建目录 (`BUILD/`)\n- 应用 `Patch`（打补丁） (`SOURCES/ => BUILD/`)\n- 描述 `rm -rf $RPM_BUILD_ROOT`\n- 描述或编辑本部分用到的命令到 `PreReq`\n- 通过 `b .XXX` 描述补丁备份\n\n它一般包含 `%setup` 与 `%patch` 两个命令。`%setup` 用于将软件包打开，执行 `%patch` 可将补丁文件加入解开的源程序中。\n\n示例：\n\n```bash\nCopy\n%prep\n%setup -q                                     ← 宏的作用是解压并切换到目录\n#%patch0 -p1                                  ← 如果需要打补丁，则依次写\n#%patch1 -p1                                  ← 如果需要打补丁，则依次写\n```\n\n### 3.1 宏 **%setup**\n\n这个宏解压源代码，将当前目录改为源代码解压之后产生的目录。这个宏还有一些选项可以用。例如，在解压后，`%setup` 宏假设产生的目录是 `%{name}-%{version}`\n\n```\nCopy\n%setup -n %{name}-%{version} #把源码包解压并放好\n```\n\n主要的用途就是将 `%sourcedir` 目录下的源代码解压到 `%builddir` 目录下，也就是将`~/rpmbuild/SOURCES` 里的包解压到 `~/rpmbuild/BUILD/%{name}-%{version}` 中。一般用 `%setup -c` 就可以了，但有两种情况：\n\n- 一就是同时编译多个源码包，\n- 二就是源码的 tar 包的名称与解压出来的目录不一致，此时，就需要使用 `n` 参数指定一下。\n\n```yaml\nCopy\n%setup 不加任何选项，仅将软件包打开。\n%setup -a 切换目录前，解压指定 Source 文件，例如 `-a 0` 表示解压 `Source0`\n%setup -n newdir 将软件包解压在newdir目录。\n%setup -c 解压缩之前先产生目录。\n%setup -b num 将第 num 个 source 文件解压缩。\n%setup -D 解压前不删除目录\n%setup -T 不使用default的解压缩操作。\n%setup -T -b 0 将第 0 个源代码文件解压缩。\n%setup -c -n newdir 指定目录名称 newdir，并在此目录产生 rpm 套件。\n%patch 最简单的补丁方式，自动指定patch level。\n%patch 0 使用第0个补丁文件，相当于%patch ?p 0。\n%patch -s 不显示打补丁时的信息。\n%patch -T 将所有打补丁时产生的输出文件删除\n```\n\n应该 `-q` 参数给 `%setup` 宏。这会显著减少编译日志文件的输出，尤其是源代码包会解压出一堆文件的时候。\n\n在 `~/rmpbuild/BUILD/%{name}-%{version}` 目录中进行 ，使用标准写法，会引用`/usr/lib/rpm/marcros` 中定义的参数。\n\n### 3.2 宏 **%patch**\n\n这个宏将头部定义的补丁应用于源代码。如果定义了多个补丁，它可以用一个数字的参数来指示应用哪个补丁文件。它也接受 `-b extension` 参数，指示 RPM 在打补丁之前，将文件备份为扩展名是 `extension` 的文件。\n\n通常补丁都会一起在源码 `tar.gz` 包中，或放到 `SOURCES` 目录下。一般参数为：\n\n- `%patch -p1` 使用前面定义的 `Patch` 补丁进行，`p1`是忽略 `patch` 的第一层目录\n- `%Patch2 -p1 -b xxx.patch`打上指定的补丁，`b`是指生成备份文件\n\n### 3.3 **%build 阶段**\n\n本段是「构建」阶段，这个阶段会在 `%_builddir` 目录下执行源码包的编译。一般是执行执行常见的 `configure` 和 `make` 操作。\n\n该阶段一般由多个 `make` 命令组成。与 `%prep` 段落一样，这些命令可以是 `shell` 命令，也可以是宏。\n\n记住两点：\n\n1. `%build` 和 `%install` 的过程中，都必须把编译和安装的文件定义到“虚拟根目录” 中\n2. `%file` 中必须明白，用的是相对目录\n\n这个阶段我们最常见只有两条指令：\n\n```\nCopy\n%configure\nmake %{?_smp_mflags} OPTIMIZE=\"%{optflags}\"           ← 多核则并行编译\n```\n\n`%configure` 这个不是关键字，而是 rpm 定义的标准宏命令。意思是执行源代码的`configure`配置。会自动将 `prefix` 设置成 `/usr`。\n\n这个 `%{?_smp_mflags} %{optflags}` 是什么意思呢？\n\n```go\nCopy\n$ rpm --eval \"%{?_smp_mflags}\"\n-j4\n$ rpm --eval \"%{optflags}\"\n-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches   -m64 -mtune=generic\n```\n\n所以，上面那个命令就是 `make -j4`。问题又来了，`make -j4` 表示什么意思？\n\n> 都是一些优化参数\n\n- [Linux kernel 笔记 （26）——利用“make -j”提高编译`kernel`速度](https://nanxiao.me/linux-kernel-note-26-make-j/)\n- [CSDB-make -j4是什么意思](https://bbs.csdn.net/topics/380072770)\n\n### 3.4 **%install 阶段**\n\n「安装」阶段，就是执行 `make install` 命令操作。开始把软件安装到虚拟的根目录中。这个阶段会在 `%buildrootdir` 目录里建好目录结构，然后将需要打包到 rpm 软件包里的文件从 `%builddir` 里拷贝到 `%_buildrootdir` 里对应的目录里。\n\n在 `~/rpmbuild/BUILD/%{name}-%{version}` 目录中进行 `make install` 的操作。`%install` 很重要，因为如果这里的路径不对的话，则下面 `%file` 中寻找文件的时候就会失败。\n\n特别需要注意的是：`%install` 部分使用的是绝对路径，而 `%file` 部分使用则是相对路径，虽然其描述的是同一个地方。千万不要写错。\n\n将已编译的软件安装到虚拟的目录结构中，从而可以打包成一个 RPM。当用户最终用 `rpm -ivh name-version.rpm` 安装软件包时，这些文件会安装到用户系统中相应的目录里。\n\n```yaml\nCopy\n%install\nif [-d %{buildroot}]; then\n   rm -rf %{buildroot}                      ← 清空下安装目录，实际会自动清除\nfi\nmake install DESTDIR=%{buildroot}           ← 安装到buildroot目录下\n%{__install} -Dp -m0755 contrib/init.d %{buildroot}%{_initrddir}/foobar\n%{__install} -d %{buildroot}%{_sysconfdir}/foobar.d/\n```\n\n「翻译」一下：\n\n```yaml\nCopy\nmake install DESTDIR=/root/rpmbuild/BUILDROOT/%{name}-%{version}-%{release}.x86_64\nmake install DESTDIR=/root/rpmbuild/BUILDROOT/%{name}-%{version}-%{release}.x86_64\n/usr/bin/install -d /root/rpmbuild/BUILDROOT/%{name}-%{version}-%{release}.x86_64/etc/foobar.d/\n```\n\n需要说明的是，这里的 `%install` 主要就是为了后面的 `%file` 服务的。所以，还可以使用常规的系统命令：\n\n```yaml\nCopy\ninstall -d $RPM_BUILD_ROOT/\ncp -a * $RPM_BUILD_ROOT/\n```\n\n其中 `%{buildroot}` 和 `$RPMBUILDROOT` 是等价的， `%{buildroot}`必须全部用小写，不然要报错。\n\n注意区分 `$RPM_BUILD_ROOT`和 `$RPM_BUILD_DIR`：\n\n- `$RPM_BUILD_ROOT` 是指开头定义的 `BuildRoot`，是 `%file` 需要的。\n- `$RPM_BUILD_DIR` 通常就是指 `~/rpmbuild/BUILD`\n\n**scripts section 没必要可以不填[#](https://www.cnblogs.com/michael-xiang/p/10480809.html#3715799303)**\n\n- `%pre` 安装前执行的脚本\n- `%post` 安装后执行的脚本\n- `%preun` 卸载前执行的脚本\n- `%postun` 卸载后执行的脚本\n- `%pretrans` 在事务开始时执行脚本\n- `%posttrans` 在事务结束时执行脚本\n\n`%preun` `%postun` 的区别是什么呢？\n\n- 前者在升级的时候会执行，后者在升级 rpm 包的时候不会执行\n\n### 3.5 **%files 阶段**\n\n任何打包的文件，都需要在这个包的详细的文件列表中，如果是目录，包的所有者的全部目录都在中间, %dir 来指定空目录，可以用 %files -f /tmp/dyanmic_filelist 来指定一个文件列表。\n\n默认 %config 会替换掉配置，给原来的配置修改名字为 .rpmorig ,如果不想修改的话，就用%config(noreplace) 就会给新的配置文件名字命名为 .rpmnew.\n\n本段是文件段，主要用来说明会将 `%{buildroot}` 目录下的哪些文件和目录最终打包到rpm包里。定义软件包所包含的文件，分为三类：\n\n- 说明文档（doc）\n- 配置文件（config）\n- 执行程序\n\n具体一点，包含如下场景：\n\n**1. 一个文件没有被%config或%config(noreplace)指令配置**\n\n此时，不管该文件在安装完成后，有没有在本地被修改过，当升级该rpm包时，该文件会被这个新的rpm包的里的同名文件替换,（旧文件被删除）。\n\n**2. 一个文件被%config指令配置**\n\n此时包含如下情况：\n\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换掉掉旧的文件，旧的文件会被保存为xx**.rpmsave**，如/etc/redis/redis.conf.rpmsave\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换掉旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。\n\n**3. 一个文件被%config(noreplace)指令配置**\n\n此时包含如下情况：\n\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，旧文件保持不变，新rpm包里的该文件并重命名为xx**.rpmnew**,例如/etc/redis/redis.conf.rpmnew\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）\n- 该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行`rpm -Uvh xxxx`时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。\n\n[Config总结](https://www.notion.so/4842b64880d6417c89d52d92b0c4d488)\n\n| 文件标记           | 在update包中是否更新 | 本地磁盘没有被修改 | 本地磁盘被修改过                            |\n| ------------------ | -------------------- | ------------------ | ------------------------------------------- |\n| 无                 | 没更新               | 替换(旧文件删除)   | 替换(旧文件删除)                            |\n| 无                 | 更新                 | 替换(旧文件删除)   | 替换(旧文件删除)                            |\n| %config            | 没更新               | 替换(旧文件删除)   | 保留修改过的文件，不替换                    |\n| %config            | 更新                 | 替换(旧文件删除)   | 旧文件被保存为xxx.rpmsave，新文件替换旧文件 |\n| %config(noreplace) | 没更新               | 替换(旧文件删除)   | 保留修改过的文件，不替换                    |\n| %config(noreplace) | 更新                 | 替换(旧文件删除)   | 旧文件保持不变，新文件重命名为xxx.rpmnew    |\n\n[当rpm包中该文件的标记方法发生改变的两个场景：](https://www.notion.so/a35c511b8d9e460f9a2e108a20a9f345)\n\n| 文件标记                                | 在update包中是否更新 | 本地磁盘被修改过                                     |\n| --------------------------------------- | -------------------- | ---------------------------------------------------- |\n| 之前是%config(noreplace)，现在是%config | 更新                 | 文件被替换，旧文件被保存为xxx.rpmsave                |\n| 之前是%config，现在是%config(noreplace) | 更新                 | 旧文件保持不变，update包中的新文件重命名为xxx.rpmnew |\n\n[常用变量](https://www.notion.so/d9928d592b604f0990f4fe3401a645a8)\n\n| macro                | definition                | comment                                     |\n| :------------------- | :------------------------ | :------------------------------------------ |\n| `%{_sysconfdir}`     | `/etc`                    |                                             |\n| `%{_prefix}`         | `/usr`                    | can be defined to `/app` for flatpak builds |\n| `%{_exec_prefix}`    | `%{_prefix}`              | default: `/usr`                             |\n| `%{_includedir}`     | `%{_prefix}/include`      | default: `/usr/include`                     |\n| `%{_bindir}`         | `%{_exec_prefix}/bin`     | default: `/usr/bin`                         |\n| `%{_libdir}`         | `%{_exec_prefix}/%{_lib}` | default: `/usr/%{_lib}`                     |\n| `%{_libexecdir}`     | `%{_exec_prefix}/libexec` | default: `/usr/libexec`                     |\n| `%{_sbindir}`        | `%{_exec_prefix}/sbin`    | default: `/usr/sbin`                        |\n| `%{_datadir}`        | `%{_datarootdir}`         | default: `/usr/share`                       |\n| `%{_infodir}`        | `%{_datarootdir}/info`    | default: `/usr/share/info`                  |\n| `%{_mandir}`         | `%{_datarootdir}/man`     | default: `/usr/share/man`                   |\n| `%{_docdir}`         | `%{_datadir}/doc`         | default: `/usr/share/doc`                   |\n| `%{_rundir}`         | `/run`                    |                                             |\n| `%{_localstatedir}`  | `/var`                    |                                             |\n| `%{_sharedstatedir}` | `/var/lib`                |                                             |\n| `%{_lib}`            | `lib64`                   | `lib` on 32bit platforms                    |\n\n还可定义文件存取权限，拥有者及组别。\n\n这里会在虚拟根目录下进行，千万不要写绝对路径，而应用宏或变量表示相对路径。\n\n在 `%files` 阶段的第一条命令的语法是：\n\n```makefile\nCopy\n%defattr(文件权限,用户名,组名,目录权限)\n```\n\n注意点：同时需要在 `%install` 中安装。\n\n```makefile\nCopy\n%files\n%defattr (-,root,root,0755)                         ← 设定默认权限\n%config(noreplace) /etc/my.cnf                      ← 表明是配置文件，noplace表示替换文件\n%doc %{src_dir}/Docs/ChangeLog                      ← 表明这个是文档\n%attr(644, root, root) %{_mandir}/man8/mysqld.8*    ← 分别是权限，属主，属组\n%attr(755, root, root) %{_sbindir}/mysqld\n```\n\n`%exclude` 列出不想打包到 rpm 中的文件。注意：如果 `%exclude` 指定的文件不存在，也会出错的。\n\n在安装 rpm 时，会将可执行的二进制文件放在 `/usr/bin` 目录下，动态库放在 `/usr/lib` 或者 `/usr/lib64` 目录下，配置文件放在 `/etc` 目录下，并且多次安装时新的配置文件不会覆盖以前已经存在的同名配置文件。\n\n关于 `%files` 阶段有两个特性：\n\n1. `%{buildroot}` 里的所有文件都要明确被指定是否要被打包到 rpm里。什么意思呢？假如，`%{buildroot}` 目录下有 4 个目录 a、b、c和d，在 `%files` 里仅指定 a 和 b 要打包到 rpm 里，如果不把 c 和 d 用 `exclude` 声明是要报错的；\n2. 如果声明了 `%{buildroot}` 里不存在的文件或者目录也会报错。\n\n关于 `%doc` 宏，所有跟在这个宏后面的文件都来自 `%{_builddir}` 目录，当用户安装 rpm 时，由这个宏所指定的文件都会安装到 `/usr/share/doc/name-version/` 目录里。\n\n## **%clean**\n\n清理段，可以通过 `--clean` 删除 `BUILD`\n\n编译完成后一些清理工作，主要包括对 `%{buildroot}` 目录的清空(这不是必须的)，通常执行诸如 `make clean` 之类的命令。\n\n## **%changelog**\n\n本段是修改日志段，记录 spec 的修改日志段。你可以将软件的每次修改记录到这里，保存到发布的软件包中，以便查询之用。\n\n每一个修改日志都有这样一种格式：\n\n- 第一行是：`星期 月 日 年 修改人 电子信箱`。其中：星期、月份均用英文形式的前 3 个字母，用中文会报错。\n- 接下来的行写的是修改了什么地方，可写多行。一般以减号开始，便于后续的查阅。\n\n```\nCopy\n%changelog\n* Fri Dec 29 2012 foobar <foobar@kidding.com> - 1.0.0-1\n- Initial version\n```\n\n## **宏**\n\n在定义文件的安装路径时，通常会使用类似 `%_sharedstatedir` 的宏，这些宏一般会在 `/usr/lib/rpm/macros` 中定义。关于宏的语法，可以查看 [Macro syntax](https://rpm.org/user_doc/macros.html)\n\nRPM 内建宏定义在 `/usr/lib/rpm/redhat/macros` 文件中，这些宏基本上定义了目录路径或体系结构等等；同时也包含了一组用于调试 spec 文件的宏。\n\n所有宏都可以在 `/usr/lib/rpm/macros` 找到，附录一些常见的宏：\n\n```\nCopy\n%{_sysconfdir}        /etc\n%{_prefix}            /usr\n%{_exec_prefix}       %{_prefix}\n%{_bindir}            %{_exec_prefix}/bin\n%{_lib}               lib (lib64 on 64bit systems)\n%{_libdir}            %{_exec_prefix}/%{_lib}\n%{_libexecdir}        %{_exec_prefix}/libexec\n%{_sbindir}           %{_exec_prefix}/sbin\n%{_sharedstatedir}    /var/lib\n%{_datadir}           %{_prefix}/share\n%{_includedir}        %{_prefix}/include\n%{_oldincludedir}     /usr/include\n%{_infodir}           /usr/share/info\n%{_mandir}            /usr/share/man\n%{_localstatedir}     /var\n%{_initddir}          %{_sysconfdir}/rc.d/init.d\n%{_topdir}            %{getenv:HOME}/rpmbuild\n%{_builddir}          %{_topdir}/BUILD\n%{_rpmdir}            %{_topdir}/RPMS\n%{_sourcedir}         %{_topdir}/SOURCES\n%{_specdir}           %{_topdir}/SPECS\n%{_srcrpmdir}         %{_topdir}/SRPMS\n%{_buildrootdir}      %{_topdir}/BUILDROOT\n%{_var}               /var\n%{_tmppath}           %{_var}/tmp\n%{_usr}               /usr\n%{_usrsrc}            %{_usr}/src\n%{_docdir}            %{_datadir}/doc\n%{buildroot}          %{_buildrootdir}/%{name}-%{version}-%{release}.%{_arch}\n$RPM_BUILD_ROOT       %{buildroot}\n```\n\n利用 rpmbuild 构建 rpm 安装包时，通过命令 `rpm --showrc|grep prefix` 查看。\n\n通过 `rpm --eval \"%{macro}\"` 来查看具体对应路径。\n\n比如我们要查看 `%{_bindir}` 的路径，就可以使用命令 `rpm --eval \"%{ _bindir}\"` 来查看。\n\n```\nCopy\n%{_topdir}            %{getenv:HOME}/rpmbuild\n%{_builddir}          %{_topdir}/BUILD\n%{_rpmdir}            %{_topdir}/RPMS\n%{_sourcedir}         %{_topdir}/SOURCES\n%{_specdir}           %{_topdir}/SPECS\n%{_srcrpmdir}         %{_topdir}/SRPMS\n%{_buildrootdir}      %{_topdir}/BUILDROOT\n\nNote: On releases older than Fedora 10 (and EPEL), %{_buildrootdir} does not exist.\nBuild flags macros\n\n%{_global_cflags}     -O2 -g -pipe\n%{_optflags}          %{__global_cflags} -m32 -march=i386 -mtune=pentium4 # if redhat-rpm-config is installed\n```\n\n## **变量**\n\n`define` 定义的变量类似于局部变量，只在 `%{!?foo: ... }` 区间有效，不过 SPEC 并不会自动清除该变量，只有再次遇到 `%{}` 时才会清除\n\n### **define vs. global**\n\n两者都可以用来进行变量定义，不过在细节上有些许差别，简单列举如下：\n\n- `define` 用来定义宏，`global` 用来定义变量；\n- 如果定义带参数的宏 (类似于函数)，必须要使用 `define`；\n- 在 `%{}` 内部，必须要使用 `global` 而非 `define`；\n- `define` 在使用时计算其值，而 `global` 则在定义时就计算其值；\n\n可以简单参考如下的示例。\n\n```\nCopy\n#--- %prep之前的参数是必须要有的\nName:           mysql\nVersion:        5.7.17\nRelease:        1%{?dist}\nSummary:        MySQL from FooBar.\nLicense:        GPLv2+ and BSD\n\n%description\nIt is a MySQL from FooBar.\n\n%prep\n#--- 带参数时，必须使用%define定义\n%define myecho() echo %1 %2\n%{!?bar: %define bar defined}\n\necho 1: %{bar}\n%{myecho 2: %{bar}}\necho 3: %{bar}\n\n# 如下是输出内容\n#1: defined\n#2: defined\n#3: %{bar}\n```\n\n3 的输出是不符合预期的，可以将 `%define` 修改为 `global` 即可\n\n### **%{?dist} 表示什么含义？**\n\n不加问号，如果 `dist` 有定义，那么就会用定义的值替换，否则就会保 `%{dist}`;加问好，如果 `dist` 有定义，那么也是会用定义的值替换，否则就直接移除这个tag `%{?dist}`\n\n举例：\n\n```\nCopy\n$ rpm -E 'foo:%{foo}'$'\\\\n''bar:%{?bar}'\nfoo:%{foo}\nbar:\n\n$ rpm -D'foo foov' -E 'foo:%{foo}'$'\\\\n''bar:%{?bar}'\nfoo:foov\nbar:\n\n$ rpm -D'foo foov' -D'bar barv' -E 'foo:%{foo}'$'\\\\n''bar:%{?bar}'\nfoo:foov\nbar:barv\n```","slug":"linux_md/Makefile/SPEC 基础知识","published":1,"updated":"2021-04-08T14:11:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6b003uw9q93m6g9yl2","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"SPEC-文件基础知识\"><a href=\"#SPEC-文件基础知识\" class=\"headerlink\" title=\"SPEC 文件基础知识\"></a>SPEC <strong>文件基础知识</strong></h1><p>制作 rpm 软件包并不是一件复杂的工作，其中的关键在于编写软件包的 spec 描述文件。要想制作一个 rpm 软件包就必须写一个软件包描述文件 spec。这个文件中包含了软件包的诸多信息，如：软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。在实际过程中，最关键的地方是要清楚虚拟路径的位置，以及宏的定义。</p>\n<p><strong>Mandatory parameters to be present in SPEC file to build and generate RPM</strong></p>\n<p>Below options are mandatory to be present in SPEC file</p>\n<p>Name, Version, Release, Summary, License, description, install and files</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">Name:           test-dev</span></span><br><span class=\"line\"><span class=\"section\">Version:        %&#123;_version&#125;</span></span><br><span class=\"line\"><span class=\"section\">Release:        %&#123;_release&#125;</span></span><br><span class=\"line\"><span class=\"section\">Summary:        &lt;update details&gt;</span></span><br><span class=\"line\"><span class=\"section\">License:        Nokia License</span></span><br><span class=\"line\">%description</span><br><span class=\"line\">&lt;update your description&gt;</span><br><span class=\"line\">%install</span><br><span class=\"line\">make -C %&#123;buildroot&#125;/.. install DESTDIR=<span class=\"string\">&quot;%&#123;buildroot&#125;&quot;</span></span><br><span class=\"line\">%files</span><br><span class=\"line\">%&#123;_bindir&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-文件头\"><a href=\"#1-文件头\" class=\"headerlink\" title=\"1. 文件头\"></a>1. <strong>文件头</strong></h2><p>语法：<code>TagName: value</code>，比如<code>Version: 2.1.0</code>，tag名大小写<strong>不敏感</strong>。</p>\n<p>spec支持定义宏，要定义宏，使用：<code>%define testMacro 2</code>，这里定义了一个宏，名称为testMacro，值为2，要使用这个宏，使用<code>%&#123;testMacro&#125;</code>或者<code>%testMacro</code>。</p>\n<p>这个区域定义的 <code>Name</code>、<code>Version</code> 这些字段对应的值可以在后面通过 <code>%&#123;name&#125;</code>,<code>%&#123;version&#125;</code> 这样的方式来引用，类似于 C 语言中的宏：</p>\n<ul>\n<li><p><code>Summary</code>：用一句话概括该软件s包尽量多的信息。</p>\n</li>\n<li><p><code>Name</code>：软件包的名字，最终 rpm 软件包是用该名字与版本号（<code>Version</code>）、释出号(<code>Release</code>）及体系号来命名软件包的，后面可使用 <code>%&#123;name&#125;</code> 的方式引用</p>\n</li>\n<li><p><code>Version</code>：软件版本号。仅当软件包比以前有较大改变时才增加版本号，后面可使用<code>%&#123;version&#125;</code>引用</p>\n</li>\n<li><p><code>Release</code>：软件包释出号/发行号。一般我们对该软件包做了一些小的补丁的时候就应该把释出号加 1，后面可使用 <code>%&#123;release&#125;</code> 引用</p>\n</li>\n<li><p><code>Packager</code>：打包的人（一般喜欢写个人邮箱）</p>\n</li>\n<li><p><code>Vendor</code>：软件开发者的名字，发行商或打包组织的信息，例如<code>RedFlagCo,Ltd</code></p>\n</li>\n<li><p><code>License</code>：软件授权方式，通常是GPL（自由软件）或GPLv2,BSD</p>\n</li>\n<li><p><code>Copyright</code>：软件包所采用的版权规则。具体有：</p>\n<ul>\n<li><p><code>GPL（自由软件）</code>，</p>\n</li>\n<li><p><code>BSD</code>，</p>\n</li>\n<li><p><code>MIT</code>，</p>\n</li>\n<li><p><code>Public Domain（公共域）</code>，</p>\n</li>\n<li><p><code>Distributable（贡献）</code>，</p>\n</li>\n<li><p><code>commercial（商业）</code>，</p>\n</li>\n<li><p><code>Share（共享）</code></p>\n<p>  一般的开发都写 <code>GPL</code>。</p>\n</li>\n</ul>\n</li>\n<li><p><code>Group</code>：软件包所属类别</p>\n<ul>\n<li>Development/System （开发/系统）</li>\n</ul>\n</li>\n<li><p>System Environment/Daemons （系统环境/守护）</p>\n</li>\n<li><p><code>Source0</code>：源程序软件包的名字/源代码包的名字，如 <code>stardict-2.0.tar.gz</code>。可以带多个用 <code>Source1</code>、<code>Source2</code> 等源，后面也可以用 <code>%&#123;source1&#125;</code>、<code>%&#123;source2&#125;</code> 引用</p>\n</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\"><span class=\"section\">Source0: %&#123;name&#125;-boost-%&#123;version&#125;.tar.gz    ← 源码包名称(可以使用URL)，可以用SourceN指定多个，如配置文件</span></span><br><span class=\"line\"><span class=\"comment\">#Patch0: some-bugs0.patch                    ← 如果需要打补丁，则依次填写</span></span><br><span class=\"line\"><span class=\"comment\">#Patch1: some-bugs1.patch                    ← 如果需要打补丁，则依次填写</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-依赖关系\"><a href=\"#2-依赖关系\" class=\"headerlink\" title=\"2. 依赖关系\"></a>2. 依赖关系</h2><p>依赖关系定义了一个包正常工作需要依赖的其他包，RPM在升级、安装和删除的时候会确保依赖关系得到满足。</p>\n<ul>\n<li><p><code>BuildRequires</code>: 制作过程中用到的软件包，构建依赖</p>\n</li>\n<li><p><code>Requires</code>: 安装时所需软件包</p>\n<ul>\n<li><code>Requires(pre)</code>: 指定不同阶段的依赖</li>\n</ul>\n</li>\n<li><p><code>BuildRoot</code>: 这个是安装或编译时使用的「虚拟目录」，打包时会用到该目录下文件，可查看安装后文件路径，例如：<code>BuildRoot: %_topdir/BUILDROOT</code>。</p>\n</li>\n<li><p><code>Prefix: %&#123;_prefix&#125;</code> 这个主要是为了解决今后安装 rpm 包时，并不一定把软件安装到 rpm 中打包的目录的情况。这样，必须在这里定义该标识，并在编写 <code>%install</code> 脚本的时候引用，才能实现 rpm 安装时重新指定位置的功能</p>\n</li>\n<li><p><code>BuildArch</code>: 指编译的目标处理器架构，<code>noarch</code> 标识不指定，但通常都是以 <code>/usr/lib/rpm/marcros</code> 中的内容为默认值</p>\n</li>\n<li><p><code>%description</code>：软件包详细说明，可写在多个行上。这样任何人使用 <code>rpm -qi</code>查询您的软件包时都可以看到它。您可以解释这个软件包做什么，描述任何警告或附加的配置指令，等等。</p>\n</li>\n<li><p><code>URL</code>：软件的主页</p>\n</li>\n</ul>\n<h3 id=\"2-1-RPM-包信息查看\"><a href=\"#2-1-RPM-包信息查看\" class=\"headerlink\" title=\"2.1 RPM 包信息查看\"></a>2.1 <strong>RPM 包信息查看</strong></h3><ul>\n<li><p>我通过命令查看了 nginx 包的信息，如下：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\"><span class=\"comment\"># 查看头部信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm -qpi ./nginx-1.12.2-2.el7.x86_64.rpm</span><br><span class=\"line\">Name        : nginx</span><br><span class=\"line\">Epoch       : 1</span><br><span class=\"line\">Version     : 1.12.2</span><br><span class=\"line\">Release     : 2.el7</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\">Install Date: (not installed)</span><br><span class=\"line\">Group       : System Environment/Daemons</span><br><span class=\"line\">Size        : 1574949</span><br><span class=\"line\">License     : BSD</span><br><span class=\"line\">Signature   : RSA/SHA256, Tue 06 Mar 2018 05:44:06 PM CST, Key ID 6a2faea2352c64e5</span><br><span class=\"line\">Source RPM  : nginx-1.12.2-2.el7.src.rpm</span><br><span class=\"line\">Build Date  : Tue 06 Mar 2018 05:27:44 PM CST</span><br><span class=\"line\">Build Host  : buildhw-02.phx2.fedoraproject.org</span><br><span class=\"line\">Relocations : (not relocatable)</span><br><span class=\"line\">Packager    : Fedora Project</span><br><span class=\"line\">Vendor      : Fedora Project</span><br><span class=\"line\">URL         : &lt;http://nginx.org/&gt;</span><br><span class=\"line\">Bug URL     : &lt;https://bugz.fedoraproject.org/nginx&gt;</span><br><span class=\"line\">Summary     : A high performance web server and reverse proxy server</span><br><span class=\"line\">Description :</span><br><span class=\"line\">Nginx is a web server and a reverse proxy server <span class=\"keyword\">for</span> HTTP, SMTP, POP3 and</span><br><span class=\"line\">IMAP protocols, with a strong focus on high concurrency, performance and low</span><br><span class=\"line\">memory usage.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看脚本内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm --scripts -qp ./nginx-1.12.2-2.el7.x86_64.rpm</span><br><span class=\"line\">postinstall scriptlet (using /bin/sh):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -eq 1 ] ; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"comment\"># Initial installation</span></span><br><span class=\"line\">        systemctl preset nginx.service &gt;/dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">preuninstall scriptlet (using /bin/sh):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -eq 0 ] ; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"comment\"># Package removal, not upgrade</span></span><br><span class=\"line\">        systemctl --no-reload <span class=\"built_in\">disable</span> nginx.service &gt; /dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\">        systemctl stop nginx.service &gt; /dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">postuninstall scriptlet (using /bin/sh):</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl daemon-reload &gt;/dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -ge 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    /usr/bin/nginx-upgrade &gt;/dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-BuildRequires\"><a href=\"#2-2-BuildRequires\" class=\"headerlink\" title=\"2.2 BuildRequires\"></a>2.2 <strong>BuildRequires</strong></h3></li>\n</ul>\n<p>定义构建时依赖的软件包，在构建机器编译 rpm 包时需要的辅助工具，以逗号分隔。</p>\n<p>假如，要求编译 <code>myapp</code> 时，gcc 的版本至少为 4.4.2，则可以写成 <code>gcc &gt;=4.2.2</code></p>\n<h3 id=\"2-3-Requires\"><a href=\"#2-3-Requires\" class=\"headerlink\" title=\"2.3 Requires\"></a>2.3 <strong>Requires</strong></h3><p>定义安装时的依赖包，该 rpm 包所依赖的软件包名称，就是指编译好的 rpm 软件在其他机器上安装时，需要依赖的其他软件包。</p>\n<p>可以用 <code>&gt;=</code> 或 <code>&lt;=</code> 表示大于或小于某一特定版本。 <code>&gt;=</code> 号两边需用空格隔开，而不同软件名称也用空格分开。</p>\n<p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">Requires:       libpng-devel &gt;&#x3D; 1.0.20 zlib</span><br></pre></td></tr></table></figure>\n<p>其它写法例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">Requires: bzip2 &#x3D; %&#123;version&#125;, bzip2-libs &#x3D;%&#123;version&#125;</span><br></pre></td></tr></table></figure>\n<p>还有例如<code>PreReq</code>、<code>Requires(pre)</code>、<code>Requires(post)</code>、<code>Requires(preun)</code>、<code>Requires(postun)</code>、<code>BuildRequires</code>等都是针对不同阶段的依赖指定。</p>\n<p>关于<code>pre</code>、<code>post</code>、<code>preun</code>、<code>postun</code>含义理解，感觉<code>post</code>有一种“完成”的意思：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\"># 安装前执行的脚本，语法和shell脚本的语法相同</span><br><span class=\"line\">%pre</span><br><span class=\"line\"># 安装后执行的脚本</span><br><span class=\"line\">%post</span><br><span class=\"line\"># 卸载前执行的脚本</span><br><span class=\"line\">%preun</span><br><span class=\"line\"># 卸载完成后执行的脚本</span><br><span class=\"line\">%postun</span><br><span class=\"line\"># 清理阶段，在制作完成后删除安装的内容</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">PreReq: capability&gt;&#x3D;version      #capability包必须先安装</span><br><span class=\"line\">Conflicts:bash&gt;&#x3D;2.0              #该包和所有不小于2.0的bash包有冲突</span><br></pre></td></tr></table></figure>\n<p><img src=\"SPEC%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210315162108826.png\" alt=\"image-20210315162108826\"></p>\n<h3 id=\"2-4-BuildRoot\"><a href=\"#2-4-BuildRoot\" class=\"headerlink\" title=\"2.4 BuildRoot\"></a>2.4 <strong>BuildRoot</strong></h3><p>该参数非常重要，因为在生成 rpm 的过程中，执行 <code>make install</code> 时就会把软件安装到上述的路径中，在打包的时候，同样依赖“虚拟目录”为“根目录”进行操作。后面可使用 <code>$RPM_BUILD_ROOT</code> 方式引用。</p>\n<p>考虑到多用户的环境，一般定义为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%&#123;_tmppath&#125;&#x2F;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root</span><br><span class=\"line\"># OR</span><br><span class=\"line\">%&#123;_tmppath&#125;&#x2F;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-buildroot-%(%&#123;__id_u&#125; -n&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-预处理-prep\"><a href=\"#3-预处理-prep\" class=\"headerlink\" title=\"3. 预处理 %prep\"></a>3. 预处理 %prep</h2><p>这个阶段是「预处理」，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备。</p>\n<p><code>%prep</code> 和下面的 <code>%build</code>，<code>%install</code> 段一样，除了可以执行 rpm 所定义的宏命令（以<code>%</code>开头）以外，还可以执行 <code>SHELL</code> 命令，命令可以有很多行，如我们常写的 <code>tar</code> 解包命令。功能上类似于 <code>./configure</code>。</p>\n<p><code>%prep</code> 阶段进行实际的打包准备工作，它是使用节前缀 <code>%prep</code> 表示的。主要功能有：</p>\n<ul>\n<li>将文件 ( <code>SOURCES/</code>) 解压到构建目录 (<code>BUILD/</code>)</li>\n<li>应用 <code>Patch</code>（打补丁） (<code>SOURCES/ =&gt; BUILD/</code>)</li>\n<li>描述 <code>rm -rf $RPM_BUILD_ROOT</code></li>\n<li>描述或编辑本部分用到的命令到 <code>PreReq</code></li>\n<li>通过 <code>b .XXX</code> 描述补丁备份</li>\n</ul>\n<p>它一般包含 <code>%setup</code> 与 <code>%patch</code> 两个命令。<code>%setup</code> 用于将软件包打开，执行 <code>%patch</code> 可将补丁文件加入解开的源程序中。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%prep</span><br><span class=\"line\">%setup -q                                     ← 宏的作用是解压并切换到目录</span><br><span class=\"line\"><span class=\"comment\">#%patch0 -p1                                  ← 如果需要打补丁，则依次写</span></span><br><span class=\"line\"><span class=\"comment\">#%patch1 -p1                                  ← 如果需要打补丁，则依次写</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-宏-setup\"><a href=\"#3-1-宏-setup\" class=\"headerlink\" title=\"3.1 宏 %setup\"></a>3.1 宏 <strong>%setup</strong></h3><p>这个宏解压源代码，将当前目录改为源代码解压之后产生的目录。这个宏还有一些选项可以用。例如，在解压后，<code>%setup</code> 宏假设产生的目录是 <code>%&#123;name&#125;-%&#123;version&#125;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%setup -n %&#123;name&#125;-%&#123;version&#125; #把源码包解压并放好</span><br></pre></td></tr></table></figure>\n<p>主要的用途就是将 <code>%sourcedir</code> 目录下的源代码解压到 <code>%builddir</code> 目录下，也就是将<code>~/rpmbuild/SOURCES</code> 里的包解压到 <code>~/rpmbuild/BUILD/%&#123;name&#125;-%&#123;version&#125;</code> 中。一般用 <code>%setup -c</code> 就可以了，但有两种情况：</p>\n<ul>\n<li>一就是同时编译多个源码包，</li>\n<li>二就是源码的 tar 包的名称与解压出来的目录不一致，此时，就需要使用 <code>n</code> 参数指定一下。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">不加任何选项，仅将软件包打开。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-a</span> <span class=\"string\">切换目录前，解压指定</span> <span class=\"string\">Source</span> <span class=\"string\">文件，例如</span> <span class=\"string\">`-a</span> <span class=\"number\">0</span><span class=\"string\">`</span> <span class=\"string\">表示解压</span> <span class=\"string\">`Source0`</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-n</span> <span class=\"string\">newdir</span> <span class=\"string\">将软件包解压在newdir目录。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-c</span> <span class=\"string\">解压缩之前先产生目录。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-b</span> <span class=\"string\">num</span> <span class=\"string\">将第</span> <span class=\"string\">num</span> <span class=\"string\">个</span> <span class=\"string\">source</span> <span class=\"string\">文件解压缩。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-D</span> <span class=\"string\">解压前不删除目录</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-T</span> <span class=\"string\">不使用default的解压缩操作。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-T</span> <span class=\"string\">-b</span> <span class=\"number\">0</span> <span class=\"string\">将第</span> <span class=\"number\">0</span> <span class=\"string\">个源代码文件解压缩。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-c</span> <span class=\"string\">-n</span> <span class=\"string\">newdir</span> <span class=\"string\">指定目录名称</span> <span class=\"string\">newdir，并在此目录产生</span> <span class=\"string\">rpm</span> <span class=\"string\">套件。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"string\">最简单的补丁方式，自动指定patch</span> <span class=\"string\">level。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"number\">0</span> <span class=\"string\">使用第0个补丁文件，相当于%patch</span> <span class=\"string\">?p</span> <span class=\"number\">0</span><span class=\"string\">。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"string\">-s</span> <span class=\"string\">不显示打补丁时的信息。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"string\">-T</span> <span class=\"string\">将所有打补丁时产生的输出文件删除</span></span><br></pre></td></tr></table></figure>\n<p>应该 <code>-q</code> 参数给 <code>%setup</code> 宏。这会显著减少编译日志文件的输出，尤其是源代码包会解压出一堆文件的时候。</p>\n<p>在 <code>~/rmpbuild/BUILD/%&#123;name&#125;-%&#123;version&#125;</code> 目录中进行 ，使用标准写法，会引用<code>/usr/lib/rpm/marcros</code> 中定义的参数。</p>\n<h3 id=\"3-2-宏-patch\"><a href=\"#3-2-宏-patch\" class=\"headerlink\" title=\"3.2 宏 %patch\"></a>3.2 宏 <strong>%patch</strong></h3><p>这个宏将头部定义的补丁应用于源代码。如果定义了多个补丁，它可以用一个数字的参数来指示应用哪个补丁文件。它也接受 <code>-b extension</code> 参数，指示 RPM 在打补丁之前，将文件备份为扩展名是 <code>extension</code> 的文件。</p>\n<p>通常补丁都会一起在源码 <code>tar.gz</code> 包中，或放到 <code>SOURCES</code> 目录下。一般参数为：</p>\n<ul>\n<li><code>%patch -p1</code> 使用前面定义的 <code>Patch</code> 补丁进行，<code>p1</code>是忽略 <code>patch</code> 的第一层目录</li>\n<li><code>%Patch2 -p1 -b xxx.patch</code>打上指定的补丁，<code>b</code>是指生成备份文件</li>\n</ul>\n<h3 id=\"3-3-build-阶段\"><a href=\"#3-3-build-阶段\" class=\"headerlink\" title=\"3.3 %build 阶段\"></a>3.3 <strong>%build 阶段</strong></h3><p>本段是「构建」阶段，这个阶段会在 <code>%_builddir</code> 目录下执行源码包的编译。一般是执行执行常见的 <code>configure</code> 和 <code>make</code> 操作。</p>\n<p>该阶段一般由多个 <code>make</code> 命令组成。与 <code>%prep</code> 段落一样，这些命令可以是 <code>shell</code> 命令，也可以是宏。</p>\n<p>记住两点：</p>\n<ol>\n<li><code>%build</code> 和 <code>%install</code> 的过程中，都必须把编译和安装的文件定义到“虚拟根目录” 中</li>\n<li><code>%file</code> 中必须明白，用的是相对目录</li>\n</ol>\n<p>这个阶段我们最常见只有两条指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%configure</span><br><span class=\"line\">make %&#123;?_smp_mflags&#125; OPTIMIZE&#x3D;&quot;%&#123;optflags&#125;&quot;           ← 多核则并行编译</span><br></pre></td></tr></table></figure>\n<p><code>%configure</code> 这个不是关键字，而是 rpm 定义的标准宏命令。意思是执行源代码的<code>configure</code>配置。会自动将 <code>prefix</code> 设置成 <code>/usr</code>。</p>\n<p>这个 <code>%&#123;?_smp_mflags&#125; %&#123;optflags&#125;</code> 是什么意思呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">$ rpm --eval <span class=\"string\">&quot;%&#123;?_smp_mflags&#125;&quot;</span></span><br><span class=\"line\">-j4</span><br><span class=\"line\">$ rpm --eval <span class=\"string\">&quot;%&#123;optflags&#125;&quot;</span></span><br><span class=\"line\">-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=<span class=\"number\">2</span> -fexceptions -fstack-protector-strong --param=ssp-buffer-size=<span class=\"number\">4</span> -grecord-gcc-switches   -m64 -mtune=generic</span><br></pre></td></tr></table></figure>\n<p>所以，上面那个命令就是 <code>make -j4</code>。问题又来了，<code>make -j4</code> 表示什么意思？</p>\n<blockquote>\n<p>都是一些优化参数</p>\n</blockquote>\n<ul>\n<li><a href=\"https://nanxiao.me/linux-kernel-note-26-make-j/\">Linux kernel 笔记 （26）——利用“make -j”提高编译<code>kernel</code>速度</a></li>\n<li><a href=\"https://bbs.csdn.net/topics/380072770\">CSDB-make -j4是什么意思</a></li>\n</ul>\n<h3 id=\"3-4-install-阶段\"><a href=\"#3-4-install-阶段\" class=\"headerlink\" title=\"3.4 %install 阶段\"></a>3.4 <strong>%install 阶段</strong></h3><p>「安装」阶段，就是执行 <code>make install</code> 命令操作。开始把软件安装到虚拟的根目录中。这个阶段会在 <code>%buildrootdir</code> 目录里建好目录结构，然后将需要打包到 rpm 软件包里的文件从 <code>%builddir</code> 里拷贝到 <code>%_buildrootdir</code> 里对应的目录里。</p>\n<p>在 <code>~/rpmbuild/BUILD/%&#123;name&#125;-%&#123;version&#125;</code> 目录中进行 <code>make install</code> 的操作。<code>%install</code> 很重要，因为如果这里的路径不对的话，则下面 <code>%file</code> 中寻找文件的时候就会失败。</p>\n<p>特别需要注意的是：<code>%install</code> 部分使用的是绝对路径，而 <code>%file</code> 部分使用则是相对路径，虽然其描述的是同一个地方。千万不要写错。</p>\n<p>将已编译的软件安装到虚拟的目录结构中，从而可以打包成一个 RPM。当用户最终用 <code>rpm -ivh name-version.rpm</code> 安装软件包时，这些文件会安装到用户系统中相应的目录里。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">%install</span></span><br><span class=\"line\"><span class=\"string\">if</span> [<span class=\"string\">-d</span> <span class=\"string\">%</span>&#123;<span class=\"string\">buildroot</span>&#125;]<span class=\"string\">;</span> <span class=\"string\">then</span></span><br><span class=\"line\">   <span class=\"string\">rm</span> <span class=\"string\">-rf</span> <span class=\"string\">%&#123;buildroot&#125;</span>                      <span class=\"string\">←</span> <span class=\"string\">清空下安装目录，实际会自动清除</span></span><br><span class=\"line\"><span class=\"string\">fi</span></span><br><span class=\"line\"><span class=\"string\">make</span> <span class=\"string\">install</span> <span class=\"string\">DESTDIR=%&#123;buildroot&#125;</span>           <span class=\"string\">←</span> <span class=\"string\">安装到buildroot目录下</span></span><br><span class=\"line\"><span class=\"string\">%&#123;__install&#125;</span> <span class=\"string\">-Dp</span> <span class=\"string\">-m0755</span> <span class=\"string\">contrib/init.d</span> <span class=\"string\">%&#123;buildroot&#125;%&#123;_initrddir&#125;/foobar</span></span><br><span class=\"line\"><span class=\"string\">%&#123;__install&#125;</span> <span class=\"string\">-d</span> <span class=\"string\">%&#123;buildroot&#125;%&#123;_sysconfdir&#125;/foobar.d/</span></span><br></pre></td></tr></table></figure>\n<p>「翻译」一下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">make</span> <span class=\"string\">install</span> <span class=\"string\">DESTDIR=/root/rpmbuild/BUILDROOT/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.x86_64</span></span><br><span class=\"line\"><span class=\"string\">make</span> <span class=\"string\">install</span> <span class=\"string\">DESTDIR=/root/rpmbuild/BUILDROOT/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.x86_64</span></span><br><span class=\"line\"><span class=\"string\">/usr/bin/install</span> <span class=\"string\">-d</span> <span class=\"string\">/root/rpmbuild/BUILDROOT/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.x86_64/etc/foobar.d/</span></span><br></pre></td></tr></table></figure>\n<p>需要说明的是，这里的 <code>%install</code> 主要就是为了后面的 <code>%file</code> 服务的。所以，还可以使用常规的系统命令：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">install</span> <span class=\"string\">-d</span> <span class=\"string\">$RPM_BUILD_ROOT/</span></span><br><span class=\"line\"><span class=\"string\">cp</span> <span class=\"string\">-a</span> <span class=\"string\">*</span> <span class=\"string\">$RPM_BUILD_ROOT/</span></span><br></pre></td></tr></table></figure>\n<p>其中 <code>%&#123;buildroot&#125;</code> 和 <code>$RPMBUILDROOT</code> 是等价的， <code>%&#123;buildroot&#125;</code>必须全部用小写，不然要报错。</p>\n<p>注意区分 <code>$RPM_BUILD_ROOT</code>和 <code>$RPM_BUILD_DIR</code>：</p>\n<ul>\n<li><code>$RPM_BUILD_ROOT</code> 是指开头定义的 <code>BuildRoot</code>，是 <code>%file</code> 需要的。</li>\n<li><code>$RPM_BUILD_DIR</code> 通常就是指 <code>~/rpmbuild/BUILD</code></li>\n</ul>\n<p><strong>scripts section 没必要可以不填<a href=\"https://www.cnblogs.com/michael-xiang/p/10480809.html#3715799303\">#</a></strong></p>\n<ul>\n<li><code>%pre</code> 安装前执行的脚本</li>\n<li><code>%post</code> 安装后执行的脚本</li>\n<li><code>%preun</code> 卸载前执行的脚本</li>\n<li><code>%postun</code> 卸载后执行的脚本</li>\n<li><code>%pretrans</code> 在事务开始时执行脚本</li>\n<li><code>%posttrans</code> 在事务结束时执行脚本</li>\n</ul>\n<p><code>%preun</code> <code>%postun</code> 的区别是什么呢？</p>\n<ul>\n<li>前者在升级的时候会执行，后者在升级 rpm 包的时候不会执行</li>\n</ul>\n<h3 id=\"3-5-files-阶段\"><a href=\"#3-5-files-阶段\" class=\"headerlink\" title=\"3.5 %files 阶段\"></a>3.5 <strong>%files 阶段</strong></h3><p>任何打包的文件，都需要在这个包的详细的文件列表中，如果是目录，包的所有者的全部目录都在中间, %dir 来指定空目录，可以用 %files -f /tmp/dyanmic_filelist 来指定一个文件列表。</p>\n<p>默认 %config 会替换掉配置，给原来的配置修改名字为 .rpmorig ,如果不想修改的话，就用%config(noreplace) 就会给新的配置文件名字命名为 .rpmnew.</p>\n<p>本段是文件段，主要用来说明会将 <code>%&#123;buildroot&#125;</code> 目录下的哪些文件和目录最终打包到rpm包里。定义软件包所包含的文件，分为三类：</p>\n<ul>\n<li>说明文档（doc）</li>\n<li>配置文件（config）</li>\n<li>执行程序</li>\n</ul>\n<p>具体一点，包含如下场景：</p>\n<p><strong>1. 一个文件没有被%config或%config(noreplace)指令配置</strong></p>\n<p>此时，不管该文件在安装完成后，有没有在本地被修改过，当升级该rpm包时，该文件会被这个新的rpm包的里的同名文件替换,（旧文件被删除）。</p>\n<p><strong>2. 一个文件被%config指令配置</strong></p>\n<p>此时包含如下情况：</p>\n<ul>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换掉掉旧的文件，旧的文件会被保存为xx**.rpmsave**，如/etc/redis/redis.conf.rpmsave</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换掉旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。</li>\n</ul>\n<p><strong>3. 一个文件被%config(noreplace)指令配置</strong></p>\n<p>此时包含如下情况：</p>\n<ul>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，旧文件保持不变，新rpm包里的该文件并重命名为xx**.rpmnew**,例如/etc/redis/redis.conf.rpmnew</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。</li>\n</ul>\n<p><a href=\"https://www.notion.so/4842b64880d6417c89d52d92b0c4d488\">Config总结</a></p>\n<table>\n<thead>\n<tr>\n<th>文件标记</th>\n<th>在update包中是否更新</th>\n<th>本地磁盘没有被修改</th>\n<th>本地磁盘被修改过</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无</td>\n<td>没更新</td>\n<td>替换(旧文件删除)</td>\n<td>替换(旧文件删除)</td>\n</tr>\n<tr>\n<td>无</td>\n<td>更新</td>\n<td>替换(旧文件删除)</td>\n<td>替换(旧文件删除)</td>\n</tr>\n<tr>\n<td>%config</td>\n<td>没更新</td>\n<td>替换(旧文件删除)</td>\n<td>保留修改过的文件，不替换</td>\n</tr>\n<tr>\n<td>%config</td>\n<td>更新</td>\n<td>替换(旧文件删除)</td>\n<td>旧文件被保存为xxx.rpmsave，新文件替换旧文件</td>\n</tr>\n<tr>\n<td>%config(noreplace)</td>\n<td>没更新</td>\n<td>替换(旧文件删除)</td>\n<td>保留修改过的文件，不替换</td>\n</tr>\n<tr>\n<td>%config(noreplace)</td>\n<td>更新</td>\n<td>替换(旧文件删除)</td>\n<td>旧文件保持不变，新文件重命名为xxx.rpmnew</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.notion.so/a35c511b8d9e460f9a2e108a20a9f345\">当rpm包中该文件的标记方法发生改变的两个场景：</a></p>\n<table>\n<thead>\n<tr>\n<th>文件标记</th>\n<th>在update包中是否更新</th>\n<th>本地磁盘被修改过</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>之前是%config(noreplace)，现在是%config</td>\n<td>更新</td>\n<td>文件被替换，旧文件被保存为xxx.rpmsave</td>\n</tr>\n<tr>\n<td>之前是%config，现在是%config(noreplace)</td>\n<td>更新</td>\n<td>旧文件保持不变，update包中的新文件重命名为xxx.rpmnew</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.notion.so/d9928d592b604f0990f4fe3401a645a8\">常用变量</a></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">macro</th>\n<th align=\"left\">definition</th>\n<th align=\"left\">comment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>%&#123;_sysconfdir&#125;</code></td>\n<td align=\"left\"><code>/etc</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_prefix&#125;</code></td>\n<td align=\"left\"><code>/usr</code></td>\n<td align=\"left\">can be defined to <code>/app</code> for flatpak builds</td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;</code></td>\n<td align=\"left\"><code>%&#123;_prefix&#125;</code></td>\n<td align=\"left\">default: <code>/usr</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_includedir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_prefix&#125;/include</code></td>\n<td align=\"left\">default: <code>/usr/include</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_bindir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/bin</code></td>\n<td align=\"left\">default: <code>/usr/bin</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_libdir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/%&#123;_lib&#125;</code></td>\n<td align=\"left\">default: <code>/usr/%&#123;_lib&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_libexecdir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/libexec</code></td>\n<td align=\"left\">default: <code>/usr/libexec</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_sbindir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/sbin</code></td>\n<td align=\"left\">default: <code>/usr/sbin</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_datadir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datarootdir&#125;</code></td>\n<td align=\"left\">default: <code>/usr/share</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_infodir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datarootdir&#125;/info</code></td>\n<td align=\"left\">default: <code>/usr/share/info</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_mandir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datarootdir&#125;/man</code></td>\n<td align=\"left\">default: <code>/usr/share/man</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_docdir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datadir&#125;/doc</code></td>\n<td align=\"left\">default: <code>/usr/share/doc</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_rundir&#125;</code></td>\n<td align=\"left\"><code>/run</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_localstatedir&#125;</code></td>\n<td align=\"left\"><code>/var</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_sharedstatedir&#125;</code></td>\n<td align=\"left\"><code>/var/lib</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_lib&#125;</code></td>\n<td align=\"left\"><code>lib64</code></td>\n<td align=\"left\"><code>lib</code> on 32bit platforms</td>\n</tr>\n</tbody></table>\n<p>还可定义文件存取权限，拥有者及组别。</p>\n<p>这里会在虚拟根目录下进行，千万不要写绝对路径，而应用宏或变量表示相对路径。</p>\n<p>在 <code>%files</code> 阶段的第一条命令的语法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%defattr(文件权限,用户名,组名,目录权限)</span><br></pre></td></tr></table></figure>\n<p>注意点：同时需要在 <code>%install</code> 中安装。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%files</span><br><span class=\"line\">%defattr (-,root,root,0755)                         ← 设定默认权限</span><br><span class=\"line\">%config(noreplace) /etc/my.cnf                      ← 表明是配置文件，noplace表示替换文件</span><br><span class=\"line\">%doc %&#123;src_dir&#125;/Docs/ChangeLog                      ← 表明这个是文档</span><br><span class=\"line\">%attr(644, root, root) %&#123;_mandir&#125;/man8/mysqld.8*    ← 分别是权限，属主，属组</span><br><span class=\"line\">%attr(755, root, root) %&#123;_sbindir&#125;/mysqld</span><br></pre></td></tr></table></figure>\n<p><code>%exclude</code> 列出不想打包到 rpm 中的文件。注意：如果 <code>%exclude</code> 指定的文件不存在，也会出错的。</p>\n<p>在安装 rpm 时，会将可执行的二进制文件放在 <code>/usr/bin</code> 目录下，动态库放在 <code>/usr/lib</code> 或者 <code>/usr/lib64</code> 目录下，配置文件放在 <code>/etc</code> 目录下，并且多次安装时新的配置文件不会覆盖以前已经存在的同名配置文件。</p>\n<p>关于 <code>%files</code> 阶段有两个特性：</p>\n<ol>\n<li><code>%&#123;buildroot&#125;</code> 里的所有文件都要明确被指定是否要被打包到 rpm里。什么意思呢？假如，<code>%&#123;buildroot&#125;</code> 目录下有 4 个目录 a、b、c和d，在 <code>%files</code> 里仅指定 a 和 b 要打包到 rpm 里，如果不把 c 和 d 用 <code>exclude</code> 声明是要报错的；</li>\n<li>如果声明了 <code>%&#123;buildroot&#125;</code> 里不存在的文件或者目录也会报错。</li>\n</ol>\n<p>关于 <code>%doc</code> 宏，所有跟在这个宏后面的文件都来自 <code>%&#123;_builddir&#125;</code> 目录，当用户安装 rpm 时，由这个宏所指定的文件都会安装到 <code>/usr/share/doc/name-version/</code> 目录里。</p>\n<h2 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"%clean\"></a><strong>%clean</strong></h2><p>清理段，可以通过 <code>--clean</code> 删除 <code>BUILD</code></p>\n<p>编译完成后一些清理工作，主要包括对 <code>%&#123;buildroot&#125;</code> 目录的清空(这不是必须的)，通常执行诸如 <code>make clean</code> 之类的命令。</p>\n<h2 id=\"changelog\"><a href=\"#changelog\" class=\"headerlink\" title=\"%changelog\"></a><strong>%changelog</strong></h2><p>本段是修改日志段，记录 spec 的修改日志段。你可以将软件的每次修改记录到这里，保存到发布的软件包中，以便查询之用。</p>\n<p>每一个修改日志都有这样一种格式：</p>\n<ul>\n<li>第一行是：<code>星期 月 日 年 修改人 电子信箱</code>。其中：星期、月份均用英文形式的前 3 个字母，用中文会报错。</li>\n<li>接下来的行写的是修改了什么地方，可写多行。一般以减号开始，便于后续的查阅。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%changelog</span><br><span class=\"line\">* Fri Dec 29 2012 foobar &lt;foobar@kidding.com&gt; - 1.0.0-1</span><br><span class=\"line\">- Initial version</span><br></pre></td></tr></table></figure>\n<h2 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a><strong>宏</strong></h2><p>在定义文件的安装路径时，通常会使用类似 <code>%_sharedstatedir</code> 的宏，这些宏一般会在 <code>/usr/lib/rpm/macros</code> 中定义。关于宏的语法，可以查看 <a href=\"https://rpm.org/user_doc/macros.html\">Macro syntax</a></p>\n<p>RPM 内建宏定义在 <code>/usr/lib/rpm/redhat/macros</code> 文件中，这些宏基本上定义了目录路径或体系结构等等；同时也包含了一组用于调试 spec 文件的宏。</p>\n<p>所有宏都可以在 <code>/usr/lib/rpm/macros</code> 找到，附录一些常见的宏：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%&#123;_sysconfdir&#125;        &#x2F;etc</span><br><span class=\"line\">%&#123;_prefix&#125;            &#x2F;usr</span><br><span class=\"line\">%&#123;_exec_prefix&#125;       %&#123;_prefix&#125;</span><br><span class=\"line\">%&#123;_bindir&#125;            %&#123;_exec_prefix&#125;&#x2F;bin</span><br><span class=\"line\">%&#123;_lib&#125;               lib (lib64 on 64bit systems)</span><br><span class=\"line\">%&#123;_libdir&#125;            %&#123;_exec_prefix&#125;&#x2F;%&#123;_lib&#125;</span><br><span class=\"line\">%&#123;_libexecdir&#125;        %&#123;_exec_prefix&#125;&#x2F;libexec</span><br><span class=\"line\">%&#123;_sbindir&#125;           %&#123;_exec_prefix&#125;&#x2F;sbin</span><br><span class=\"line\">%&#123;_sharedstatedir&#125;    &#x2F;var&#x2F;lib</span><br><span class=\"line\">%&#123;_datadir&#125;           %&#123;_prefix&#125;&#x2F;share</span><br><span class=\"line\">%&#123;_includedir&#125;        %&#123;_prefix&#125;&#x2F;include</span><br><span class=\"line\">%&#123;_oldincludedir&#125;     &#x2F;usr&#x2F;include</span><br><span class=\"line\">%&#123;_infodir&#125;           &#x2F;usr&#x2F;share&#x2F;info</span><br><span class=\"line\">%&#123;_mandir&#125;            &#x2F;usr&#x2F;share&#x2F;man</span><br><span class=\"line\">%&#123;_localstatedir&#125;     &#x2F;var</span><br><span class=\"line\">%&#123;_initddir&#125;          %&#123;_sysconfdir&#125;&#x2F;rc.d&#x2F;init.d</span><br><span class=\"line\">%&#123;_topdir&#125;            %&#123;getenv:HOME&#125;&#x2F;rpmbuild</span><br><span class=\"line\">%&#123;_builddir&#125;          %&#123;_topdir&#125;&#x2F;BUILD</span><br><span class=\"line\">%&#123;_rpmdir&#125;            %&#123;_topdir&#125;&#x2F;RPMS</span><br><span class=\"line\">%&#123;_sourcedir&#125;         %&#123;_topdir&#125;&#x2F;SOURCES</span><br><span class=\"line\">%&#123;_specdir&#125;           %&#123;_topdir&#125;&#x2F;SPECS</span><br><span class=\"line\">%&#123;_srcrpmdir&#125;         %&#123;_topdir&#125;&#x2F;SRPMS</span><br><span class=\"line\">%&#123;_buildrootdir&#125;      %&#123;_topdir&#125;&#x2F;BUILDROOT</span><br><span class=\"line\">%&#123;_var&#125;               &#x2F;var</span><br><span class=\"line\">%&#123;_tmppath&#125;           %&#123;_var&#125;&#x2F;tmp</span><br><span class=\"line\">%&#123;_usr&#125;               &#x2F;usr</span><br><span class=\"line\">%&#123;_usrsrc&#125;            %&#123;_usr&#125;&#x2F;src</span><br><span class=\"line\">%&#123;_docdir&#125;            %&#123;_datadir&#125;&#x2F;doc</span><br><span class=\"line\">%&#123;buildroot&#125;          %&#123;_buildrootdir&#125;&#x2F;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.%&#123;_arch&#125;</span><br><span class=\"line\">$RPM_BUILD_ROOT       %&#123;buildroot&#125;</span><br></pre></td></tr></table></figure>\n<p>利用 rpmbuild 构建 rpm 安装包时，通过命令 <code>rpm --showrc|grep prefix</code> 查看。</p>\n<p>通过 <code>rpm --eval &quot;%&#123;macro&#125;&quot;</code> 来查看具体对应路径。</p>\n<p>比如我们要查看 <code>%&#123;_bindir&#125;</code> 的路径，就可以使用命令 <code>rpm --eval &quot;%&#123; _bindir&#125;&quot;</code> 来查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%&#123;_topdir&#125;            %&#123;getenv:HOME&#125;&#x2F;rpmbuild</span><br><span class=\"line\">%&#123;_builddir&#125;          %&#123;_topdir&#125;&#x2F;BUILD</span><br><span class=\"line\">%&#123;_rpmdir&#125;            %&#123;_topdir&#125;&#x2F;RPMS</span><br><span class=\"line\">%&#123;_sourcedir&#125;         %&#123;_topdir&#125;&#x2F;SOURCES</span><br><span class=\"line\">%&#123;_specdir&#125;           %&#123;_topdir&#125;&#x2F;SPECS</span><br><span class=\"line\">%&#123;_srcrpmdir&#125;         %&#123;_topdir&#125;&#x2F;SRPMS</span><br><span class=\"line\">%&#123;_buildrootdir&#125;      %&#123;_topdir&#125;&#x2F;BUILDROOT</span><br><span class=\"line\"></span><br><span class=\"line\">Note: On releases older than Fedora 10 (and EPEL), %&#123;_buildrootdir&#125; does not exist.</span><br><span class=\"line\">Build flags macros</span><br><span class=\"line\"></span><br><span class=\"line\">%&#123;_global_cflags&#125;     -O2 -g -pipe</span><br><span class=\"line\">%&#123;_optflags&#125;          %&#123;__global_cflags&#125; -m32 -march&#x3D;i386 -mtune&#x3D;pentium4 # if redhat-rpm-config is installed</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a><strong>变量</strong></h2><p><code>define</code> 定义的变量类似于局部变量，只在 <code>%&#123;!?foo: ... &#125;</code> 区间有效，不过 SPEC 并不会自动清除该变量，只有再次遇到 <code>%&#123;&#125;</code> 时才会清除</p>\n<h3 id=\"define-vs-global\"><a href=\"#define-vs-global\" class=\"headerlink\" title=\"define vs. global\"></a><strong>define vs. global</strong></h3><p>两者都可以用来进行变量定义，不过在细节上有些许差别，简单列举如下：</p>\n<ul>\n<li><code>define</code> 用来定义宏，<code>global</code> 用来定义变量；</li>\n<li>如果定义带参数的宏 (类似于函数)，必须要使用 <code>define</code>；</li>\n<li>在 <code>%&#123;&#125;</code> 内部，必须要使用 <code>global</code> 而非 <code>define</code>；</li>\n<li><code>define</code> 在使用时计算其值，而 <code>global</code> 则在定义时就计算其值；</li>\n</ul>\n<p>可以简单参考如下的示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">#--- %prep之前的参数是必须要有的</span><br><span class=\"line\">Name:           mysql</span><br><span class=\"line\">Version:        5.7.17</span><br><span class=\"line\">Release:        1%&#123;?dist&#125;</span><br><span class=\"line\">Summary:        MySQL from FooBar.</span><br><span class=\"line\">License:        GPLv2+ and BSD</span><br><span class=\"line\"></span><br><span class=\"line\">%description</span><br><span class=\"line\">It is a MySQL from FooBar.</span><br><span class=\"line\"></span><br><span class=\"line\">%prep</span><br><span class=\"line\">#--- 带参数时，必须使用%define定义</span><br><span class=\"line\">%define myecho() echo %1 %2</span><br><span class=\"line\">%&#123;!?bar: %define bar defined&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo 1: %&#123;bar&#125;</span><br><span class=\"line\">%&#123;myecho 2: %&#123;bar&#125;&#125;</span><br><span class=\"line\">echo 3: %&#123;bar&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 如下是输出内容</span><br><span class=\"line\">#1: defined</span><br><span class=\"line\">#2: defined</span><br><span class=\"line\">#3: %&#123;bar&#125;</span><br></pre></td></tr></table></figure>\n<p>3 的输出是不符合预期的，可以将 <code>%define</code> 修改为 <code>global</code> 即可</p>\n<h3 id=\"dist-表示什么含义？\"><a href=\"#dist-表示什么含义？\" class=\"headerlink\" title=\"%{?dist} 表示什么含义？\"></a><strong>%{?dist} 表示什么含义？</strong></h3><p>不加问号，如果 <code>dist</code> 有定义，那么就会用定义的值替换，否则就会保 <code>%&#123;dist&#125;</code>;加问好，如果 <code>dist</code> 有定义，那么也是会用定义的值替换，否则就直接移除这个tag <code>%&#123;?dist&#125;</code></p>\n<p>举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">$ rpm -E &#39;foo:%&#123;foo&#125;&#39;$&#39;\\\\n&#39;&#39;bar:%&#123;?bar&#125;&#39;</span><br><span class=\"line\">foo:%&#123;foo&#125;</span><br><span class=\"line\">bar:</span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm -D&#39;foo foov&#39; -E &#39;foo:%&#123;foo&#125;&#39;$&#39;\\\\n&#39;&#39;bar:%&#123;?bar&#125;&#39;</span><br><span class=\"line\">foo:foov</span><br><span class=\"line\">bar:</span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm -D&#39;foo foov&#39; -D&#39;bar barv&#39; -E &#39;foo:%&#123;foo&#125;&#39;$&#39;\\\\n&#39;&#39;bar:%&#123;?bar&#125;&#39;</span><br><span class=\"line\">foo:foov</span><br><span class=\"line\">bar:barv</span><br></pre></td></tr></table></figure>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"SPEC-文件基础知识\"><a href=\"#SPEC-文件基础知识\" class=\"headerlink\" title=\"SPEC 文件基础知识\"></a>SPEC <strong>文件基础知识</strong></h1><p>制作 rpm 软件包并不是一件复杂的工作，其中的关键在于编写软件包的 spec 描述文件。要想制作一个 rpm 软件包就必须写一个软件包描述文件 spec。这个文件中包含了软件包的诸多信息，如：软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。在实际过程中，最关键的地方是要清楚虚拟路径的位置，以及宏的定义。</p>\n<p><strong>Mandatory parameters to be present in SPEC file to build and generate RPM</strong></p>\n<p>Below options are mandatory to be present in SPEC file</p>\n<p>Name, Version, Release, Summary, License, description, install and files</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">Name:           test-dev</span></span><br><span class=\"line\"><span class=\"section\">Version:        %&#123;_version&#125;</span></span><br><span class=\"line\"><span class=\"section\">Release:        %&#123;_release&#125;</span></span><br><span class=\"line\"><span class=\"section\">Summary:        &lt;update details&gt;</span></span><br><span class=\"line\"><span class=\"section\">License:        Nokia License</span></span><br><span class=\"line\">%description</span><br><span class=\"line\">&lt;update your description&gt;</span><br><span class=\"line\">%install</span><br><span class=\"line\">make -C %&#123;buildroot&#125;/.. install DESTDIR=<span class=\"string\">&quot;%&#123;buildroot&#125;&quot;</span></span><br><span class=\"line\">%files</span><br><span class=\"line\">%&#123;_bindir&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-文件头\"><a href=\"#1-文件头\" class=\"headerlink\" title=\"1. 文件头\"></a>1. <strong>文件头</strong></h2><p>语法：<code>TagName: value</code>，比如<code>Version: 2.1.0</code>，tag名大小写<strong>不敏感</strong>。</p>\n<p>spec支持定义宏，要定义宏，使用：<code>%define testMacro 2</code>，这里定义了一个宏，名称为testMacro，值为2，要使用这个宏，使用<code>%&#123;testMacro&#125;</code>或者<code>%testMacro</code>。</p>\n<p>这个区域定义的 <code>Name</code>、<code>Version</code> 这些字段对应的值可以在后面通过 <code>%&#123;name&#125;</code>,<code>%&#123;version&#125;</code> 这样的方式来引用，类似于 C 语言中的宏：</p>\n<ul>\n<li><p><code>Summary</code>：用一句话概括该软件s包尽量多的信息。</p>\n</li>\n<li><p><code>Name</code>：软件包的名字，最终 rpm 软件包是用该名字与版本号（<code>Version</code>）、释出号(<code>Release</code>）及体系号来命名软件包的，后面可使用 <code>%&#123;name&#125;</code> 的方式引用</p>\n</li>\n<li><p><code>Version</code>：软件版本号。仅当软件包比以前有较大改变时才增加版本号，后面可使用<code>%&#123;version&#125;</code>引用</p>\n</li>\n<li><p><code>Release</code>：软件包释出号/发行号。一般我们对该软件包做了一些小的补丁的时候就应该把释出号加 1，后面可使用 <code>%&#123;release&#125;</code> 引用</p>\n</li>\n<li><p><code>Packager</code>：打包的人（一般喜欢写个人邮箱）</p>\n</li>\n<li><p><code>Vendor</code>：软件开发者的名字，发行商或打包组织的信息，例如<code>RedFlagCo,Ltd</code></p>\n</li>\n<li><p><code>License</code>：软件授权方式，通常是GPL（自由软件）或GPLv2,BSD</p>\n</li>\n<li><p><code>Copyright</code>：软件包所采用的版权规则。具体有：</p>\n<ul>\n<li><p><code>GPL（自由软件）</code>，</p>\n</li>\n<li><p><code>BSD</code>，</p>\n</li>\n<li><p><code>MIT</code>，</p>\n</li>\n<li><p><code>Public Domain（公共域）</code>，</p>\n</li>\n<li><p><code>Distributable（贡献）</code>，</p>\n</li>\n<li><p><code>commercial（商业）</code>，</p>\n</li>\n<li><p><code>Share（共享）</code></p>\n<p>  一般的开发都写 <code>GPL</code>。</p>\n</li>\n</ul>\n</li>\n<li><p><code>Group</code>：软件包所属类别</p>\n<ul>\n<li>Development/System （开发/系统）</li>\n</ul>\n</li>\n<li><p>System Environment/Daemons （系统环境/守护）</p>\n</li>\n<li><p><code>Source0</code>：源程序软件包的名字/源代码包的名字，如 <code>stardict-2.0.tar.gz</code>。可以带多个用 <code>Source1</code>、<code>Source2</code> 等源，后面也可以用 <code>%&#123;source1&#125;</code>、<code>%&#123;source2&#125;</code> 引用</p>\n</li>\n</ul>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\"><span class=\"section\">Source0: %&#123;name&#125;-boost-%&#123;version&#125;.tar.gz    ← 源码包名称(可以使用URL)，可以用SourceN指定多个，如配置文件</span></span><br><span class=\"line\"><span class=\"comment\">#Patch0: some-bugs0.patch                    ← 如果需要打补丁，则依次填写</span></span><br><span class=\"line\"><span class=\"comment\">#Patch1: some-bugs1.patch                    ← 如果需要打补丁，则依次填写</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-依赖关系\"><a href=\"#2-依赖关系\" class=\"headerlink\" title=\"2. 依赖关系\"></a>2. 依赖关系</h2><p>依赖关系定义了一个包正常工作需要依赖的其他包，RPM在升级、安装和删除的时候会确保依赖关系得到满足。</p>\n<ul>\n<li><p><code>BuildRequires</code>: 制作过程中用到的软件包，构建依赖</p>\n</li>\n<li><p><code>Requires</code>: 安装时所需软件包</p>\n<ul>\n<li><code>Requires(pre)</code>: 指定不同阶段的依赖</li>\n</ul>\n</li>\n<li><p><code>BuildRoot</code>: 这个是安装或编译时使用的「虚拟目录」，打包时会用到该目录下文件，可查看安装后文件路径，例如：<code>BuildRoot: %_topdir/BUILDROOT</code>。</p>\n</li>\n<li><p><code>Prefix: %&#123;_prefix&#125;</code> 这个主要是为了解决今后安装 rpm 包时，并不一定把软件安装到 rpm 中打包的目录的情况。这样，必须在这里定义该标识，并在编写 <code>%install</code> 脚本的时候引用，才能实现 rpm 安装时重新指定位置的功能</p>\n</li>\n<li><p><code>BuildArch</code>: 指编译的目标处理器架构，<code>noarch</code> 标识不指定，但通常都是以 <code>/usr/lib/rpm/marcros</code> 中的内容为默认值</p>\n</li>\n<li><p><code>%description</code>：软件包详细说明，可写在多个行上。这样任何人使用 <code>rpm -qi</code>查询您的软件包时都可以看到它。您可以解释这个软件包做什么，描述任何警告或附加的配置指令，等等。</p>\n</li>\n<li><p><code>URL</code>：软件的主页</p>\n</li>\n</ul>\n<h3 id=\"2-1-RPM-包信息查看\"><a href=\"#2-1-RPM-包信息查看\" class=\"headerlink\" title=\"2.1 RPM 包信息查看\"></a>2.1 <strong>RPM 包信息查看</strong></h3><ul>\n<li><p>我通过命令查看了 nginx 包的信息，如下：</p>\n  <figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\"><span class=\"comment\"># 查看头部信息</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm -qpi ./nginx-1.12.2-2.el7.x86_64.rpm</span><br><span class=\"line\">Name        : nginx</span><br><span class=\"line\">Epoch       : 1</span><br><span class=\"line\">Version     : 1.12.2</span><br><span class=\"line\">Release     : 2.el7</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\">Install Date: (not installed)</span><br><span class=\"line\">Group       : System Environment/Daemons</span><br><span class=\"line\">Size        : 1574949</span><br><span class=\"line\">License     : BSD</span><br><span class=\"line\">Signature   : RSA/SHA256, Tue 06 Mar 2018 05:44:06 PM CST, Key ID 6a2faea2352c64e5</span><br><span class=\"line\">Source RPM  : nginx-1.12.2-2.el7.src.rpm</span><br><span class=\"line\">Build Date  : Tue 06 Mar 2018 05:27:44 PM CST</span><br><span class=\"line\">Build Host  : buildhw-02.phx2.fedoraproject.org</span><br><span class=\"line\">Relocations : (not relocatable)</span><br><span class=\"line\">Packager    : Fedora Project</span><br><span class=\"line\">Vendor      : Fedora Project</span><br><span class=\"line\">URL         : &lt;http://nginx.org/&gt;</span><br><span class=\"line\">Bug URL     : &lt;https://bugz.fedoraproject.org/nginx&gt;</span><br><span class=\"line\">Summary     : A high performance web server and reverse proxy server</span><br><span class=\"line\">Description :</span><br><span class=\"line\">Nginx is a web server and a reverse proxy server <span class=\"keyword\">for</span> HTTP, SMTP, POP3 and</span><br><span class=\"line\">IMAP protocols, with a strong focus on high concurrency, performance and low</span><br><span class=\"line\">memory usage.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看脚本内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm --scripts -qp ./nginx-1.12.2-2.el7.x86_64.rpm</span><br><span class=\"line\">postinstall scriptlet (using /bin/sh):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -eq 1 ] ; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"comment\"># Initial installation</span></span><br><span class=\"line\">        systemctl preset nginx.service &gt;/dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">preuninstall scriptlet (using /bin/sh):</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -eq 0 ] ; <span class=\"keyword\">then</span></span><br><span class=\"line\">        <span class=\"comment\"># Package removal, not upgrade</span></span><br><span class=\"line\">        systemctl --no-reload <span class=\"built_in\">disable</span> nginx.service &gt; /dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\">        systemctl stop nginx.service &gt; /dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br><span class=\"line\">postuninstall scriptlet (using /bin/sh):</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl daemon-reload &gt;/dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [ <span class=\"variable\">$1</span> -ge 1 ]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    /usr/bin/nginx-upgrade &gt;/dev/null 2&gt;&amp;1 || :</span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-BuildRequires\"><a href=\"#2-2-BuildRequires\" class=\"headerlink\" title=\"2.2 BuildRequires\"></a>2.2 <strong>BuildRequires</strong></h3></li>\n</ul>\n<p>定义构建时依赖的软件包，在构建机器编译 rpm 包时需要的辅助工具，以逗号分隔。</p>\n<p>假如，要求编译 <code>myapp</code> 时，gcc 的版本至少为 4.4.2，则可以写成 <code>gcc &gt;=4.2.2</code></p>\n<h3 id=\"2-3-Requires\"><a href=\"#2-3-Requires\" class=\"headerlink\" title=\"2.3 Requires\"></a>2.3 <strong>Requires</strong></h3><p>定义安装时的依赖包，该 rpm 包所依赖的软件包名称，就是指编译好的 rpm 软件在其他机器上安装时，需要依赖的其他软件包。</p>\n<p>可以用 <code>&gt;=</code> 或 <code>&lt;=</code> 表示大于或小于某一特定版本。 <code>&gt;=</code> 号两边需用空格隔开，而不同软件名称也用空格分开。</p>\n<p>格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">Requires:       libpng-devel &gt;&#x3D; 1.0.20 zlib</span><br></pre></td></tr></table></figure>\n<p>其它写法例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">Requires: bzip2 &#x3D; %&#123;version&#125;, bzip2-libs &#x3D;%&#123;version&#125;</span><br></pre></td></tr></table></figure>\n<p>还有例如<code>PreReq</code>、<code>Requires(pre)</code>、<code>Requires(post)</code>、<code>Requires(preun)</code>、<code>Requires(postun)</code>、<code>BuildRequires</code>等都是针对不同阶段的依赖指定。</p>\n<p>关于<code>pre</code>、<code>post</code>、<code>preun</code>、<code>postun</code>含义理解，感觉<code>post</code>有一种“完成”的意思：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\"># 安装前执行的脚本，语法和shell脚本的语法相同</span><br><span class=\"line\">%pre</span><br><span class=\"line\"># 安装后执行的脚本</span><br><span class=\"line\">%post</span><br><span class=\"line\"># 卸载前执行的脚本</span><br><span class=\"line\">%preun</span><br><span class=\"line\"># 卸载完成后执行的脚本</span><br><span class=\"line\">%postun</span><br><span class=\"line\"># 清理阶段，在制作完成后删除安装的内容</span><br></pre></td></tr></table></figure>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">PreReq: capability&gt;&#x3D;version      #capability包必须先安装</span><br><span class=\"line\">Conflicts:bash&gt;&#x3D;2.0              #该包和所有不小于2.0的bash包有冲突</span><br></pre></td></tr></table></figure>\n<p><img src=\"SPEC%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20210315162108826.png\" alt=\"image-20210315162108826\"></p>\n<h3 id=\"2-4-BuildRoot\"><a href=\"#2-4-BuildRoot\" class=\"headerlink\" title=\"2.4 BuildRoot\"></a>2.4 <strong>BuildRoot</strong></h3><p>该参数非常重要，因为在生成 rpm 的过程中，执行 <code>make install</code> 时就会把软件安装到上述的路径中，在打包的时候，同样依赖“虚拟目录”为“根目录”进行操作。后面可使用 <code>$RPM_BUILD_ROOT</code> 方式引用。</p>\n<p>考虑到多用户的环境，一般定义为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%&#123;_tmppath&#125;&#x2F;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-root</span><br><span class=\"line\"># OR</span><br><span class=\"line\">%&#123;_tmppath&#125;&#x2F;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;-buildroot-%(%&#123;__id_u&#125; -n&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-预处理-prep\"><a href=\"#3-预处理-prep\" class=\"headerlink\" title=\"3. 预处理 %prep\"></a>3. 预处理 %prep</h2><p>这个阶段是「预处理」，通常用来执行一些解开源程序包的命令，为下一步的编译安装作准备。</p>\n<p><code>%prep</code> 和下面的 <code>%build</code>，<code>%install</code> 段一样，除了可以执行 rpm 所定义的宏命令（以<code>%</code>开头）以外，还可以执行 <code>SHELL</code> 命令，命令可以有很多行，如我们常写的 <code>tar</code> 解包命令。功能上类似于 <code>./configure</code>。</p>\n<p><code>%prep</code> 阶段进行实际的打包准备工作，它是使用节前缀 <code>%prep</code> 表示的。主要功能有：</p>\n<ul>\n<li>将文件 ( <code>SOURCES/</code>) 解压到构建目录 (<code>BUILD/</code>)</li>\n<li>应用 <code>Patch</code>（打补丁） (<code>SOURCES/ =&gt; BUILD/</code>)</li>\n<li>描述 <code>rm -rf $RPM_BUILD_ROOT</code></li>\n<li>描述或编辑本部分用到的命令到 <code>PreReq</code></li>\n<li>通过 <code>b .XXX</code> 描述补丁备份</li>\n</ul>\n<p>它一般包含 <code>%setup</code> 与 <code>%patch</code> 两个命令。<code>%setup</code> 用于将软件包打开，执行 <code>%patch</code> 可将补丁文件加入解开的源程序中。</p>\n<p>示例：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%prep</span><br><span class=\"line\">%setup -q                                     ← 宏的作用是解压并切换到目录</span><br><span class=\"line\"><span class=\"comment\">#%patch0 -p1                                  ← 如果需要打补丁，则依次写</span></span><br><span class=\"line\"><span class=\"comment\">#%patch1 -p1                                  ← 如果需要打补丁，则依次写</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-宏-setup\"><a href=\"#3-1-宏-setup\" class=\"headerlink\" title=\"3.1 宏 %setup\"></a>3.1 宏 <strong>%setup</strong></h3><p>这个宏解压源代码，将当前目录改为源代码解压之后产生的目录。这个宏还有一些选项可以用。例如，在解压后，<code>%setup</code> 宏假设产生的目录是 <code>%&#123;name&#125;-%&#123;version&#125;</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%setup -n %&#123;name&#125;-%&#123;version&#125; #把源码包解压并放好</span><br></pre></td></tr></table></figure>\n<p>主要的用途就是将 <code>%sourcedir</code> 目录下的源代码解压到 <code>%builddir</code> 目录下，也就是将<code>~/rpmbuild/SOURCES</code> 里的包解压到 <code>~/rpmbuild/BUILD/%&#123;name&#125;-%&#123;version&#125;</code> 中。一般用 <code>%setup -c</code> 就可以了，但有两种情况：</p>\n<ul>\n<li>一就是同时编译多个源码包，</li>\n<li>二就是源码的 tar 包的名称与解压出来的目录不一致，此时，就需要使用 <code>n</code> 参数指定一下。</li>\n</ul>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">不加任何选项，仅将软件包打开。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-a</span> <span class=\"string\">切换目录前，解压指定</span> <span class=\"string\">Source</span> <span class=\"string\">文件，例如</span> <span class=\"string\">`-a</span> <span class=\"number\">0</span><span class=\"string\">`</span> <span class=\"string\">表示解压</span> <span class=\"string\">`Source0`</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-n</span> <span class=\"string\">newdir</span> <span class=\"string\">将软件包解压在newdir目录。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-c</span> <span class=\"string\">解压缩之前先产生目录。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-b</span> <span class=\"string\">num</span> <span class=\"string\">将第</span> <span class=\"string\">num</span> <span class=\"string\">个</span> <span class=\"string\">source</span> <span class=\"string\">文件解压缩。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-D</span> <span class=\"string\">解压前不删除目录</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-T</span> <span class=\"string\">不使用default的解压缩操作。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-T</span> <span class=\"string\">-b</span> <span class=\"number\">0</span> <span class=\"string\">将第</span> <span class=\"number\">0</span> <span class=\"string\">个源代码文件解压缩。</span></span><br><span class=\"line\"><span class=\"string\">%setup</span> <span class=\"string\">-c</span> <span class=\"string\">-n</span> <span class=\"string\">newdir</span> <span class=\"string\">指定目录名称</span> <span class=\"string\">newdir，并在此目录产生</span> <span class=\"string\">rpm</span> <span class=\"string\">套件。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"string\">最简单的补丁方式，自动指定patch</span> <span class=\"string\">level。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"number\">0</span> <span class=\"string\">使用第0个补丁文件，相当于%patch</span> <span class=\"string\">?p</span> <span class=\"number\">0</span><span class=\"string\">。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"string\">-s</span> <span class=\"string\">不显示打补丁时的信息。</span></span><br><span class=\"line\"><span class=\"string\">%patch</span> <span class=\"string\">-T</span> <span class=\"string\">将所有打补丁时产生的输出文件删除</span></span><br></pre></td></tr></table></figure>\n<p>应该 <code>-q</code> 参数给 <code>%setup</code> 宏。这会显著减少编译日志文件的输出，尤其是源代码包会解压出一堆文件的时候。</p>\n<p>在 <code>~/rmpbuild/BUILD/%&#123;name&#125;-%&#123;version&#125;</code> 目录中进行 ，使用标准写法，会引用<code>/usr/lib/rpm/marcros</code> 中定义的参数。</p>\n<h3 id=\"3-2-宏-patch\"><a href=\"#3-2-宏-patch\" class=\"headerlink\" title=\"3.2 宏 %patch\"></a>3.2 宏 <strong>%patch</strong></h3><p>这个宏将头部定义的补丁应用于源代码。如果定义了多个补丁，它可以用一个数字的参数来指示应用哪个补丁文件。它也接受 <code>-b extension</code> 参数，指示 RPM 在打补丁之前，将文件备份为扩展名是 <code>extension</code> 的文件。</p>\n<p>通常补丁都会一起在源码 <code>tar.gz</code> 包中，或放到 <code>SOURCES</code> 目录下。一般参数为：</p>\n<ul>\n<li><code>%patch -p1</code> 使用前面定义的 <code>Patch</code> 补丁进行，<code>p1</code>是忽略 <code>patch</code> 的第一层目录</li>\n<li><code>%Patch2 -p1 -b xxx.patch</code>打上指定的补丁，<code>b</code>是指生成备份文件</li>\n</ul>\n<h3 id=\"3-3-build-阶段\"><a href=\"#3-3-build-阶段\" class=\"headerlink\" title=\"3.3 %build 阶段\"></a>3.3 <strong>%build 阶段</strong></h3><p>本段是「构建」阶段，这个阶段会在 <code>%_builddir</code> 目录下执行源码包的编译。一般是执行执行常见的 <code>configure</code> 和 <code>make</code> 操作。</p>\n<p>该阶段一般由多个 <code>make</code> 命令组成。与 <code>%prep</code> 段落一样，这些命令可以是 <code>shell</code> 命令，也可以是宏。</p>\n<p>记住两点：</p>\n<ol>\n<li><code>%build</code> 和 <code>%install</code> 的过程中，都必须把编译和安装的文件定义到“虚拟根目录” 中</li>\n<li><code>%file</code> 中必须明白，用的是相对目录</li>\n</ol>\n<p>这个阶段我们最常见只有两条指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%configure</span><br><span class=\"line\">make %&#123;?_smp_mflags&#125; OPTIMIZE&#x3D;&quot;%&#123;optflags&#125;&quot;           ← 多核则并行编译</span><br></pre></td></tr></table></figure>\n<p><code>%configure</code> 这个不是关键字，而是 rpm 定义的标准宏命令。意思是执行源代码的<code>configure</code>配置。会自动将 <code>prefix</code> 设置成 <code>/usr</code>。</p>\n<p>这个 <code>%&#123;?_smp_mflags&#125; %&#123;optflags&#125;</code> 是什么意思呢？</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">$ rpm --eval <span class=\"string\">&quot;%&#123;?_smp_mflags&#125;&quot;</span></span><br><span class=\"line\">-j4</span><br><span class=\"line\">$ rpm --eval <span class=\"string\">&quot;%&#123;optflags&#125;&quot;</span></span><br><span class=\"line\">-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=<span class=\"number\">2</span> -fexceptions -fstack-protector-strong --param=ssp-buffer-size=<span class=\"number\">4</span> -grecord-gcc-switches   -m64 -mtune=generic</span><br></pre></td></tr></table></figure>\n<p>所以，上面那个命令就是 <code>make -j4</code>。问题又来了，<code>make -j4</code> 表示什么意思？</p>\n<blockquote>\n<p>都是一些优化参数</p>\n</blockquote>\n<ul>\n<li><a href=\"https://nanxiao.me/linux-kernel-note-26-make-j/\">Linux kernel 笔记 （26）——利用“make -j”提高编译<code>kernel</code>速度</a></li>\n<li><a href=\"https://bbs.csdn.net/topics/380072770\">CSDB-make -j4是什么意思</a></li>\n</ul>\n<h3 id=\"3-4-install-阶段\"><a href=\"#3-4-install-阶段\" class=\"headerlink\" title=\"3.4 %install 阶段\"></a>3.4 <strong>%install 阶段</strong></h3><p>「安装」阶段，就是执行 <code>make install</code> 命令操作。开始把软件安装到虚拟的根目录中。这个阶段会在 <code>%buildrootdir</code> 目录里建好目录结构，然后将需要打包到 rpm 软件包里的文件从 <code>%builddir</code> 里拷贝到 <code>%_buildrootdir</code> 里对应的目录里。</p>\n<p>在 <code>~/rpmbuild/BUILD/%&#123;name&#125;-%&#123;version&#125;</code> 目录中进行 <code>make install</code> 的操作。<code>%install</code> 很重要，因为如果这里的路径不对的话，则下面 <code>%file</code> 中寻找文件的时候就会失败。</p>\n<p>特别需要注意的是：<code>%install</code> 部分使用的是绝对路径，而 <code>%file</code> 部分使用则是相对路径，虽然其描述的是同一个地方。千万不要写错。</p>\n<p>将已编译的软件安装到虚拟的目录结构中，从而可以打包成一个 RPM。当用户最终用 <code>rpm -ivh name-version.rpm</code> 安装软件包时，这些文件会安装到用户系统中相应的目录里。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">%install</span></span><br><span class=\"line\"><span class=\"string\">if</span> [<span class=\"string\">-d</span> <span class=\"string\">%</span>&#123;<span class=\"string\">buildroot</span>&#125;]<span class=\"string\">;</span> <span class=\"string\">then</span></span><br><span class=\"line\">   <span class=\"string\">rm</span> <span class=\"string\">-rf</span> <span class=\"string\">%&#123;buildroot&#125;</span>                      <span class=\"string\">←</span> <span class=\"string\">清空下安装目录，实际会自动清除</span></span><br><span class=\"line\"><span class=\"string\">fi</span></span><br><span class=\"line\"><span class=\"string\">make</span> <span class=\"string\">install</span> <span class=\"string\">DESTDIR=%&#123;buildroot&#125;</span>           <span class=\"string\">←</span> <span class=\"string\">安装到buildroot目录下</span></span><br><span class=\"line\"><span class=\"string\">%&#123;__install&#125;</span> <span class=\"string\">-Dp</span> <span class=\"string\">-m0755</span> <span class=\"string\">contrib/init.d</span> <span class=\"string\">%&#123;buildroot&#125;%&#123;_initrddir&#125;/foobar</span></span><br><span class=\"line\"><span class=\"string\">%&#123;__install&#125;</span> <span class=\"string\">-d</span> <span class=\"string\">%&#123;buildroot&#125;%&#123;_sysconfdir&#125;/foobar.d/</span></span><br></pre></td></tr></table></figure>\n<p>「翻译」一下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">make</span> <span class=\"string\">install</span> <span class=\"string\">DESTDIR=/root/rpmbuild/BUILDROOT/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.x86_64</span></span><br><span class=\"line\"><span class=\"string\">make</span> <span class=\"string\">install</span> <span class=\"string\">DESTDIR=/root/rpmbuild/BUILDROOT/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.x86_64</span></span><br><span class=\"line\"><span class=\"string\">/usr/bin/install</span> <span class=\"string\">-d</span> <span class=\"string\">/root/rpmbuild/BUILDROOT/%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.x86_64/etc/foobar.d/</span></span><br></pre></td></tr></table></figure>\n<p>需要说明的是，这里的 <code>%install</code> 主要就是为了后面的 <code>%file</code> 服务的。所以，还可以使用常规的系统命令：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">Copy</span></span><br><span class=\"line\"><span class=\"string\">install</span> <span class=\"string\">-d</span> <span class=\"string\">$RPM_BUILD_ROOT/</span></span><br><span class=\"line\"><span class=\"string\">cp</span> <span class=\"string\">-a</span> <span class=\"string\">*</span> <span class=\"string\">$RPM_BUILD_ROOT/</span></span><br></pre></td></tr></table></figure>\n<p>其中 <code>%&#123;buildroot&#125;</code> 和 <code>$RPMBUILDROOT</code> 是等价的， <code>%&#123;buildroot&#125;</code>必须全部用小写，不然要报错。</p>\n<p>注意区分 <code>$RPM_BUILD_ROOT</code>和 <code>$RPM_BUILD_DIR</code>：</p>\n<ul>\n<li><code>$RPM_BUILD_ROOT</code> 是指开头定义的 <code>BuildRoot</code>，是 <code>%file</code> 需要的。</li>\n<li><code>$RPM_BUILD_DIR</code> 通常就是指 <code>~/rpmbuild/BUILD</code></li>\n</ul>\n<p><strong>scripts section 没必要可以不填<a href=\"https://www.cnblogs.com/michael-xiang/p/10480809.html#3715799303\">#</a></strong></p>\n<ul>\n<li><code>%pre</code> 安装前执行的脚本</li>\n<li><code>%post</code> 安装后执行的脚本</li>\n<li><code>%preun</code> 卸载前执行的脚本</li>\n<li><code>%postun</code> 卸载后执行的脚本</li>\n<li><code>%pretrans</code> 在事务开始时执行脚本</li>\n<li><code>%posttrans</code> 在事务结束时执行脚本</li>\n</ul>\n<p><code>%preun</code> <code>%postun</code> 的区别是什么呢？</p>\n<ul>\n<li>前者在升级的时候会执行，后者在升级 rpm 包的时候不会执行</li>\n</ul>\n<h3 id=\"3-5-files-阶段\"><a href=\"#3-5-files-阶段\" class=\"headerlink\" title=\"3.5 %files 阶段\"></a>3.5 <strong>%files 阶段</strong></h3><p>任何打包的文件，都需要在这个包的详细的文件列表中，如果是目录，包的所有者的全部目录都在中间, %dir 来指定空目录，可以用 %files -f /tmp/dyanmic_filelist 来指定一个文件列表。</p>\n<p>默认 %config 会替换掉配置，给原来的配置修改名字为 .rpmorig ,如果不想修改的话，就用%config(noreplace) 就会给新的配置文件名字命名为 .rpmnew.</p>\n<p>本段是文件段，主要用来说明会将 <code>%&#123;buildroot&#125;</code> 目录下的哪些文件和目录最终打包到rpm包里。定义软件包所包含的文件，分为三类：</p>\n<ul>\n<li>说明文档（doc）</li>\n<li>配置文件（config）</li>\n<li>执行程序</li>\n</ul>\n<p>具体一点，包含如下场景：</p>\n<p><strong>1. 一个文件没有被%config或%config(noreplace)指令配置</strong></p>\n<p>此时，不管该文件在安装完成后，有没有在本地被修改过，当升级该rpm包时，该文件会被这个新的rpm包的里的同名文件替换,（旧文件被删除）。</p>\n<p><strong>2. 一个文件被%config指令配置</strong></p>\n<p>此时包含如下情况：</p>\n<ul>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换掉掉旧的文件，旧的文件会被保存为xx**.rpmsave**，如/etc/redis/redis.conf.rpmsave</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换掉旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。</li>\n</ul>\n<p><strong>3. 一个文件被%config(noreplace)指令配置</strong></p>\n<p>此时包含如下情况：</p>\n<ul>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，旧文件保持不变，新rpm包里的该文件并重命名为xx**.rpmnew**,例如/etc/redis/redis.conf.rpmnew</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地没有被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件会替换旧的文件。（旧文件被删除）</li>\n<li>该文件在新的rpm包里相对之前的rpm没有变化，且在本地被修改过。此时执行<code>rpm -Uvh xxxx</code>时，新rpm包里的该文件不会覆盖旧的文件，旧文件保持不变。</li>\n</ul>\n<p><a href=\"https://www.notion.so/4842b64880d6417c89d52d92b0c4d488\">Config总结</a></p>\n<table>\n<thead>\n<tr>\n<th>文件标记</th>\n<th>在update包中是否更新</th>\n<th>本地磁盘没有被修改</th>\n<th>本地磁盘被修改过</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>无</td>\n<td>没更新</td>\n<td>替换(旧文件删除)</td>\n<td>替换(旧文件删除)</td>\n</tr>\n<tr>\n<td>无</td>\n<td>更新</td>\n<td>替换(旧文件删除)</td>\n<td>替换(旧文件删除)</td>\n</tr>\n<tr>\n<td>%config</td>\n<td>没更新</td>\n<td>替换(旧文件删除)</td>\n<td>保留修改过的文件，不替换</td>\n</tr>\n<tr>\n<td>%config</td>\n<td>更新</td>\n<td>替换(旧文件删除)</td>\n<td>旧文件被保存为xxx.rpmsave，新文件替换旧文件</td>\n</tr>\n<tr>\n<td>%config(noreplace)</td>\n<td>没更新</td>\n<td>替换(旧文件删除)</td>\n<td>保留修改过的文件，不替换</td>\n</tr>\n<tr>\n<td>%config(noreplace)</td>\n<td>更新</td>\n<td>替换(旧文件删除)</td>\n<td>旧文件保持不变，新文件重命名为xxx.rpmnew</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.notion.so/a35c511b8d9e460f9a2e108a20a9f345\">当rpm包中该文件的标记方法发生改变的两个场景：</a></p>\n<table>\n<thead>\n<tr>\n<th>文件标记</th>\n<th>在update包中是否更新</th>\n<th>本地磁盘被修改过</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>之前是%config(noreplace)，现在是%config</td>\n<td>更新</td>\n<td>文件被替换，旧文件被保存为xxx.rpmsave</td>\n</tr>\n<tr>\n<td>之前是%config，现在是%config(noreplace)</td>\n<td>更新</td>\n<td>旧文件保持不变，update包中的新文件重命名为xxx.rpmnew</td>\n</tr>\n</tbody></table>\n<p><a href=\"https://www.notion.so/d9928d592b604f0990f4fe3401a645a8\">常用变量</a></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">macro</th>\n<th align=\"left\">definition</th>\n<th align=\"left\">comment</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><code>%&#123;_sysconfdir&#125;</code></td>\n<td align=\"left\"><code>/etc</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_prefix&#125;</code></td>\n<td align=\"left\"><code>/usr</code></td>\n<td align=\"left\">can be defined to <code>/app</code> for flatpak builds</td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;</code></td>\n<td align=\"left\"><code>%&#123;_prefix&#125;</code></td>\n<td align=\"left\">default: <code>/usr</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_includedir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_prefix&#125;/include</code></td>\n<td align=\"left\">default: <code>/usr/include</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_bindir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/bin</code></td>\n<td align=\"left\">default: <code>/usr/bin</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_libdir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/%&#123;_lib&#125;</code></td>\n<td align=\"left\">default: <code>/usr/%&#123;_lib&#125;</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_libexecdir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/libexec</code></td>\n<td align=\"left\">default: <code>/usr/libexec</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_sbindir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_exec_prefix&#125;/sbin</code></td>\n<td align=\"left\">default: <code>/usr/sbin</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_datadir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datarootdir&#125;</code></td>\n<td align=\"left\">default: <code>/usr/share</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_infodir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datarootdir&#125;/info</code></td>\n<td align=\"left\">default: <code>/usr/share/info</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_mandir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datarootdir&#125;/man</code></td>\n<td align=\"left\">default: <code>/usr/share/man</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_docdir&#125;</code></td>\n<td align=\"left\"><code>%&#123;_datadir&#125;/doc</code></td>\n<td align=\"left\">default: <code>/usr/share/doc</code></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_rundir&#125;</code></td>\n<td align=\"left\"><code>/run</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_localstatedir&#125;</code></td>\n<td align=\"left\"><code>/var</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_sharedstatedir&#125;</code></td>\n<td align=\"left\"><code>/var/lib</code></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"><code>%&#123;_lib&#125;</code></td>\n<td align=\"left\"><code>lib64</code></td>\n<td align=\"left\"><code>lib</code> on 32bit platforms</td>\n</tr>\n</tbody></table>\n<p>还可定义文件存取权限，拥有者及组别。</p>\n<p>这里会在虚拟根目录下进行，千万不要写绝对路径，而应用宏或变量表示相对路径。</p>\n<p>在 <code>%files</code> 阶段的第一条命令的语法是：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%defattr(文件权限,用户名,组名,目录权限)</span><br></pre></td></tr></table></figure>\n<p>注意点：同时需要在 <code>%install</code> 中安装。</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%files</span><br><span class=\"line\">%defattr (-,root,root,0755)                         ← 设定默认权限</span><br><span class=\"line\">%config(noreplace) /etc/my.cnf                      ← 表明是配置文件，noplace表示替换文件</span><br><span class=\"line\">%doc %&#123;src_dir&#125;/Docs/ChangeLog                      ← 表明这个是文档</span><br><span class=\"line\">%attr(644, root, root) %&#123;_mandir&#125;/man8/mysqld.8*    ← 分别是权限，属主，属组</span><br><span class=\"line\">%attr(755, root, root) %&#123;_sbindir&#125;/mysqld</span><br></pre></td></tr></table></figure>\n<p><code>%exclude</code> 列出不想打包到 rpm 中的文件。注意：如果 <code>%exclude</code> 指定的文件不存在，也会出错的。</p>\n<p>在安装 rpm 时，会将可执行的二进制文件放在 <code>/usr/bin</code> 目录下，动态库放在 <code>/usr/lib</code> 或者 <code>/usr/lib64</code> 目录下，配置文件放在 <code>/etc</code> 目录下，并且多次安装时新的配置文件不会覆盖以前已经存在的同名配置文件。</p>\n<p>关于 <code>%files</code> 阶段有两个特性：</p>\n<ol>\n<li><code>%&#123;buildroot&#125;</code> 里的所有文件都要明确被指定是否要被打包到 rpm里。什么意思呢？假如，<code>%&#123;buildroot&#125;</code> 目录下有 4 个目录 a、b、c和d，在 <code>%files</code> 里仅指定 a 和 b 要打包到 rpm 里，如果不把 c 和 d 用 <code>exclude</code> 声明是要报错的；</li>\n<li>如果声明了 <code>%&#123;buildroot&#125;</code> 里不存在的文件或者目录也会报错。</li>\n</ol>\n<p>关于 <code>%doc</code> 宏，所有跟在这个宏后面的文件都来自 <code>%&#123;_builddir&#125;</code> 目录，当用户安装 rpm 时，由这个宏所指定的文件都会安装到 <code>/usr/share/doc/name-version/</code> 目录里。</p>\n<h2 id=\"clean\"><a href=\"#clean\" class=\"headerlink\" title=\"%clean\"></a><strong>%clean</strong></h2><p>清理段，可以通过 <code>--clean</code> 删除 <code>BUILD</code></p>\n<p>编译完成后一些清理工作，主要包括对 <code>%&#123;buildroot&#125;</code> 目录的清空(这不是必须的)，通常执行诸如 <code>make clean</code> 之类的命令。</p>\n<h2 id=\"changelog\"><a href=\"#changelog\" class=\"headerlink\" title=\"%changelog\"></a><strong>%changelog</strong></h2><p>本段是修改日志段，记录 spec 的修改日志段。你可以将软件的每次修改记录到这里，保存到发布的软件包中，以便查询之用。</p>\n<p>每一个修改日志都有这样一种格式：</p>\n<ul>\n<li>第一行是：<code>星期 月 日 年 修改人 电子信箱</code>。其中：星期、月份均用英文形式的前 3 个字母，用中文会报错。</li>\n<li>接下来的行写的是修改了什么地方，可写多行。一般以减号开始，便于后续的查阅。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%changelog</span><br><span class=\"line\">* Fri Dec 29 2012 foobar &lt;foobar@kidding.com&gt; - 1.0.0-1</span><br><span class=\"line\">- Initial version</span><br></pre></td></tr></table></figure>\n<h2 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a><strong>宏</strong></h2><p>在定义文件的安装路径时，通常会使用类似 <code>%_sharedstatedir</code> 的宏，这些宏一般会在 <code>/usr/lib/rpm/macros</code> 中定义。关于宏的语法，可以查看 <a href=\"https://rpm.org/user_doc/macros.html\">Macro syntax</a></p>\n<p>RPM 内建宏定义在 <code>/usr/lib/rpm/redhat/macros</code> 文件中，这些宏基本上定义了目录路径或体系结构等等；同时也包含了一组用于调试 spec 文件的宏。</p>\n<p>所有宏都可以在 <code>/usr/lib/rpm/macros</code> 找到，附录一些常见的宏：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%&#123;_sysconfdir&#125;        &#x2F;etc</span><br><span class=\"line\">%&#123;_prefix&#125;            &#x2F;usr</span><br><span class=\"line\">%&#123;_exec_prefix&#125;       %&#123;_prefix&#125;</span><br><span class=\"line\">%&#123;_bindir&#125;            %&#123;_exec_prefix&#125;&#x2F;bin</span><br><span class=\"line\">%&#123;_lib&#125;               lib (lib64 on 64bit systems)</span><br><span class=\"line\">%&#123;_libdir&#125;            %&#123;_exec_prefix&#125;&#x2F;%&#123;_lib&#125;</span><br><span class=\"line\">%&#123;_libexecdir&#125;        %&#123;_exec_prefix&#125;&#x2F;libexec</span><br><span class=\"line\">%&#123;_sbindir&#125;           %&#123;_exec_prefix&#125;&#x2F;sbin</span><br><span class=\"line\">%&#123;_sharedstatedir&#125;    &#x2F;var&#x2F;lib</span><br><span class=\"line\">%&#123;_datadir&#125;           %&#123;_prefix&#125;&#x2F;share</span><br><span class=\"line\">%&#123;_includedir&#125;        %&#123;_prefix&#125;&#x2F;include</span><br><span class=\"line\">%&#123;_oldincludedir&#125;     &#x2F;usr&#x2F;include</span><br><span class=\"line\">%&#123;_infodir&#125;           &#x2F;usr&#x2F;share&#x2F;info</span><br><span class=\"line\">%&#123;_mandir&#125;            &#x2F;usr&#x2F;share&#x2F;man</span><br><span class=\"line\">%&#123;_localstatedir&#125;     &#x2F;var</span><br><span class=\"line\">%&#123;_initddir&#125;          %&#123;_sysconfdir&#125;&#x2F;rc.d&#x2F;init.d</span><br><span class=\"line\">%&#123;_topdir&#125;            %&#123;getenv:HOME&#125;&#x2F;rpmbuild</span><br><span class=\"line\">%&#123;_builddir&#125;          %&#123;_topdir&#125;&#x2F;BUILD</span><br><span class=\"line\">%&#123;_rpmdir&#125;            %&#123;_topdir&#125;&#x2F;RPMS</span><br><span class=\"line\">%&#123;_sourcedir&#125;         %&#123;_topdir&#125;&#x2F;SOURCES</span><br><span class=\"line\">%&#123;_specdir&#125;           %&#123;_topdir&#125;&#x2F;SPECS</span><br><span class=\"line\">%&#123;_srcrpmdir&#125;         %&#123;_topdir&#125;&#x2F;SRPMS</span><br><span class=\"line\">%&#123;_buildrootdir&#125;      %&#123;_topdir&#125;&#x2F;BUILDROOT</span><br><span class=\"line\">%&#123;_var&#125;               &#x2F;var</span><br><span class=\"line\">%&#123;_tmppath&#125;           %&#123;_var&#125;&#x2F;tmp</span><br><span class=\"line\">%&#123;_usr&#125;               &#x2F;usr</span><br><span class=\"line\">%&#123;_usrsrc&#125;            %&#123;_usr&#125;&#x2F;src</span><br><span class=\"line\">%&#123;_docdir&#125;            %&#123;_datadir&#125;&#x2F;doc</span><br><span class=\"line\">%&#123;buildroot&#125;          %&#123;_buildrootdir&#125;&#x2F;%&#123;name&#125;-%&#123;version&#125;-%&#123;release&#125;.%&#123;_arch&#125;</span><br><span class=\"line\">$RPM_BUILD_ROOT       %&#123;buildroot&#125;</span><br></pre></td></tr></table></figure>\n<p>利用 rpmbuild 构建 rpm 安装包时，通过命令 <code>rpm --showrc|grep prefix</code> 查看。</p>\n<p>通过 <code>rpm --eval &quot;%&#123;macro&#125;&quot;</code> 来查看具体对应路径。</p>\n<p>比如我们要查看 <code>%&#123;_bindir&#125;</code> 的路径，就可以使用命令 <code>rpm --eval &quot;%&#123; _bindir&#125;&quot;</code> 来查看。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">%&#123;_topdir&#125;            %&#123;getenv:HOME&#125;&#x2F;rpmbuild</span><br><span class=\"line\">%&#123;_builddir&#125;          %&#123;_topdir&#125;&#x2F;BUILD</span><br><span class=\"line\">%&#123;_rpmdir&#125;            %&#123;_topdir&#125;&#x2F;RPMS</span><br><span class=\"line\">%&#123;_sourcedir&#125;         %&#123;_topdir&#125;&#x2F;SOURCES</span><br><span class=\"line\">%&#123;_specdir&#125;           %&#123;_topdir&#125;&#x2F;SPECS</span><br><span class=\"line\">%&#123;_srcrpmdir&#125;         %&#123;_topdir&#125;&#x2F;SRPMS</span><br><span class=\"line\">%&#123;_buildrootdir&#125;      %&#123;_topdir&#125;&#x2F;BUILDROOT</span><br><span class=\"line\"></span><br><span class=\"line\">Note: On releases older than Fedora 10 (and EPEL), %&#123;_buildrootdir&#125; does not exist.</span><br><span class=\"line\">Build flags macros</span><br><span class=\"line\"></span><br><span class=\"line\">%&#123;_global_cflags&#125;     -O2 -g -pipe</span><br><span class=\"line\">%&#123;_optflags&#125;          %&#123;__global_cflags&#125; -m32 -march&#x3D;i386 -mtune&#x3D;pentium4 # if redhat-rpm-config is installed</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a><strong>变量</strong></h2><p><code>define</code> 定义的变量类似于局部变量，只在 <code>%&#123;!?foo: ... &#125;</code> 区间有效，不过 SPEC 并不会自动清除该变量，只有再次遇到 <code>%&#123;&#125;</code> 时才会清除</p>\n<h3 id=\"define-vs-global\"><a href=\"#define-vs-global\" class=\"headerlink\" title=\"define vs. global\"></a><strong>define vs. global</strong></h3><p>两者都可以用来进行变量定义，不过在细节上有些许差别，简单列举如下：</p>\n<ul>\n<li><code>define</code> 用来定义宏，<code>global</code> 用来定义变量；</li>\n<li>如果定义带参数的宏 (类似于函数)，必须要使用 <code>define</code>；</li>\n<li>在 <code>%&#123;&#125;</code> 内部，必须要使用 <code>global</code> 而非 <code>define</code>；</li>\n<li><code>define</code> 在使用时计算其值，而 <code>global</code> 则在定义时就计算其值；</li>\n</ul>\n<p>可以简单参考如下的示例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">#--- %prep之前的参数是必须要有的</span><br><span class=\"line\">Name:           mysql</span><br><span class=\"line\">Version:        5.7.17</span><br><span class=\"line\">Release:        1%&#123;?dist&#125;</span><br><span class=\"line\">Summary:        MySQL from FooBar.</span><br><span class=\"line\">License:        GPLv2+ and BSD</span><br><span class=\"line\"></span><br><span class=\"line\">%description</span><br><span class=\"line\">It is a MySQL from FooBar.</span><br><span class=\"line\"></span><br><span class=\"line\">%prep</span><br><span class=\"line\">#--- 带参数时，必须使用%define定义</span><br><span class=\"line\">%define myecho() echo %1 %2</span><br><span class=\"line\">%&#123;!?bar: %define bar defined&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">echo 1: %&#123;bar&#125;</span><br><span class=\"line\">%&#123;myecho 2: %&#123;bar&#125;&#125;</span><br><span class=\"line\">echo 3: %&#123;bar&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"># 如下是输出内容</span><br><span class=\"line\">#1: defined</span><br><span class=\"line\">#2: defined</span><br><span class=\"line\">#3: %&#123;bar&#125;</span><br></pre></td></tr></table></figure>\n<p>3 的输出是不符合预期的，可以将 <code>%define</code> 修改为 <code>global</code> 即可</p>\n<h3 id=\"dist-表示什么含义？\"><a href=\"#dist-表示什么含义？\" class=\"headerlink\" title=\"%{?dist} 表示什么含义？\"></a><strong>%{?dist} 表示什么含义？</strong></h3><p>不加问号，如果 <code>dist</code> 有定义，那么就会用定义的值替换，否则就会保 <code>%&#123;dist&#125;</code>;加问好，如果 <code>dist</code> 有定义，那么也是会用定义的值替换，否则就直接移除这个tag <code>%&#123;?dist&#125;</code></p>\n<p>举例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Copy</span><br><span class=\"line\">$ rpm -E &#39;foo:%&#123;foo&#125;&#39;$&#39;\\\\n&#39;&#39;bar:%&#123;?bar&#125;&#39;</span><br><span class=\"line\">foo:%&#123;foo&#125;</span><br><span class=\"line\">bar:</span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm -D&#39;foo foov&#39; -E &#39;foo:%&#123;foo&#125;&#39;$&#39;\\\\n&#39;&#39;bar:%&#123;?bar&#125;&#39;</span><br><span class=\"line\">foo:foov</span><br><span class=\"line\">bar:</span><br><span class=\"line\"></span><br><span class=\"line\">$ rpm -D&#39;foo foov&#39; -D&#39;bar barv&#39; -E &#39;foo:%&#123;foo&#125;&#39;$&#39;\\\\n&#39;&#39;bar:%&#123;?bar&#125;&#39;</span><br><span class=\"line\">foo:foov</span><br><span class=\"line\">bar:barv</span><br></pre></td></tr></table></figure>"},{"abbrlink":3,"_content":"# 《明解C语言》读书笔记\n\n## 第一章 初识C语言\n\n### 1. 转义字符\n\n1. 响铃🔔： \\a\n\n   <!--不过似乎没有什么用-->\n\n   ```c\n   #include <stdio.h>\n   \n   int main(void)\n   {\n       char *name = \"Evan\";\n       printf(\"Hello, %s!\\a\\a\\a\\n\", name);\n       return 0;\n   }\n   ```\n\n### 2. 通过键盘输入和显示\n\n 1. scanf\n\n    ```C\n    #include <stdio.h>\n    \n    int main(int argc, const char * argv[]) {\n        int number;\n        printf(\"Please input a number: \\n\");\n        scanf(\"%d\", &number);\n        printf(\"Your number is %d\\n\", number);\n        return 0;\n    }\n    ```\n\n2. puts\n\n   <!--注意puts已经带换行了-->\n\n   <!--scanf后面不用加\\n-->\n\n   ```C\n   #include <stdio.h>\n   \n   int main(int argc, const char * argv[]) {\n       int num1, num2;\n       puts(\"Please input two numbers.\");\n       printf(\"num1: \");\n       scanf(\"%d\", &num1);\n       printf(\"num2: \");\n       scanf(\"%d\", &num2);\n       printf(\"Sum is %d\\n\", num1 + num2);\n       return 0;\n   }\n   ```\n\n## 第二章 运算和数据类型\n\n### 1. 使用printf打印%\n\n​\t<!--如果想通过printf打印%的话，必须写成%%-->     \n\n```C\n#include <stdio.h>\n\nint main(int argc, const char * argv[]) {\n    int num1, num2;\n    puts(\"Please input two numbers.\");\n    printf(\"整数A: \");\n    scanf(\"%d\", &num1);\n    printf(\"整数B: \");\n    scanf(\"%d\", &num2);\n    printf(\"A的值是B的%d%%\\n\", num1*100/num2);\n    return 0;\n}\n```\n\n## 第三章 指针编程\n\n","source":"_posts/cplus_md/C Baisc/《明解C语言》读书笔记.md","raw":"---\nabbrlink: 3\n---\n# 《明解C语言》读书笔记\n\n## 第一章 初识C语言\n\n### 1. 转义字符\n\n1. 响铃🔔： \\a\n\n   <!--不过似乎没有什么用-->\n\n   ```c\n   #include <stdio.h>\n   \n   int main(void)\n   {\n       char *name = \"Evan\";\n       printf(\"Hello, %s!\\a\\a\\a\\n\", name);\n       return 0;\n   }\n   ```\n\n### 2. 通过键盘输入和显示\n\n 1. scanf\n\n    ```C\n    #include <stdio.h>\n    \n    int main(int argc, const char * argv[]) {\n        int number;\n        printf(\"Please input a number: \\n\");\n        scanf(\"%d\", &number);\n        printf(\"Your number is %d\\n\", number);\n        return 0;\n    }\n    ```\n\n2. puts\n\n   <!--注意puts已经带换行了-->\n\n   <!--scanf后面不用加\\n-->\n\n   ```C\n   #include <stdio.h>\n   \n   int main(int argc, const char * argv[]) {\n       int num1, num2;\n       puts(\"Please input two numbers.\");\n       printf(\"num1: \");\n       scanf(\"%d\", &num1);\n       printf(\"num2: \");\n       scanf(\"%d\", &num2);\n       printf(\"Sum is %d\\n\", num1 + num2);\n       return 0;\n   }\n   ```\n\n## 第二章 运算和数据类型\n\n### 1. 使用printf打印%\n\n​\t<!--如果想通过printf打印%的话，必须写成%%-->     \n\n```C\n#include <stdio.h>\n\nint main(int argc, const char * argv[]) {\n    int num1, num2;\n    puts(\"Please input two numbers.\");\n    printf(\"整数A: \");\n    scanf(\"%d\", &num1);\n    printf(\"整数B: \");\n    scanf(\"%d\", &num2);\n    printf(\"A的值是B的%d%%\\n\", num1*100/num2);\n    return 0;\n}\n```\n\n## 第三章 指针编程\n\n","slug":"cplus_md/C Baisc/《明解C语言》读书笔记","published":1,"date":"2020-11-03T11:19:17.000Z","updated":"2021-04-20T13:07:42.254Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6c003xw9q99dqkb2ya","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"《明解C语言》读书笔记\"><a href=\"#《明解C语言》读书笔记\" class=\"headerlink\" title=\"《明解C语言》读书笔记\"></a>《明解C语言》读书笔记</h1><h2 id=\"第一章-初识C语言\"><a href=\"#第一章-初识C语言\" class=\"headerlink\" title=\"第一章 初识C语言\"></a>第一章 初识C语言</h2><h3 id=\"1-转义字符\"><a href=\"#1-转义字符\" class=\"headerlink\" title=\"1. 转义字符\"></a>1. 转义字符</h3><ol>\n<li><p>响铃🔔： \\a</p>\n<!--不过似乎没有什么用-->\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name = <span class=\"string\">&quot;Evan&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello, %s!\\a\\a\\a\\n&quot;</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-通过键盘输入和显示\"><a href=\"#2-通过键盘输入和显示\" class=\"headerlink\" title=\"2. 通过键盘输入和显示\"></a>2. 通过键盘输入和显示</h3></li>\n<li><p>scanf</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Please input a number: \\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;number);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your number is %d\\n&quot;</span>, number);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>puts</p>\n<!--注意puts已经带换行了-->\n\n<!--scanf后面不用加\\n-->\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1, num2;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please input two numbers.&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;num1: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num1);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;num2: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num2);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Sum is %d\\n&quot;</span>, num1 + num2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二章-运算和数据类型\"><a href=\"#第二章-运算和数据类型\" class=\"headerlink\" title=\"第二章 运算和数据类型\"></a>第二章 运算和数据类型</h2></li>\n</ol>\n<h3 id=\"1-使用printf打印\"><a href=\"#1-使用printf打印\" class=\"headerlink\" title=\"1. 使用printf打印%\"></a>1. 使用printf打印%</h3><p>​    <!--如果想通过printf打印%的话，必须写成%%-->     </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1, num2;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please input two numbers.&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;整数A: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num1);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;整数B: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num2);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;A的值是B的%d%%\\n&quot;</span>, num1*<span class=\"number\">100</span>/num2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三章-指针编程\"><a href=\"#第三章-指针编程\" class=\"headerlink\" title=\"第三章 指针编程\"></a>第三章 指针编程</h2>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"《明解C语言》读书笔记\"><a href=\"#《明解C语言》读书笔记\" class=\"headerlink\" title=\"《明解C语言》读书笔记\"></a>《明解C语言》读书笔记</h1><h2 id=\"第一章-初识C语言\"><a href=\"#第一章-初识C语言\" class=\"headerlink\" title=\"第一章 初识C语言\"></a>第一章 初识C语言</h2><h3 id=\"1-转义字符\"><a href=\"#1-转义字符\" class=\"headerlink\" title=\"1. 转义字符\"></a>1. 转义字符</h3><ol>\n<li><p>响铃🔔： \\a</p>\n<!--不过似乎没有什么用-->\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *name = <span class=\"string\">&quot;Evan&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello, %s!\\a\\a\\a\\n&quot;</span>, name);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-通过键盘输入和显示\"><a href=\"#2-通过键盘输入和显示\" class=\"headerlink\" title=\"2. 通过键盘输入和显示\"></a>2. 通过键盘输入和显示</h3></li>\n<li><p>scanf</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Please input a number: \\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;number);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Your number is %d\\n&quot;</span>, number);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>puts</p>\n<!--注意puts已经带换行了-->\n\n<!--scanf后面不用加\\n-->\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1, num2;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please input two numbers.&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;num1: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num1);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;num2: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num2);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Sum is %d\\n&quot;</span>, num1 + num2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二章-运算和数据类型\"><a href=\"#第二章-运算和数据类型\" class=\"headerlink\" title=\"第二章 运算和数据类型\"></a>第二章 运算和数据类型</h2></li>\n</ol>\n<h3 id=\"1-使用printf打印\"><a href=\"#1-使用printf打印\" class=\"headerlink\" title=\"1. 使用printf打印%\"></a>1. 使用printf打印%</h3><p>​    <!--如果想通过printf打印%的话，必须写成%%-->     </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> * argv[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num1, num2;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Please input two numbers.&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;整数A: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num1);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;整数B: &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>, &amp;num2);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;A的值是B的%d%%\\n&quot;</span>, num1*<span class=\"number\">100</span>/num2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三章-指针编程\"><a href=\"#第三章-指针编程\" class=\"headerlink\" title=\"第三章 指针编程\"></a>第三章 指针编程</h2>"},{"title":"C++11 中的std::function和std::bind","date":"2020-12-31T15:59:00.000Z","abbrlink":13001,"cover":"img/cpp.png","_content":"# C++11 中的std::function和std::bind\n\n------\n\n## 可调用对象\n\n可调用对象有一下几种定义：\n\n- 是一个函数指针，参考 [C++ 函数指针和函数类型](https://www.jianshu.com/p/6ecfd541ec04)；\n- 是一个具有operator()成员函数的类的对象；\n- 可被转换成函数指针的类对象；\n- 一个类成员函数指针；\n\nC++中**可调用对象**的虽然都有一个比较统一的操作形式，但是定义方法五花八门，这样就导致使用统一的方式保存可调用对象或者传递可调用对象时，会十分繁琐。C++11中提供了std::function和std::bind统一了可调用对象的各种操作。\n\n不同类型可能具有相同的调用形式，如：\n\n```cpp\n// 普通函数\nint add(int a, int b){return a+b;} \n\n// lambda表达式\nauto mod = [](int a, int b){ return a % b;}\n\n// 函数对象类\nstruct divide{\n    int operator()(int denominator, int divisor){\n        return denominator/divisor;\n    }\n};\n```\n\n上述三种可调用对象虽然类型不同，但是共享了一种调用形式：\n\n```cpp\nint(int ,int)\n```\n\nstd::function就可以将上述类型保存起来，如下：\n\n```cpp\nstd::function<int(int ,int)>  a = add; \nstd::function<int(int ,int)>  b = mod ; \nstd::function<int(int ,int)>  c = divide(); \n```\n\n## std::function\n\n- std::function 是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。\n- 定义格式：std::function<函数类型>。\n- std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为回调函数使用。它比普通函数指针更加的灵活和便利。\n\n## std::bind\n\n可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。\n\nstd::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：\n\n- 将可调用对象和其参数绑定成一个防函数；\n- 只绑定部分参数，减少可调用对象传入的参数。\n\n### std::bind绑定普通函数\n\n```cpp\ndouble my_divide (double x, double y) {return x/y;}\nauto fn_half = std::bind (my_divide,_1,2);  \nstd::cout << fn_half(10) << '\\n';                        // 5\n```\n\n- bind的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此std::bind (my_divide,_1,2)等价于std::bind (&my_divide,_1,2)；\n- _1表示占位符，位于<functional>中，std::placeholders::_1；\n\n### std::bind绑定一个成员函数\n\n```cpp\nstruct Foo {\n    void print_sum(int n1, int n2)\n    {\n        std::cout << n1+n2 << '\\n';\n    }\n    int data = 10;\n};\nint main() \n{\n    Foo foo;\n    auto f = std::bind(&Foo::print_sum, &foo, 95, std::placeholders::_1);\n    f(5); // 100\n}\n```\n\n- bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。\n- 必须显示的指定&Foo::print_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在Foo::print_sum前添加&；\n- 使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &foo；\n\n### 绑定一个引用参数\n\n默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。\n\n\n\n```cpp\n#include <iostream>\n#include <functional>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std::placeholders;\nusing namespace std;\n\nostream & print(ostream &os, const string& s, char c)\n{\n    os << s << c;\n    return os;\n}\n\nint main()\n{\n    vector<string> words{\"helo\", \"world\", \"this\", \"is\", \"C++11\"};\n    ostringstream os;\n    char c = ' ';\n    for_each(words.begin(), words.end(), \n                   [&os, c](const string & s){os << s << c;} );\n    cout << os.str() << endl;\n\n    ostringstream os1;\n    // ostream不能拷贝，若希望传递给bind一个对象，\n    // 而不拷贝它，就必须使用标准库提供的ref函数\n    for_each(words.begin(), words.end(),\n                   bind(print, ref(os1), _1, c));\n    cout << os1.str() << endl;\n}\n```\n\n## 指向成员函数的指针\n\n通过下面的例子，熟悉一下指向成员函数的指针的定义方法。\n\n```cpp\n#include <iostream>\nstruct Foo {\n    int value;\n    void f() { std::cout << \"f(\" << this->value << \")\\n\"; }\n    void g() { std::cout << \"g(\" << this->value << \")\\n\"; }\n};\nvoid apply(Foo* foo1, Foo* foo2, void (Foo::*fun)()) {\n    (foo1->*fun)();  // call fun on the object foo1\n    (foo2->*fun)();  // call fun on the object foo2\n}\nint main() {\n    Foo foo1{1};\n    Foo foo2{2};\n    apply(&foo1, &foo2, &Foo::f);\n    apply(&foo1, &foo2, &Foo::g);\n}\n```\n\n- 成员函数指针的定义：void (Foo::*fun)()，调用是传递的实参: &Foo::f；\n- fun为类成员函数指针，所以调用是要通过解引用的方式获取成员函数*fun,即`(foo1->*fun)();`\n\n## 参考\n\n- [C++ 函数指针和函数类型](https://www.jianshu.com/p/6ecfd541ec04)\n- [How std::function works](https://link.jianshu.com?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F14936539%2Fhow-stdfunction-works)\n- [How std::bind works with member functions](https://link.jianshu.com?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F37636373%2Fhow-stdbind-works-with-member-functions)","source":"_posts/cplus_md/CPlus Basic/C++ stdbind的使用.md","raw":"---\ntitle: C++11 中的std::function和std::bind\ndate: '2020/12/31 23:59'\ntags:\n - cpp\ncategories:\n - 使用教程\nabbrlink: 13001\ncover: img/cpp.png\n---\n# C++11 中的std::function和std::bind\n\n------\n\n## 可调用对象\n\n可调用对象有一下几种定义：\n\n- 是一个函数指针，参考 [C++ 函数指针和函数类型](https://www.jianshu.com/p/6ecfd541ec04)；\n- 是一个具有operator()成员函数的类的对象；\n- 可被转换成函数指针的类对象；\n- 一个类成员函数指针；\n\nC++中**可调用对象**的虽然都有一个比较统一的操作形式，但是定义方法五花八门，这样就导致使用统一的方式保存可调用对象或者传递可调用对象时，会十分繁琐。C++11中提供了std::function和std::bind统一了可调用对象的各种操作。\n\n不同类型可能具有相同的调用形式，如：\n\n```cpp\n// 普通函数\nint add(int a, int b){return a+b;} \n\n// lambda表达式\nauto mod = [](int a, int b){ return a % b;}\n\n// 函数对象类\nstruct divide{\n    int operator()(int denominator, int divisor){\n        return denominator/divisor;\n    }\n};\n```\n\n上述三种可调用对象虽然类型不同，但是共享了一种调用形式：\n\n```cpp\nint(int ,int)\n```\n\nstd::function就可以将上述类型保存起来，如下：\n\n```cpp\nstd::function<int(int ,int)>  a = add; \nstd::function<int(int ,int)>  b = mod ; \nstd::function<int(int ,int)>  c = divide(); \n```\n\n## std::function\n\n- std::function 是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。\n- 定义格式：std::function<函数类型>。\n- std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为回调函数使用。它比普通函数指针更加的灵活和便利。\n\n## std::bind\n\n可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。\n\nstd::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：\n\n- 将可调用对象和其参数绑定成一个防函数；\n- 只绑定部分参数，减少可调用对象传入的参数。\n\n### std::bind绑定普通函数\n\n```cpp\ndouble my_divide (double x, double y) {return x/y;}\nauto fn_half = std::bind (my_divide,_1,2);  \nstd::cout << fn_half(10) << '\\n';                        // 5\n```\n\n- bind的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此std::bind (my_divide,_1,2)等价于std::bind (&my_divide,_1,2)；\n- _1表示占位符，位于<functional>中，std::placeholders::_1；\n\n### std::bind绑定一个成员函数\n\n```cpp\nstruct Foo {\n    void print_sum(int n1, int n2)\n    {\n        std::cout << n1+n2 << '\\n';\n    }\n    int data = 10;\n};\nint main() \n{\n    Foo foo;\n    auto f = std::bind(&Foo::print_sum, &foo, 95, std::placeholders::_1);\n    f(5); // 100\n}\n```\n\n- bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。\n- 必须显示的指定&Foo::print_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在Foo::print_sum前添加&；\n- 使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &foo；\n\n### 绑定一个引用参数\n\n默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。\n\n\n\n```cpp\n#include <iostream>\n#include <functional>\n#include <vector>\n#include <algorithm>\n#include <sstream>\nusing namespace std::placeholders;\nusing namespace std;\n\nostream & print(ostream &os, const string& s, char c)\n{\n    os << s << c;\n    return os;\n}\n\nint main()\n{\n    vector<string> words{\"helo\", \"world\", \"this\", \"is\", \"C++11\"};\n    ostringstream os;\n    char c = ' ';\n    for_each(words.begin(), words.end(), \n                   [&os, c](const string & s){os << s << c;} );\n    cout << os.str() << endl;\n\n    ostringstream os1;\n    // ostream不能拷贝，若希望传递给bind一个对象，\n    // 而不拷贝它，就必须使用标准库提供的ref函数\n    for_each(words.begin(), words.end(),\n                   bind(print, ref(os1), _1, c));\n    cout << os1.str() << endl;\n}\n```\n\n## 指向成员函数的指针\n\n通过下面的例子，熟悉一下指向成员函数的指针的定义方法。\n\n```cpp\n#include <iostream>\nstruct Foo {\n    int value;\n    void f() { std::cout << \"f(\" << this->value << \")\\n\"; }\n    void g() { std::cout << \"g(\" << this->value << \")\\n\"; }\n};\nvoid apply(Foo* foo1, Foo* foo2, void (Foo::*fun)()) {\n    (foo1->*fun)();  // call fun on the object foo1\n    (foo2->*fun)();  // call fun on the object foo2\n}\nint main() {\n    Foo foo1{1};\n    Foo foo2{2};\n    apply(&foo1, &foo2, &Foo::f);\n    apply(&foo1, &foo2, &Foo::g);\n}\n```\n\n- 成员函数指针的定义：void (Foo::*fun)()，调用是传递的实参: &Foo::f；\n- fun为类成员函数指针，所以调用是要通过解引用的方式获取成员函数*fun,即`(foo1->*fun)();`\n\n## 参考\n\n- [C++ 函数指针和函数类型](https://www.jianshu.com/p/6ecfd541ec04)\n- [How std::function works](https://link.jianshu.com?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F14936539%2Fhow-stdfunction-works)\n- [How std::bind works with member functions](https://link.jianshu.com?t=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F37636373%2Fhow-stdbind-works-with-member-functions)","slug":"cplus_md/CPlus Basic/C++ stdbind的使用","published":1,"updated":"2021-04-09T14:06:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6c003zw9q90fik4xi8","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"C-11-中的std-function和std-bind\"><a href=\"#C-11-中的std-function和std-bind\" class=\"headerlink\" title=\"C++11 中的std::function和std::bind\"></a>C++11 中的std::function和std::bind</h1><hr>\n<h2 id=\"可调用对象\"><a href=\"#可调用对象\" class=\"headerlink\" title=\"可调用对象\"></a>可调用对象</h2><p>可调用对象有一下几种定义：</p>\n<ul>\n<li>是一个函数指针，参考 <a href=\"https://www.jianshu.com/p/6ecfd541ec04\">C++ 函数指针和函数类型</a>；</li>\n<li>是一个具有operator()成员函数的类的对象；</li>\n<li>可被转换成函数指针的类对象；</li>\n<li>一个类成员函数指针；</li>\n</ul>\n<p>C++中<strong>可调用对象</strong>的虽然都有一个比较统一的操作形式，但是定义方法五花八门，这样就导致使用统一的方式保存可调用对象或者传递可调用对象时，会十分繁琐。C++11中提供了std::function和std::bind统一了可调用对象的各种操作。</p>\n<p>不同类型可能具有相同的调用形式，如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;<span class=\"keyword\">return</span> a+b;&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lambda表达式</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> mod = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123; <span class=\"keyword\">return</span> a % b;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数对象类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">divide</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> denominator, <span class=\"keyword\">int</span> divisor)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> denominator/divisor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述三种可调用对象虽然类型不同，但是共享了一种调用形式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)</span><br></pre></td></tr></table></figure>\n<p>std::function就可以将上述类型保存起来，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)&gt;  a = add; </span><br><span class=\"line\"><span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)&gt;  b = mod ; </span><br><span class=\"line\"><span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)&gt;  c = divide(); </span><br></pre></td></tr></table></figure>\n<h2 id=\"std-function\"><a href=\"#std-function\" class=\"headerlink\" title=\"std::function\"></a>std::function</h2><ul>\n<li>std::function 是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。</li>\n<li>定义格式：std::function&lt;函数类型&gt;。</li>\n<li>std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为回调函数使用。它比普通函数指针更加的灵活和便利。</li>\n</ul>\n<h2 id=\"std-bind\"><a href=\"#std-bind\" class=\"headerlink\" title=\"std::bind\"></a>std::bind</h2><p>可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>\n<p>std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：</p>\n<ul>\n<li>将可调用对象和其参数绑定成一个防函数；</li>\n<li>只绑定部分参数，减少可调用对象传入的参数。</li>\n</ul>\n<h3 id=\"std-bind绑定普通函数\"><a href=\"#std-bind绑定普通函数\" class=\"headerlink\" title=\"std::bind绑定普通函数\"></a>std::bind绑定普通函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">my_divide</span> <span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x/y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> fn_half = <span class=\"built_in\">std</span>::bind (my_divide,_1,<span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; fn_half(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;                        <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>bind的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此std::bind (my_divide,_1,2)等价于std::bind (&amp;my_divide,_1,2)；</li>\n<li>_1表示占位符，位于<functional>中，std::placeholders::_1；</li>\n</ul>\n<h3 id=\"std-bind绑定一个成员函数\"><a href=\"#std-bind绑定一个成员函数\" class=\"headerlink\" title=\"std::bind绑定一个成员函数\"></a>std::bind绑定一个成员函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> n1, <span class=\"keyword\">int</span> n2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; n1+n2 &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Foo foo;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = <span class=\"built_in\">std</span>::bind(&amp;Foo::print_sum, &amp;foo, <span class=\"number\">95</span>, <span class=\"built_in\">std</span>::placeholders::_1);</span><br><span class=\"line\">    f(<span class=\"number\">5</span>); <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。</li>\n<li>必须显示的指定&amp;Foo::print_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在Foo::print_sum前添加&amp;；</li>\n<li>使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &amp;foo；</li>\n</ul>\n<h3 id=\"绑定一个引用参数\"><a href=\"#绑定一个引用参数\" class=\"headerlink\" title=\"绑定一个引用参数\"></a>绑定一个引用参数</h3><p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>::placeholders;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ostream &amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s, <span class=\"keyword\">char</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    os &lt;&lt; s &lt;&lt; c;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; words&#123;<span class=\"string\">&quot;helo&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;this&quot;</span>, <span class=\"string\">&quot;is&quot;</span>, <span class=\"string\">&quot;C++11&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">ostringstream</span> os;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    for_each(words.begin(), words.end(), </span><br><span class=\"line\">                   [&amp;os, c](<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp; s)&#123;os &lt;&lt; s &lt;&lt; c;&#125; );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; os.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ostringstream</span> os1;</span><br><span class=\"line\">    <span class=\"comment\">// ostream不能拷贝，若希望传递给bind一个对象，</span></span><br><span class=\"line\">    <span class=\"comment\">// 而不拷贝它，就必须使用标准库提供的ref函数</span></span><br><span class=\"line\">    for_each(words.begin(), words.end(),</span><br><span class=\"line\">                   bind(print, ref(os1), _1, c));</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; os1.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"指向成员函数的指针\"><a href=\"#指向成员函数的指针\" class=\"headerlink\" title=\"指向成员函数的指针\"></a>指向成员函数的指针</h2><p>通过下面的例子，熟悉一下指向成员函数的指针的定义方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;f(&quot;</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;value &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;g(&quot;</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;value &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(Foo* foo1, Foo* foo2, <span class=\"keyword\">void</span> (Foo::*fun)())</span> </span>&#123;</span><br><span class=\"line\">    (foo1-&gt;*fun)();  <span class=\"comment\">// call fun on the object foo1</span></span><br><span class=\"line\">    (foo2-&gt;*fun)();  <span class=\"comment\">// call fun on the object foo2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Foo foo1&#123;<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    Foo foo2&#123;<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    apply(&amp;foo1, &amp;foo2, &amp;Foo::f);</span><br><span class=\"line\">    apply(&amp;foo1, &amp;foo2, &amp;Foo::g);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>成员函数指针的定义：void (Foo::*fun)()，调用是传递的实参: &amp;Foo::f；</li>\n<li>fun为类成员函数指针，所以调用是要通过解引用的方式获取成员函数*fun,即<code>(foo1-&gt;*fun)();</code></li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/6ecfd541ec04\">C++ 函数指针和函数类型</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https://stackoverflow.com/questions/14936539/how-stdfunction-works\">How std::function works</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https://stackoverflow.com/questions/37636373/how-stdbind-works-with-member-functions\">How std::bind works with member functions</a></li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"C-11-中的std-function和std-bind\"><a href=\"#C-11-中的std-function和std-bind\" class=\"headerlink\" title=\"C++11 中的std::function和std::bind\"></a>C++11 中的std::function和std::bind</h1><hr>\n<h2 id=\"可调用对象\"><a href=\"#可调用对象\" class=\"headerlink\" title=\"可调用对象\"></a>可调用对象</h2><p>可调用对象有一下几种定义：</p>\n<ul>\n<li>是一个函数指针，参考 <a href=\"https://www.jianshu.com/p/6ecfd541ec04\">C++ 函数指针和函数类型</a>；</li>\n<li>是一个具有operator()成员函数的类的对象；</li>\n<li>可被转换成函数指针的类对象；</li>\n<li>一个类成员函数指针；</li>\n</ul>\n<p>C++中<strong>可调用对象</strong>的虽然都有一个比较统一的操作形式，但是定义方法五花八门，这样就导致使用统一的方式保存可调用对象或者传递可调用对象时，会十分繁琐。C++11中提供了std::function和std::bind统一了可调用对象的各种操作。</p>\n<p>不同类型可能具有相同的调用形式，如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 普通函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;<span class=\"keyword\">return</span> a+b;&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// lambda表达式</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> mod = [](<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)&#123; <span class=\"keyword\">return</span> a % b;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数对象类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">divide</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">operator</span><span class=\"params\">()</span><span class=\"params\">(<span class=\"keyword\">int</span> denominator, <span class=\"keyword\">int</span> divisor)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> denominator/divisor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>上述三种可调用对象虽然类型不同，但是共享了一种调用形式：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)</span><br></pre></td></tr></table></figure>\n<p>std::function就可以将上述类型保存起来，如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)&gt;  a = add; </span><br><span class=\"line\"><span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)&gt;  b = mod ; </span><br><span class=\"line\"><span class=\"built_in\">std</span>::function&lt;<span class=\"keyword\">int</span>(<span class=\"keyword\">int</span> ,<span class=\"keyword\">int</span>)&gt;  c = divide(); </span><br></pre></td></tr></table></figure>\n<h2 id=\"std-function\"><a href=\"#std-function\" class=\"headerlink\" title=\"std::function\"></a>std::function</h2><ul>\n<li>std::function 是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行。</li>\n<li>定义格式：std::function&lt;函数类型&gt;。</li>\n<li>std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为回调函数使用。它比普通函数指针更加的灵活和便利。</li>\n</ul>\n<h2 id=\"std-bind\"><a href=\"#std-bind\" class=\"headerlink\" title=\"std::bind\"></a>std::bind</h2><p>可将std::bind函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。</p>\n<p>std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：</p>\n<ul>\n<li>将可调用对象和其参数绑定成一个防函数；</li>\n<li>只绑定部分参数，减少可调用对象传入的参数。</li>\n</ul>\n<h3 id=\"std-bind绑定普通函数\"><a href=\"#std-bind绑定普通函数\" class=\"headerlink\" title=\"std::bind绑定普通函数\"></a>std::bind绑定普通函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">my_divide</span> <span class=\"params\">(<span class=\"keyword\">double</span> x, <span class=\"keyword\">double</span> y)</span> </span>&#123;<span class=\"keyword\">return</span> x/y;&#125;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> fn_half = <span class=\"built_in\">std</span>::bind (my_divide,_1,<span class=\"number\">2</span>);  </span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; fn_half(<span class=\"number\">10</span>) &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;                        <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>bind的第一个参数是函数名，普通函数做实参时，会隐式转换成函数指针。因此std::bind (my_divide,_1,2)等价于std::bind (&amp;my_divide,_1,2)；</li>\n<li>_1表示占位符，位于<functional>中，std::placeholders::_1；</li>\n</ul>\n<h3 id=\"std-bind绑定一个成员函数\"><a href=\"#std-bind绑定一个成员函数\" class=\"headerlink\" title=\"std::bind绑定一个成员函数\"></a>std::bind绑定一个成员函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_sum</span><span class=\"params\">(<span class=\"keyword\">int</span> n1, <span class=\"keyword\">int</span> n2)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; n1+n2 &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data = <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    Foo foo;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> f = <span class=\"built_in\">std</span>::bind(&amp;Foo::print_sum, &amp;foo, <span class=\"number\">95</span>, <span class=\"built_in\">std</span>::placeholders::_1);</span><br><span class=\"line\">    f(<span class=\"number\">5</span>); <span class=\"comment\">// 100</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址。</li>\n<li>必须显示的指定&amp;Foo::print_sum，因为编译器不会将对象的成员函数隐式转换成函数指针，所以必须在Foo::print_sum前添加&amp;；</li>\n<li>使用对象成员函数的指针时，必须要知道该指针属于哪个对象，因此第二个参数为对象的地址 &amp;foo；</li>\n</ul>\n<h3 id=\"绑定一个引用参数\"><a href=\"#绑定一个引用参数\" class=\"headerlink\" title=\"绑定一个引用参数\"></a>绑定一个引用参数</h3><p>默认情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。但是，与lambda类似，有时对有些绑定的参数希望以引用的方式传递，或是要绑定参数的类型无法拷贝。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;functional&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>::placeholders;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ostream &amp; <span class=\"title\">print</span><span class=\"params\">(ostream &amp;os, <span class=\"keyword\">const</span> <span class=\"built_in\">string</span>&amp; s, <span class=\"keyword\">char</span> c)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    os &lt;&lt; s &lt;&lt; c;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">string</span>&gt; words&#123;<span class=\"string\">&quot;helo&quot;</span>, <span class=\"string\">&quot;world&quot;</span>, <span class=\"string\">&quot;this&quot;</span>, <span class=\"string\">&quot;is&quot;</span>, <span class=\"string\">&quot;C++11&quot;</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">ostringstream</span> os;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">    for_each(words.begin(), words.end(), </span><br><span class=\"line\">                   [&amp;os, c](<span class=\"keyword\">const</span> <span class=\"built_in\">string</span> &amp; s)&#123;os &lt;&lt; s &lt;&lt; c;&#125; );</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; os.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">ostringstream</span> os1;</span><br><span class=\"line\">    <span class=\"comment\">// ostream不能拷贝，若希望传递给bind一个对象，</span></span><br><span class=\"line\">    <span class=\"comment\">// 而不拷贝它，就必须使用标准库提供的ref函数</span></span><br><span class=\"line\">    for_each(words.begin(), words.end(),</span><br><span class=\"line\">                   bind(print, ref(os1), _1, c));</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; os1.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"指向成员函数的指针\"><a href=\"#指向成员函数的指针\" class=\"headerlink\" title=\"指向成员函数的指针\"></a>指向成员函数的指针</h2><p>通过下面的例子，熟悉一下指向成员函数的指针的定义方法。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Foo</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> value;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;f(&quot;</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;value &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">g</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;g(&quot;</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;value &lt;&lt; <span class=\"string\">&quot;)\\n&quot;</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">apply</span><span class=\"params\">(Foo* foo1, Foo* foo2, <span class=\"keyword\">void</span> (Foo::*fun)())</span> </span>&#123;</span><br><span class=\"line\">    (foo1-&gt;*fun)();  <span class=\"comment\">// call fun on the object foo1</span></span><br><span class=\"line\">    (foo2-&gt;*fun)();  <span class=\"comment\">// call fun on the object foo2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Foo foo1&#123;<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    Foo foo2&#123;<span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">    apply(&amp;foo1, &amp;foo2, &amp;Foo::f);</span><br><span class=\"line\">    apply(&amp;foo1, &amp;foo2, &amp;Foo::g);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>成员函数指针的定义：void (Foo::*fun)()，调用是传递的实参: &amp;Foo::f；</li>\n<li>fun为类成员函数指针，所以调用是要通过解引用的方式获取成员函数*fun,即<code>(foo1-&gt;*fun)();</code></li>\n</ul>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/6ecfd541ec04\">C++ 函数指针和函数类型</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https://stackoverflow.com/questions/14936539/how-stdfunction-works\">How std::function works</a></li>\n<li><a href=\"https://link.jianshu.com/?t=https://stackoverflow.com/questions/37636373/how-stdbind-works-with-member-functions\">How std::bind works with member functions</a></li>\n</ul>\n"},{"abbrlink":1,"_content":"# 计算导论与C语言基础\n\n## 一、计算机基本原理\n\n### 1. 第一次数学危机\n\n- 毕达哥拉斯学派    ---勾股定理\n- 西帕索斯悖论\n- 欧德克索斯    --比例论\n\n### 2. 第二次数学危机\n\n- 微积分 --牛顿、布莱尼兹\n- 贝克莱悖论\n\n### 3. 第三次数学危机\n\n- 集合论 -- 康托尔\n- 庞加莱\n- 罗素悖论  ---集合论也不是完美无缺的\n- 哥德尔的不完备性定理\n\n### 4. 图灵与图灵机\n\n- 图灵机是数学模型\n- 计算机中数的表示  -- 欧拉常熟e 2.7182818284590...\n- 与具有==两个状态==的电子元件相比，具有三个状态的电子元件在制造商更困难，可靠性更低。 量子？\n- 二进制的出现\n\n### 5. 冯诺依曼式计算机\n\n![image-20191202204151447](/Users/Evan/Documents/CPlus_Excellence_Project/计算导论与C语言基础.assets/image-20191202204151447.png)\n\n* 命令记录员： 记录当前执行到哪条命令，接下来要执行哪条命令\n* 控制信号记录器： 产生相应的控制信号\n* 命令暂存处： 把命令提取出来暂存\n* 命令解释器：对命令进行解释\n* 工作过程：\n  * 在控制器指挥下，从存储器上取出指令\n  * 分析指令，得到计算命令和待操作的数\n  * 从存储器上取出待计算的数放入到运算器\n  * 运算器计算结果\n  * 输出到存储器或输出设备\n* 运算器、控制器、存储器： CPU\n* 存储器： 内存、外存\n  * 寄存器： CPU内部，用于存放待操作数和结果\n  * 高速缓存：CPU内部，用作数据缓存区\n  * 内存\n  * 外存\n* 多级缓存机制： 局部性原理-时间局部性-空间局部性\n\n## 二 计算机内存分区模型\n\n### 1. 内存分区\n\n#### 1.1 运行之前\n\n* 预处理\n* 编译\n* 汇编\n* 链接： 函数和变量默认都是外部链接的\n\n* 代码区： 只读（防止恶意修改）、共享 \n\n* 内存泄漏时堆区的内存（手动申请、手动释放）\n\n* 程序在进行过程后，称为进程\n\n#### 1.2 函数的调用流程\n\n* 栈： 先进后出\n\n\n\n","source":"_posts/cplus_md/C Baisc/计算导论与C语言基础.md","raw":"---\nabbrlink: 1\n---\n# 计算导论与C语言基础\n\n## 一、计算机基本原理\n\n### 1. 第一次数学危机\n\n- 毕达哥拉斯学派    ---勾股定理\n- 西帕索斯悖论\n- 欧德克索斯    --比例论\n\n### 2. 第二次数学危机\n\n- 微积分 --牛顿、布莱尼兹\n- 贝克莱悖论\n\n### 3. 第三次数学危机\n\n- 集合论 -- 康托尔\n- 庞加莱\n- 罗素悖论  ---集合论也不是完美无缺的\n- 哥德尔的不完备性定理\n\n### 4. 图灵与图灵机\n\n- 图灵机是数学模型\n- 计算机中数的表示  -- 欧拉常熟e 2.7182818284590...\n- 与具有==两个状态==的电子元件相比，具有三个状态的电子元件在制造商更困难，可靠性更低。 量子？\n- 二进制的出现\n\n### 5. 冯诺依曼式计算机\n\n![image-20191202204151447](/Users/Evan/Documents/CPlus_Excellence_Project/计算导论与C语言基础.assets/image-20191202204151447.png)\n\n* 命令记录员： 记录当前执行到哪条命令，接下来要执行哪条命令\n* 控制信号记录器： 产生相应的控制信号\n* 命令暂存处： 把命令提取出来暂存\n* 命令解释器：对命令进行解释\n* 工作过程：\n  * 在控制器指挥下，从存储器上取出指令\n  * 分析指令，得到计算命令和待操作的数\n  * 从存储器上取出待计算的数放入到运算器\n  * 运算器计算结果\n  * 输出到存储器或输出设备\n* 运算器、控制器、存储器： CPU\n* 存储器： 内存、外存\n  * 寄存器： CPU内部，用于存放待操作数和结果\n  * 高速缓存：CPU内部，用作数据缓存区\n  * 内存\n  * 外存\n* 多级缓存机制： 局部性原理-时间局部性-空间局部性\n\n## 二 计算机内存分区模型\n\n### 1. 内存分区\n\n#### 1.1 运行之前\n\n* 预处理\n* 编译\n* 汇编\n* 链接： 函数和变量默认都是外部链接的\n\n* 代码区： 只读（防止恶意修改）、共享 \n\n* 内存泄漏时堆区的内存（手动申请、手动释放）\n\n* 程序在进行过程后，称为进程\n\n#### 1.2 函数的调用流程\n\n* 栈： 先进后出\n\n\n\n","slug":"cplus_md/C Baisc/计算导论与C语言基础","published":1,"date":"2020-02-22T01:41:39.000Z","updated":"2021-04-20T13:07:34.653Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6c0040w9q95ex2b6dx","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"计算导论与C语言基础\"><a href=\"#计算导论与C语言基础\" class=\"headerlink\" title=\"计算导论与C语言基础\"></a>计算导论与C语言基础</h1><h2 id=\"一、计算机基本原理\"><a href=\"#一、计算机基本原理\" class=\"headerlink\" title=\"一、计算机基本原理\"></a>一、计算机基本原理</h2><h3 id=\"1-第一次数学危机\"><a href=\"#1-第一次数学危机\" class=\"headerlink\" title=\"1. 第一次数学危机\"></a>1. 第一次数学危机</h3><ul>\n<li>毕达哥拉斯学派    —勾股定理</li>\n<li>西帕索斯悖论</li>\n<li>欧德克索斯    –比例论</li>\n</ul>\n<h3 id=\"2-第二次数学危机\"><a href=\"#2-第二次数学危机\" class=\"headerlink\" title=\"2. 第二次数学危机\"></a>2. 第二次数学危机</h3><ul>\n<li>微积分 –牛顿、布莱尼兹</li>\n<li>贝克莱悖论</li>\n</ul>\n<h3 id=\"3-第三次数学危机\"><a href=\"#3-第三次数学危机\" class=\"headerlink\" title=\"3. 第三次数学危机\"></a>3. 第三次数学危机</h3><ul>\n<li>集合论 – 康托尔</li>\n<li>庞加莱</li>\n<li>罗素悖论  —集合论也不是完美无缺的</li>\n<li>哥德尔的不完备性定理</li>\n</ul>\n<h3 id=\"4-图灵与图灵机\"><a href=\"#4-图灵与图灵机\" class=\"headerlink\" title=\"4. 图灵与图灵机\"></a>4. 图灵与图灵机</h3><ul>\n<li>图灵机是数学模型</li>\n<li>计算机中数的表示  – 欧拉常熟e 2.7182818284590…</li>\n<li>与具有==两个状态==的电子元件相比，具有三个状态的电子元件在制造商更困难，可靠性更低。 量子？</li>\n<li>二进制的出现</li>\n</ul>\n<h3 id=\"5-冯诺依曼式计算机\"><a href=\"#5-冯诺依曼式计算机\" class=\"headerlink\" title=\"5. 冯诺依曼式计算机\"></a>5. 冯诺依曼式计算机</h3><p><img src=\"/Users/Evan/Documents/CPlus_Excellence_Project/%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.assets/image-20191202204151447.png\" alt=\"image-20191202204151447\"></p>\n<ul>\n<li>命令记录员： 记录当前执行到哪条命令，接下来要执行哪条命令</li>\n<li>控制信号记录器： 产生相应的控制信号</li>\n<li>命令暂存处： 把命令提取出来暂存</li>\n<li>命令解释器：对命令进行解释</li>\n<li>工作过程：<ul>\n<li>在控制器指挥下，从存储器上取出指令</li>\n<li>分析指令，得到计算命令和待操作的数</li>\n<li>从存储器上取出待计算的数放入到运算器</li>\n<li>运算器计算结果</li>\n<li>输出到存储器或输出设备</li>\n</ul>\n</li>\n<li>运算器、控制器、存储器： CPU</li>\n<li>存储器： 内存、外存<ul>\n<li>寄存器： CPU内部，用于存放待操作数和结果</li>\n<li>高速缓存：CPU内部，用作数据缓存区</li>\n<li>内存</li>\n<li>外存</li>\n</ul>\n</li>\n<li>多级缓存机制： 局部性原理-时间局部性-空间局部性</li>\n</ul>\n<h2 id=\"二-计算机内存分区模型\"><a href=\"#二-计算机内存分区模型\" class=\"headerlink\" title=\"二 计算机内存分区模型\"></a>二 计算机内存分区模型</h2><h3 id=\"1-内存分区\"><a href=\"#1-内存分区\" class=\"headerlink\" title=\"1. 内存分区\"></a>1. 内存分区</h3><h4 id=\"1-1-运行之前\"><a href=\"#1-1-运行之前\" class=\"headerlink\" title=\"1.1 运行之前\"></a>1.1 运行之前</h4><ul>\n<li><p>预处理</p>\n</li>\n<li><p>编译</p>\n</li>\n<li><p>汇编</p>\n</li>\n<li><p>链接： 函数和变量默认都是外部链接的</p>\n</li>\n<li><p>代码区： 只读（防止恶意修改）、共享 </p>\n</li>\n<li><p>内存泄漏时堆区的内存（手动申请、手动释放）</p>\n</li>\n<li><p>程序在进行过程后，称为进程</p>\n</li>\n</ul>\n<h4 id=\"1-2-函数的调用流程\"><a href=\"#1-2-函数的调用流程\" class=\"headerlink\" title=\"1.2 函数的调用流程\"></a>1.2 函数的调用流程</h4><ul>\n<li>栈： 先进后出</li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"计算导论与C语言基础\"><a href=\"#计算导论与C语言基础\" class=\"headerlink\" title=\"计算导论与C语言基础\"></a>计算导论与C语言基础</h1><h2 id=\"一、计算机基本原理\"><a href=\"#一、计算机基本原理\" class=\"headerlink\" title=\"一、计算机基本原理\"></a>一、计算机基本原理</h2><h3 id=\"1-第一次数学危机\"><a href=\"#1-第一次数学危机\" class=\"headerlink\" title=\"1. 第一次数学危机\"></a>1. 第一次数学危机</h3><ul>\n<li>毕达哥拉斯学派    —勾股定理</li>\n<li>西帕索斯悖论</li>\n<li>欧德克索斯    –比例论</li>\n</ul>\n<h3 id=\"2-第二次数学危机\"><a href=\"#2-第二次数学危机\" class=\"headerlink\" title=\"2. 第二次数学危机\"></a>2. 第二次数学危机</h3><ul>\n<li>微积分 –牛顿、布莱尼兹</li>\n<li>贝克莱悖论</li>\n</ul>\n<h3 id=\"3-第三次数学危机\"><a href=\"#3-第三次数学危机\" class=\"headerlink\" title=\"3. 第三次数学危机\"></a>3. 第三次数学危机</h3><ul>\n<li>集合论 – 康托尔</li>\n<li>庞加莱</li>\n<li>罗素悖论  —集合论也不是完美无缺的</li>\n<li>哥德尔的不完备性定理</li>\n</ul>\n<h3 id=\"4-图灵与图灵机\"><a href=\"#4-图灵与图灵机\" class=\"headerlink\" title=\"4. 图灵与图灵机\"></a>4. 图灵与图灵机</h3><ul>\n<li>图灵机是数学模型</li>\n<li>计算机中数的表示  – 欧拉常熟e 2.7182818284590…</li>\n<li>与具有==两个状态==的电子元件相比，具有三个状态的电子元件在制造商更困难，可靠性更低。 量子？</li>\n<li>二进制的出现</li>\n</ul>\n<h3 id=\"5-冯诺依曼式计算机\"><a href=\"#5-冯诺依曼式计算机\" class=\"headerlink\" title=\"5. 冯诺依曼式计算机\"></a>5. 冯诺依曼式计算机</h3><p><img src=\"/Users/Evan/Documents/CPlus_Excellence_Project/%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA%E4%B8%8EC%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.assets/image-20191202204151447.png\" alt=\"image-20191202204151447\"></p>\n<ul>\n<li>命令记录员： 记录当前执行到哪条命令，接下来要执行哪条命令</li>\n<li>控制信号记录器： 产生相应的控制信号</li>\n<li>命令暂存处： 把命令提取出来暂存</li>\n<li>命令解释器：对命令进行解释</li>\n<li>工作过程：<ul>\n<li>在控制器指挥下，从存储器上取出指令</li>\n<li>分析指令，得到计算命令和待操作的数</li>\n<li>从存储器上取出待计算的数放入到运算器</li>\n<li>运算器计算结果</li>\n<li>输出到存储器或输出设备</li>\n</ul>\n</li>\n<li>运算器、控制器、存储器： CPU</li>\n<li>存储器： 内存、外存<ul>\n<li>寄存器： CPU内部，用于存放待操作数和结果</li>\n<li>高速缓存：CPU内部，用作数据缓存区</li>\n<li>内存</li>\n<li>外存</li>\n</ul>\n</li>\n<li>多级缓存机制： 局部性原理-时间局部性-空间局部性</li>\n</ul>\n<h2 id=\"二-计算机内存分区模型\"><a href=\"#二-计算机内存分区模型\" class=\"headerlink\" title=\"二 计算机内存分区模型\"></a>二 计算机内存分区模型</h2><h3 id=\"1-内存分区\"><a href=\"#1-内存分区\" class=\"headerlink\" title=\"1. 内存分区\"></a>1. 内存分区</h3><h4 id=\"1-1-运行之前\"><a href=\"#1-1-运行之前\" class=\"headerlink\" title=\"1.1 运行之前\"></a>1.1 运行之前</h4><ul>\n<li><p>预处理</p>\n</li>\n<li><p>编译</p>\n</li>\n<li><p>汇编</p>\n</li>\n<li><p>链接： 函数和变量默认都是外部链接的</p>\n</li>\n<li><p>代码区： 只读（防止恶意修改）、共享 </p>\n</li>\n<li><p>内存泄漏时堆区的内存（手动申请、手动释放）</p>\n</li>\n<li><p>程序在进行过程后，称为进程</p>\n</li>\n</ul>\n<h4 id=\"1-2-函数的调用流程\"><a href=\"#1-2-函数的调用流程\" class=\"headerlink\" title=\"1.2 函数的调用流程\"></a>1.2 函数的调用流程</h4><ul>\n<li>栈： 先进后出</li>\n</ul>\n"},{"title":"C++ Primer Plus笔记","date":"2020-12-31T15:59:00.000Z","abbrlink":13010,"cover":"img/cpp.png","_content":"\n# C++ Primer Plus笔记\n\n## 预备知识\n\n### 如何运行C++程序\n\n1. 使用文本编辑器编写程序，保存文件，这个文件就是源代码。\n\n2. 编译源代码。运行程序将源代码翻译为机器语言。翻译后的文件就是目标代码。\n\n3. 将目标代码与其他代码链接起来，生成程序的运行阶段版本。最终产品文件为可执行代码。\n\n   > 链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本\n\n编程步骤如下图：\n\n​\t<img src=\"./C++ Primer Plus/编程步骤-8644713.png\" alt=\"编程步骤\" style=\"zoom: 67%;\" />\n\n> 从4.2版起，g++要求编译源代码文件时使用标记-std=c++0x： `g++ -std=C++11 use_auto.cpp`\n\n## 开始学习C++\n\n### 为什么main()不能使用其他名称？\n\nC++程序必须包含一个名为main()的函数， 这是由系统的C++运行时决定的。编译器生成目标系统的可执行文件时，操作系统的启动入口就是C++运行时，然后运行时完成初始化之后就会调用main函数(入口点)。\n\n存在一些例外情况：比如windows上编写DLL模块，是因为DLL模块不是独立的程序。\n\n### cin不支持录入空格\n\n在C++中，用`cin>>str;`这种方法来接收字符串那么录入的str不能包含空格，否则它会按照空格将整个字符串切分成若干段。如果你要是想输入带空格的字符串那就要用到getline()这个函数了。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string name;\n    string address;\n    cout << \"Please input your name: \";\n    getline(cin, name);\n    cout << \"Please input your address: \";\n    getline(cin, address);\n    cout << \"Your name is \" << name << \" and address is \" << address << endl;\n    return 0;\n}\n```\n\n执行程序：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \nPlease input your name: Evan Yang\nPlease input your address: Comba Street 64, cot\nYour name is Evan Yang and address is Comba Street 64, cot\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % \n```\n\n## 处理数据\n\n### 整型的范围\n\n整型： char、short、int、long、long long(C++11)\n\nC++提供了一种灵活的标准，确保了最小长度：\n\n* short至少16位\n* int至少与short一样长\n* long至少32位，且至少与int一样长\n* long long至少64位，且至少与long一样长\n\n查看大小：\n\n```cpp\n#include <iostream>\n#include <climits>\n\nusing namespace std;\n\nint main()\n{\n    int n_int = INT_MAX;\n    short n_short = SHRT_MAX;\n    long n_long = LONG_MAX;\n    long long n_llong = LLONG_MAX;\n\n    cout << \"int is \" << sizeof(int) << \" bytes\" << endl;\n    cout << \"short is \" << sizeof(short) << \" bytes\" << endl;\n    cout << \"long is \" << sizeof(long) << \" bytes\" << endl;\n    cout << \"long long is \" << sizeof(long long) << \" bytes\" << endl;\n\n    cout << \"int is \" << n_int << endl;\n    cout << \"short is \" << n_short << endl;\n    cout << \"long is \" << n_long << endl;\n    cout << \"long long is \" << n_llong << endl;\n  \treturn 0；\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \nint is 4 bytes\nshort is 2 bytes\nlong is 8 bytes\nlong long is 8 bytes\nint is 2147483647\nshort is 32767\nlong is 9223372036854775807\nlong long is 9223372036854775807\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % \n```\n\n### 整型的字面值\n\nC++能以三种不同的计数方式来书写整数：\n\n* 基数为10\n* 基数为8(老式UNIX版本)：0\n* 基数为16(硬件黑客的最爱)： 0x或者0X\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int chest = 42;\n    int waist = 42;\n    int inseam = 42;\n\n    cout << \"Monsieur cuts a striking figure !\\n\";\n    cout << \"chest = \" << chest << \" (decimal for 42)\\n\";\n    cout << hex;\n    cout << \"waist = \" << waist << \" (hexadecimal for 42)\\n\";\n    cout << oct;\n    cout << \"inseam = \" << inseam << \" (octal for 42)\\n\";\n    return 0;\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \nMonsieur cuts a striking figure !\nchest = 42 (decimal for 42)\nwaist = 2a (hexadecimal for 42)\ninseam = 52 (octal for 42)\n```\n\n### 类型转换\n\nC++11将使用大括号的初始化称为列表初始化(list-initialization)，这种初始化常用于给复杂的数据类型提供值列表。列表初始化不允许缩窄(narrowing)，即变量的类型可能无法表示赋给它的值。例如：\n\n```cpp\nconst int code = 66;\nint x = 66;\nchar c1 {31325}; // narrowing, not allowed\nchar c2 {66}; //allowed because char can hold 66\nchar c3 {code}; //ditto\nchar c4 = {x}; // not allowed, cause x is not constant\nx = 32325;\nchar c5 = x;  //allowed by this form of initialization\n```\n\n编译：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\ncpp_chapter_2.cpp:9:14: error: constant expression evaluates to 31325 which cannot be narrowed to type 'char' [-Wc++11-narrowing]\n    char c1 {31325}; // narrowing, not allowed\n             ^~~~~\ncpp_chapter_2.cpp:9:14: note: insert an explicit cast to silence this issue\n    char c1 {31325}; // narrowing, not allowed\n             ^~~~~\n             static_cast<char>( )\ncpp_chapter_2.cpp:12:16: error: non-constant-expression cannot be narrowed from type 'int' to 'char' in initializer list [-Wc++11-narrowing]\n    char c4 = {x}; // not allowed, cause x is not constant\n               ^\ncpp_chapter_2.cpp:12:16: note: insert an explicit cast to silence this issue\n    char c4 = {x}; // not allowed, cause x is not constant\n               ^\n               static_cast<char>( )\ncpp_chapter_2.cpp:9:14: warning: implicit conversion from 'int' to 'char' changes value from 31325 to 93 [-Wconstant-conversion]\n    char c1 {31325}; // narrowing, not allowed\n            ~^~~~~\n1 warning and 2 errors generated.\n```\n\n### auto声明\n\nC++11新增一个工具，让编译器能够根据初始化值的类型推断变量的类型。重新定义了auto的含义。\n\n`auto n = 100` // n is int\n\n`auto x = 1.5;`  // x is double\n\n`auto y = 1.3e12L` // y is long double\n\n处理复杂类型，比如STL中的类型时，自动类型的优势才能显现出来：\n\n```cpp\nstd::vector<double> scores;\nauto pv = scores.begin()\n```\n\n## 复合类型\n\n### C++11数组初始化\n\n初始化数组的时候，可以省略等号：\n\n`double earning[4] = {1.2e4, 1.1e4, 1.6e4, 1.7e4}`等价于\n\n`double earning[4] {1.2e4, 1.1e4, 1.6e4, 1.7e4}`\n\n关于列表初始化的缩窄问题：\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    long plifs[] = {25, 29, 3.0};\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n    char tlifs[4] = {'h', 'i', 112, '\\0'};\n    return 0;\n}\n```\n\n编译：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\ncpp_chapter_2.cpp:7:29: error: type 'double' cannot be narrowed to 'long' in initializer list [-Wc++11-narrowing]\n    long plifs[] = {25, 29, 3.0};\n                            ^~~\ncpp_chapter_2.cpp:7:29: note: insert an explicit cast to silence this issue\n    long plifs[] = {25, 29, 3.0};\n                            ^~~\n                            static_cast<long>( )\ncpp_chapter_2.cpp:8:32: error: constant expression evaluates to 1122011 which cannot be narrowed to type 'char' [-Wc++11-narrowing]\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n                               ^~~~~~~\ncpp_chapter_2.cpp:8:32: note: insert an explicit cast to silence this issue\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n                               ^~~~~~~\n                               static_cast<char>( )\ncpp_chapter_2.cpp:8:32: warning: implicit conversion from 'int' to 'char' changes value from 1122011 to -37 [-Wconstant-conversion]\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n                    ~          ^~~~~~~\n1 warning and 2 errors generated.\n```\n\n### 为什么使用cin.get()\n\nistream类有一个get()成员函数。\n\n使用不带任何参数的cin.get()可以读取下一个字符(即使是换行符)， 因此可以处理换行符，比如：\n\n```cpp\ncin.get(name, ArSize);     // read first line\ncin.get();                 // read newline\ncin.get(dessert, ArSize);  // read second line\n```\n\n另一种使用get()的方式是将两个类成员函数拼接起来：\n\n`cin.get(name, ArSize).get()`\n\n之所以可以这么做，是因为cin.get(name, ArSize)返回一个cin对象，该对象随后将被用来调用get()函数。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    const int ArSize = 20;\n    char name[ArSize];\n    char dessert[ArSize];\n\n    cout << \"Enter your name: \\n\";\n    cin.get(name ,ArSize).get();\n    cout << \"Enter your favorite dessert: \\n\";\n    cin.get(dessert, ArSize).get();\n    cout << \"I have some delicious \" << dessert;\n    cout << \" for you, \" << name << \".\\n\";\n    return 0;\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test\nEnter your name: \nEvan Yang\nEnter your favorite dessert: \nChocolate Mouses\nI have some delicious Chocolate Mouses for you, Evan Yang.\n```\n\n### cin.clear()\n\n当cin函数输入错误的时候，cin里面有个函数cin.rdstate()可以自动检测到输入错误，当cin.rdstate()返回0(即ios::goodbit)时表示无错误。若返回4则发生非致命错误，即ios::failbit，不能继续输入或操作。cin.clear()则可以控制此时cin里的标识。其中标识符号有：\n\n* goodbit 无错误 \n* Eofbit 已到达文件尾 \n* failbit 非致命的输入/输出错误，可挽回 \n* badbit　致命的输入/输出错误,无法挽回。若在输入输出类里，需要加ios::标识符号 \n\ncin.clear()一般会与cin.sync()或者cin.ignore()一起使用。cin.sync()代表清除缓冲区中的未读信息， cin.ignore()代表缓冲区中指定个数的字符。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int number = 0;\n    while(cin >> number,!cin.eof()) \n    {\n        if(cin.bad())\n\t\t\tthrow runtime_error(\"IO stream corrupted\");\n        if(cin.fail()) \n        {\n            \n            cout << \"Error input: \" << cin.rdstate() << endl;\n            cin.clear();\n            cin.ignore();\n          \t// cin.sync();   这里用sync会死循环？？？为什么？？？\n            cout << \"cin.rdstate(): \" << cin.rdstate() << endl;\n        }\n        else\n        {\n            cout << \"Input is: \" << number << endl;\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \ns\nError input: 4\ncin.rdstate(): 0\n3\nInput is: 3\n```\n\n","source":"_posts/cplus_md/CPlus Basic/C++ Primer Plus笔记.md","raw":"---\ntitle: C++ Primer Plus笔记\ndate: '2020/12/31 23:59'\ntags:\n - cpp\ncategories:\n - 学习笔记\nabbrlink: 13010\ncover: img/cpp.png\n---\n\n# C++ Primer Plus笔记\n\n## 预备知识\n\n### 如何运行C++程序\n\n1. 使用文本编辑器编写程序，保存文件，这个文件就是源代码。\n\n2. 编译源代码。运行程序将源代码翻译为机器语言。翻译后的文件就是目标代码。\n\n3. 将目标代码与其他代码链接起来，生成程序的运行阶段版本。最终产品文件为可执行代码。\n\n   > 链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本\n\n编程步骤如下图：\n\n​\t<img src=\"./C++ Primer Plus/编程步骤-8644713.png\" alt=\"编程步骤\" style=\"zoom: 67%;\" />\n\n> 从4.2版起，g++要求编译源代码文件时使用标记-std=c++0x： `g++ -std=C++11 use_auto.cpp`\n\n## 开始学习C++\n\n### 为什么main()不能使用其他名称？\n\nC++程序必须包含一个名为main()的函数， 这是由系统的C++运行时决定的。编译器生成目标系统的可执行文件时，操作系统的启动入口就是C++运行时，然后运行时完成初始化之后就会调用main函数(入口点)。\n\n存在一些例外情况：比如windows上编写DLL模块，是因为DLL模块不是独立的程序。\n\n### cin不支持录入空格\n\n在C++中，用`cin>>str;`这种方法来接收字符串那么录入的str不能包含空格，否则它会按照空格将整个字符串切分成若干段。如果你要是想输入带空格的字符串那就要用到getline()这个函数了。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    string name;\n    string address;\n    cout << \"Please input your name: \";\n    getline(cin, name);\n    cout << \"Please input your address: \";\n    getline(cin, address);\n    cout << \"Your name is \" << name << \" and address is \" << address << endl;\n    return 0;\n}\n```\n\n执行程序：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \nPlease input your name: Evan Yang\nPlease input your address: Comba Street 64, cot\nYour name is Evan Yang and address is Comba Street 64, cot\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % \n```\n\n## 处理数据\n\n### 整型的范围\n\n整型： char、short、int、long、long long(C++11)\n\nC++提供了一种灵活的标准，确保了最小长度：\n\n* short至少16位\n* int至少与short一样长\n* long至少32位，且至少与int一样长\n* long long至少64位，且至少与long一样长\n\n查看大小：\n\n```cpp\n#include <iostream>\n#include <climits>\n\nusing namespace std;\n\nint main()\n{\n    int n_int = INT_MAX;\n    short n_short = SHRT_MAX;\n    long n_long = LONG_MAX;\n    long long n_llong = LLONG_MAX;\n\n    cout << \"int is \" << sizeof(int) << \" bytes\" << endl;\n    cout << \"short is \" << sizeof(short) << \" bytes\" << endl;\n    cout << \"long is \" << sizeof(long) << \" bytes\" << endl;\n    cout << \"long long is \" << sizeof(long long) << \" bytes\" << endl;\n\n    cout << \"int is \" << n_int << endl;\n    cout << \"short is \" << n_short << endl;\n    cout << \"long is \" << n_long << endl;\n    cout << \"long long is \" << n_llong << endl;\n  \treturn 0；\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \nint is 4 bytes\nshort is 2 bytes\nlong is 8 bytes\nlong long is 8 bytes\nint is 2147483647\nshort is 32767\nlong is 9223372036854775807\nlong long is 9223372036854775807\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % \n```\n\n### 整型的字面值\n\nC++能以三种不同的计数方式来书写整数：\n\n* 基数为10\n* 基数为8(老式UNIX版本)：0\n* 基数为16(硬件黑客的最爱)： 0x或者0X\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int chest = 42;\n    int waist = 42;\n    int inseam = 42;\n\n    cout << \"Monsieur cuts a striking figure !\\n\";\n    cout << \"chest = \" << chest << \" (decimal for 42)\\n\";\n    cout << hex;\n    cout << \"waist = \" << waist << \" (hexadecimal for 42)\\n\";\n    cout << oct;\n    cout << \"inseam = \" << inseam << \" (octal for 42)\\n\";\n    return 0;\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \nMonsieur cuts a striking figure !\nchest = 42 (decimal for 42)\nwaist = 2a (hexadecimal for 42)\ninseam = 52 (octal for 42)\n```\n\n### 类型转换\n\nC++11将使用大括号的初始化称为列表初始化(list-initialization)，这种初始化常用于给复杂的数据类型提供值列表。列表初始化不允许缩窄(narrowing)，即变量的类型可能无法表示赋给它的值。例如：\n\n```cpp\nconst int code = 66;\nint x = 66;\nchar c1 {31325}; // narrowing, not allowed\nchar c2 {66}; //allowed because char can hold 66\nchar c3 {code}; //ditto\nchar c4 = {x}; // not allowed, cause x is not constant\nx = 32325;\nchar c5 = x;  //allowed by this form of initialization\n```\n\n编译：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\ncpp_chapter_2.cpp:9:14: error: constant expression evaluates to 31325 which cannot be narrowed to type 'char' [-Wc++11-narrowing]\n    char c1 {31325}; // narrowing, not allowed\n             ^~~~~\ncpp_chapter_2.cpp:9:14: note: insert an explicit cast to silence this issue\n    char c1 {31325}; // narrowing, not allowed\n             ^~~~~\n             static_cast<char>( )\ncpp_chapter_2.cpp:12:16: error: non-constant-expression cannot be narrowed from type 'int' to 'char' in initializer list [-Wc++11-narrowing]\n    char c4 = {x}; // not allowed, cause x is not constant\n               ^\ncpp_chapter_2.cpp:12:16: note: insert an explicit cast to silence this issue\n    char c4 = {x}; // not allowed, cause x is not constant\n               ^\n               static_cast<char>( )\ncpp_chapter_2.cpp:9:14: warning: implicit conversion from 'int' to 'char' changes value from 31325 to 93 [-Wconstant-conversion]\n    char c1 {31325}; // narrowing, not allowed\n            ~^~~~~\n1 warning and 2 errors generated.\n```\n\n### auto声明\n\nC++11新增一个工具，让编译器能够根据初始化值的类型推断变量的类型。重新定义了auto的含义。\n\n`auto n = 100` // n is int\n\n`auto x = 1.5;`  // x is double\n\n`auto y = 1.3e12L` // y is long double\n\n处理复杂类型，比如STL中的类型时，自动类型的优势才能显现出来：\n\n```cpp\nstd::vector<double> scores;\nauto pv = scores.begin()\n```\n\n## 复合类型\n\n### C++11数组初始化\n\n初始化数组的时候，可以省略等号：\n\n`double earning[4] = {1.2e4, 1.1e4, 1.6e4, 1.7e4}`等价于\n\n`double earning[4] {1.2e4, 1.1e4, 1.6e4, 1.7e4}`\n\n关于列表初始化的缩窄问题：\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    long plifs[] = {25, 29, 3.0};\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n    char tlifs[4] = {'h', 'i', 112, '\\0'};\n    return 0;\n}\n```\n\n编译：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\ncpp_chapter_2.cpp:7:29: error: type 'double' cannot be narrowed to 'long' in initializer list [-Wc++11-narrowing]\n    long plifs[] = {25, 29, 3.0};\n                            ^~~\ncpp_chapter_2.cpp:7:29: note: insert an explicit cast to silence this issue\n    long plifs[] = {25, 29, 3.0};\n                            ^~~\n                            static_cast<long>( )\ncpp_chapter_2.cpp:8:32: error: constant expression evaluates to 1122011 which cannot be narrowed to type 'char' [-Wc++11-narrowing]\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n                               ^~~~~~~\ncpp_chapter_2.cpp:8:32: note: insert an explicit cast to silence this issue\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n                               ^~~~~~~\n                               static_cast<char>( )\ncpp_chapter_2.cpp:8:32: warning: implicit conversion from 'int' to 'char' changes value from 1122011 to -37 [-Wconstant-conversion]\n    char slifs[4] = {'h', 'i', 1122011, '\\0'};\n                    ~          ^~~~~~~\n1 warning and 2 errors generated.\n```\n\n### 为什么使用cin.get()\n\nistream类有一个get()成员函数。\n\n使用不带任何参数的cin.get()可以读取下一个字符(即使是换行符)， 因此可以处理换行符，比如：\n\n```cpp\ncin.get(name, ArSize);     // read first line\ncin.get();                 // read newline\ncin.get(dessert, ArSize);  // read second line\n```\n\n另一种使用get()的方式是将两个类成员函数拼接起来：\n\n`cin.get(name, ArSize).get()`\n\n之所以可以这么做，是因为cin.get(name, ArSize)返回一个cin对象，该对象随后将被用来调用get()函数。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    const int ArSize = 20;\n    char name[ArSize];\n    char dessert[ArSize];\n\n    cout << \"Enter your name: \\n\";\n    cin.get(name ,ArSize).get();\n    cout << \"Enter your favorite dessert: \\n\";\n    cin.get(dessert, ArSize).get();\n    cout << \"I have some delicious \" << dessert;\n    cout << \" for you, \" << name << \".\\n\";\n    return 0;\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test\nEnter your name: \nEvan Yang\nEnter your favorite dessert: \nChocolate Mouses\nI have some delicious Chocolate Mouses for you, Evan Yang.\n```\n\n### cin.clear()\n\n当cin函数输入错误的时候，cin里面有个函数cin.rdstate()可以自动检测到输入错误，当cin.rdstate()返回0(即ios::goodbit)时表示无错误。若返回4则发生非致命错误，即ios::failbit，不能继续输入或操作。cin.clear()则可以控制此时cin里的标识。其中标识符号有：\n\n* goodbit 无错误 \n* Eofbit 已到达文件尾 \n* failbit 非致命的输入/输出错误，可挽回 \n* badbit　致命的输入/输出错误,无法挽回。若在输入输出类里，需要加ios::标识符号 \n\ncin.clear()一般会与cin.sync()或者cin.ignore()一起使用。cin.sync()代表清除缓冲区中的未读信息， cin.ignore()代表缓冲区中指定个数的字符。\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n    int number = 0;\n    while(cin >> number,!cin.eof()) \n    {\n        if(cin.bad())\n\t\t\tthrow runtime_error(\"IO stream corrupted\");\n        if(cin.fail()) \n        {\n            \n            cout << \"Error input: \" << cin.rdstate() << endl;\n            cin.clear();\n            cin.ignore();\n          \t// cin.sync();   这里用sync会死循环？？？为什么？？？\n            cout << \"cin.rdstate(): \" << cin.rdstate() << endl;\n        }\n        else\n        {\n            cout << \"Input is: \" << number << endl;\n            break;\n        }\n    }\n    return 0;\n}\n```\n\n输出：\n\n```shell\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test\n(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  \ns\nError input: 4\ncin.rdstate(): 0\n3\nInput is: 3\n```\n\n","slug":"cplus_md/CPlus Basic/C++ Primer Plus笔记","published":1,"updated":"2021-04-19T11:30:13.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6c0043w9q9g4wi6bxs","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"C-Primer-Plus笔记\"><a href=\"#C-Primer-Plus笔记\" class=\"headerlink\" title=\"C++ Primer Plus笔记\"></a>C++ Primer Plus笔记</h1><h2 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h2><h3 id=\"如何运行C-程序\"><a href=\"#如何运行C-程序\" class=\"headerlink\" title=\"如何运行C++程序\"></a>如何运行C++程序</h3><ol>\n<li><p>使用文本编辑器编写程序，保存文件，这个文件就是源代码。</p>\n</li>\n<li><p>编译源代码。运行程序将源代码翻译为机器语言。翻译后的文件就是目标代码。</p>\n</li>\n<li><p>将目标代码与其他代码链接起来，生成程序的运行阶段版本。最终产品文件为可执行代码。</p>\n<blockquote>\n<p>链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本</p>\n</blockquote>\n</li>\n</ol>\n<p>编程步骤如下图：</p>\n<p>​    <img src=\"./C++ Primer Plus/编程步骤-8644713.png\" alt=\"编程步骤\" style=\"zoom: 67%;\" /></p>\n<blockquote>\n<p>从4.2版起，g++要求编译源代码文件时使用标记-std=c++0x： <code>g++ -std=C++11 use_auto.cpp</code></p>\n</blockquote>\n<h2 id=\"开始学习C\"><a href=\"#开始学习C\" class=\"headerlink\" title=\"开始学习C++\"></a>开始学习C++</h2><h3 id=\"为什么main-不能使用其他名称？\"><a href=\"#为什么main-不能使用其他名称？\" class=\"headerlink\" title=\"为什么main()不能使用其他名称？\"></a>为什么main()不能使用其他名称？</h3><p>C++程序必须包含一个名为main()的函数， 这是由系统的C++运行时决定的。编译器生成目标系统的可执行文件时，操作系统的启动入口就是C++运行时，然后运行时完成初始化之后就会调用main函数(入口点)。</p>\n<p>存在一些例外情况：比如windows上编写DLL模块，是因为DLL模块不是独立的程序。</p>\n<h3 id=\"cin不支持录入空格\"><a href=\"#cin不支持录入空格\" class=\"headerlink\" title=\"cin不支持录入空格\"></a>cin不支持录入空格</h3><p>在C++中，用<code>cin&gt;&gt;str;</code>这种方法来接收字符串那么录入的str不能包含空格，否则它会按照空格将整个字符串切分成若干段。如果你要是想输入带空格的字符串那就要用到getline()这个函数了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> address;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Please input your name: &quot;</span>;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, name);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Please input your address: &quot;</span>;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, address);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Your name is &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; and address is &quot;</span> &lt;&lt; address &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">Please input your name: Evan Yang</span><br><span class=\"line\">Please input your address: Comba Street 64, cot</span><br><span class=\"line\">Your name is Evan Yang and address is Comba Street 64, cot</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % </span><br></pre></td></tr></table></figure>\n<h2 id=\"处理数据\"><a href=\"#处理数据\" class=\"headerlink\" title=\"处理数据\"></a>处理数据</h2><h3 id=\"整型的范围\"><a href=\"#整型的范围\" class=\"headerlink\" title=\"整型的范围\"></a>整型的范围</h3><p>整型： char、short、int、long、long long(C++11)</p>\n<p>C++提供了一种灵活的标准，确保了最小长度：</p>\n<ul>\n<li>short至少16位</li>\n<li>int至少与short一样长</li>\n<li>long至少32位，且至少与int一样长</li>\n<li>long long至少64位，且至少与long一样长</li>\n</ul>\n<p>查看大小：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;climits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n_int = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> n_short = SHRT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> n_long = LONG_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n_llong = LLONG_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;int is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;short is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">short</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long long is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;int is &quot;</span> &lt;&lt; n_int &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;short is &quot;</span> &lt;&lt; n_short &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long is &quot;</span> &lt;&lt; n_long &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long long is &quot;</span> &lt;&lt; n_llong &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">int is 4 bytes</span><br><span class=\"line\">short is 2 bytes</span><br><span class=\"line\">long is 8 bytes</span><br><span class=\"line\">long long is 8 bytes</span><br><span class=\"line\">int is 2147483647</span><br><span class=\"line\">short is 32767</span><br><span class=\"line\">long is 9223372036854775807</span><br><span class=\"line\">long long is 9223372036854775807</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % </span><br></pre></td></tr></table></figure>\n<h3 id=\"整型的字面值\"><a href=\"#整型的字面值\" class=\"headerlink\" title=\"整型的字面值\"></a>整型的字面值</h3><p>C++能以三种不同的计数方式来书写整数：</p>\n<ul>\n<li>基数为10</li>\n<li>基数为8(老式UNIX版本)：0</li>\n<li>基数为16(硬件黑客的最爱)： 0x或者0X</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> chest = <span class=\"number\">42</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> waist = <span class=\"number\">42</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inseam = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Monsieur cuts a striking figure !\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;chest = &quot;</span> &lt;&lt; chest &lt;&lt; <span class=\"string\">&quot; (decimal for 42)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; hex;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;waist = &quot;</span> &lt;&lt; waist &lt;&lt; <span class=\"string\">&quot; (hexadecimal for 42)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; oct;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;inseam = &quot;</span> &lt;&lt; inseam &lt;&lt; <span class=\"string\">&quot; (octal for 42)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">Monsieur cuts a striking figure !</span><br><span class=\"line\">chest = 42 (decimal for 42)</span><br><span class=\"line\">waist = 2a (hexadecimal for 42)</span><br><span class=\"line\">inseam = 52 (octal for 42)</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>C++11将使用大括号的初始化称为列表初始化(list-initialization)，这种初始化常用于给复杂的数据类型提供值列表。列表初始化不允许缩窄(narrowing)，即变量的类型可能无法表示赋给它的值。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> code = <span class=\"number\">66</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">66</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> c1 &#123;<span class=\"number\">31325</span>&#125;; <span class=\"comment\">// narrowing, not allowed</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c2 &#123;<span class=\"number\">66</span>&#125;; <span class=\"comment\">//allowed because char can hold 66</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c3 &#123;code&#125;; <span class=\"comment\">//ditto</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c4 = &#123;x&#125;; <span class=\"comment\">// not allowed, cause x is not constant</span></span><br><span class=\"line\">x = <span class=\"number\">32325</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> c5 = x;  <span class=\"comment\">//allowed by this form of initialization</span></span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">cpp_chapter_2.cpp:9:14: error: constant expression evaluates to 31325 which cannot be narrowed to type &#x27;char&#x27; [-Wc++11-narrowing]</span><br><span class=\"line\">    char c1 &#123;31325&#125;; // narrowing, not allowed</span><br><span class=\"line\">             ^~~~~</span><br><span class=\"line\">cpp_chapter_2.cpp:9:14: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    char c1 &#123;31325&#125;; // narrowing, not allowed</span><br><span class=\"line\">             ^~~~~</span><br><span class=\"line\">             static_cast&lt;char&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:12:16: error: non-constant-expression cannot be narrowed from type &#x27;int&#x27; to &#x27;char&#x27; in initializer list [-Wc++11-narrowing]</span><br><span class=\"line\">    char c4 = &#123;x&#125;; // not allowed, cause x is not constant</span><br><span class=\"line\">               ^</span><br><span class=\"line\">cpp_chapter_2.cpp:12:16: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    char c4 = &#123;x&#125;; // not allowed, cause x is not constant</span><br><span class=\"line\">               ^</span><br><span class=\"line\">               static_cast&lt;char&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:9:14: warning: implicit conversion from &#x27;int&#x27; to &#x27;char&#x27; changes value from 31325 to 93 [-Wconstant-conversion]</span><br><span class=\"line\">    char c1 &#123;31325&#125;; // narrowing, not allowed</span><br><span class=\"line\">            ~^~~~~</span><br><span class=\"line\">1 warning and 2 errors generated.</span><br></pre></td></tr></table></figure>\n<h3 id=\"auto声明\"><a href=\"#auto声明\" class=\"headerlink\" title=\"auto声明\"></a>auto声明</h3><p>C++11新增一个工具，让编译器能够根据初始化值的类型推断变量的类型。重新定义了auto的含义。</p>\n<p><code>auto n = 100</code> // n is int</p>\n<p><code>auto x = 1.5;</code>  // x is double</p>\n<p><code>auto y = 1.3e12L</code> // y is long double</p>\n<p>处理复杂类型，比如STL中的类型时，自动类型的优势才能显现出来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; scores;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> pv = scores.begin()</span><br></pre></td></tr></table></figure>\n<h2 id=\"复合类型\"><a href=\"#复合类型\" class=\"headerlink\" title=\"复合类型\"></a>复合类型</h2><h3 id=\"C-11数组初始化\"><a href=\"#C-11数组初始化\" class=\"headerlink\" title=\"C++11数组初始化\"></a>C++11数组初始化</h3><p>初始化数组的时候，可以省略等号：</p>\n<p><code>double earning[4] = &#123;1.2e4, 1.1e4, 1.6e4, 1.7e4&#125;</code>等价于</p>\n<p><code>double earning[4] &#123;1.2e4, 1.1e4, 1.6e4, 1.7e4&#125;</code></p>\n<p>关于列表初始化的缩窄问题：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> plifs[] = &#123;<span class=\"number\">25</span>, <span class=\"number\">29</span>, <span class=\"number\">3.0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> slifs[<span class=\"number\">4</span>] = &#123;<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"number\">1122011</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> tlifs[<span class=\"number\">4</span>] = &#123;<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"number\">112</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">cpp_chapter_2.cpp:7:29: error: type &#x27;double&#x27; cannot be narrowed to &#x27;long&#x27; in initializer list [-Wc++11-narrowing]</span><br><span class=\"line\">    long plifs[] = &#123;25, 29, 3.0&#125;;</span><br><span class=\"line\">                            ^~~</span><br><span class=\"line\">cpp_chapter_2.cpp:7:29: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    long plifs[] = &#123;25, 29, 3.0&#125;;</span><br><span class=\"line\">                            ^~~</span><br><span class=\"line\">                            static_cast&lt;long&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:8:32: error: constant expression evaluates to 1122011 which cannot be narrowed to type &#x27;char&#x27; [-Wc++11-narrowing]</span><br><span class=\"line\">    char slifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 1122011, &#x27;\\0&#x27;&#125;;</span><br><span class=\"line\">                               ^~~~~~~</span><br><span class=\"line\">cpp_chapter_2.cpp:8:32: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    char slifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 1122011, &#x27;\\0&#x27;&#125;;</span><br><span class=\"line\">                               ^~~~~~~</span><br><span class=\"line\">                               static_cast&lt;char&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:8:32: warning: implicit conversion from &#x27;int&#x27; to &#x27;char&#x27; changes value from 1122011 to -37 [-Wconstant-conversion]</span><br><span class=\"line\">    char slifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 1122011, &#x27;\\0&#x27;&#125;;</span><br><span class=\"line\">                    ~          ^~~~~~~</span><br><span class=\"line\">1 warning and 2 errors generated.</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么使用cin-get\"><a href=\"#为什么使用cin-get\" class=\"headerlink\" title=\"为什么使用cin.get()\"></a>为什么使用cin.get()</h3><p>istream类有一个get()成员函数。</p>\n<p>使用不带任何参数的cin.get()可以读取下一个字符(即使是换行符)， 因此可以处理换行符，比如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cin</span>.get(name, ArSize);     <span class=\"comment\">// read first line</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.get();                 <span class=\"comment\">// read newline</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.get(dessert, ArSize);  <span class=\"comment\">// read second line</span></span><br></pre></td></tr></table></figure>\n<p>另一种使用get()的方式是将两个类成员函数拼接起来：</p>\n<p><code>cin.get(name, ArSize).get()</code></p>\n<p>之所以可以这么做，是因为cin.get(name, ArSize)返回一个cin对象，该对象随后将被用来调用get()函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ArSize = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[ArSize];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dessert[ArSize];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter your name: \\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.get(name ,ArSize).get();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter your favorite dessert: \\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.get(dessert, ArSize).get();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;I have some delicious &quot;</span> &lt;&lt; dessert;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot;.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test</span><br><span class=\"line\">Enter your name: </span><br><span class=\"line\">Evan Yang</span><br><span class=\"line\">Enter your favorite dessert: </span><br><span class=\"line\">Chocolate Mouses</span><br><span class=\"line\">I have some delicious Chocolate Mouses for you, Evan Yang.</span><br></pre></td></tr></table></figure>\n<h3 id=\"cin-clear\"><a href=\"#cin-clear\" class=\"headerlink\" title=\"cin.clear()\"></a>cin.clear()</h3><p>当cin函数输入错误的时候，cin里面有个函数cin.rdstate()可以自动检测到输入错误，当cin.rdstate()返回0(即ios::goodbit)时表示无错误。若返回4则发生非致命错误，即ios::failbit，不能继续输入或操作。cin.clear()则可以控制此时cin里的标识。其中标识符号有：</p>\n<ul>\n<li>goodbit 无错误 </li>\n<li>Eofbit 已到达文件尾 </li>\n<li>failbit 非致命的输入/输出错误，可挽回 </li>\n<li>badbit　致命的输入/输出错误,无法挽回。若在输入输出类里，需要加ios::标识符号 </li>\n</ul>\n<p>cin.clear()一般会与cin.sync()或者cin.ignore()一起使用。cin.sync()代表清除缓冲区中的未读信息， cin.ignore()代表缓冲区中指定个数的字符。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; number,!<span class=\"built_in\">cin</span>.eof()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">cin</span>.bad())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> runtime_error(<span class=\"string\">&quot;IO stream corrupted&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">cin</span>.fail()) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Error input: &quot;</span> &lt;&lt; <span class=\"built_in\">cin</span>.rdstate() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>.clear();</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>.ignore();</span><br><span class=\"line\">          \t<span class=\"comment\">// cin.sync();   这里用sync会死循环？？？为什么？？？</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;cin.rdstate(): &quot;</span> &lt;&lt; <span class=\"built_in\">cin</span>.rdstate() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Input is: &quot;</span> &lt;&lt; number &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">s</span><br><span class=\"line\">Error input: 4</span><br><span class=\"line\">cin.rdstate(): 0</span><br><span class=\"line\">3</span><br><span class=\"line\">Input is: 3</span><br></pre></td></tr></table></figure>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"C-Primer-Plus笔记\"><a href=\"#C-Primer-Plus笔记\" class=\"headerlink\" title=\"C++ Primer Plus笔记\"></a>C++ Primer Plus笔记</h1><h2 id=\"预备知识\"><a href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"></a>预备知识</h2><h3 id=\"如何运行C-程序\"><a href=\"#如何运行C-程序\" class=\"headerlink\" title=\"如何运行C++程序\"></a>如何运行C++程序</h3><ol>\n<li><p>使用文本编辑器编写程序，保存文件，这个文件就是源代码。</p>\n</li>\n<li><p>编译源代码。运行程序将源代码翻译为机器语言。翻译后的文件就是目标代码。</p>\n</li>\n<li><p>将目标代码与其他代码链接起来，生成程序的运行阶段版本。最终产品文件为可执行代码。</p>\n<blockquote>\n<p>链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本</p>\n</blockquote>\n</li>\n</ol>\n<p>编程步骤如下图：</p>\n<p>​    <img src=\"./C++ Primer Plus/编程步骤-8644713.png\" alt=\"编程步骤\" style=\"zoom: 67%;\" /></p>\n<blockquote>\n<p>从4.2版起，g++要求编译源代码文件时使用标记-std=c++0x： <code>g++ -std=C++11 use_auto.cpp</code></p>\n</blockquote>\n<h2 id=\"开始学习C\"><a href=\"#开始学习C\" class=\"headerlink\" title=\"开始学习C++\"></a>开始学习C++</h2><h3 id=\"为什么main-不能使用其他名称？\"><a href=\"#为什么main-不能使用其他名称？\" class=\"headerlink\" title=\"为什么main()不能使用其他名称？\"></a>为什么main()不能使用其他名称？</h3><p>C++程序必须包含一个名为main()的函数， 这是由系统的C++运行时决定的。编译器生成目标系统的可执行文件时，操作系统的启动入口就是C++运行时，然后运行时完成初始化之后就会调用main函数(入口点)。</p>\n<p>存在一些例外情况：比如windows上编写DLL模块，是因为DLL模块不是独立的程序。</p>\n<h3 id=\"cin不支持录入空格\"><a href=\"#cin不支持录入空格\" class=\"headerlink\" title=\"cin不支持录入空格\"></a>cin不支持录入空格</h3><p>在C++中，用<code>cin&gt;&gt;str;</code>这种方法来接收字符串那么录入的str不能包含空格，否则它会按照空格将整个字符串切分成若干段。如果你要是想输入带空格的字符串那就要用到getline()这个函数了。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> name;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> address;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Please input your name: &quot;</span>;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, name);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Please input your address: &quot;</span>;</span><br><span class=\"line\">    getline(<span class=\"built_in\">cin</span>, address);</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Your name is &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot; and address is &quot;</span> &lt;&lt; address &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>执行程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">Please input your name: Evan Yang</span><br><span class=\"line\">Please input your address: Comba Street 64, cot</span><br><span class=\"line\">Your name is Evan Yang and address is Comba Street 64, cot</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % </span><br></pre></td></tr></table></figure>\n<h2 id=\"处理数据\"><a href=\"#处理数据\" class=\"headerlink\" title=\"处理数据\"></a>处理数据</h2><h3 id=\"整型的范围\"><a href=\"#整型的范围\" class=\"headerlink\" title=\"整型的范围\"></a>整型的范围</h3><p>整型： char、short、int、long、long long(C++11)</p>\n<p>C++提供了一种灵活的标准，确保了最小长度：</p>\n<ul>\n<li>short至少16位</li>\n<li>int至少与short一样长</li>\n<li>long至少32位，且至少与int一样长</li>\n<li>long long至少64位，且至少与long一样长</li>\n</ul>\n<p>查看大小：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;climits&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n_int = INT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> n_short = SHRT_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> n_long = LONG_MAX;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n_llong = LLONG_MAX;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;int is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;short is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">short</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long long is &quot;</span> &lt;&lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>) &lt;&lt; <span class=\"string\">&quot; bytes&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;int is &quot;</span> &lt;&lt; n_int &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;short is &quot;</span> &lt;&lt; n_short &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long is &quot;</span> &lt;&lt; n_long &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;long long is &quot;</span> &lt;&lt; n_llong &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  \t<span class=\"keyword\">return</span> <span class=\"number\">0</span>；</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">int is 4 bytes</span><br><span class=\"line\">short is 2 bytes</span><br><span class=\"line\">long is 8 bytes</span><br><span class=\"line\">long long is 8 bytes</span><br><span class=\"line\">int is 2147483647</span><br><span class=\"line\">short is 32767</span><br><span class=\"line\">long is 9223372036854775807</span><br><span class=\"line\">long long is 9223372036854775807</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % </span><br></pre></td></tr></table></figure>\n<h3 id=\"整型的字面值\"><a href=\"#整型的字面值\" class=\"headerlink\" title=\"整型的字面值\"></a>整型的字面值</h3><p>C++能以三种不同的计数方式来书写整数：</p>\n<ul>\n<li>基数为10</li>\n<li>基数为8(老式UNIX版本)：0</li>\n<li>基数为16(硬件黑客的最爱)： 0x或者0X</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> chest = <span class=\"number\">42</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> waist = <span class=\"number\">42</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inseam = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Monsieur cuts a striking figure !\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;chest = &quot;</span> &lt;&lt; chest &lt;&lt; <span class=\"string\">&quot; (decimal for 42)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; hex;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;waist = &quot;</span> &lt;&lt; waist &lt;&lt; <span class=\"string\">&quot; (hexadecimal for 42)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; oct;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;inseam = &quot;</span> &lt;&lt; inseam &lt;&lt; <span class=\"string\">&quot; (octal for 42)\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">Monsieur cuts a striking figure !</span><br><span class=\"line\">chest = 42 (decimal for 42)</span><br><span class=\"line\">waist = 2a (hexadecimal for 42)</span><br><span class=\"line\">inseam = 52 (octal for 42)</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>C++11将使用大括号的初始化称为列表初始化(list-initialization)，这种初始化常用于给复杂的数据类型提供值列表。列表初始化不允许缩窄(narrowing)，即变量的类型可能无法表示赋给它的值。例如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> code = <span class=\"number\">66</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> x = <span class=\"number\">66</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> c1 &#123;<span class=\"number\">31325</span>&#125;; <span class=\"comment\">// narrowing, not allowed</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c2 &#123;<span class=\"number\">66</span>&#125;; <span class=\"comment\">//allowed because char can hold 66</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c3 &#123;code&#125;; <span class=\"comment\">//ditto</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> c4 = &#123;x&#125;; <span class=\"comment\">// not allowed, cause x is not constant</span></span><br><span class=\"line\">x = <span class=\"number\">32325</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> c5 = x;  <span class=\"comment\">//allowed by this form of initialization</span></span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">cpp_chapter_2.cpp:9:14: error: constant expression evaluates to 31325 which cannot be narrowed to type &#x27;char&#x27; [-Wc++11-narrowing]</span><br><span class=\"line\">    char c1 &#123;31325&#125;; // narrowing, not allowed</span><br><span class=\"line\">             ^~~~~</span><br><span class=\"line\">cpp_chapter_2.cpp:9:14: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    char c1 &#123;31325&#125;; // narrowing, not allowed</span><br><span class=\"line\">             ^~~~~</span><br><span class=\"line\">             static_cast&lt;char&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:12:16: error: non-constant-expression cannot be narrowed from type &#x27;int&#x27; to &#x27;char&#x27; in initializer list [-Wc++11-narrowing]</span><br><span class=\"line\">    char c4 = &#123;x&#125;; // not allowed, cause x is not constant</span><br><span class=\"line\">               ^</span><br><span class=\"line\">cpp_chapter_2.cpp:12:16: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    char c4 = &#123;x&#125;; // not allowed, cause x is not constant</span><br><span class=\"line\">               ^</span><br><span class=\"line\">               static_cast&lt;char&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:9:14: warning: implicit conversion from &#x27;int&#x27; to &#x27;char&#x27; changes value from 31325 to 93 [-Wconstant-conversion]</span><br><span class=\"line\">    char c1 &#123;31325&#125;; // narrowing, not allowed</span><br><span class=\"line\">            ~^~~~~</span><br><span class=\"line\">1 warning and 2 errors generated.</span><br></pre></td></tr></table></figure>\n<h3 id=\"auto声明\"><a href=\"#auto声明\" class=\"headerlink\" title=\"auto声明\"></a>auto声明</h3><p>C++11新增一个工具，让编译器能够根据初始化值的类型推断变量的类型。重新定义了auto的含义。</p>\n<p><code>auto n = 100</code> // n is int</p>\n<p><code>auto x = 1.5;</code>  // x is double</p>\n<p><code>auto y = 1.3e12L</code> // y is long double</p>\n<p>处理复杂类型，比如STL中的类型时，自动类型的优势才能显现出来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; scores;</span><br><span class=\"line\"><span class=\"keyword\">auto</span> pv = scores.begin()</span><br></pre></td></tr></table></figure>\n<h2 id=\"复合类型\"><a href=\"#复合类型\" class=\"headerlink\" title=\"复合类型\"></a>复合类型</h2><h3 id=\"C-11数组初始化\"><a href=\"#C-11数组初始化\" class=\"headerlink\" title=\"C++11数组初始化\"></a>C++11数组初始化</h3><p>初始化数组的时候，可以省略等号：</p>\n<p><code>double earning[4] = &#123;1.2e4, 1.1e4, 1.6e4, 1.7e4&#125;</code>等价于</p>\n<p><code>double earning[4] &#123;1.2e4, 1.1e4, 1.6e4, 1.7e4&#125;</code></p>\n<p>关于列表初始化的缩窄问题：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> plifs[] = &#123;<span class=\"number\">25</span>, <span class=\"number\">29</span>, <span class=\"number\">3.0</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> slifs[<span class=\"number\">4</span>] = &#123;<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"number\">1122011</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> tlifs[<span class=\"number\">4</span>] = &#123;<span class=\"string\">&#x27;h&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"number\">112</span>, <span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>编译：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">cpp_chapter_2.cpp:7:29: error: type &#x27;double&#x27; cannot be narrowed to &#x27;long&#x27; in initializer list [-Wc++11-narrowing]</span><br><span class=\"line\">    long plifs[] = &#123;25, 29, 3.0&#125;;</span><br><span class=\"line\">                            ^~~</span><br><span class=\"line\">cpp_chapter_2.cpp:7:29: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    long plifs[] = &#123;25, 29, 3.0&#125;;</span><br><span class=\"line\">                            ^~~</span><br><span class=\"line\">                            static_cast&lt;long&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:8:32: error: constant expression evaluates to 1122011 which cannot be narrowed to type &#x27;char&#x27; [-Wc++11-narrowing]</span><br><span class=\"line\">    char slifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 1122011, &#x27;\\0&#x27;&#125;;</span><br><span class=\"line\">                               ^~~~~~~</span><br><span class=\"line\">cpp_chapter_2.cpp:8:32: note: insert an explicit cast to silence this issue</span><br><span class=\"line\">    char slifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 1122011, &#x27;\\0&#x27;&#125;;</span><br><span class=\"line\">                               ^~~~~~~</span><br><span class=\"line\">                               static_cast&lt;char&gt;( )</span><br><span class=\"line\">cpp_chapter_2.cpp:8:32: warning: implicit conversion from &#x27;int&#x27; to &#x27;char&#x27; changes value from 1122011 to -37 [-Wconstant-conversion]</span><br><span class=\"line\">    char slifs[4] = &#123;&#x27;h&#x27;, &#x27;i&#x27;, 1122011, &#x27;\\0&#x27;&#125;;</span><br><span class=\"line\">                    ~          ^~~~~~~</span><br><span class=\"line\">1 warning and 2 errors generated.</span><br></pre></td></tr></table></figure>\n<h3 id=\"为什么使用cin-get\"><a href=\"#为什么使用cin-get\" class=\"headerlink\" title=\"为什么使用cin.get()\"></a>为什么使用cin.get()</h3><p>istream类有一个get()成员函数。</p>\n<p>使用不带任何参数的cin.get()可以读取下一个字符(即使是换行符)， 因此可以处理换行符，比如：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cin</span>.get(name, ArSize);     <span class=\"comment\">// read first line</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.get();                 <span class=\"comment\">// read newline</span></span><br><span class=\"line\"><span class=\"built_in\">cin</span>.get(dessert, ArSize);  <span class=\"comment\">// read second line</span></span><br></pre></td></tr></table></figure>\n<p>另一种使用get()的方式是将两个类成员函数拼接起来：</p>\n<p><code>cin.get(name, ArSize).get()</code></p>\n<p>之所以可以这么做，是因为cin.get(name, ArSize)返回一个cin对象，该对象随后将被用来调用get()函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ArSize = <span class=\"number\">20</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> name[ArSize];</span><br><span class=\"line\">    <span class=\"keyword\">char</span> dessert[ArSize];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter your name: \\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.get(name ,ArSize).get();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Enter your favorite dessert: \\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>.get(dessert, ArSize).get();</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;I have some delicious &quot;</span> &lt;&lt; dessert;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot; for you, &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"string\">&quot;.\\n&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test</span><br><span class=\"line\">Enter your name: </span><br><span class=\"line\">Evan Yang</span><br><span class=\"line\">Enter your favorite dessert: </span><br><span class=\"line\">Chocolate Mouses</span><br><span class=\"line\">I have some delicious Chocolate Mouses for you, Evan Yang.</span><br></pre></td></tr></table></figure>\n<h3 id=\"cin-clear\"><a href=\"#cin-clear\" class=\"headerlink\" title=\"cin.clear()\"></a>cin.clear()</h3><p>当cin函数输入错误的时候，cin里面有个函数cin.rdstate()可以自动检测到输入错误，当cin.rdstate()返回0(即ios::goodbit)时表示无错误。若返回4则发生非致命错误，即ios::failbit，不能继续输入或操作。cin.clear()则可以控制此时cin里的标识。其中标识符号有：</p>\n<ul>\n<li>goodbit 无错误 </li>\n<li>Eofbit 已到达文件尾 </li>\n<li>failbit 非致命的输入/输出错误，可挽回 </li>\n<li>badbit　致命的输入/输出错误,无法挽回。若在输入输出类里，需要加ios::标识符号 </li>\n</ul>\n<p>cin.clear()一般会与cin.sync()或者cin.ignore()一起使用。cin.sync()代表清除缓冲区中的未读信息， cin.ignore()代表缓冲区中指定个数的字符。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> number = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; number,!<span class=\"built_in\">cin</span>.eof()) </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">cin</span>.bad())</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">throw</span> runtime_error(<span class=\"string\">&quot;IO stream corrupted&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"built_in\">cin</span>.fail()) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Error input: &quot;</span> &lt;&lt; <span class=\"built_in\">cin</span>.rdstate() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>.clear();</span><br><span class=\"line\">            <span class=\"built_in\">cin</span>.ignore();</span><br><span class=\"line\">          \t<span class=\"comment\">// cin.sync();   这里用sync会死循环？？？为什么？？？</span></span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;cin.rdstate(): &quot;</span> &lt;&lt; <span class=\"built_in\">cin</span>.rdstate() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Input is: &quot;</span> &lt;&lt; number &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % g++ -std=c++17 cpp_chapter_2.cpp -o test</span><br><span class=\"line\">(base) phoenine@EvandeMacBook-Pro C_Study_1 % ./test                                  </span><br><span class=\"line\">s</span><br><span class=\"line\">Error input: 4</span><br><span class=\"line\">cin.rdstate(): 0</span><br><span class=\"line\">3</span><br><span class=\"line\">Input is: 3</span><br></pre></td></tr></table></figure>\n"},{"title":"学习C++ - 不常见概念解释","date":"2020-12-31T15:59:00.000Z","abbrlink":13004,"cover":"img/cpp.png","_content":"**学习C++ - 不常见概念解释**\n\n# 模板相关\n\n## Dependent Name\n\nhttps://en.cppreference.com/w/cpp/language/dependent_name\n\n在涉及到模板时，如果引用模板参数中的符号，那么这个符号就是dependent name，即依赖于模板实例化才能确定符号类型。\n\n\n\n### Binding Rules\n\n不依赖模板参数的符号是在模板定义时绑定的。如果绑定时和模板实例化时，同一个符号的含义发生了变化，那程序可能会出问题。\n\n\n\n### Lookup Rules\n\n依赖模板参数的符号是在模板实例化时才去绑定的。\n\n\n\n#### 非ADL\n\n非ADL的情况下，只会在模板定义的上下文寻找符号定义；\n\n下面的例子中，writeObject方法的模板参数类型并不是用户命名空间中定义的，因此对应非ADL场景，只会在模板定义上下文寻找 operator << (std::ostream& os, std::vector<int>&) 符号的定义，不会去用户命名空间中查找：\n\n```\n// an external library\nnamespace E {\n  template<typename T>\n  void writeObject(const T& t) {\n    std::cout << \"Value = \" << t << '\\n';\n  }\n}\n \n// translation unit 1:\n// Programmer 1 wants to allow E::writeObject to work with vector<int>\nnamespace P1 {\n  std::ostream& operator<<(std::ostream& os, const std::vector<int>& v) {\n      for(int n: v) os << n << ' '; return os;\n  }\n  void doSomething() {\n    std::vector<int> v;\n    E::writeObject(v); // error: will not find P1::operator<<\n  }\n}\n \n// translation unit 2:\n// Programmer 2 wants to allow E::writeObject to work with vector<int>\nnamespace P2 {\n  std::ostream& operator<<(std::ostream& os, const std::vector<int>& v) {\n      for(int n: v) os << n <<':'; return os << \"[]\";\n  }\n  void doSomethingElse() {\n    std::vector<int> v;\n    E::writeObject(v); // error: will not find P2::operator<<\n  }\n}\n```\n\n\n\n#### ADL\n\nADL的情况下，不仅会在模板定义的上下文，还会在模板实例化的上下文寻找符号定义；\n\n在下面的这个例子中，模板参数中包括用户命名空间P1中的C，因此对应着ADL场景，会在P1中寻找合适的函数。\n\n```\nnamespace P1 {\n  // if C is a class defined in the P1 namespace\n  std::ostream& operator<<(std::ostream& os, const std::vector<C>& v) {\n      for(C n: v) os << n; return os;\n  }\n  void doSomething() {\n    std::vector<C> v;\n    E::writeObject(v); // OK: instantiates writeObject(std::vector<P1::C>)\n                       //     which finds P1::operator<< via ADL\n  }\n}\n```\n\n\n\n## injected-class-name\n\nhttps://zh.cppreference.com/w/cpp/language/injected-class-name\n\n### 非模板情况\n\n在类作用域中，可以直接使用当前类名来指代当前类，这个类名被称为“注入类名”，这个和当前类名相同的符号是在类定义一开始就被自动注入的，注入类名可以被继承，因此private继承可能导致父类的注入类名对子类不可见，此时只能通过使用父类namespace来显式地指代父类；\n\n### 模板情况\n\n在模板类的作用域中，类名即可指代当前类，又可指代当前模板名称，需要多加分辨。\n\n\n\n### 注入类名与构造函数\n\n在类作用域中，注入类名被当作构造函数的名称，由此引入了一个需要注意的规则：\n\n在限定名C::D解析过程中，如果D是C作用域中的注入类名，且编译器认为C::D可能是一个函数，那么该限定名一定会被解析成构造函数：\n\n不过事实上，只有当D和C同名时，C才会是D作用域的注入类名，毕竟对于D作用域而言，唯一的注入类名就是D了。。也就是说，C::D规则其实就是C::C规则，当然，标准里面的表述方式逻辑上也没毛病，就是理解起来差点意思。\n\n\n\n```\nstruct A {\n    // 在A的作用域开始处，编译器会注入符号A作为注入类名\n    A();\n    A(int);\n    template<class T> A(T) {}\n};\nusing A_alias = A;\n \nA::A() {}\nA_alias::A(int) {}\ntemplate A::A(double);\n \nstruct B : A {\n    using A_alias::A;\n};\n \n// 编译器认为A::A可能是一个函数，并且在A的作用域中查找到了注入类名A，于是将A::A解释为指代构造函数\nA::A a; // 错误：A::A 被认为指名构造函数，而非类型\n// 明确指出A::A是一个struct，编译器不会尝试将A::A解释为构造函数\nstruct A::A a2; // OK：与 'A a2;' 相同\n// B的声明作用域中没有注入类名A，编译器不会将B::A解释为构造函数引用\nB::A b; // OK：与 'A b;' 相同\n```\n\n\n\n# 函数相关\n\n## ADL - Argument-dependent lookup\n\nhttps://en.cppreference.com/w/cpp/language/adl\n\n在编写函数调用（包括操作符函数）语句时，如果函数没有限定符并且在当前环境下找不到定义，编译器根据函数参数的限定符去推测函数限定符的行为。\n\n\n\n# 异常相关\n\n## Function-try-block\n\nhttps://en.cppreference.com/w/cpp/language/function-try-block\n\n\n\n\n\n# 基础概念\n\n## ODR - One Definition Rule\n\nhttps://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule\n\n一个符号可以被多次声明，但只能定义一次。\n\n\n\n## ill-formed\n\n非良构。当文档中提及ill-formed时，指的是一个遵从标准的C++编译器应该识别这种情况并给出明显提示。\n\n\n\n# 名字查找\n\n为了编译std::cout << std::endl，编译器进行了：\n\n- 名字 `std` 的**无限定**的名字查找，找到了头文件 `<iostream>` 中的命名空间 std 的声明\n- 名字 `cout` 的**有限定**的名字查找，找到了命名空间 `std` 中的一个变量声明\n- 名字 `endl` 的有限定的名字查找，找到了命名空间 `std` 中的一个函数模板声明\n- 名字 `operator <<` 的两个[**实参依赖查找**](https://zh.cppreference.com/w/cpp/language/adl)找到命名空间 `std` 中的多个函数模板声明，而名字 `std::ostream::operator<<` 的**有限定名字查找**找到声明于类 `std::ostream` 中的多个成员函数\n\n\n\n对于函数和函数模板的名字，名字查找可以将同一个名字和多个声明联系起来，而且可能从[实参依赖查找](https://zh.cppreference.com/w/cpp/language/adl)中得到额外的声明。还会进行[模板实参推导](https://zh.cppreference.com/w/cpp/language/function_template)，并将声明的集合交给[重载决议](https://zh.cppreference.com/w/cpp/language/overload_resolution)，由它选择所要使用的那个声明。如果适用的话，[成员访问](https://zh.cppreference.com/w/cpp/language/access)的规则只会在名字查找和重载解析之后才被考虑。\n\n\n\n## 有限定的名字查找\n\n*限定*名，是出现在作用域解析操作符 `**::**` 右边的名字（参阅[有限定的标识符](https://zh.cppreference.com/w/cpp/language/identifiers#.E6.9C.89.E9.99.90.E5.AE.9A.E7.9A.84.E6.A0.87.E8.AF.86.E7.AC.A6)）。 限定名可能代表的是：\n\n- 类的成员（包括静态和非静态函数、类型和模板等）\n- 命名空间的成员（包括其它的命名空间）\n- 枚举项\n\n若 `**::**` 左边为空，则查找过程仅会考虑全局命名空间作用域中作出（或通过 [using 声明](https://zh.cppreference.com/w/cpp/language/namespace)引入到全局命名空间中）的声明。这样一来，即使局部声明隐藏了该名字，也能够访问它。\n\n\n在能对 `**::**` 右边的名字进行名字查找之前，必须完成对其左边的名字的查找（除非左边所用的是 [decltype](https://zh.cppreference.com/w/cpp/language/decltype) 表达式或左边为空）。对左边的名字所进行的查找，根据这个名字左边是否有另一个 `**::**` 可以是有限定或无限定的，但其仅考虑命名空间、类类型、枚举和能特化为类型的模板（这一句话的意思参考下面的例子）。\n\n\n\n```\nstruct A {\n  static int n;\n};\nint main() {\n  int A;\n  A::n = 42;    // 正确：对 :: 左边的 A 的无限定查找忽略变量。因为A在当前作用域中不是类型\n  A b;          // 错误：对 A 的无限定查找找到了变量 A\n}\n```\n\n\n\n若 `**::**` 后跟字符 `**~**` 再跟着一个标识符（也就是说指定了析构函数或伪析构函数），那么该标识符将在 `**::**` 左边的名字相同的作用域中查找。下面的例子可以让你喝一壶：\n\n\n\n```\nstruct C { typedef int I; };\ntypedef int I1, I2;\nextern int *p, *q;\nstruct A { ~A(); };\ntypedef A AB;\nint main() {\n  p->C::I::~I(); // ~ 之后的名字 I 在 :: 前面的 I 的同一个作用域中查找\n                 //（也就是说，在 C 的作用域中查找，因此查找结果是 C::I ）\n  q->I1::~I2();  // 名字 I2 在 I1 的同一个作用域中查找，\n                 // 也就是说从当前的作用域中查找，因此查找结果是 ::I2\n  AB x;\n  x.AB::~AB(); // ~ 之后的名字 AB 在 :: 前面的 AB 的同一个作用域中查找\n               // 也就是说从当前的作用域中查找，因此查找结果是 ::AB\n}\n```\n\n\n\n\n\n#### 枚举项\n\n若对左边的名字的查找结果是[枚举](https://zh.cppreference.com/w/cpp/language/enum)（无论是有作用域还是无作用域），右边名字的查找结果必须是属于该枚举的一个枚举项，否则程序非良构。\n\n####  \n\n#### 类成员\n\n若对左边的名字的查找结果是某个类、结构体或联合体的名字，则 `**::**` 右边的名字在该类、结构体或联合体的作用域中进行查找（因此可能找到该类或其基类的成员的声明），但有以下例外情况：\n\n- 析构函数按如上所述进行查找（即在 :: 左边的名字的作用域中查找）\n- [用户定义转换](https://zh.cppreference.com/w/cpp/language/cast_operator)函数名中的转换类型标识（ conversion-type-id ），首先在该类类型的作用域中查找。若未找到，则在当前作用域中查找该名字。\n- 模板实参中使用的名字，在当前作用域中查找（而非在模板名的作用域中查找）\n- [using 声明](https://zh.cppreference.com/w/cpp/language/namespace)中的名字，还考虑在当前作用域中声明的变量、数据成员、函数或枚举项所隐藏的类或枚举名\n\n\n\n若 `**::**` 右边所指名的是和其左边相同的类，则右边的名字表示的是该类的[构造函数](https://zh.cppreference.com/w/cpp/language/constructor)。这种限定名仅能用在构造函数的声明以及引入[继承构造函数](https://zh.cppreference.com/w/cpp/language/using_declaration#.E7.BB.A7.E6.89.BF.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0)的 [using 声明](https://zh.cppreference.com/w/cpp/language/using_declaration)中。在所有忽略函数名的查找过程中（即在查找 `**::**` 左边的名字，或查找[详述类型说明符](https://zh.cppreference.com/w/cpp/language/elaborated_type_specifier)或[基类说明符](https://zh.cppreference.com/w/cpp/language/derived_class)中的名字时），则将同样的语法解释成**注入类名（ injected-class-name ）**：struct A::A a2; a2类型就是struct A。\n\n\n\n有限定名字查找可用来访问被嵌套声明或被派生类隐藏了的类成员。对有限定的成员函数的调用将不再是**虚调用**。\n\n\n\n#### 命名空间的成员\n\n若 `**::**` 左边的名字代表的是命名空间，或者 `**::**` 左边为空（这种情况其代表全局命名空间），那么 `**::**` 右边的名字就在这个命名空间的作用域中进行查找，但有以下例外：\n\n- 在模板实参中使用的名字在当前作用域中查找\n\n\n\n```\nnamespace N {\n   template<typename T> struct foo {};\n   struct X {};\n}\nN::foo<X> x; // 错误：X 查找结果为 ::X 而不是 N::X\n```\n\n\n\n在[命名空间](https://zh.cppreference.com/w/cpp/language/namespace) `N` 中进行有限定查找时，首先要考虑处于 `N` 之中的**所有声明**，以及处于 `N` 的[内联命名空间成员](https://zh.cppreference.com/w/cpp/language/namespace#.E5.86.85.E8.81.94.E5.91.BD.E5.90.8D.E7.A9.BA.E9.97.B4)（并且传递性地包括它们的内联命名空间成员）之中的**所有声明**。如果这个集合中没有找到任何声明，则再考虑在 `N` 和 `N` 的所有传递性的内联命名空间成员中发现的**所有**[**using 指令**](https://zh.cppreference.com/w/cpp/language/namespace#using_.E6.8C.87.E4.BB.A4)**所指名的命名空间之中的声明**。这条规则是递归实施的：\n\n\n\n```\nint x;\nnamespace Y {\n  void f(float);\n  void h(int);\n}\nnamespace Z {\n  void h(double);\n}\nnamespace A {\n  using namespace Y;\n  void f(int);\n  void g(int);\n  int i;\n}\nnamespace B {\n  using namespace Z;\n  void f(char);\n  int i;\n}\nnamespace AB {\n  using namespace A;\n  using namespace B;\n  void g();\n}\nvoid h()\n{\n  AB::g();  // 在 AB 中查找，找到了 AB::g 并且选择了 AB::g(void)\n            // （并未在 A 和 B 中查找）\n  AB::f(1); // 首先在 AB 中查找，未能找到 f\n            // 然后再在 A 和 B 中查找\n            // 找到了 A::f 和 B::f（但并未在 Y 中查找，因而不考虑 Y::f）\n            // 重载解析选中 A::f(int)\n  AB::x++;    // 首先在 AB 中查找，未能找到 x\n              // 然后再在 A 和 B 中查找。未能找到 x\n              // 然后再在 X 和 Y 中查找。还是没有 x：这是一个错误\n  AB::i++;  // 在 AB 中查找，未能找到 i\n            // 然后再在 A 和 B 中查找。找到了 A::i 和 B::i：这是一个错误\n  AB::h(16.8);  // 首先在 AB 中查找：未能找到 h\n                // 然后再在 A 和 B 中查找。未能找到 h\n                // 然后再在 X 和 Y 中查找。\n                // 找到了 Y::h 和 Z::h。重载解析选中 Z::h(double)\n}\n```\n\n\n\n上面的例子中多次定义同一个符号是违法的，但是同一个声明允许被多次找到：\n\n\n\n```\nnamespace A { int a; }\nnamespace B { using namespace A; }\nnamespace D { using A::a; }\nnamespace BD {\n  using namespace B;\n  using namespace D;\n}\nvoid g()\n{\n  BD::a++; // OK ： 通过 B 和 D 找到同一个 A::a\n}\n```\n\n\n\n## 无限定的名字查找\n\n\n\n\n\n## 最内层的外围命名空间\n\n这是英文原文：innermost enclosing namespace 的标准中文表述。\n\n这种表述出现在对友元引入的名字的查找中：\n\n若所查找的是由[友元](https://zh.cppreference.com/w/cpp/language/friend)声明所引入的名字：这种情况下仅考虑其最内层的外围命名空间，否则的话，对外围命名空间的查找将照常持续直到全局作用域。\n\n指的是，如果通过friend引入了名字A，当使用A::a时，只会在A所限定的名字空间中查找a，该查找过程不会扩展到A所处的名字空间，这样的一个严格限定的名字空间就叫做a的最内层的外围名字空间（innermost enclosing namespace）。","source":"_posts/cplus_md/CPlus Basic/学习C++ - 不常见概念解释.md","raw":"---\ntitle: 学习C++ - 不常见概念解释\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 使用教程\nabbrlink: 13004\ncover: img/cpp.png\n---\n**学习C++ - 不常见概念解释**\n\n# 模板相关\n\n## Dependent Name\n\nhttps://en.cppreference.com/w/cpp/language/dependent_name\n\n在涉及到模板时，如果引用模板参数中的符号，那么这个符号就是dependent name，即依赖于模板实例化才能确定符号类型。\n\n\n\n### Binding Rules\n\n不依赖模板参数的符号是在模板定义时绑定的。如果绑定时和模板实例化时，同一个符号的含义发生了变化，那程序可能会出问题。\n\n\n\n### Lookup Rules\n\n依赖模板参数的符号是在模板实例化时才去绑定的。\n\n\n\n#### 非ADL\n\n非ADL的情况下，只会在模板定义的上下文寻找符号定义；\n\n下面的例子中，writeObject方法的模板参数类型并不是用户命名空间中定义的，因此对应非ADL场景，只会在模板定义上下文寻找 operator << (std::ostream& os, std::vector<int>&) 符号的定义，不会去用户命名空间中查找：\n\n```\n// an external library\nnamespace E {\n  template<typename T>\n  void writeObject(const T& t) {\n    std::cout << \"Value = \" << t << '\\n';\n  }\n}\n \n// translation unit 1:\n// Programmer 1 wants to allow E::writeObject to work with vector<int>\nnamespace P1 {\n  std::ostream& operator<<(std::ostream& os, const std::vector<int>& v) {\n      for(int n: v) os << n << ' '; return os;\n  }\n  void doSomething() {\n    std::vector<int> v;\n    E::writeObject(v); // error: will not find P1::operator<<\n  }\n}\n \n// translation unit 2:\n// Programmer 2 wants to allow E::writeObject to work with vector<int>\nnamespace P2 {\n  std::ostream& operator<<(std::ostream& os, const std::vector<int>& v) {\n      for(int n: v) os << n <<':'; return os << \"[]\";\n  }\n  void doSomethingElse() {\n    std::vector<int> v;\n    E::writeObject(v); // error: will not find P2::operator<<\n  }\n}\n```\n\n\n\n#### ADL\n\nADL的情况下，不仅会在模板定义的上下文，还会在模板实例化的上下文寻找符号定义；\n\n在下面的这个例子中，模板参数中包括用户命名空间P1中的C，因此对应着ADL场景，会在P1中寻找合适的函数。\n\n```\nnamespace P1 {\n  // if C is a class defined in the P1 namespace\n  std::ostream& operator<<(std::ostream& os, const std::vector<C>& v) {\n      for(C n: v) os << n; return os;\n  }\n  void doSomething() {\n    std::vector<C> v;\n    E::writeObject(v); // OK: instantiates writeObject(std::vector<P1::C>)\n                       //     which finds P1::operator<< via ADL\n  }\n}\n```\n\n\n\n## injected-class-name\n\nhttps://zh.cppreference.com/w/cpp/language/injected-class-name\n\n### 非模板情况\n\n在类作用域中，可以直接使用当前类名来指代当前类，这个类名被称为“注入类名”，这个和当前类名相同的符号是在类定义一开始就被自动注入的，注入类名可以被继承，因此private继承可能导致父类的注入类名对子类不可见，此时只能通过使用父类namespace来显式地指代父类；\n\n### 模板情况\n\n在模板类的作用域中，类名即可指代当前类，又可指代当前模板名称，需要多加分辨。\n\n\n\n### 注入类名与构造函数\n\n在类作用域中，注入类名被当作构造函数的名称，由此引入了一个需要注意的规则：\n\n在限定名C::D解析过程中，如果D是C作用域中的注入类名，且编译器认为C::D可能是一个函数，那么该限定名一定会被解析成构造函数：\n\n不过事实上，只有当D和C同名时，C才会是D作用域的注入类名，毕竟对于D作用域而言，唯一的注入类名就是D了。。也就是说，C::D规则其实就是C::C规则，当然，标准里面的表述方式逻辑上也没毛病，就是理解起来差点意思。\n\n\n\n```\nstruct A {\n    // 在A的作用域开始处，编译器会注入符号A作为注入类名\n    A();\n    A(int);\n    template<class T> A(T) {}\n};\nusing A_alias = A;\n \nA::A() {}\nA_alias::A(int) {}\ntemplate A::A(double);\n \nstruct B : A {\n    using A_alias::A;\n};\n \n// 编译器认为A::A可能是一个函数，并且在A的作用域中查找到了注入类名A，于是将A::A解释为指代构造函数\nA::A a; // 错误：A::A 被认为指名构造函数，而非类型\n// 明确指出A::A是一个struct，编译器不会尝试将A::A解释为构造函数\nstruct A::A a2; // OK：与 'A a2;' 相同\n// B的声明作用域中没有注入类名A，编译器不会将B::A解释为构造函数引用\nB::A b; // OK：与 'A b;' 相同\n```\n\n\n\n# 函数相关\n\n## ADL - Argument-dependent lookup\n\nhttps://en.cppreference.com/w/cpp/language/adl\n\n在编写函数调用（包括操作符函数）语句时，如果函数没有限定符并且在当前环境下找不到定义，编译器根据函数参数的限定符去推测函数限定符的行为。\n\n\n\n# 异常相关\n\n## Function-try-block\n\nhttps://en.cppreference.com/w/cpp/language/function-try-block\n\n\n\n\n\n# 基础概念\n\n## ODR - One Definition Rule\n\nhttps://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule\n\n一个符号可以被多次声明，但只能定义一次。\n\n\n\n## ill-formed\n\n非良构。当文档中提及ill-formed时，指的是一个遵从标准的C++编译器应该识别这种情况并给出明显提示。\n\n\n\n# 名字查找\n\n为了编译std::cout << std::endl，编译器进行了：\n\n- 名字 `std` 的**无限定**的名字查找，找到了头文件 `<iostream>` 中的命名空间 std 的声明\n- 名字 `cout` 的**有限定**的名字查找，找到了命名空间 `std` 中的一个变量声明\n- 名字 `endl` 的有限定的名字查找，找到了命名空间 `std` 中的一个函数模板声明\n- 名字 `operator <<` 的两个[**实参依赖查找**](https://zh.cppreference.com/w/cpp/language/adl)找到命名空间 `std` 中的多个函数模板声明，而名字 `std::ostream::operator<<` 的**有限定名字查找**找到声明于类 `std::ostream` 中的多个成员函数\n\n\n\n对于函数和函数模板的名字，名字查找可以将同一个名字和多个声明联系起来，而且可能从[实参依赖查找](https://zh.cppreference.com/w/cpp/language/adl)中得到额外的声明。还会进行[模板实参推导](https://zh.cppreference.com/w/cpp/language/function_template)，并将声明的集合交给[重载决议](https://zh.cppreference.com/w/cpp/language/overload_resolution)，由它选择所要使用的那个声明。如果适用的话，[成员访问](https://zh.cppreference.com/w/cpp/language/access)的规则只会在名字查找和重载解析之后才被考虑。\n\n\n\n## 有限定的名字查找\n\n*限定*名，是出现在作用域解析操作符 `**::**` 右边的名字（参阅[有限定的标识符](https://zh.cppreference.com/w/cpp/language/identifiers#.E6.9C.89.E9.99.90.E5.AE.9A.E7.9A.84.E6.A0.87.E8.AF.86.E7.AC.A6)）。 限定名可能代表的是：\n\n- 类的成员（包括静态和非静态函数、类型和模板等）\n- 命名空间的成员（包括其它的命名空间）\n- 枚举项\n\n若 `**::**` 左边为空，则查找过程仅会考虑全局命名空间作用域中作出（或通过 [using 声明](https://zh.cppreference.com/w/cpp/language/namespace)引入到全局命名空间中）的声明。这样一来，即使局部声明隐藏了该名字，也能够访问它。\n\n\n在能对 `**::**` 右边的名字进行名字查找之前，必须完成对其左边的名字的查找（除非左边所用的是 [decltype](https://zh.cppreference.com/w/cpp/language/decltype) 表达式或左边为空）。对左边的名字所进行的查找，根据这个名字左边是否有另一个 `**::**` 可以是有限定或无限定的，但其仅考虑命名空间、类类型、枚举和能特化为类型的模板（这一句话的意思参考下面的例子）。\n\n\n\n```\nstruct A {\n  static int n;\n};\nint main() {\n  int A;\n  A::n = 42;    // 正确：对 :: 左边的 A 的无限定查找忽略变量。因为A在当前作用域中不是类型\n  A b;          // 错误：对 A 的无限定查找找到了变量 A\n}\n```\n\n\n\n若 `**::**` 后跟字符 `**~**` 再跟着一个标识符（也就是说指定了析构函数或伪析构函数），那么该标识符将在 `**::**` 左边的名字相同的作用域中查找。下面的例子可以让你喝一壶：\n\n\n\n```\nstruct C { typedef int I; };\ntypedef int I1, I2;\nextern int *p, *q;\nstruct A { ~A(); };\ntypedef A AB;\nint main() {\n  p->C::I::~I(); // ~ 之后的名字 I 在 :: 前面的 I 的同一个作用域中查找\n                 //（也就是说，在 C 的作用域中查找，因此查找结果是 C::I ）\n  q->I1::~I2();  // 名字 I2 在 I1 的同一个作用域中查找，\n                 // 也就是说从当前的作用域中查找，因此查找结果是 ::I2\n  AB x;\n  x.AB::~AB(); // ~ 之后的名字 AB 在 :: 前面的 AB 的同一个作用域中查找\n               // 也就是说从当前的作用域中查找，因此查找结果是 ::AB\n}\n```\n\n\n\n\n\n#### 枚举项\n\n若对左边的名字的查找结果是[枚举](https://zh.cppreference.com/w/cpp/language/enum)（无论是有作用域还是无作用域），右边名字的查找结果必须是属于该枚举的一个枚举项，否则程序非良构。\n\n####  \n\n#### 类成员\n\n若对左边的名字的查找结果是某个类、结构体或联合体的名字，则 `**::**` 右边的名字在该类、结构体或联合体的作用域中进行查找（因此可能找到该类或其基类的成员的声明），但有以下例外情况：\n\n- 析构函数按如上所述进行查找（即在 :: 左边的名字的作用域中查找）\n- [用户定义转换](https://zh.cppreference.com/w/cpp/language/cast_operator)函数名中的转换类型标识（ conversion-type-id ），首先在该类类型的作用域中查找。若未找到，则在当前作用域中查找该名字。\n- 模板实参中使用的名字，在当前作用域中查找（而非在模板名的作用域中查找）\n- [using 声明](https://zh.cppreference.com/w/cpp/language/namespace)中的名字，还考虑在当前作用域中声明的变量、数据成员、函数或枚举项所隐藏的类或枚举名\n\n\n\n若 `**::**` 右边所指名的是和其左边相同的类，则右边的名字表示的是该类的[构造函数](https://zh.cppreference.com/w/cpp/language/constructor)。这种限定名仅能用在构造函数的声明以及引入[继承构造函数](https://zh.cppreference.com/w/cpp/language/using_declaration#.E7.BB.A7.E6.89.BF.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0)的 [using 声明](https://zh.cppreference.com/w/cpp/language/using_declaration)中。在所有忽略函数名的查找过程中（即在查找 `**::**` 左边的名字，或查找[详述类型说明符](https://zh.cppreference.com/w/cpp/language/elaborated_type_specifier)或[基类说明符](https://zh.cppreference.com/w/cpp/language/derived_class)中的名字时），则将同样的语法解释成**注入类名（ injected-class-name ）**：struct A::A a2; a2类型就是struct A。\n\n\n\n有限定名字查找可用来访问被嵌套声明或被派生类隐藏了的类成员。对有限定的成员函数的调用将不再是**虚调用**。\n\n\n\n#### 命名空间的成员\n\n若 `**::**` 左边的名字代表的是命名空间，或者 `**::**` 左边为空（这种情况其代表全局命名空间），那么 `**::**` 右边的名字就在这个命名空间的作用域中进行查找，但有以下例外：\n\n- 在模板实参中使用的名字在当前作用域中查找\n\n\n\n```\nnamespace N {\n   template<typename T> struct foo {};\n   struct X {};\n}\nN::foo<X> x; // 错误：X 查找结果为 ::X 而不是 N::X\n```\n\n\n\n在[命名空间](https://zh.cppreference.com/w/cpp/language/namespace) `N` 中进行有限定查找时，首先要考虑处于 `N` 之中的**所有声明**，以及处于 `N` 的[内联命名空间成员](https://zh.cppreference.com/w/cpp/language/namespace#.E5.86.85.E8.81.94.E5.91.BD.E5.90.8D.E7.A9.BA.E9.97.B4)（并且传递性地包括它们的内联命名空间成员）之中的**所有声明**。如果这个集合中没有找到任何声明，则再考虑在 `N` 和 `N` 的所有传递性的内联命名空间成员中发现的**所有**[**using 指令**](https://zh.cppreference.com/w/cpp/language/namespace#using_.E6.8C.87.E4.BB.A4)**所指名的命名空间之中的声明**。这条规则是递归实施的：\n\n\n\n```\nint x;\nnamespace Y {\n  void f(float);\n  void h(int);\n}\nnamespace Z {\n  void h(double);\n}\nnamespace A {\n  using namespace Y;\n  void f(int);\n  void g(int);\n  int i;\n}\nnamespace B {\n  using namespace Z;\n  void f(char);\n  int i;\n}\nnamespace AB {\n  using namespace A;\n  using namespace B;\n  void g();\n}\nvoid h()\n{\n  AB::g();  // 在 AB 中查找，找到了 AB::g 并且选择了 AB::g(void)\n            // （并未在 A 和 B 中查找）\n  AB::f(1); // 首先在 AB 中查找，未能找到 f\n            // 然后再在 A 和 B 中查找\n            // 找到了 A::f 和 B::f（但并未在 Y 中查找，因而不考虑 Y::f）\n            // 重载解析选中 A::f(int)\n  AB::x++;    // 首先在 AB 中查找，未能找到 x\n              // 然后再在 A 和 B 中查找。未能找到 x\n              // 然后再在 X 和 Y 中查找。还是没有 x：这是一个错误\n  AB::i++;  // 在 AB 中查找，未能找到 i\n            // 然后再在 A 和 B 中查找。找到了 A::i 和 B::i：这是一个错误\n  AB::h(16.8);  // 首先在 AB 中查找：未能找到 h\n                // 然后再在 A 和 B 中查找。未能找到 h\n                // 然后再在 X 和 Y 中查找。\n                // 找到了 Y::h 和 Z::h。重载解析选中 Z::h(double)\n}\n```\n\n\n\n上面的例子中多次定义同一个符号是违法的，但是同一个声明允许被多次找到：\n\n\n\n```\nnamespace A { int a; }\nnamespace B { using namespace A; }\nnamespace D { using A::a; }\nnamespace BD {\n  using namespace B;\n  using namespace D;\n}\nvoid g()\n{\n  BD::a++; // OK ： 通过 B 和 D 找到同一个 A::a\n}\n```\n\n\n\n## 无限定的名字查找\n\n\n\n\n\n## 最内层的外围命名空间\n\n这是英文原文：innermost enclosing namespace 的标准中文表述。\n\n这种表述出现在对友元引入的名字的查找中：\n\n若所查找的是由[友元](https://zh.cppreference.com/w/cpp/language/friend)声明所引入的名字：这种情况下仅考虑其最内层的外围命名空间，否则的话，对外围命名空间的查找将照常持续直到全局作用域。\n\n指的是，如果通过friend引入了名字A，当使用A::a时，只会在A所限定的名字空间中查找a，该查找过程不会扩展到A所处的名字空间，这样的一个严格限定的名字空间就叫做a的最内层的外围名字空间（innermost enclosing namespace）。","slug":"cplus_md/CPlus Basic/学习C++ - 不常见概念解释","published":1,"updated":"2021-04-09T14:06:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6d0044w9q9dw4v4a52","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><p><strong>学习C++ - 不常见概念解释</strong></p>\n<h1 id=\"模板相关\"><a href=\"#模板相关\" class=\"headerlink\" title=\"模板相关\"></a>模板相关</h1><h2 id=\"Dependent-Name\"><a href=\"#Dependent-Name\" class=\"headerlink\" title=\"Dependent Name\"></a>Dependent Name</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/dependent_name\">https://en.cppreference.com/w/cpp/language/dependent_name</a></p>\n<p>在涉及到模板时，如果引用模板参数中的符号，那么这个符号就是dependent name，即依赖于模板实例化才能确定符号类型。</p>\n<h3 id=\"Binding-Rules\"><a href=\"#Binding-Rules\" class=\"headerlink\" title=\"Binding Rules\"></a>Binding Rules</h3><p>不依赖模板参数的符号是在模板定义时绑定的。如果绑定时和模板实例化时，同一个符号的含义发生了变化，那程序可能会出问题。</p>\n<h3 id=\"Lookup-Rules\"><a href=\"#Lookup-Rules\" class=\"headerlink\" title=\"Lookup Rules\"></a>Lookup Rules</h3><p>依赖模板参数的符号是在模板实例化时才去绑定的。</p>\n<h4 id=\"非ADL\"><a href=\"#非ADL\" class=\"headerlink\" title=\"非ADL\"></a>非ADL</h4><p>非ADL的情况下，只会在模板定义的上下文寻找符号定义；</p>\n<p>下面的例子中，writeObject方法的模板参数类型并不是用户命名空间中定义的，因此对应非ADL场景，只会在模板定义上下文寻找 operator &lt;&lt; (std::ostream&amp; os, std::vector<int>&amp;) 符号的定义，不会去用户命名空间中查找：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; an external library</span><br><span class=\"line\">namespace E &#123;</span><br><span class=\"line\">  template&lt;typename T&gt;</span><br><span class=\"line\">  void writeObject(const T&amp; t) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;Value &#x3D; &quot; &lt;&lt; t &lt;&lt; &#39;\\n&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; translation unit 1:</span><br><span class=\"line\">&#x2F;&#x2F; Programmer 1 wants to allow E::writeObject to work with vector&lt;int&gt;</span><br><span class=\"line\">namespace P1 &#123;</span><br><span class=\"line\">  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v) &#123;</span><br><span class=\"line\">      for(int n: v) os &lt;&lt; n &lt;&lt; &#39; &#39;; return os;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void doSomething() &#123;</span><br><span class=\"line\">    std::vector&lt;int&gt; v;</span><br><span class=\"line\">    E::writeObject(v); &#x2F;&#x2F; error: will not find P1::operator&lt;&lt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; translation unit 2:</span><br><span class=\"line\">&#x2F;&#x2F; Programmer 2 wants to allow E::writeObject to work with vector&lt;int&gt;</span><br><span class=\"line\">namespace P2 &#123;</span><br><span class=\"line\">  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v) &#123;</span><br><span class=\"line\">      for(int n: v) os &lt;&lt; n &lt;&lt;&#39;:&#39;; return os &lt;&lt; &quot;[]&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void doSomethingElse() &#123;</span><br><span class=\"line\">    std::vector&lt;int&gt; v;</span><br><span class=\"line\">    E::writeObject(v); &#x2F;&#x2F; error: will not find P2::operator&lt;&lt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"ADL\"><a href=\"#ADL\" class=\"headerlink\" title=\"ADL\"></a>ADL</h4><p>ADL的情况下，不仅会在模板定义的上下文，还会在模板实例化的上下文寻找符号定义；</p>\n<p>在下面的这个例子中，模板参数中包括用户命名空间P1中的C，因此对应着ADL场景，会在P1中寻找合适的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace P1 &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; if C is a class defined in the P1 namespace</span><br><span class=\"line\">  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;C&gt;&amp; v) &#123;</span><br><span class=\"line\">      for(C n: v) os &lt;&lt; n; return os;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void doSomething() &#123;</span><br><span class=\"line\">    std::vector&lt;C&gt; v;</span><br><span class=\"line\">    E::writeObject(v); &#x2F;&#x2F; OK: instantiates writeObject(std::vector&lt;P1::C&gt;)</span><br><span class=\"line\">                       &#x2F;&#x2F;     which finds P1::operator&lt;&lt; via ADL</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"injected-class-name\"><a href=\"#injected-class-name\" class=\"headerlink\" title=\"injected-class-name\"></a>injected-class-name</h2><p><a href=\"https://zh.cppreference.com/w/cpp/language/injected-class-name\">https://zh.cppreference.com/w/cpp/language/injected-class-name</a></p>\n<h3 id=\"非模板情况\"><a href=\"#非模板情况\" class=\"headerlink\" title=\"非模板情况\"></a>非模板情况</h3><p>在类作用域中，可以直接使用当前类名来指代当前类，这个类名被称为“注入类名”，这个和当前类名相同的符号是在类定义一开始就被自动注入的，注入类名可以被继承，因此private继承可能导致父类的注入类名对子类不可见，此时只能通过使用父类namespace来显式地指代父类；</p>\n<h3 id=\"模板情况\"><a href=\"#模板情况\" class=\"headerlink\" title=\"模板情况\"></a>模板情况</h3><p>在模板类的作用域中，类名即可指代当前类，又可指代当前模板名称，需要多加分辨。</p>\n<h3 id=\"注入类名与构造函数\"><a href=\"#注入类名与构造函数\" class=\"headerlink\" title=\"注入类名与构造函数\"></a>注入类名与构造函数</h3><p>在类作用域中，注入类名被当作构造函数的名称，由此引入了一个需要注意的规则：</p>\n<p>在限定名C::D解析过程中，如果D是C作用域中的注入类名，且编译器认为C::D可能是一个函数，那么该限定名一定会被解析成构造函数：</p>\n<p>不过事实上，只有当D和C同名时，C才会是D作用域的注入类名，毕竟对于D作用域而言，唯一的注入类名就是D了。。也就是说，C::D规则其实就是C::C规则，当然，标准里面的表述方式逻辑上也没毛病，就是理解起来差点意思。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct A &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 在A的作用域开始处，编译器会注入符号A作为注入类名</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    A(int);</span><br><span class=\"line\">    template&lt;class T&gt; A(T) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">using A_alias &#x3D; A;</span><br><span class=\"line\"> </span><br><span class=\"line\">A::A() &#123;&#125;</span><br><span class=\"line\">A_alias::A(int) &#123;&#125;</span><br><span class=\"line\">template A::A(double);</span><br><span class=\"line\"> </span><br><span class=\"line\">struct B : A &#123;</span><br><span class=\"line\">    using A_alias::A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 编译器认为A::A可能是一个函数，并且在A的作用域中查找到了注入类名A，于是将A::A解释为指代构造函数</span><br><span class=\"line\">A::A a; &#x2F;&#x2F; 错误：A::A 被认为指名构造函数，而非类型</span><br><span class=\"line\">&#x2F;&#x2F; 明确指出A::A是一个struct，编译器不会尝试将A::A解释为构造函数</span><br><span class=\"line\">struct A::A a2; &#x2F;&#x2F; OK：与 &#39;A a2;&#39; 相同</span><br><span class=\"line\">&#x2F;&#x2F; B的声明作用域中没有注入类名A，编译器不会将B::A解释为构造函数引用</span><br><span class=\"line\">B::A b; &#x2F;&#x2F; OK：与 &#39;A b;&#39; 相同</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"函数相关\"><a href=\"#函数相关\" class=\"headerlink\" title=\"函数相关\"></a>函数相关</h1><h2 id=\"ADL-Argument-dependent-lookup\"><a href=\"#ADL-Argument-dependent-lookup\" class=\"headerlink\" title=\"ADL - Argument-dependent lookup\"></a>ADL - Argument-dependent lookup</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/adl\">https://en.cppreference.com/w/cpp/language/adl</a></p>\n<p>在编写函数调用（包括操作符函数）语句时，如果函数没有限定符并且在当前环境下找不到定义，编译器根据函数参数的限定符去推测函数限定符的行为。</p>\n<h1 id=\"异常相关\"><a href=\"#异常相关\" class=\"headerlink\" title=\"异常相关\"></a>异常相关</h1><h2 id=\"Function-try-block\"><a href=\"#Function-try-block\" class=\"headerlink\" title=\"Function-try-block\"></a>Function-try-block</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/function-try-block\">https://en.cppreference.com/w/cpp/language/function-try-block</a></p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"ODR-One-Definition-Rule\"><a href=\"#ODR-One-Definition-Rule\" class=\"headerlink\" title=\"ODR - One Definition Rule\"></a>ODR - One Definition Rule</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule\">https://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule</a></p>\n<p>一个符号可以被多次声明，但只能定义一次。</p>\n<h2 id=\"ill-formed\"><a href=\"#ill-formed\" class=\"headerlink\" title=\"ill-formed\"></a>ill-formed</h2><p>非良构。当文档中提及ill-formed时，指的是一个遵从标准的C++编译器应该识别这种情况并给出明显提示。</p>\n<h1 id=\"名字查找\"><a href=\"#名字查找\" class=\"headerlink\" title=\"名字查找\"></a>名字查找</h1><p>为了编译std::cout &lt;&lt; std::endl，编译器进行了：</p>\n<ul>\n<li>名字 <code>std</code> 的<strong>无限定</strong>的名字查找，找到了头文件 <code>&lt;iostream&gt;</code> 中的命名空间 std 的声明</li>\n<li>名字 <code>cout</code> 的<strong>有限定</strong>的名字查找，找到了命名空间 <code>std</code> 中的一个变量声明</li>\n<li>名字 <code>endl</code> 的有限定的名字查找，找到了命名空间 <code>std</code> 中的一个函数模板声明</li>\n<li>名字 <code>operator &lt;&lt;</code> 的两个<a href=\"https://zh.cppreference.com/w/cpp/language/adl\"><strong>实参依赖查找</strong></a>找到命名空间 <code>std</code> 中的多个函数模板声明，而名字 <code>std::ostream::operator&lt;&lt;</code> 的<strong>有限定名字查找</strong>找到声明于类 <code>std::ostream</code> 中的多个成员函数</li>\n</ul>\n<p>对于函数和函数模板的名字，名字查找可以将同一个名字和多个声明联系起来，而且可能从<a href=\"https://zh.cppreference.com/w/cpp/language/adl\">实参依赖查找</a>中得到额外的声明。还会进行<a href=\"https://zh.cppreference.com/w/cpp/language/function_template\">模板实参推导</a>，并将声明的集合交给<a href=\"https://zh.cppreference.com/w/cpp/language/overload_resolution\">重载决议</a>，由它选择所要使用的那个声明。如果适用的话，<a href=\"https://zh.cppreference.com/w/cpp/language/access\">成员访问</a>的规则只会在名字查找和重载解析之后才被考虑。</p>\n<h2 id=\"有限定的名字查找\"><a href=\"#有限定的名字查找\" class=\"headerlink\" title=\"有限定的名字查找\"></a>有限定的名字查找</h2><p><em>限定</em>名，是出现在作用域解析操作符 <code>**::**</code> 右边的名字（参阅<a href=\"https://zh.cppreference.com/w/cpp/language/identifiers#.E6.9C.89.E9.99.90.E5.AE.9A.E7.9A.84.E6.A0.87.E8.AF.86.E7.AC.A6\">有限定的标识符</a>）。 限定名可能代表的是：</p>\n<ul>\n<li>类的成员（包括静态和非静态函数、类型和模板等）</li>\n<li>命名空间的成员（包括其它的命名空间）</li>\n<li>枚举项</li>\n</ul>\n<p>若 <code>**::**</code> 左边为空，则查找过程仅会考虑全局命名空间作用域中作出（或通过 <a href=\"https://zh.cppreference.com/w/cpp/language/namespace\">using 声明</a>引入到全局命名空间中）的声明。这样一来，即使局部声明隐藏了该名字，也能够访问它。</p>\n<p>在能对 <code>**::**</code> 右边的名字进行名字查找之前，必须完成对其左边的名字的查找（除非左边所用的是 <a href=\"https://zh.cppreference.com/w/cpp/language/decltype\">decltype</a> 表达式或左边为空）。对左边的名字所进行的查找，根据这个名字左边是否有另一个 <code>**::**</code> 可以是有限定或无限定的，但其仅考虑命名空间、类类型、枚举和能特化为类型的模板（这一句话的意思参考下面的例子）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct A &#123;</span><br><span class=\"line\">  static int n;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  int A;</span><br><span class=\"line\">  A::n &#x3D; 42;    &#x2F;&#x2F; 正确：对 :: 左边的 A 的无限定查找忽略变量。因为A在当前作用域中不是类型</span><br><span class=\"line\">  A b;          &#x2F;&#x2F; 错误：对 A 的无限定查找找到了变量 A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>若 <code>**::**</code> 后跟字符 <code>**~**</code> 再跟着一个标识符（也就是说指定了析构函数或伪析构函数），那么该标识符将在 <code>**::**</code> 左边的名字相同的作用域中查找。下面的例子可以让你喝一壶：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct C &#123; typedef int I; &#125;;</span><br><span class=\"line\">typedef int I1, I2;</span><br><span class=\"line\">extern int *p, *q;</span><br><span class=\"line\">struct A &#123; ~A(); &#125;;</span><br><span class=\"line\">typedef A AB;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  p-&gt;C::I::~I(); &#x2F;&#x2F; ~ 之后的名字 I 在 :: 前面的 I 的同一个作用域中查找</span><br><span class=\"line\">                 &#x2F;&#x2F;（也就是说，在 C 的作用域中查找，因此查找结果是 C::I ）</span><br><span class=\"line\">  q-&gt;I1::~I2();  &#x2F;&#x2F; 名字 I2 在 I1 的同一个作用域中查找，</span><br><span class=\"line\">                 &#x2F;&#x2F; 也就是说从当前的作用域中查找，因此查找结果是 ::I2</span><br><span class=\"line\">  AB x;</span><br><span class=\"line\">  x.AB::~AB(); &#x2F;&#x2F; ~ 之后的名字 AB 在 :: 前面的 AB 的同一个作用域中查找</span><br><span class=\"line\">               &#x2F;&#x2F; 也就是说从当前的作用域中查找，因此查找结果是 ::AB</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"枚举项\"><a href=\"#枚举项\" class=\"headerlink\" title=\"枚举项\"></a>枚举项</h4><p>若对左边的名字的查找结果是<a href=\"https://zh.cppreference.com/w/cpp/language/enum\">枚举</a>（无论是有作用域还是无作用域），右边名字的查找结果必须是属于该枚举的一个枚举项，否则程序非良构。</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"类成员\"><a href=\"#类成员\" class=\"headerlink\" title=\"类成员\"></a>类成员</h4><p>若对左边的名字的查找结果是某个类、结构体或联合体的名字，则 <code>**::**</code> 右边的名字在该类、结构体或联合体的作用域中进行查找（因此可能找到该类或其基类的成员的声明），但有以下例外情况：</p>\n<ul>\n<li>析构函数按如上所述进行查找（即在 :: 左边的名字的作用域中查找）</li>\n<li><a href=\"https://zh.cppreference.com/w/cpp/language/cast_operator\">用户定义转换</a>函数名中的转换类型标识（ conversion-type-id ），首先在该类类型的作用域中查找。若未找到，则在当前作用域中查找该名字。</li>\n<li>模板实参中使用的名字，在当前作用域中查找（而非在模板名的作用域中查找）</li>\n<li><a href=\"https://zh.cppreference.com/w/cpp/language/namespace\">using 声明</a>中的名字，还考虑在当前作用域中声明的变量、数据成员、函数或枚举项所隐藏的类或枚举名</li>\n</ul>\n<p>若 <code>**::**</code> 右边所指名的是和其左边相同的类，则右边的名字表示的是该类的<a href=\"https://zh.cppreference.com/w/cpp/language/constructor\">构造函数</a>。这种限定名仅能用在构造函数的声明以及引入<a href=\"https://zh.cppreference.com/w/cpp/language/using_declaration#.E7.BB.A7.E6.89.BF.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0\">继承构造函数</a>的 <a href=\"https://zh.cppreference.com/w/cpp/language/using_declaration\">using 声明</a>中。在所有忽略函数名的查找过程中（即在查找 <code>**::**</code> 左边的名字，或查找<a href=\"https://zh.cppreference.com/w/cpp/language/elaborated_type_specifier\">详述类型说明符</a>或<a href=\"https://zh.cppreference.com/w/cpp/language/derived_class\">基类说明符</a>中的名字时），则将同样的语法解释成<strong>注入类名（ injected-class-name ）</strong>：struct A::A a2; a2类型就是struct A。</p>\n<p>有限定名字查找可用来访问被嵌套声明或被派生类隐藏了的类成员。对有限定的成员函数的调用将不再是<strong>虚调用</strong>。</p>\n<h4 id=\"命名空间的成员\"><a href=\"#命名空间的成员\" class=\"headerlink\" title=\"命名空间的成员\"></a>命名空间的成员</h4><p>若 <code>**::**</code> 左边的名字代表的是命名空间，或者 <code>**::**</code> 左边为空（这种情况其代表全局命名空间），那么 <code>**::**</code> 右边的名字就在这个命名空间的作用域中进行查找，但有以下例外：</p>\n<ul>\n<li>在模板实参中使用的名字在当前作用域中查找</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace N &#123;</span><br><span class=\"line\">   template&lt;typename T&gt; struct foo &#123;&#125;;</span><br><span class=\"line\">   struct X &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">N::foo&lt;X&gt; x; &#x2F;&#x2F; 错误：X 查找结果为 ::X 而不是 N::X</span><br></pre></td></tr></table></figure>\n\n\n<p>在<a href=\"https://zh.cppreference.com/w/cpp/language/namespace\">命名空间</a> <code>N</code> 中进行有限定查找时，首先要考虑处于 <code>N</code> 之中的<strong>所有声明</strong>，以及处于 <code>N</code> 的<a href=\"https://zh.cppreference.com/w/cpp/language/namespace#.E5.86.85.E8.81.94.E5.91.BD.E5.90.8D.E7.A9.BA.E9.97.B4\">内联命名空间成员</a>（并且传递性地包括它们的内联命名空间成员）之中的<strong>所有声明</strong>。如果这个集合中没有找到任何声明，则再考虑在 <code>N</code> 和 <code>N</code> 的所有传递性的内联命名空间成员中发现的<strong>所有</strong><a href=\"https://zh.cppreference.com/w/cpp/language/namespace#using_.E6.8C.87.E4.BB.A4\"><strong>using 指令</strong></a><strong>所指名的命名空间之中的声明</strong>。这条规则是递归实施的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x;</span><br><span class=\"line\">namespace Y &#123;</span><br><span class=\"line\">  void f(float);</span><br><span class=\"line\">  void h(int);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace Z &#123;</span><br><span class=\"line\">  void h(double);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace A &#123;</span><br><span class=\"line\">  using namespace Y;</span><br><span class=\"line\">  void f(int);</span><br><span class=\"line\">  void g(int);</span><br><span class=\"line\">  int i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace B &#123;</span><br><span class=\"line\">  using namespace Z;</span><br><span class=\"line\">  void f(char);</span><br><span class=\"line\">  int i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace AB &#123;</span><br><span class=\"line\">  using namespace A;</span><br><span class=\"line\">  using namespace B;</span><br><span class=\"line\">  void g();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void h()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  AB::g();  &#x2F;&#x2F; 在 AB 中查找，找到了 AB::g 并且选择了 AB::g(void)</span><br><span class=\"line\">            &#x2F;&#x2F; （并未在 A 和 B 中查找）</span><br><span class=\"line\">  AB::f(1); &#x2F;&#x2F; 首先在 AB 中查找，未能找到 f</span><br><span class=\"line\">            &#x2F;&#x2F; 然后再在 A 和 B 中查找</span><br><span class=\"line\">            &#x2F;&#x2F; 找到了 A::f 和 B::f（但并未在 Y 中查找，因而不考虑 Y::f）</span><br><span class=\"line\">            &#x2F;&#x2F; 重载解析选中 A::f(int)</span><br><span class=\"line\">  AB::x++;    &#x2F;&#x2F; 首先在 AB 中查找，未能找到 x</span><br><span class=\"line\">              &#x2F;&#x2F; 然后再在 A 和 B 中查找。未能找到 x</span><br><span class=\"line\">              &#x2F;&#x2F; 然后再在 X 和 Y 中查找。还是没有 x：这是一个错误</span><br><span class=\"line\">  AB::i++;  &#x2F;&#x2F; 在 AB 中查找，未能找到 i</span><br><span class=\"line\">            &#x2F;&#x2F; 然后再在 A 和 B 中查找。找到了 A::i 和 B::i：这是一个错误</span><br><span class=\"line\">  AB::h(16.8);  &#x2F;&#x2F; 首先在 AB 中查找：未能找到 h</span><br><span class=\"line\">                &#x2F;&#x2F; 然后再在 A 和 B 中查找。未能找到 h</span><br><span class=\"line\">                &#x2F;&#x2F; 然后再在 X 和 Y 中查找。</span><br><span class=\"line\">                &#x2F;&#x2F; 找到了 Y::h 和 Z::h。重载解析选中 Z::h(double)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>上面的例子中多次定义同一个符号是违法的，但是同一个声明允许被多次找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace A &#123; int a; &#125;</span><br><span class=\"line\">namespace B &#123; using namespace A; &#125;</span><br><span class=\"line\">namespace D &#123; using A::a; &#125;</span><br><span class=\"line\">namespace BD &#123;</span><br><span class=\"line\">  using namespace B;</span><br><span class=\"line\">  using namespace D;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void g()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  BD::a++; &#x2F;&#x2F; OK ： 通过 B 和 D 找到同一个 A::a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"无限定的名字查找\"><a href=\"#无限定的名字查找\" class=\"headerlink\" title=\"无限定的名字查找\"></a>无限定的名字查找</h2><h2 id=\"最内层的外围命名空间\"><a href=\"#最内层的外围命名空间\" class=\"headerlink\" title=\"最内层的外围命名空间\"></a>最内层的外围命名空间</h2><p>这是英文原文：innermost enclosing namespace 的标准中文表述。</p>\n<p>这种表述出现在对友元引入的名字的查找中：</p>\n<p>若所查找的是由<a href=\"https://zh.cppreference.com/w/cpp/language/friend\">友元</a>声明所引入的名字：这种情况下仅考虑其最内层的外围命名空间，否则的话，对外围命名空间的查找将照常持续直到全局作用域。</p>\n<p>指的是，如果通过friend引入了名字A，当使用A::a时，只会在A所限定的名字空间中查找a，该查找过程不会扩展到A所处的名字空间，这样的一个严格限定的名字空间就叫做a的最内层的外围名字空间（innermost enclosing namespace）。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p><strong>学习C++ - 不常见概念解释</strong></p>\n<h1 id=\"模板相关\"><a href=\"#模板相关\" class=\"headerlink\" title=\"模板相关\"></a>模板相关</h1><h2 id=\"Dependent-Name\"><a href=\"#Dependent-Name\" class=\"headerlink\" title=\"Dependent Name\"></a>Dependent Name</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/dependent_name\">https://en.cppreference.com/w/cpp/language/dependent_name</a></p>\n<p>在涉及到模板时，如果引用模板参数中的符号，那么这个符号就是dependent name，即依赖于模板实例化才能确定符号类型。</p>\n<h3 id=\"Binding-Rules\"><a href=\"#Binding-Rules\" class=\"headerlink\" title=\"Binding Rules\"></a>Binding Rules</h3><p>不依赖模板参数的符号是在模板定义时绑定的。如果绑定时和模板实例化时，同一个符号的含义发生了变化，那程序可能会出问题。</p>\n<h3 id=\"Lookup-Rules\"><a href=\"#Lookup-Rules\" class=\"headerlink\" title=\"Lookup Rules\"></a>Lookup Rules</h3><p>依赖模板参数的符号是在模板实例化时才去绑定的。</p>\n<h4 id=\"非ADL\"><a href=\"#非ADL\" class=\"headerlink\" title=\"非ADL\"></a>非ADL</h4><p>非ADL的情况下，只会在模板定义的上下文寻找符号定义；</p>\n<p>下面的例子中，writeObject方法的模板参数类型并不是用户命名空间中定义的，因此对应非ADL场景，只会在模板定义上下文寻找 operator &lt;&lt; (std::ostream&amp; os, std::vector<int>&amp;) 符号的定义，不会去用户命名空间中查找：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; an external library</span><br><span class=\"line\">namespace E &#123;</span><br><span class=\"line\">  template&lt;typename T&gt;</span><br><span class=\"line\">  void writeObject(const T&amp; t) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; &quot;Value &#x3D; &quot; &lt;&lt; t &lt;&lt; &#39;\\n&#39;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; translation unit 1:</span><br><span class=\"line\">&#x2F;&#x2F; Programmer 1 wants to allow E::writeObject to work with vector&lt;int&gt;</span><br><span class=\"line\">namespace P1 &#123;</span><br><span class=\"line\">  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v) &#123;</span><br><span class=\"line\">      for(int n: v) os &lt;&lt; n &lt;&lt; &#39; &#39;; return os;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void doSomething() &#123;</span><br><span class=\"line\">    std::vector&lt;int&gt; v;</span><br><span class=\"line\">    E::writeObject(v); &#x2F;&#x2F; error: will not find P1::operator&lt;&lt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; translation unit 2:</span><br><span class=\"line\">&#x2F;&#x2F; Programmer 2 wants to allow E::writeObject to work with vector&lt;int&gt;</span><br><span class=\"line\">namespace P2 &#123;</span><br><span class=\"line\">  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v) &#123;</span><br><span class=\"line\">      for(int n: v) os &lt;&lt; n &lt;&lt;&#39;:&#39;; return os &lt;&lt; &quot;[]&quot;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void doSomethingElse() &#123;</span><br><span class=\"line\">    std::vector&lt;int&gt; v;</span><br><span class=\"line\">    E::writeObject(v); &#x2F;&#x2F; error: will not find P2::operator&lt;&lt;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"ADL\"><a href=\"#ADL\" class=\"headerlink\" title=\"ADL\"></a>ADL</h4><p>ADL的情况下，不仅会在模板定义的上下文，还会在模板实例化的上下文寻找符号定义；</p>\n<p>在下面的这个例子中，模板参数中包括用户命名空间P1中的C，因此对应着ADL场景，会在P1中寻找合适的函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace P1 &#123;</span><br><span class=\"line\">  &#x2F;&#x2F; if C is a class defined in the P1 namespace</span><br><span class=\"line\">  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;C&gt;&amp; v) &#123;</span><br><span class=\"line\">      for(C n: v) os &lt;&lt; n; return os;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  void doSomething() &#123;</span><br><span class=\"line\">    std::vector&lt;C&gt; v;</span><br><span class=\"line\">    E::writeObject(v); &#x2F;&#x2F; OK: instantiates writeObject(std::vector&lt;P1::C&gt;)</span><br><span class=\"line\">                       &#x2F;&#x2F;     which finds P1::operator&lt;&lt; via ADL</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"injected-class-name\"><a href=\"#injected-class-name\" class=\"headerlink\" title=\"injected-class-name\"></a>injected-class-name</h2><p><a href=\"https://zh.cppreference.com/w/cpp/language/injected-class-name\">https://zh.cppreference.com/w/cpp/language/injected-class-name</a></p>\n<h3 id=\"非模板情况\"><a href=\"#非模板情况\" class=\"headerlink\" title=\"非模板情况\"></a>非模板情况</h3><p>在类作用域中，可以直接使用当前类名来指代当前类，这个类名被称为“注入类名”，这个和当前类名相同的符号是在类定义一开始就被自动注入的，注入类名可以被继承，因此private继承可能导致父类的注入类名对子类不可见，此时只能通过使用父类namespace来显式地指代父类；</p>\n<h3 id=\"模板情况\"><a href=\"#模板情况\" class=\"headerlink\" title=\"模板情况\"></a>模板情况</h3><p>在模板类的作用域中，类名即可指代当前类，又可指代当前模板名称，需要多加分辨。</p>\n<h3 id=\"注入类名与构造函数\"><a href=\"#注入类名与构造函数\" class=\"headerlink\" title=\"注入类名与构造函数\"></a>注入类名与构造函数</h3><p>在类作用域中，注入类名被当作构造函数的名称，由此引入了一个需要注意的规则：</p>\n<p>在限定名C::D解析过程中，如果D是C作用域中的注入类名，且编译器认为C::D可能是一个函数，那么该限定名一定会被解析成构造函数：</p>\n<p>不过事实上，只有当D和C同名时，C才会是D作用域的注入类名，毕竟对于D作用域而言，唯一的注入类名就是D了。。也就是说，C::D规则其实就是C::C规则，当然，标准里面的表述方式逻辑上也没毛病，就是理解起来差点意思。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct A &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 在A的作用域开始处，编译器会注入符号A作为注入类名</span><br><span class=\"line\">    A();</span><br><span class=\"line\">    A(int);</span><br><span class=\"line\">    template&lt;class T&gt; A(T) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">using A_alias &#x3D; A;</span><br><span class=\"line\"> </span><br><span class=\"line\">A::A() &#123;&#125;</span><br><span class=\"line\">A_alias::A(int) &#123;&#125;</span><br><span class=\"line\">template A::A(double);</span><br><span class=\"line\"> </span><br><span class=\"line\">struct B : A &#123;</span><br><span class=\"line\">    using A_alias::A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">&#x2F;&#x2F; 编译器认为A::A可能是一个函数，并且在A的作用域中查找到了注入类名A，于是将A::A解释为指代构造函数</span><br><span class=\"line\">A::A a; &#x2F;&#x2F; 错误：A::A 被认为指名构造函数，而非类型</span><br><span class=\"line\">&#x2F;&#x2F; 明确指出A::A是一个struct，编译器不会尝试将A::A解释为构造函数</span><br><span class=\"line\">struct A::A a2; &#x2F;&#x2F; OK：与 &#39;A a2;&#39; 相同</span><br><span class=\"line\">&#x2F;&#x2F; B的声明作用域中没有注入类名A，编译器不会将B::A解释为构造函数引用</span><br><span class=\"line\">B::A b; &#x2F;&#x2F; OK：与 &#39;A b;&#39; 相同</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"函数相关\"><a href=\"#函数相关\" class=\"headerlink\" title=\"函数相关\"></a>函数相关</h1><h2 id=\"ADL-Argument-dependent-lookup\"><a href=\"#ADL-Argument-dependent-lookup\" class=\"headerlink\" title=\"ADL - Argument-dependent lookup\"></a>ADL - Argument-dependent lookup</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/adl\">https://en.cppreference.com/w/cpp/language/adl</a></p>\n<p>在编写函数调用（包括操作符函数）语句时，如果函数没有限定符并且在当前环境下找不到定义，编译器根据函数参数的限定符去推测函数限定符的行为。</p>\n<h1 id=\"异常相关\"><a href=\"#异常相关\" class=\"headerlink\" title=\"异常相关\"></a>异常相关</h1><h2 id=\"Function-try-block\"><a href=\"#Function-try-block\" class=\"headerlink\" title=\"Function-try-block\"></a>Function-try-block</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/function-try-block\">https://en.cppreference.com/w/cpp/language/function-try-block</a></p>\n<h1 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h1><h2 id=\"ODR-One-Definition-Rule\"><a href=\"#ODR-One-Definition-Rule\" class=\"headerlink\" title=\"ODR - One Definition Rule\"></a>ODR - One Definition Rule</h2><p><a href=\"https://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule\">https://en.cppreference.com/w/cpp/language/definition#One_Definition_Rule</a></p>\n<p>一个符号可以被多次声明，但只能定义一次。</p>\n<h2 id=\"ill-formed\"><a href=\"#ill-formed\" class=\"headerlink\" title=\"ill-formed\"></a>ill-formed</h2><p>非良构。当文档中提及ill-formed时，指的是一个遵从标准的C++编译器应该识别这种情况并给出明显提示。</p>\n<h1 id=\"名字查找\"><a href=\"#名字查找\" class=\"headerlink\" title=\"名字查找\"></a>名字查找</h1><p>为了编译std::cout &lt;&lt; std::endl，编译器进行了：</p>\n<ul>\n<li>名字 <code>std</code> 的<strong>无限定</strong>的名字查找，找到了头文件 <code>&lt;iostream&gt;</code> 中的命名空间 std 的声明</li>\n<li>名字 <code>cout</code> 的<strong>有限定</strong>的名字查找，找到了命名空间 <code>std</code> 中的一个变量声明</li>\n<li>名字 <code>endl</code> 的有限定的名字查找，找到了命名空间 <code>std</code> 中的一个函数模板声明</li>\n<li>名字 <code>operator &lt;&lt;</code> 的两个<a href=\"https://zh.cppreference.com/w/cpp/language/adl\"><strong>实参依赖查找</strong></a>找到命名空间 <code>std</code> 中的多个函数模板声明，而名字 <code>std::ostream::operator&lt;&lt;</code> 的<strong>有限定名字查找</strong>找到声明于类 <code>std::ostream</code> 中的多个成员函数</li>\n</ul>\n<p>对于函数和函数模板的名字，名字查找可以将同一个名字和多个声明联系起来，而且可能从<a href=\"https://zh.cppreference.com/w/cpp/language/adl\">实参依赖查找</a>中得到额外的声明。还会进行<a href=\"https://zh.cppreference.com/w/cpp/language/function_template\">模板实参推导</a>，并将声明的集合交给<a href=\"https://zh.cppreference.com/w/cpp/language/overload_resolution\">重载决议</a>，由它选择所要使用的那个声明。如果适用的话，<a href=\"https://zh.cppreference.com/w/cpp/language/access\">成员访问</a>的规则只会在名字查找和重载解析之后才被考虑。</p>\n<h2 id=\"有限定的名字查找\"><a href=\"#有限定的名字查找\" class=\"headerlink\" title=\"有限定的名字查找\"></a>有限定的名字查找</h2><p><em>限定</em>名，是出现在作用域解析操作符 <code>**::**</code> 右边的名字（参阅<a href=\"https://zh.cppreference.com/w/cpp/language/identifiers#.E6.9C.89.E9.99.90.E5.AE.9A.E7.9A.84.E6.A0.87.E8.AF.86.E7.AC.A6\">有限定的标识符</a>）。 限定名可能代表的是：</p>\n<ul>\n<li>类的成员（包括静态和非静态函数、类型和模板等）</li>\n<li>命名空间的成员（包括其它的命名空间）</li>\n<li>枚举项</li>\n</ul>\n<p>若 <code>**::**</code> 左边为空，则查找过程仅会考虑全局命名空间作用域中作出（或通过 <a href=\"https://zh.cppreference.com/w/cpp/language/namespace\">using 声明</a>引入到全局命名空间中）的声明。这样一来，即使局部声明隐藏了该名字，也能够访问它。</p>\n<p>在能对 <code>**::**</code> 右边的名字进行名字查找之前，必须完成对其左边的名字的查找（除非左边所用的是 <a href=\"https://zh.cppreference.com/w/cpp/language/decltype\">decltype</a> 表达式或左边为空）。对左边的名字所进行的查找，根据这个名字左边是否有另一个 <code>**::**</code> 可以是有限定或无限定的，但其仅考虑命名空间、类类型、枚举和能特化为类型的模板（这一句话的意思参考下面的例子）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct A &#123;</span><br><span class=\"line\">  static int n;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  int A;</span><br><span class=\"line\">  A::n &#x3D; 42;    &#x2F;&#x2F; 正确：对 :: 左边的 A 的无限定查找忽略变量。因为A在当前作用域中不是类型</span><br><span class=\"line\">  A b;          &#x2F;&#x2F; 错误：对 A 的无限定查找找到了变量 A</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>若 <code>**::**</code> 后跟字符 <code>**~**</code> 再跟着一个标识符（也就是说指定了析构函数或伪析构函数），那么该标识符将在 <code>**::**</code> 左边的名字相同的作用域中查找。下面的例子可以让你喝一壶：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct C &#123; typedef int I; &#125;;</span><br><span class=\"line\">typedef int I1, I2;</span><br><span class=\"line\">extern int *p, *q;</span><br><span class=\"line\">struct A &#123; ~A(); &#125;;</span><br><span class=\"line\">typedef A AB;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">  p-&gt;C::I::~I(); &#x2F;&#x2F; ~ 之后的名字 I 在 :: 前面的 I 的同一个作用域中查找</span><br><span class=\"line\">                 &#x2F;&#x2F;（也就是说，在 C 的作用域中查找，因此查找结果是 C::I ）</span><br><span class=\"line\">  q-&gt;I1::~I2();  &#x2F;&#x2F; 名字 I2 在 I1 的同一个作用域中查找，</span><br><span class=\"line\">                 &#x2F;&#x2F; 也就是说从当前的作用域中查找，因此查找结果是 ::I2</span><br><span class=\"line\">  AB x;</span><br><span class=\"line\">  x.AB::~AB(); &#x2F;&#x2F; ~ 之后的名字 AB 在 :: 前面的 AB 的同一个作用域中查找</span><br><span class=\"line\">               &#x2F;&#x2F; 也就是说从当前的作用域中查找，因此查找结果是 ::AB</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h4 id=\"枚举项\"><a href=\"#枚举项\" class=\"headerlink\" title=\"枚举项\"></a>枚举项</h4><p>若对左边的名字的查找结果是<a href=\"https://zh.cppreference.com/w/cpp/language/enum\">枚举</a>（无论是有作用域还是无作用域），右边名字的查找结果必须是属于该枚举的一个枚举项，否则程序非良构。</p>\n<h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h4><h4 id=\"类成员\"><a href=\"#类成员\" class=\"headerlink\" title=\"类成员\"></a>类成员</h4><p>若对左边的名字的查找结果是某个类、结构体或联合体的名字，则 <code>**::**</code> 右边的名字在该类、结构体或联合体的作用域中进行查找（因此可能找到该类或其基类的成员的声明），但有以下例外情况：</p>\n<ul>\n<li>析构函数按如上所述进行查找（即在 :: 左边的名字的作用域中查找）</li>\n<li><a href=\"https://zh.cppreference.com/w/cpp/language/cast_operator\">用户定义转换</a>函数名中的转换类型标识（ conversion-type-id ），首先在该类类型的作用域中查找。若未找到，则在当前作用域中查找该名字。</li>\n<li>模板实参中使用的名字，在当前作用域中查找（而非在模板名的作用域中查找）</li>\n<li><a href=\"https://zh.cppreference.com/w/cpp/language/namespace\">using 声明</a>中的名字，还考虑在当前作用域中声明的变量、数据成员、函数或枚举项所隐藏的类或枚举名</li>\n</ul>\n<p>若 <code>**::**</code> 右边所指名的是和其左边相同的类，则右边的名字表示的是该类的<a href=\"https://zh.cppreference.com/w/cpp/language/constructor\">构造函数</a>。这种限定名仅能用在构造函数的声明以及引入<a href=\"https://zh.cppreference.com/w/cpp/language/using_declaration#.E7.BB.A7.E6.89.BF.E6.9E.84.E9.80.A0.E5.87.BD.E6.95.B0\">继承构造函数</a>的 <a href=\"https://zh.cppreference.com/w/cpp/language/using_declaration\">using 声明</a>中。在所有忽略函数名的查找过程中（即在查找 <code>**::**</code> 左边的名字，或查找<a href=\"https://zh.cppreference.com/w/cpp/language/elaborated_type_specifier\">详述类型说明符</a>或<a href=\"https://zh.cppreference.com/w/cpp/language/derived_class\">基类说明符</a>中的名字时），则将同样的语法解释成<strong>注入类名（ injected-class-name ）</strong>：struct A::A a2; a2类型就是struct A。</p>\n<p>有限定名字查找可用来访问被嵌套声明或被派生类隐藏了的类成员。对有限定的成员函数的调用将不再是<strong>虚调用</strong>。</p>\n<h4 id=\"命名空间的成员\"><a href=\"#命名空间的成员\" class=\"headerlink\" title=\"命名空间的成员\"></a>命名空间的成员</h4><p>若 <code>**::**</code> 左边的名字代表的是命名空间，或者 <code>**::**</code> 左边为空（这种情况其代表全局命名空间），那么 <code>**::**</code> 右边的名字就在这个命名空间的作用域中进行查找，但有以下例外：</p>\n<ul>\n<li>在模板实参中使用的名字在当前作用域中查找</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace N &#123;</span><br><span class=\"line\">   template&lt;typename T&gt; struct foo &#123;&#125;;</span><br><span class=\"line\">   struct X &#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">N::foo&lt;X&gt; x; &#x2F;&#x2F; 错误：X 查找结果为 ::X 而不是 N::X</span><br></pre></td></tr></table></figure>\n\n\n<p>在<a href=\"https://zh.cppreference.com/w/cpp/language/namespace\">命名空间</a> <code>N</code> 中进行有限定查找时，首先要考虑处于 <code>N</code> 之中的<strong>所有声明</strong>，以及处于 <code>N</code> 的<a href=\"https://zh.cppreference.com/w/cpp/language/namespace#.E5.86.85.E8.81.94.E5.91.BD.E5.90.8D.E7.A9.BA.E9.97.B4\">内联命名空间成员</a>（并且传递性地包括它们的内联命名空间成员）之中的<strong>所有声明</strong>。如果这个集合中没有找到任何声明，则再考虑在 <code>N</code> 和 <code>N</code> 的所有传递性的内联命名空间成员中发现的<strong>所有</strong><a href=\"https://zh.cppreference.com/w/cpp/language/namespace#using_.E6.8C.87.E4.BB.A4\"><strong>using 指令</strong></a><strong>所指名的命名空间之中的声明</strong>。这条规则是递归实施的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int x;</span><br><span class=\"line\">namespace Y &#123;</span><br><span class=\"line\">  void f(float);</span><br><span class=\"line\">  void h(int);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace Z &#123;</span><br><span class=\"line\">  void h(double);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace A &#123;</span><br><span class=\"line\">  using namespace Y;</span><br><span class=\"line\">  void f(int);</span><br><span class=\"line\">  void g(int);</span><br><span class=\"line\">  int i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace B &#123;</span><br><span class=\"line\">  using namespace Z;</span><br><span class=\"line\">  void f(char);</span><br><span class=\"line\">  int i;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">namespace AB &#123;</span><br><span class=\"line\">  using namespace A;</span><br><span class=\"line\">  using namespace B;</span><br><span class=\"line\">  void g();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void h()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  AB::g();  &#x2F;&#x2F; 在 AB 中查找，找到了 AB::g 并且选择了 AB::g(void)</span><br><span class=\"line\">            &#x2F;&#x2F; （并未在 A 和 B 中查找）</span><br><span class=\"line\">  AB::f(1); &#x2F;&#x2F; 首先在 AB 中查找，未能找到 f</span><br><span class=\"line\">            &#x2F;&#x2F; 然后再在 A 和 B 中查找</span><br><span class=\"line\">            &#x2F;&#x2F; 找到了 A::f 和 B::f（但并未在 Y 中查找，因而不考虑 Y::f）</span><br><span class=\"line\">            &#x2F;&#x2F; 重载解析选中 A::f(int)</span><br><span class=\"line\">  AB::x++;    &#x2F;&#x2F; 首先在 AB 中查找，未能找到 x</span><br><span class=\"line\">              &#x2F;&#x2F; 然后再在 A 和 B 中查找。未能找到 x</span><br><span class=\"line\">              &#x2F;&#x2F; 然后再在 X 和 Y 中查找。还是没有 x：这是一个错误</span><br><span class=\"line\">  AB::i++;  &#x2F;&#x2F; 在 AB 中查找，未能找到 i</span><br><span class=\"line\">            &#x2F;&#x2F; 然后再在 A 和 B 中查找。找到了 A::i 和 B::i：这是一个错误</span><br><span class=\"line\">  AB::h(16.8);  &#x2F;&#x2F; 首先在 AB 中查找：未能找到 h</span><br><span class=\"line\">                &#x2F;&#x2F; 然后再在 A 和 B 中查找。未能找到 h</span><br><span class=\"line\">                &#x2F;&#x2F; 然后再在 X 和 Y 中查找。</span><br><span class=\"line\">                &#x2F;&#x2F; 找到了 Y::h 和 Z::h。重载解析选中 Z::h(double)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>上面的例子中多次定义同一个符号是违法的，但是同一个声明允许被多次找到：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace A &#123; int a; &#125;</span><br><span class=\"line\">namespace B &#123; using namespace A; &#125;</span><br><span class=\"line\">namespace D &#123; using A::a; &#125;</span><br><span class=\"line\">namespace BD &#123;</span><br><span class=\"line\">  using namespace B;</span><br><span class=\"line\">  using namespace D;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void g()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  BD::a++; &#x2F;&#x2F; OK ： 通过 B 和 D 找到同一个 A::a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"无限定的名字查找\"><a href=\"#无限定的名字查找\" class=\"headerlink\" title=\"无限定的名字查找\"></a>无限定的名字查找</h2><h2 id=\"最内层的外围命名空间\"><a href=\"#最内层的外围命名空间\" class=\"headerlink\" title=\"最内层的外围命名空间\"></a>最内层的外围命名空间</h2><p>这是英文原文：innermost enclosing namespace 的标准中文表述。</p>\n<p>这种表述出现在对友元引入的名字的查找中：</p>\n<p>若所查找的是由<a href=\"https://zh.cppreference.com/w/cpp/language/friend\">友元</a>声明所引入的名字：这种情况下仅考虑其最内层的外围命名空间，否则的话，对外围命名空间的查找将照常持续直到全局作用域。</p>\n<p>指的是，如果通过friend引入了名字A，当使用A::a时，只会在A所限定的名字空间中查找a，该查找过程不会扩展到A所处的名字空间，这样的一个严格限定的名字空间就叫做a的最内层的外围名字空间（innermost enclosing namespace）。</p>\n"},{"title":"C++ Struct的使用","date":"2020-12-31T15:59:00.000Z","abbrlink":13002,"cover":"img/cpp.png","_content":"# C++ Struct的使用\n\n## C++中的结构体\n\n在C语言中，结构体不能包含函数。\n\n在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。\n\nC语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展,C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而class中默认是private。\n\nC++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。\n\nstruct能包含成员函数吗？   能！\n\nstruct能继承吗？          能！！\n\nstruct能实现多态吗？       能！！！\n\n## 结构体的定义与声明\n\n实例代码1：\n\n```c++\nstruct tag \n{\n    member-list;\n}variable-list;\n\n/*\n注：struct为结构体关键字；\n   tag为结构体的标志；\n   member-list为结构体成员变量及成员函数列表，其必须列出其所有成员；\n   variable-list为此结构体声明的变量；\n*/\n```\n\n实例代码2：\n\n```cpp\n#include <iostream> \n\nusing namespace std;\n\nstruct SAMPLE\n{\n    int x;\n    int y;\n    int add() {return x+y;}\n}s1;\n\nint main()\n{\n    cout<<\"没初始化成员变量的情况下：\"<<s1.add()<<endl;\n    s1.x = 3;\n    s1.y = 4;\n    cout<<\"初始化成员变量的情况下：\"<<s1.add()<<endl;\n    system(\"pause\");\n    return 0;\n}\n\n/*\n=>没初始化成员变量的情况下：0\n  初始化成员变量的情况下：7\n*/\n```\n\nC++中的结构体与类的区别： \n\n(1)class中默认的成员访问权限是private的，而struct中则是public的。 \n\n(2)class继承默认是private继承，而从struct继承默认是public继承。\n\nC++中的结构体与类的区别： \n\n(1)class中默认的成员访问权限是private的，而struct中则是public的。\n\n (2)class继承默认是private继承，而从struct继承默认是public继承。\n\n结构体也可以继承结构体或者类。\n\n**关于使用大括号初始化**\n　　class和struct如果定义了构造函数的话，都不能用大括号进行初始化\n　　如果没有定义构造函数，struct可以用大括号初始化。\n　　如果没有定义构造函数，且所有成员变量全是public的话，可以用大括号初始化。\n\n**关于模版**\n　　在模版中，类型参数前面可以使用class或typename，如果使用struct，则含义不同，struct后面跟的是“non-type template parameter”，而class或typename后面跟的是类型参数。\n\n**关于默认访问权限**\n　　class中默认的成员访问权限是private的，而struct中则是public的。\n\n## 结构体的作用\n\n在实际项目中，结构体是大量存在的。研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言内部程序比较简单，研发人员通常使用结构体创造新的“属性”，其目的是简化运算。\n结构体在函数中的作用不是简便，最主要的作用就是封装。封装的好处就是可以再次利用。让使用者不必关心这个是什么，只要根据定义使用就可以了。","source":"_posts/cplus_md/CPlus Basic/C++ Struct的使用.md","raw":"---\ntitle: C++ Struct的使用\ndate: '2020/12/31 23:59'\ntags:\n - cpp\ncategories:\n - 使用教程\nabbrlink: 13002\ncover: img/cpp.png\n---\n# C++ Struct的使用\n\n## C++中的结构体\n\n在C语言中，结构体不能包含函数。\n\n在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。\n\nC语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展,C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而class中默认是private。\n\nC++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。\n\nstruct能包含成员函数吗？   能！\n\nstruct能继承吗？          能！！\n\nstruct能实现多态吗？       能！！！\n\n## 结构体的定义与声明\n\n实例代码1：\n\n```c++\nstruct tag \n{\n    member-list;\n}variable-list;\n\n/*\n注：struct为结构体关键字；\n   tag为结构体的标志；\n   member-list为结构体成员变量及成员函数列表，其必须列出其所有成员；\n   variable-list为此结构体声明的变量；\n*/\n```\n\n实例代码2：\n\n```cpp\n#include <iostream> \n\nusing namespace std;\n\nstruct SAMPLE\n{\n    int x;\n    int y;\n    int add() {return x+y;}\n}s1;\n\nint main()\n{\n    cout<<\"没初始化成员变量的情况下：\"<<s1.add()<<endl;\n    s1.x = 3;\n    s1.y = 4;\n    cout<<\"初始化成员变量的情况下：\"<<s1.add()<<endl;\n    system(\"pause\");\n    return 0;\n}\n\n/*\n=>没初始化成员变量的情况下：0\n  初始化成员变量的情况下：7\n*/\n```\n\nC++中的结构体与类的区别： \n\n(1)class中默认的成员访问权限是private的，而struct中则是public的。 \n\n(2)class继承默认是private继承，而从struct继承默认是public继承。\n\nC++中的结构体与类的区别： \n\n(1)class中默认的成员访问权限是private的，而struct中则是public的。\n\n (2)class继承默认是private继承，而从struct继承默认是public继承。\n\n结构体也可以继承结构体或者类。\n\n**关于使用大括号初始化**\n　　class和struct如果定义了构造函数的话，都不能用大括号进行初始化\n　　如果没有定义构造函数，struct可以用大括号初始化。\n　　如果没有定义构造函数，且所有成员变量全是public的话，可以用大括号初始化。\n\n**关于模版**\n　　在模版中，类型参数前面可以使用class或typename，如果使用struct，则含义不同，struct后面跟的是“non-type template parameter”，而class或typename后面跟的是类型参数。\n\n**关于默认访问权限**\n　　class中默认的成员访问权限是private的，而struct中则是public的。\n\n## 结构体的作用\n\n在实际项目中，结构体是大量存在的。研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言内部程序比较简单，研发人员通常使用结构体创造新的“属性”，其目的是简化运算。\n结构体在函数中的作用不是简便，最主要的作用就是封装。封装的好处就是可以再次利用。让使用者不必关心这个是什么，只要根据定义使用就可以了。","slug":"cplus_md/CPlus Basic/C++ Struct的使用","published":1,"updated":"2021-04-09T14:06:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6d0046w9q91vck25vy","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"C-Struct的使用\"><a href=\"#C-Struct的使用\" class=\"headerlink\" title=\"C++ Struct的使用\"></a>C++ Struct的使用</h1><h2 id=\"C-中的结构体\"><a href=\"#C-中的结构体\" class=\"headerlink\" title=\"C++中的结构体\"></a>C++中的结构体</h2><p>在C语言中，结构体不能包含函数。</p>\n<p>在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。</p>\n<p>C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展,C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而class中默认是private。</p>\n<p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。</p>\n<p>struct能包含成员函数吗？   能！</p>\n<p>struct能继承吗？          能！！</p>\n<p>struct能实现多态吗？       能！！！</p>\n<h2 id=\"结构体的定义与声明\"><a href=\"#结构体的定义与声明\" class=\"headerlink\" title=\"结构体的定义与声明\"></a>结构体的定义与声明</h2><p>实例代码1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    member-<span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;variable-<span class=\"built_in\">list</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">注：struct为结构体关键字；</span></span><br><span class=\"line\"><span class=\"comment\">   tag为结构体的标志；</span></span><br><span class=\"line\"><span class=\"comment\">   member-list为结构体成员变量及成员函数列表，其必须列出其所有成员；</span></span><br><span class=\"line\"><span class=\"comment\">   variable-list为此结构体声明的变量；</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>实例代码2：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt; </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SAMPLE</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> x+y;&#125;</span><br><span class=\"line\">&#125;s1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;没初始化成员变量的情况下：&quot;</span>&lt;&lt;s1.add()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    s1.x = <span class=\"number\">3</span>;</span><br><span class=\"line\">    s1.y = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;初始化成员变量的情况下：&quot;</span>&lt;&lt;s1.add()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    system(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">=&gt;没初始化成员变量的情况下：0</span></span><br><span class=\"line\"><span class=\"comment\">  初始化成员变量的情况下：7</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>C++中的结构体与类的区别： </p>\n<p>(1)class中默认的成员访问权限是private的，而struct中则是public的。 </p>\n<p>(2)class继承默认是private继承，而从struct继承默认是public继承。</p>\n<p>C++中的结构体与类的区别： </p>\n<p>(1)class中默认的成员访问权限是private的，而struct中则是public的。</p>\n<p> (2)class继承默认是private继承，而从struct继承默认是public继承。</p>\n<p>结构体也可以继承结构体或者类。</p>\n<p><strong>关于使用大括号初始化</strong><br>　　class和struct如果定义了构造函数的话，都不能用大括号进行初始化<br>　　如果没有定义构造函数，struct可以用大括号初始化。<br>　　如果没有定义构造函数，且所有成员变量全是public的话，可以用大括号初始化。</p>\n<p><strong>关于模版</strong><br>　　在模版中，类型参数前面可以使用class或typename，如果使用struct，则含义不同，struct后面跟的是“non-type template parameter”，而class或typename后面跟的是类型参数。</p>\n<p><strong>关于默认访问权限</strong><br>　　class中默认的成员访问权限是private的，而struct中则是public的。</p>\n<h2 id=\"结构体的作用\"><a href=\"#结构体的作用\" class=\"headerlink\" title=\"结构体的作用\"></a>结构体的作用</h2><p>在实际项目中，结构体是大量存在的。研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言内部程序比较简单，研发人员通常使用结构体创造新的“属性”，其目的是简化运算。<br>结构体在函数中的作用不是简便，最主要的作用就是封装。封装的好处就是可以再次利用。让使用者不必关心这个是什么，只要根据定义使用就可以了。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"C-Struct的使用\"><a href=\"#C-Struct的使用\" class=\"headerlink\" title=\"C++ Struct的使用\"></a>C++ Struct的使用</h1><h2 id=\"C-中的结构体\"><a href=\"#C-中的结构体\" class=\"headerlink\" title=\"C++中的结构体\"></a>C++中的结构体</h2><p>在C语言中，结构体不能包含函数。</p>\n<p>在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。</p>\n<p>C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展,C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而class中默认是private。</p>\n<p>C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。</p>\n<p>struct能包含成员函数吗？   能！</p>\n<p>struct能继承吗？          能！！</p>\n<p>struct能实现多态吗？       能！！！</p>\n<h2 id=\"结构体的定义与声明\"><a href=\"#结构体的定义与声明\" class=\"headerlink\" title=\"结构体的定义与声明\"></a>结构体的定义与声明</h2><p>实例代码1：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tag</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    member-<span class=\"built_in\">list</span>;</span><br><span class=\"line\">&#125;variable-<span class=\"built_in\">list</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">注：struct为结构体关键字；</span></span><br><span class=\"line\"><span class=\"comment\">   tag为结构体的标志；</span></span><br><span class=\"line\"><span class=\"comment\">   member-list为结构体成员变量及成员函数列表，其必须列出其所有成员；</span></span><br><span class=\"line\"><span class=\"comment\">   variable-list为此结构体声明的变量；</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>实例代码2：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt; </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SAMPLE</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> y;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">add</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> x+y;&#125;</span><br><span class=\"line\">&#125;s1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;没初始化成员变量的情况下：&quot;</span>&lt;&lt;s1.add()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    s1.x = <span class=\"number\">3</span>;</span><br><span class=\"line\">    s1.y = <span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">&quot;初始化成员变量的情况下：&quot;</span>&lt;&lt;s1.add()&lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    system(<span class=\"string\">&quot;pause&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">=&gt;没初始化成员变量的情况下：0</span></span><br><span class=\"line\"><span class=\"comment\">  初始化成员变量的情况下：7</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>C++中的结构体与类的区别： </p>\n<p>(1)class中默认的成员访问权限是private的，而struct中则是public的。 </p>\n<p>(2)class继承默认是private继承，而从struct继承默认是public继承。</p>\n<p>C++中的结构体与类的区别： </p>\n<p>(1)class中默认的成员访问权限是private的，而struct中则是public的。</p>\n<p> (2)class继承默认是private继承，而从struct继承默认是public继承。</p>\n<p>结构体也可以继承结构体或者类。</p>\n<p><strong>关于使用大括号初始化</strong><br>　　class和struct如果定义了构造函数的话，都不能用大括号进行初始化<br>　　如果没有定义构造函数，struct可以用大括号初始化。<br>　　如果没有定义构造函数，且所有成员变量全是public的话，可以用大括号初始化。</p>\n<p><strong>关于模版</strong><br>　　在模版中，类型参数前面可以使用class或typename，如果使用struct，则含义不同，struct后面跟的是“non-type template parameter”，而class或typename后面跟的是类型参数。</p>\n<p><strong>关于默认访问权限</strong><br>　　class中默认的成员访问权限是private的，而struct中则是public的。</p>\n<h2 id=\"结构体的作用\"><a href=\"#结构体的作用\" class=\"headerlink\" title=\"结构体的作用\"></a>结构体的作用</h2><p>在实际项目中，结构体是大量存在的。研发人员常使用结构体来封装一些属性来组成新的类型。由于C语言内部程序比较简单，研发人员通常使用结构体创造新的“属性”，其目的是简化运算。<br>结构体在函数中的作用不是简便，最主要的作用就是封装。封装的好处就是可以再次利用。让使用者不必关心这个是什么，只要根据定义使用就可以了。</p>\n"},{"title":"学习C++ - 艰难的熟悉过程","date":"2020-12-31T15:59:00.000Z","abbrlink":13005,"cover":"img/cpp.png","_content":"**学习C++ - 艰难的熟悉过程**\n\n# using声明\n\nhttps://en.cppreference.com/w/cpp/language/using_declaration\n\n自C++11开始，除了可以使用using引入命名空间所有符号外，还可以使用using来定义类型别名，以及使用using为子类引入父类定义的函数，**包括构造函数**；\n\n\n\n昨天晚上读React-Native源码时，发现调用了一个类的构造函数，但是并没有找到这个构造函数的定义在哪里，找了很久才发现看漏了一行using，原来子类是通过using将父类的构造函数全部引入了进来。\n\n\n\n如果子类使用using引入父类构造函数会有一些需要注意的点，第一个是引入时，会将父类的所有构造函数一次性的全部引入到子类，如果子类中新定义的所有成员都能进行隐式的初始化，那就可以直接使用using引入的父类构造函数方法来实例化子类实例了。\n\n如果子类自己定义了函数，并且签名和using引入的函数的签名一样，那么using引入的函数会被隐藏。\n\n例如：\n\n\n\n```\nstruct B1 {  B1(int, ...) { } };\nstruct B2 {  B2(double)   { } };\n \nint get();\n \nstruct D1 : B1 {\n  using B1::B1;  // inherits B1(int, ...)\n  int x;\n  int y = get();\n};\n \nvoid test() {\n  D1 d(2, 3, 4); // OK: B1 is initialized by calling B1(2, 3, 4),\n                 // then d.x is default-initialized (no initialization is performed),\n                 // then d.y is initialized by calling get()\n  D1 e;          // Error: D1 has no default constructor\n}\n \nstruct D2 : B2 {\n  using B2::B2; // inherits B2(double)\n  B1 b; // unable to implicitly initialize b, parent constructor can't be used\n};\n \nD2 f(1.0);       // error: B1 has no default constructor\n```\n\n\n\n\n\n# in-class initialization\n\n在C++03中，禁止在struct或class定义中为成员指定默认值，只能使用initialization-list进行指定，但从C++11开始，允许在定义时为成员指定默认值了。指定默认值时，可以使用=，也可以使用C++11新提供的initializer-list初始化列表语法。（注意上面的表述中有一个例外：大多数编译器一直允许为static const整型成员指定默认值。）\n\n如果同时使用了列表初始化和就地初始化，编译器需要保证最终列表初始化覆盖就地初始化。\n\n\n\n# 静态成员变量定义\n\n静态成员变量在类的头文件中声明，但必须在实现文件中定义，因为一个符号只能被定义一次，如果将定义放在头文件中，一旦任意两个文件引用了这个头文件，那么该静态变量就会被定义两次，导致链接错误。\n\n\n\n# C++陷阱\n\n在函数调用语法中，C++没有明确规定各个参数表达式的求值顺序，这可能会导致问题：\n\n\n\n```\n// dont do this\ncallSomeMethod(new std::shared_ptr<Widget>(new Widget), methodMayThrow());\n\n// this is ok\nstd::shared_ptr<Widget> widgetPtr = new std::shared_ptr<Widget>(new Widget);\ncallSomeMethod(widgetPtr, methodMayThrow());\n```\n\n\n\n如果上面的函数调用中，如果new Widget先被执行了，然后methodMayThrow被执行，最后才轮到shared_ptr的构造，那么一旦methodMayThrow抛出了异常，new Widget占用的资源就永远得不到清理。\n\n为什么C++不对这种场景进行明确的规定？因为C++的设计哲学中，更多的考虑的是效率、语言能力，规范制定得往往较为宽松，留给编译器实现者充足的优化空间，易用性并不在其中，开发者必须自己识别出代码中的缺陷并加以规避，因此C++是一门初学者很难上手，但在专家手中非常好用的语言。\n\n\n\n# 方法调用的习惯\n\n方法参数应该尽量声明成const reference，而不是value，避免不必要的拷贝构造函数调用；\n\n但是，需要返回新创建的值时，直接返回value一般没什么问题，因为编译器有RVO。\n\n\n\n# 命名空间与名字查找(argument-dependent-lookup)\n\n在函数调用发生时，C++规定编译器应该尝试去参数类型所处的命名空间中查找函数，这使得如下的程序能够通过编译：\n\n\n\n```\nnamespace MyNameSpace {\n    template <typename T>\n    class MyClass {...};\n    \n    template <typename T>\n    void swap(MyClass<T>& lhv, MyClass<T>& rhv) {...}\n}\n\n// 初始化myClass1, myClass2\n// 以下语句可以被编译，相当于MyNameSpace::swap(myClass1, myClass2);\nswap(myClass1, myClass2);\n```\n\n\n\nC++标准规定std命名空间内的template可以被客户全特化，但是禁止添加任何新的template、function、class到std命名空间中去，这意味着我们可以全特化std命名空间中的swap，但是却不能在std中声明一个新的swap模板方法：\n\n\n\n```\nnamespace std {\n    // ok\n    void swap(Widget<MyClass>& a, Widget<MyClass>& b) {...};   \n    // 下面这个是标准禁止的\n    template <typename T>\n    void swap(Widget<T>& a, Widget<T>& b) {...};\n}\n```\n\n\n\nC++的这种特殊的名字查找规则规定：在查找函数名字时，应先在参数类型所处作用域中查找，在模板编程中为了能够在模板类型定义了自己的swap时，使用模板类型自己的swap，并在其他情况下使用std的标准swap，可以这样写：\n\n\n\n```\ntemplate <typename T>\nvoid myFunction(T& a, T& b) {\n    using std::swap;\n    // 如果T所处的命名空间内有合适的swap函数，会优先使用；否则，才会使用上面引入的std命名空间的swap\n    swap(a, b);\n}\n```\n\n\n\n# 降低编译依存关系\n\nC++库通常会提供给用户一个头文件，头文件详细描述了库所提供的功能，同时不透露任何实现细节。这可以确保用户只依赖库提供的对外头文件，而不用依赖任何实现的细节。\n\n通常，这是由如下的技术实现的：\n\n\n\n```\n// interface.h, 对外接口头文件\n// 前置声明\nclass MyInterfaceImpl;\nclass MyInterface {\npublic:\n    void a();\n    void b();\nprivate:\n    MyInterfaceImpl* impl;\n};\n\n// interface.cpp, 实现文件\nclass MyInterfaceImpl {\npublic:\n    void a();\n    void b();\n};\nvoid MyInterface::a() {\n    impl->a();\n}\n    \n```\n\n\n\n# CRTP\n\ncrtp指的是curiously recurring template pattern，奇异递归模板模式。\n\n维基百科指出，奇异递归模板模式让基类可以调用子类的非virtual方法，用这种模式即兼顾了运行效率，又获得了类似多态的表现；\n\n而Effective C++指出，如果每个子类都需要独享基类中定义的static成员变量，可以使基类成为一个template类，然后在继承基类时以子类作为模板类型参数实例化基类。\n\n\n\n# placement new\n\n通常，placement new指的是：当客户调用new (ptr) Widget时，会有一个特定版本的operator new就会被编译器调用（void* operator new(std::size_t, void*)）。上述形式的operator new被专门用来将Widget对象构造在addr指向的内存处，这件事是由编译器完成的，编译器中实际的placement new方法实现仅仅返回传入的地址即可。\n\n自定义类可以通过定义一个 static void* operator new(std::size_t, void*) 静态成员方法来替换编译器的默认实现。\n\n如果使用placement new来在指定的位置构造了一个对象，在需要销毁这个对象时一定要小心，明确能否直接使用delete释放所处内存，如果这片内存不应该在这个对象销毁时被释放，就需要仅调用对象的destroctor，而不可以直接使用delete。\n\n\n\n不过，placement new其实还有另外的意思，事实上C++标准允许我们在常规的operator new的std::size_t参数之后声明任意额外参数，只要在使用new关键字创建堆上对象时，通过括号传入兼容的参数即可（不过除了void*以外的额外参数没有编译器的默认实现）。通常大家在说placement new时，指的都是第一个意思。\n\n\n\n# Const重载\n\nC++中，被声明为const的成员函数和没有被声明为const的成员函数是两个同名的重载函数。\n\n当调用const对象的方法时，只有被const修饰的成员函数会被考虑；但是当调用没有const修饰的对象的方法时，会优先调用无const修饰的成员函数，如果没有找到，编译器会接着尝试调用有const修饰的成员函数。这非常合理，const是强保证，确保方法调用时不会修改对象上的任何属性，因此const对象只能调用const方法，对于非const对象，有无强保证都无所谓。一般来说，如果实现了const版本的成员函数，就不应该再实现一个非const版本的成员函数了。\n\n当函数的参数类型中有const时，top-level cv qualifiers都会被移除掉，因为函数参数是按值传递的，顶级cv qualifier没有意义，只有次级cv qualifier会被保留到函数签名中。\n\n什么是top-level cv qualifier？https://stackoverflow.com/questions/24676824/where-is-the-definition-of-top-level-cv-qualifiers-in-the-c11-standard\n\n\n\n# 异常\n\nC++的异常被抛出时，抛出的异常的类型是在编译时静态确定的，如果通过一个base&抛出一个实际类型是derived类型的异常，最终被抛出的异常类型不是derived，而是base；\n\n在确定被抛出的异常和哪个catch语句匹配时，C++不会尝试做隐式类型转换，只有两种转换是会自动尝试的：\n\n- 子类会与父类catch语句匹配，catch语句参数是by reference, by value, 还是by pointer（如果是by value，会有问题吗？会的，父类以外部分会被“切割”掉，这个对象将表现不出来子类特征）\n- 指针类型一定会和无类型指针类型的catch语句catch(void *)匹配\n\n即使catch语句中参数是by reference，被throw的异常对象也会被先拷贝一份，然后被引用的实际上是这个被拷贝的对象，它的生命期就是catch语句块；\n\n在catch语句块中，throw exception和throw是不同的，前者会导致被catch的exception被复制一份，而后者不会复制，直接将catch到的excepition抛出。\n\n\n\n# 继承\n\n## misc\n\n子类实现父类的虚函数时，其返回类型不必和父类虚函数声明完全一致，如果父类虚函数返回类型声明为一个基类的指针或者引用，那么子类可以将返回类型声明为基类的子类的指针或者引用。这样的宽松不会导致类型问题，毕竟一个父类的指针或者引用必然可以接收子类的指针或者引用，并且可以享受到多态性带来的便利。\n\n## More Effective C++\n\n在More Effective C++中，提到了virtual constructor，和virtual copy constructor，这种说法其实不太合适，virtual constructor就是一个普通函数，返回基类指针或引用，根据其参数确定实际返回的类型，factory就是典型的virtual constructor的应用；而virtual copy constructor指的是真正的virtual方法，该virtual方法负责通过copy constructor复制自身，相当于Java中的clone方法。\n\n类似的，还有virtual non member function也不是指一个真正的虚函数，而是指一种技巧：为了让一个类型的non member function表现出多态行为，需要在这个类型中定义一个虚函数并在这个虚函数中实现non member function的需求，然后再定义一个参数为指定类型的non member function，调用类提供的这个虚函数。\n\n\n\n# 智能指针\n\n说到智能指针，我们应该想到：构造和析构、复制和赋值、解引用。\n\n- 构造和析构、复制和赋值：如何实现构造函数和复制构造函数？如何实现赋值函数？如何实现析构函数？\n- 解引用：如何实现->和* operator函数？\n\n- - operator*应该返回被指向的真实对象引用（为什么是引用？当然是为了避免将你本来已经指向的对象再复制一份。。）；\n    - operator->应该返回一个定义了operator->方法的对象（如果调用a->hello()，其实会被解释成a.(operator->)->hello()，也就是说一个对象的operator->必须返回一个长得向指针的类型，然后编译器会对这个返回的类型调用后面的hello方法），对于智能指针来说就是应该返回指针本身。\n\n更加有经验的人除了上面的主题，还会想到：如何测试智能指针是否为null？能否判断智能指针是否存在，比如if (ptr) {...}？答案是前者通常要提供一个隐式转换操作符：operator void*，后者要求我们提供另一个隐式转换操作符：operator bool。\n\n\n\n# 数组引用\n\n数组也是有引用语法的。学习C和C++时，我们都学过数组作为函数调用的参数传递时，会被隐式转换成一个指针，但其实C++允许我们直接传递数组引用：\n\nvoid acceptArrayRef(const int (&arr)[10]) {...}\n\n这样，就声明并定义了一个能够接受长度为10的数组作为参数的函数。\n\n不过，作为一个现代的C++程序员，总是应该更倾向于stl容器，而不是原始数组。\n\n\n\n# 模板类型推导\n\n模板类型推导往往相当直接，比如：\n\n\n\n```\ntemplate <typename T>\nvoid test(Param p) {...}    \n// 当然上边的代码无法编译，因为Param是一个方便我们描述用的符号，实际表示的是T*, const T*等等，\n// 下面会讨论Param为不同的模板类型时，编译器如何处理\n```\n\n\n\n当我们调用test时，参数p的类型是什么，那么Param就会被推成什么，而T则是根据Param来推导的。这里面Param其实是一个由T构成的类型修饰，如const T，或者const T&，此时Param分别指的是const T整体和const T&整体的类型。\n\n\n\n果真如此吗？现在考虑三种情况：\n\n## Param是个引用或指针\n\n如果函数被声明为test(Param& p)或test(Param* p)，那么推导时，Param会保留p的cv限定符。也就是说，当p是一个const Widget*或者const Widget&时，Param成为const Widget。\n\n\n\n## Param是个万能引用\n\ntest(Param&& p)\n\n如果p是个左值，Param会被推导成左值引用；如果p是个右值，Param会被推导成右值引用。\n\n随后，根据引用合并规则，&&&被视作左值引用，而&&&&被视作右值引用。\n\ncv限定符会被保留。\n\n\n\n## Param不是引用或指针\n\n此时推导规则会对应按值传递。按值传递时，会发生拷贝构造，传递过来的值一定不是参数本身。\n\n当p是一个引用时，Param不会被推导成引用。\n\np的cv限定符会被忽略，因为p的副本和p不是同一个对象，不需要保留限定。\n\n\n\n## 当p是数组\n\n当p是数组时，如果Param是引用，那么Param会被推导成数组引用：如int (&)[10]这样的类型。\n\n而如果Param不是引用，那么Param一定会被推导成一个指针。\n\n可以利用这一点实现一个推导数组长度的编译时方法：\n\n\n\n```\ntemplate <typename T, std::size_t N>\nconstexpr std::size_t arraySize(T (&)[N]) noexcept {\n    return N;   \n}\n```\n\n\n\n## 当p是函数\n\n当p是函数，情况和数组很像，因为函数也是一个可以退化成指针，也可以被直接引用的类型。\n\n\n\n# 模板类型推导和auto\n\nauto类型推导的形式如下：\n\nconst auto& a = p;\n\n可以将const auto&这样的带修饰的类型看作上面模板里的Param，而将auto看作一个裸的类型T，如此，类型推导规则便和模板类型推导对得上了。\n\nauto类型推导仅有一处和模板不同：initializer-list。\n\nC++11增加了initializer-list语法，这使得我们可以使用四种方式初始化int：\n\nint x = 2;\n\nint x(2);\n\nint x = {27}; // C++11\n\nint x{27};   // C++11\n\n如果将上面的int以auto替换，那么有initializer-list的初始化方式会导致auto被推导为std::initializer_list。\n\n而如果为一个test(Param p)传入{27, 2, 3}这样的表达式，模板推导规则将无法推导出std::initializer_list。这是C++模板和auto推导规则的唯一不同之处。\n\n\n\n普通的函数不能将参数或返回值声明为auto，毕竟如果你需要auto，那么你可以使用模板函数。\n\n但是，如果要写lambda表达式，要想使用模板的语法来声明入参类型和返回值就太过麻烦了，毕竟lambda就是用来简化functor的编写的。此时C++规定可以在lambda中使用auto来起到模板函数中的Param及T的效果，但此时auto只是模板函数的一种简写，推导规则依然以模板为准，也就是说，initializer-list此时不受支持。\n\n\n\n# template typedef\n\n考虑你有一个模板：\n\nmap<Key, Value>\n\n如果你想要声明一个模板别名：\n\ntemplate <typename Value> using IntKeyMap = map<int, Value>;\n\n你会发现C++编译器阻止你这样做。这不是正确的C++语法。但是，为了达到我们的目的，可以这样做：\n\ntemplate <typename Value>\n\nstruct BindedIntMap {\n\nusing type = map<int, Value>;\n\n}\n\n然后，就可以通过BindedIntMap::type来表示前面我们想要的类型了。事实上这种做法在C++标准库中非常普遍，so get used to it!\n\n\n\n上面的写法还导出一个经常被人们忽视的细节：如果我们将BindedIntMap作为模板参数实例化模板，会怎么样？比如：\n\ntemplate <typename T>\n\nvoid test() {\n\nT::type<int> map;\n\n}\n\n考虑一下可怜的编译器要怎么理解上面的T::type<int>，T::type是一个static变量？一个类型？还是一个模板？不同的场景上面的语句有不同的解释，编译器要到真正实例化时才能弄清楚这句代码的意图，但那有点太晚了，能不能在编译时期就确定代码的意图？答案：https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords。\n\n如果T::type是一个类型，那么需要使用typename：\n\ntypename T::type map;\n\n但是如果T::type是一个模板，语法又稍微有些区别：\n\nT::template type<int> map;\n\n上面的两个例子都无法正常编译，因为很多时候这两个技巧要结合起来才是正确的模板类型声明：\n\ntypename T::template type<int> map;\n\n语言设计上的精巧和持续超出初学者的预期，这就是C++的魅力。。。\n\n\n\n# 函数指针\n\nC++标准规定，任何一个函数都可以被隐式的转换成函数指针，给定void test(int)，下面几种写法，最终的结果都会是一个void(*)(int)类型的指针：\n\n*test\n\n&test\n\ntest\n\n****test\n\nC++允许使用一个函数指针或者函数来进行函数调用，有了一个C++的函数指针：void(*ptrFunc)(int)，下面几种写法都是合法的函数调用：\n\n(*ptrFunc)(1);\n\nptrFunc(1);\n\n(******ptrFunc)(1);\n\n再次感叹，C++的魅力。\n\n\n\n# 模板重载\n\n函数重载指的是拥有不同的参数类型或者数量的不同函数可以拥有同样的名称。当我们说不同类型的参数时，要记得const和volatile也是类型的一部分。\n\n如果要为不同类型的参数实现一套完全相同的算法，那么可以为每个类型的参数编写函数，不过C++提供了函数模板来简化这个工作。\n\n\n\n# SFINAE\n\nSubstitution failure is not an error，替换失败并不是错误。\n\n指的是在进行模板实例化时，如果编译器遇到了错误，就会认为这种实例化是ill-formed，并放弃进行实例化，转而寻找其他特化。\n\n需要注意的是，在C++11中，SFINAE只在“immediate context”中生效，也就是模板参数和函数参数/返回类型实例化阶段生效，函数body内部的\"substitution failure\"依然会导致error。\n\n要想理解C++11的std标准库提供的各式各样的模板，必须要对SFINAE、函数重载决议、模板特化规则等常规OO风格的C++中不太被提及的方面非常了解和熟悉，然后还要多看些模板元编程的设计惯例、模式，否则生啃标准源码的效率会很低，正常的C++书籍中对于模板编程一般不会有非常详细的讲解。\n\n利用SFINAE，我们得以通过模板编程技巧指定一个模板可接受的参数类型特征，为模板指定明确的重载规则。\n\n\n\n# 临时对象\n\nC++中，一个表达式可能由多个子表达式构成，标准并未明确各个语义上无依赖关系的子表达式的求值顺序，不要认为最左边的表达式会被率先求值。如果多个表达式之间没有语法上的依赖关系，只有语义上的依赖关系，那么必须要将这些表达式放在不同的行，明确指定求值顺序。\n\n如果子表达式会导致产生临时对象，那么这个临时对象会在整个表达式求值结束后才会被析构、回收内存。不过，标准在这方面有个非常特殊的规定：一个const引用可以短暂地延长临时对象的生命，临时对象若被赋给引用，则这个临时对象的生命期会被延长到引用无效，或者是临时对象所在作用域结束时。\n\n\n\n# C风格变长参数\n\nhttps://zh.cppreference.com/w/c/variadic\n\nC中可以在函数声明中使用...代表任意数量任意类型的参数，但是...前面必须至少存在一个具名参数：\n\nvoid test(char* buf, size_t length, ...);\n\n被...代表的参数会经历参数类型提升，整数类型的char和boolean都会被提升为int，而float类型会被提升为double。\n\n为了在函数体中使用变长参数，必须使用<stdarg.h>库提供的工具方法：\n\n- va_start\n- va_arg\n- va_end\n- va_list\n\n上面的方法都是宏方法，安全性需要使用者自行保证，如果调用va_arg次数超出了实际传入的变长参数个数，其行为是未定义的。\n\n文档中对此没有过多解释，直接提供了两个例子：\n\n\n\n如何在函数体中使用变长参数：\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n \nvoid simple_printf(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n \n    while (*fmt != '\\0') {\n        if (*fmt == 'd') {\n            int i = va_arg(args, int);\n            printf(\"%d\\n\", i);\n        } else if (*fmt == 'c') {\n            // 将提升 'char' 类型值为 'int'\n            // C 中字符常量自身为 'int' 类型\n            int c = va_arg(args, int);\n            printf(\"%c\\n\", c);\n        } else if (*fmt == 'f') {\n            double d = va_arg(args, double);\n            printf(\"%f\\n\", d);\n        }\n        ++fmt;\n    }\n \n    va_end(args);\n}\n \nint main(void)\n{\n    simple_printf(\"dcff\", 3, 'a', 1.999, 42.5); \n}\n```\n\n\n\n如何将变长参数转发给另一个接受变长参数的函数：\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n \nvoid tlog(const char* fmt,...)\n{\n    char msg[50];\n    strftime(msg, sizeof msg, \"%T\", localtime(&(time_t){time(NULL)}));\n    printf(\"[%s] \", msg);\n    va_list args;\n    va_start(args, fmt);\n    vprintf(fmt, args);\n    va_end(args);\n}\n \nint main(void)\n{\n   tlog(\"logging %d %d %d...\\n\", 1, 2, 3);\n}\n```\n\n\n\n# 栈上对象销毁顺序\n\n栈上对象总是以和创建顺序相反的顺序被销毁。\n\n\n\n# 委托构造函数\n\nC++11起，可以使用委托构造函数。\n\n\n\n```\nclass Foo {\npublic: \n  Foo(char x, int y) {}\n  Foo(int y) : Foo('a', y) {} // Foo(int) 委托到 Foo(char,int)\n};\n```\n\n\n\n# 模板特化与实例化\n\n## 特化\n\n模板特化分为全特化和偏特化，使用template<>关键字进行模板特化，介绍：\n\nhttps://harttle.land/2015/10/03/cpp-template.html\n\n\n\n## 实例化\n\n实例化分为显式实例化和隐式实例化，隐式实例化就是编译期间按需根据模板头文件生成实际代码，显式实例化则是不论是否需要进行模板实例化，编译时都会生成一份指定的代码参与编译。\n\n显式实例化使用不带模板类型部分的template关键字进行，在对类进行显式实例化时，必须提供所有static属性的定义，定义static属性时要使用和特化类似的语法：template <> VAR_TYPE TYPE::sVar = ...。","source":"_posts/cplus_md/CPlus Basic/学习C++ - 艰难的熟悉过程.md","raw":"---\ntitle: 学习C++ - 艰难的熟悉过程\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 使用教程\nabbrlink: 13005\ncover: img/cpp.png\n---\n**学习C++ - 艰难的熟悉过程**\n\n# using声明\n\nhttps://en.cppreference.com/w/cpp/language/using_declaration\n\n自C++11开始，除了可以使用using引入命名空间所有符号外，还可以使用using来定义类型别名，以及使用using为子类引入父类定义的函数，**包括构造函数**；\n\n\n\n昨天晚上读React-Native源码时，发现调用了一个类的构造函数，但是并没有找到这个构造函数的定义在哪里，找了很久才发现看漏了一行using，原来子类是通过using将父类的构造函数全部引入了进来。\n\n\n\n如果子类使用using引入父类构造函数会有一些需要注意的点，第一个是引入时，会将父类的所有构造函数一次性的全部引入到子类，如果子类中新定义的所有成员都能进行隐式的初始化，那就可以直接使用using引入的父类构造函数方法来实例化子类实例了。\n\n如果子类自己定义了函数，并且签名和using引入的函数的签名一样，那么using引入的函数会被隐藏。\n\n例如：\n\n\n\n```\nstruct B1 {  B1(int, ...) { } };\nstruct B2 {  B2(double)   { } };\n \nint get();\n \nstruct D1 : B1 {\n  using B1::B1;  // inherits B1(int, ...)\n  int x;\n  int y = get();\n};\n \nvoid test() {\n  D1 d(2, 3, 4); // OK: B1 is initialized by calling B1(2, 3, 4),\n                 // then d.x is default-initialized (no initialization is performed),\n                 // then d.y is initialized by calling get()\n  D1 e;          // Error: D1 has no default constructor\n}\n \nstruct D2 : B2 {\n  using B2::B2; // inherits B2(double)\n  B1 b; // unable to implicitly initialize b, parent constructor can't be used\n};\n \nD2 f(1.0);       // error: B1 has no default constructor\n```\n\n\n\n\n\n# in-class initialization\n\n在C++03中，禁止在struct或class定义中为成员指定默认值，只能使用initialization-list进行指定，但从C++11开始，允许在定义时为成员指定默认值了。指定默认值时，可以使用=，也可以使用C++11新提供的initializer-list初始化列表语法。（注意上面的表述中有一个例外：大多数编译器一直允许为static const整型成员指定默认值。）\n\n如果同时使用了列表初始化和就地初始化，编译器需要保证最终列表初始化覆盖就地初始化。\n\n\n\n# 静态成员变量定义\n\n静态成员变量在类的头文件中声明，但必须在实现文件中定义，因为一个符号只能被定义一次，如果将定义放在头文件中，一旦任意两个文件引用了这个头文件，那么该静态变量就会被定义两次，导致链接错误。\n\n\n\n# C++陷阱\n\n在函数调用语法中，C++没有明确规定各个参数表达式的求值顺序，这可能会导致问题：\n\n\n\n```\n// dont do this\ncallSomeMethod(new std::shared_ptr<Widget>(new Widget), methodMayThrow());\n\n// this is ok\nstd::shared_ptr<Widget> widgetPtr = new std::shared_ptr<Widget>(new Widget);\ncallSomeMethod(widgetPtr, methodMayThrow());\n```\n\n\n\n如果上面的函数调用中，如果new Widget先被执行了，然后methodMayThrow被执行，最后才轮到shared_ptr的构造，那么一旦methodMayThrow抛出了异常，new Widget占用的资源就永远得不到清理。\n\n为什么C++不对这种场景进行明确的规定？因为C++的设计哲学中，更多的考虑的是效率、语言能力，规范制定得往往较为宽松，留给编译器实现者充足的优化空间，易用性并不在其中，开发者必须自己识别出代码中的缺陷并加以规避，因此C++是一门初学者很难上手，但在专家手中非常好用的语言。\n\n\n\n# 方法调用的习惯\n\n方法参数应该尽量声明成const reference，而不是value，避免不必要的拷贝构造函数调用；\n\n但是，需要返回新创建的值时，直接返回value一般没什么问题，因为编译器有RVO。\n\n\n\n# 命名空间与名字查找(argument-dependent-lookup)\n\n在函数调用发生时，C++规定编译器应该尝试去参数类型所处的命名空间中查找函数，这使得如下的程序能够通过编译：\n\n\n\n```\nnamespace MyNameSpace {\n    template <typename T>\n    class MyClass {...};\n    \n    template <typename T>\n    void swap(MyClass<T>& lhv, MyClass<T>& rhv) {...}\n}\n\n// 初始化myClass1, myClass2\n// 以下语句可以被编译，相当于MyNameSpace::swap(myClass1, myClass2);\nswap(myClass1, myClass2);\n```\n\n\n\nC++标准规定std命名空间内的template可以被客户全特化，但是禁止添加任何新的template、function、class到std命名空间中去，这意味着我们可以全特化std命名空间中的swap，但是却不能在std中声明一个新的swap模板方法：\n\n\n\n```\nnamespace std {\n    // ok\n    void swap(Widget<MyClass>& a, Widget<MyClass>& b) {...};   \n    // 下面这个是标准禁止的\n    template <typename T>\n    void swap(Widget<T>& a, Widget<T>& b) {...};\n}\n```\n\n\n\nC++的这种特殊的名字查找规则规定：在查找函数名字时，应先在参数类型所处作用域中查找，在模板编程中为了能够在模板类型定义了自己的swap时，使用模板类型自己的swap，并在其他情况下使用std的标准swap，可以这样写：\n\n\n\n```\ntemplate <typename T>\nvoid myFunction(T& a, T& b) {\n    using std::swap;\n    // 如果T所处的命名空间内有合适的swap函数，会优先使用；否则，才会使用上面引入的std命名空间的swap\n    swap(a, b);\n}\n```\n\n\n\n# 降低编译依存关系\n\nC++库通常会提供给用户一个头文件，头文件详细描述了库所提供的功能，同时不透露任何实现细节。这可以确保用户只依赖库提供的对外头文件，而不用依赖任何实现的细节。\n\n通常，这是由如下的技术实现的：\n\n\n\n```\n// interface.h, 对外接口头文件\n// 前置声明\nclass MyInterfaceImpl;\nclass MyInterface {\npublic:\n    void a();\n    void b();\nprivate:\n    MyInterfaceImpl* impl;\n};\n\n// interface.cpp, 实现文件\nclass MyInterfaceImpl {\npublic:\n    void a();\n    void b();\n};\nvoid MyInterface::a() {\n    impl->a();\n}\n    \n```\n\n\n\n# CRTP\n\ncrtp指的是curiously recurring template pattern，奇异递归模板模式。\n\n维基百科指出，奇异递归模板模式让基类可以调用子类的非virtual方法，用这种模式即兼顾了运行效率，又获得了类似多态的表现；\n\n而Effective C++指出，如果每个子类都需要独享基类中定义的static成员变量，可以使基类成为一个template类，然后在继承基类时以子类作为模板类型参数实例化基类。\n\n\n\n# placement new\n\n通常，placement new指的是：当客户调用new (ptr) Widget时，会有一个特定版本的operator new就会被编译器调用（void* operator new(std::size_t, void*)）。上述形式的operator new被专门用来将Widget对象构造在addr指向的内存处，这件事是由编译器完成的，编译器中实际的placement new方法实现仅仅返回传入的地址即可。\n\n自定义类可以通过定义一个 static void* operator new(std::size_t, void*) 静态成员方法来替换编译器的默认实现。\n\n如果使用placement new来在指定的位置构造了一个对象，在需要销毁这个对象时一定要小心，明确能否直接使用delete释放所处内存，如果这片内存不应该在这个对象销毁时被释放，就需要仅调用对象的destroctor，而不可以直接使用delete。\n\n\n\n不过，placement new其实还有另外的意思，事实上C++标准允许我们在常规的operator new的std::size_t参数之后声明任意额外参数，只要在使用new关键字创建堆上对象时，通过括号传入兼容的参数即可（不过除了void*以外的额外参数没有编译器的默认实现）。通常大家在说placement new时，指的都是第一个意思。\n\n\n\n# Const重载\n\nC++中，被声明为const的成员函数和没有被声明为const的成员函数是两个同名的重载函数。\n\n当调用const对象的方法时，只有被const修饰的成员函数会被考虑；但是当调用没有const修饰的对象的方法时，会优先调用无const修饰的成员函数，如果没有找到，编译器会接着尝试调用有const修饰的成员函数。这非常合理，const是强保证，确保方法调用时不会修改对象上的任何属性，因此const对象只能调用const方法，对于非const对象，有无强保证都无所谓。一般来说，如果实现了const版本的成员函数，就不应该再实现一个非const版本的成员函数了。\n\n当函数的参数类型中有const时，top-level cv qualifiers都会被移除掉，因为函数参数是按值传递的，顶级cv qualifier没有意义，只有次级cv qualifier会被保留到函数签名中。\n\n什么是top-level cv qualifier？https://stackoverflow.com/questions/24676824/where-is-the-definition-of-top-level-cv-qualifiers-in-the-c11-standard\n\n\n\n# 异常\n\nC++的异常被抛出时，抛出的异常的类型是在编译时静态确定的，如果通过一个base&抛出一个实际类型是derived类型的异常，最终被抛出的异常类型不是derived，而是base；\n\n在确定被抛出的异常和哪个catch语句匹配时，C++不会尝试做隐式类型转换，只有两种转换是会自动尝试的：\n\n- 子类会与父类catch语句匹配，catch语句参数是by reference, by value, 还是by pointer（如果是by value，会有问题吗？会的，父类以外部分会被“切割”掉，这个对象将表现不出来子类特征）\n- 指针类型一定会和无类型指针类型的catch语句catch(void *)匹配\n\n即使catch语句中参数是by reference，被throw的异常对象也会被先拷贝一份，然后被引用的实际上是这个被拷贝的对象，它的生命期就是catch语句块；\n\n在catch语句块中，throw exception和throw是不同的，前者会导致被catch的exception被复制一份，而后者不会复制，直接将catch到的excepition抛出。\n\n\n\n# 继承\n\n## misc\n\n子类实现父类的虚函数时，其返回类型不必和父类虚函数声明完全一致，如果父类虚函数返回类型声明为一个基类的指针或者引用，那么子类可以将返回类型声明为基类的子类的指针或者引用。这样的宽松不会导致类型问题，毕竟一个父类的指针或者引用必然可以接收子类的指针或者引用，并且可以享受到多态性带来的便利。\n\n## More Effective C++\n\n在More Effective C++中，提到了virtual constructor，和virtual copy constructor，这种说法其实不太合适，virtual constructor就是一个普通函数，返回基类指针或引用，根据其参数确定实际返回的类型，factory就是典型的virtual constructor的应用；而virtual copy constructor指的是真正的virtual方法，该virtual方法负责通过copy constructor复制自身，相当于Java中的clone方法。\n\n类似的，还有virtual non member function也不是指一个真正的虚函数，而是指一种技巧：为了让一个类型的non member function表现出多态行为，需要在这个类型中定义一个虚函数并在这个虚函数中实现non member function的需求，然后再定义一个参数为指定类型的non member function，调用类提供的这个虚函数。\n\n\n\n# 智能指针\n\n说到智能指针，我们应该想到：构造和析构、复制和赋值、解引用。\n\n- 构造和析构、复制和赋值：如何实现构造函数和复制构造函数？如何实现赋值函数？如何实现析构函数？\n- 解引用：如何实现->和* operator函数？\n\n- - operator*应该返回被指向的真实对象引用（为什么是引用？当然是为了避免将你本来已经指向的对象再复制一份。。）；\n    - operator->应该返回一个定义了operator->方法的对象（如果调用a->hello()，其实会被解释成a.(operator->)->hello()，也就是说一个对象的operator->必须返回一个长得向指针的类型，然后编译器会对这个返回的类型调用后面的hello方法），对于智能指针来说就是应该返回指针本身。\n\n更加有经验的人除了上面的主题，还会想到：如何测试智能指针是否为null？能否判断智能指针是否存在，比如if (ptr) {...}？答案是前者通常要提供一个隐式转换操作符：operator void*，后者要求我们提供另一个隐式转换操作符：operator bool。\n\n\n\n# 数组引用\n\n数组也是有引用语法的。学习C和C++时，我们都学过数组作为函数调用的参数传递时，会被隐式转换成一个指针，但其实C++允许我们直接传递数组引用：\n\nvoid acceptArrayRef(const int (&arr)[10]) {...}\n\n这样，就声明并定义了一个能够接受长度为10的数组作为参数的函数。\n\n不过，作为一个现代的C++程序员，总是应该更倾向于stl容器，而不是原始数组。\n\n\n\n# 模板类型推导\n\n模板类型推导往往相当直接，比如：\n\n\n\n```\ntemplate <typename T>\nvoid test(Param p) {...}    \n// 当然上边的代码无法编译，因为Param是一个方便我们描述用的符号，实际表示的是T*, const T*等等，\n// 下面会讨论Param为不同的模板类型时，编译器如何处理\n```\n\n\n\n当我们调用test时，参数p的类型是什么，那么Param就会被推成什么，而T则是根据Param来推导的。这里面Param其实是一个由T构成的类型修饰，如const T，或者const T&，此时Param分别指的是const T整体和const T&整体的类型。\n\n\n\n果真如此吗？现在考虑三种情况：\n\n## Param是个引用或指针\n\n如果函数被声明为test(Param& p)或test(Param* p)，那么推导时，Param会保留p的cv限定符。也就是说，当p是一个const Widget*或者const Widget&时，Param成为const Widget。\n\n\n\n## Param是个万能引用\n\ntest(Param&& p)\n\n如果p是个左值，Param会被推导成左值引用；如果p是个右值，Param会被推导成右值引用。\n\n随后，根据引用合并规则，&&&被视作左值引用，而&&&&被视作右值引用。\n\ncv限定符会被保留。\n\n\n\n## Param不是引用或指针\n\n此时推导规则会对应按值传递。按值传递时，会发生拷贝构造，传递过来的值一定不是参数本身。\n\n当p是一个引用时，Param不会被推导成引用。\n\np的cv限定符会被忽略，因为p的副本和p不是同一个对象，不需要保留限定。\n\n\n\n## 当p是数组\n\n当p是数组时，如果Param是引用，那么Param会被推导成数组引用：如int (&)[10]这样的类型。\n\n而如果Param不是引用，那么Param一定会被推导成一个指针。\n\n可以利用这一点实现一个推导数组长度的编译时方法：\n\n\n\n```\ntemplate <typename T, std::size_t N>\nconstexpr std::size_t arraySize(T (&)[N]) noexcept {\n    return N;   \n}\n```\n\n\n\n## 当p是函数\n\n当p是函数，情况和数组很像，因为函数也是一个可以退化成指针，也可以被直接引用的类型。\n\n\n\n# 模板类型推导和auto\n\nauto类型推导的形式如下：\n\nconst auto& a = p;\n\n可以将const auto&这样的带修饰的类型看作上面模板里的Param，而将auto看作一个裸的类型T，如此，类型推导规则便和模板类型推导对得上了。\n\nauto类型推导仅有一处和模板不同：initializer-list。\n\nC++11增加了initializer-list语法，这使得我们可以使用四种方式初始化int：\n\nint x = 2;\n\nint x(2);\n\nint x = {27}; // C++11\n\nint x{27};   // C++11\n\n如果将上面的int以auto替换，那么有initializer-list的初始化方式会导致auto被推导为std::initializer_list。\n\n而如果为一个test(Param p)传入{27, 2, 3}这样的表达式，模板推导规则将无法推导出std::initializer_list。这是C++模板和auto推导规则的唯一不同之处。\n\n\n\n普通的函数不能将参数或返回值声明为auto，毕竟如果你需要auto，那么你可以使用模板函数。\n\n但是，如果要写lambda表达式，要想使用模板的语法来声明入参类型和返回值就太过麻烦了，毕竟lambda就是用来简化functor的编写的。此时C++规定可以在lambda中使用auto来起到模板函数中的Param及T的效果，但此时auto只是模板函数的一种简写，推导规则依然以模板为准，也就是说，initializer-list此时不受支持。\n\n\n\n# template typedef\n\n考虑你有一个模板：\n\nmap<Key, Value>\n\n如果你想要声明一个模板别名：\n\ntemplate <typename Value> using IntKeyMap = map<int, Value>;\n\n你会发现C++编译器阻止你这样做。这不是正确的C++语法。但是，为了达到我们的目的，可以这样做：\n\ntemplate <typename Value>\n\nstruct BindedIntMap {\n\nusing type = map<int, Value>;\n\n}\n\n然后，就可以通过BindedIntMap::type来表示前面我们想要的类型了。事实上这种做法在C++标准库中非常普遍，so get used to it!\n\n\n\n上面的写法还导出一个经常被人们忽视的细节：如果我们将BindedIntMap作为模板参数实例化模板，会怎么样？比如：\n\ntemplate <typename T>\n\nvoid test() {\n\nT::type<int> map;\n\n}\n\n考虑一下可怜的编译器要怎么理解上面的T::type<int>，T::type是一个static变量？一个类型？还是一个模板？不同的场景上面的语句有不同的解释，编译器要到真正实例化时才能弄清楚这句代码的意图，但那有点太晚了，能不能在编译时期就确定代码的意图？答案：https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords。\n\n如果T::type是一个类型，那么需要使用typename：\n\ntypename T::type map;\n\n但是如果T::type是一个模板，语法又稍微有些区别：\n\nT::template type<int> map;\n\n上面的两个例子都无法正常编译，因为很多时候这两个技巧要结合起来才是正确的模板类型声明：\n\ntypename T::template type<int> map;\n\n语言设计上的精巧和持续超出初学者的预期，这就是C++的魅力。。。\n\n\n\n# 函数指针\n\nC++标准规定，任何一个函数都可以被隐式的转换成函数指针，给定void test(int)，下面几种写法，最终的结果都会是一个void(*)(int)类型的指针：\n\n*test\n\n&test\n\ntest\n\n****test\n\nC++允许使用一个函数指针或者函数来进行函数调用，有了一个C++的函数指针：void(*ptrFunc)(int)，下面几种写法都是合法的函数调用：\n\n(*ptrFunc)(1);\n\nptrFunc(1);\n\n(******ptrFunc)(1);\n\n再次感叹，C++的魅力。\n\n\n\n# 模板重载\n\n函数重载指的是拥有不同的参数类型或者数量的不同函数可以拥有同样的名称。当我们说不同类型的参数时，要记得const和volatile也是类型的一部分。\n\n如果要为不同类型的参数实现一套完全相同的算法，那么可以为每个类型的参数编写函数，不过C++提供了函数模板来简化这个工作。\n\n\n\n# SFINAE\n\nSubstitution failure is not an error，替换失败并不是错误。\n\n指的是在进行模板实例化时，如果编译器遇到了错误，就会认为这种实例化是ill-formed，并放弃进行实例化，转而寻找其他特化。\n\n需要注意的是，在C++11中，SFINAE只在“immediate context”中生效，也就是模板参数和函数参数/返回类型实例化阶段生效，函数body内部的\"substitution failure\"依然会导致error。\n\n要想理解C++11的std标准库提供的各式各样的模板，必须要对SFINAE、函数重载决议、模板特化规则等常规OO风格的C++中不太被提及的方面非常了解和熟悉，然后还要多看些模板元编程的设计惯例、模式，否则生啃标准源码的效率会很低，正常的C++书籍中对于模板编程一般不会有非常详细的讲解。\n\n利用SFINAE，我们得以通过模板编程技巧指定一个模板可接受的参数类型特征，为模板指定明确的重载规则。\n\n\n\n# 临时对象\n\nC++中，一个表达式可能由多个子表达式构成，标准并未明确各个语义上无依赖关系的子表达式的求值顺序，不要认为最左边的表达式会被率先求值。如果多个表达式之间没有语法上的依赖关系，只有语义上的依赖关系，那么必须要将这些表达式放在不同的行，明确指定求值顺序。\n\n如果子表达式会导致产生临时对象，那么这个临时对象会在整个表达式求值结束后才会被析构、回收内存。不过，标准在这方面有个非常特殊的规定：一个const引用可以短暂地延长临时对象的生命，临时对象若被赋给引用，则这个临时对象的生命期会被延长到引用无效，或者是临时对象所在作用域结束时。\n\n\n\n# C风格变长参数\n\nhttps://zh.cppreference.com/w/c/variadic\n\nC中可以在函数声明中使用...代表任意数量任意类型的参数，但是...前面必须至少存在一个具名参数：\n\nvoid test(char* buf, size_t length, ...);\n\n被...代表的参数会经历参数类型提升，整数类型的char和boolean都会被提升为int，而float类型会被提升为double。\n\n为了在函数体中使用变长参数，必须使用<stdarg.h>库提供的工具方法：\n\n- va_start\n- va_arg\n- va_end\n- va_list\n\n上面的方法都是宏方法，安全性需要使用者自行保证，如果调用va_arg次数超出了实际传入的变长参数个数，其行为是未定义的。\n\n文档中对此没有过多解释，直接提供了两个例子：\n\n\n\n如何在函数体中使用变长参数：\n\n```\n#include <stdio.h>\n#include <stdarg.h>\n \nvoid simple_printf(const char* fmt, ...)\n{\n    va_list args;\n    va_start(args, fmt);\n \n    while (*fmt != '\\0') {\n        if (*fmt == 'd') {\n            int i = va_arg(args, int);\n            printf(\"%d\\n\", i);\n        } else if (*fmt == 'c') {\n            // 将提升 'char' 类型值为 'int'\n            // C 中字符常量自身为 'int' 类型\n            int c = va_arg(args, int);\n            printf(\"%c\\n\", c);\n        } else if (*fmt == 'f') {\n            double d = va_arg(args, double);\n            printf(\"%f\\n\", d);\n        }\n        ++fmt;\n    }\n \n    va_end(args);\n}\n \nint main(void)\n{\n    simple_printf(\"dcff\", 3, 'a', 1.999, 42.5); \n}\n```\n\n\n\n如何将变长参数转发给另一个接受变长参数的函数：\n\n```\n#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n \nvoid tlog(const char* fmt,...)\n{\n    char msg[50];\n    strftime(msg, sizeof msg, \"%T\", localtime(&(time_t){time(NULL)}));\n    printf(\"[%s] \", msg);\n    va_list args;\n    va_start(args, fmt);\n    vprintf(fmt, args);\n    va_end(args);\n}\n \nint main(void)\n{\n   tlog(\"logging %d %d %d...\\n\", 1, 2, 3);\n}\n```\n\n\n\n# 栈上对象销毁顺序\n\n栈上对象总是以和创建顺序相反的顺序被销毁。\n\n\n\n# 委托构造函数\n\nC++11起，可以使用委托构造函数。\n\n\n\n```\nclass Foo {\npublic: \n  Foo(char x, int y) {}\n  Foo(int y) : Foo('a', y) {} // Foo(int) 委托到 Foo(char,int)\n};\n```\n\n\n\n# 模板特化与实例化\n\n## 特化\n\n模板特化分为全特化和偏特化，使用template<>关键字进行模板特化，介绍：\n\nhttps://harttle.land/2015/10/03/cpp-template.html\n\n\n\n## 实例化\n\n实例化分为显式实例化和隐式实例化，隐式实例化就是编译期间按需根据模板头文件生成实际代码，显式实例化则是不论是否需要进行模板实例化，编译时都会生成一份指定的代码参与编译。\n\n显式实例化使用不带模板类型部分的template关键字进行，在对类进行显式实例化时，必须提供所有static属性的定义，定义static属性时要使用和特化类似的语法：template <> VAR_TYPE TYPE::sVar = ...。","slug":"cplus_md/CPlus Basic/学习C++ - 艰难的熟悉过程","published":1,"updated":"2021-04-09T14:06:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6d004aw9q9c9kjbrzw","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><p><strong>学习C++ - 艰难的熟悉过程</strong></p>\n<h1 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a>using声明</h1><p><a href=\"https://en.cppreference.com/w/cpp/language/using_declaration\">https://en.cppreference.com/w/cpp/language/using_declaration</a></p>\n<p>自C++11开始，除了可以使用using引入命名空间所有符号外，还可以使用using来定义类型别名，以及使用using为子类引入父类定义的函数，<strong>包括构造函数</strong>；</p>\n<p>昨天晚上读React-Native源码时，发现调用了一个类的构造函数，但是并没有找到这个构造函数的定义在哪里，找了很久才发现看漏了一行using，原来子类是通过using将父类的构造函数全部引入了进来。</p>\n<p>如果子类使用using引入父类构造函数会有一些需要注意的点，第一个是引入时，会将父类的所有构造函数一次性的全部引入到子类，如果子类中新定义的所有成员都能进行隐式的初始化，那就可以直接使用using引入的父类构造函数方法来实例化子类实例了。</p>\n<p>如果子类自己定义了函数，并且签名和using引入的函数的签名一样，那么using引入的函数会被隐藏。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct B1 &#123;  B1(int, ...) &#123; &#125; &#125;;</span><br><span class=\"line\">struct B2 &#123;  B2(double)   &#123; &#125; &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">int get();</span><br><span class=\"line\"> </span><br><span class=\"line\">struct D1 : B1 &#123;</span><br><span class=\"line\">  using B1::B1;  &#x2F;&#x2F; inherits B1(int, ...)</span><br><span class=\"line\">  int x;</span><br><span class=\"line\">  int y &#x3D; get();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">void test() &#123;</span><br><span class=\"line\">  D1 d(2, 3, 4); &#x2F;&#x2F; OK: B1 is initialized by calling B1(2, 3, 4),</span><br><span class=\"line\">                 &#x2F;&#x2F; then d.x is default-initialized (no initialization is performed),</span><br><span class=\"line\">                 &#x2F;&#x2F; then d.y is initialized by calling get()</span><br><span class=\"line\">  D1 e;          &#x2F;&#x2F; Error: D1 has no default constructor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct D2 : B2 &#123;</span><br><span class=\"line\">  using B2::B2; &#x2F;&#x2F; inherits B2(double)</span><br><span class=\"line\">  B1 b; &#x2F;&#x2F; unable to implicitly initialize b, parent constructor can&#39;t be used</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">D2 f(1.0);       &#x2F;&#x2F; error: B1 has no default constructor</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"in-class-initialization\"><a href=\"#in-class-initialization\" class=\"headerlink\" title=\"in-class initialization\"></a>in-class initialization</h1><p>在C++03中，禁止在struct或class定义中为成员指定默认值，只能使用initialization-list进行指定，但从C++11开始，允许在定义时为成员指定默认值了。指定默认值时，可以使用=，也可以使用C++11新提供的initializer-list初始化列表语法。（注意上面的表述中有一个例外：大多数编译器一直允许为static const整型成员指定默认值。）</p>\n<p>如果同时使用了列表初始化和就地初始化，编译器需要保证最终列表初始化覆盖就地初始化。</p>\n<h1 id=\"静态成员变量定义\"><a href=\"#静态成员变量定义\" class=\"headerlink\" title=\"静态成员变量定义\"></a>静态成员变量定义</h1><p>静态成员变量在类的头文件中声明，但必须在实现文件中定义，因为一个符号只能被定义一次，如果将定义放在头文件中，一旦任意两个文件引用了这个头文件，那么该静态变量就会被定义两次，导致链接错误。</p>\n<h1 id=\"C-陷阱\"><a href=\"#C-陷阱\" class=\"headerlink\" title=\"C++陷阱\"></a>C++陷阱</h1><p>在函数调用语法中，C++没有明确规定各个参数表达式的求值顺序，这可能会导致问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; dont do this</span><br><span class=\"line\">callSomeMethod(new std::shared_ptr&lt;Widget&gt;(new Widget), methodMayThrow());</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; this is ok</span><br><span class=\"line\">std::shared_ptr&lt;Widget&gt; widgetPtr &#x3D; new std::shared_ptr&lt;Widget&gt;(new Widget);</span><br><span class=\"line\">callSomeMethod(widgetPtr, methodMayThrow());</span><br></pre></td></tr></table></figure>\n\n\n<p>如果上面的函数调用中，如果new Widget先被执行了，然后methodMayThrow被执行，最后才轮到shared_ptr的构造，那么一旦methodMayThrow抛出了异常，new Widget占用的资源就永远得不到清理。</p>\n<p>为什么C++不对这种场景进行明确的规定？因为C++的设计哲学中，更多的考虑的是效率、语言能力，规范制定得往往较为宽松，留给编译器实现者充足的优化空间，易用性并不在其中，开发者必须自己识别出代码中的缺陷并加以规避，因此C++是一门初学者很难上手，但在专家手中非常好用的语言。</p>\n<h1 id=\"方法调用的习惯\"><a href=\"#方法调用的习惯\" class=\"headerlink\" title=\"方法调用的习惯\"></a>方法调用的习惯</h1><p>方法参数应该尽量声明成const reference，而不是value，避免不必要的拷贝构造函数调用；</p>\n<p>但是，需要返回新创建的值时，直接返回value一般没什么问题，因为编译器有RVO。</p>\n<h1 id=\"命名空间与名字查找-argument-dependent-lookup\"><a href=\"#命名空间与名字查找-argument-dependent-lookup\" class=\"headerlink\" title=\"命名空间与名字查找(argument-dependent-lookup)\"></a>命名空间与名字查找(argument-dependent-lookup)</h1><p>在函数调用发生时，C++规定编译器应该尝试去参数类型所处的命名空间中查找函数，这使得如下的程序能够通过编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace MyNameSpace &#123;</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    class MyClass &#123;...&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    void swap(MyClass&lt;T&gt;&amp; lhv, MyClass&lt;T&gt;&amp; rhv) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 初始化myClass1, myClass2</span><br><span class=\"line\">&#x2F;&#x2F; 以下语句可以被编译，相当于MyNameSpace::swap(myClass1, myClass2);</span><br><span class=\"line\">swap(myClass1, myClass2);</span><br></pre></td></tr></table></figure>\n\n\n<p>C++标准规定std命名空间内的template可以被客户全特化，但是禁止添加任何新的template、function、class到std命名空间中去，这意味着我们可以全特化std命名空间中的swap，但是却不能在std中声明一个新的swap模板方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace std &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ok</span><br><span class=\"line\">    void swap(Widget&lt;MyClass&gt;&amp; a, Widget&lt;MyClass&gt;&amp; b) &#123;...&#125;;   </span><br><span class=\"line\">    &#x2F;&#x2F; 下面这个是标准禁止的</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;...&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>C++的这种特殊的名字查找规则规定：在查找函数名字时，应先在参数类型所处作用域中查找，在模板编程中为了能够在模板类型定义了自己的swap时，使用模板类型自己的swap，并在其他情况下使用std的标准swap，可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void myFunction(T&amp; a, T&amp; b) &#123;</span><br><span class=\"line\">    using std::swap;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果T所处的命名空间内有合适的swap函数，会优先使用；否则，才会使用上面引入的std命名空间的swap</span><br><span class=\"line\">    swap(a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"降低编译依存关系\"><a href=\"#降低编译依存关系\" class=\"headerlink\" title=\"降低编译依存关系\"></a>降低编译依存关系</h1><p>C++库通常会提供给用户一个头文件，头文件详细描述了库所提供的功能，同时不透露任何实现细节。这可以确保用户只依赖库提供的对外头文件，而不用依赖任何实现的细节。</p>\n<p>通常，这是由如下的技术实现的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; interface.h, 对外接口头文件</span><br><span class=\"line\">&#x2F;&#x2F; 前置声明</span><br><span class=\"line\">class MyInterfaceImpl;</span><br><span class=\"line\">class MyInterface &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">    void b();</span><br><span class=\"line\">private:</span><br><span class=\"line\">    MyInterfaceImpl* impl;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; interface.cpp, 实现文件</span><br><span class=\"line\">class MyInterfaceImpl &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">    void b();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void MyInterface::a() &#123;</span><br><span class=\"line\">    impl-&gt;a();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"CRTP\"><a href=\"#CRTP\" class=\"headerlink\" title=\"CRTP\"></a>CRTP</h1><p>crtp指的是curiously recurring template pattern，奇异递归模板模式。</p>\n<p>维基百科指出，奇异递归模板模式让基类可以调用子类的非virtual方法，用这种模式即兼顾了运行效率，又获得了类似多态的表现；</p>\n<p>而Effective C++指出，如果每个子类都需要独享基类中定义的static成员变量，可以使基类成为一个template类，然后在继承基类时以子类作为模板类型参数实例化基类。</p>\n<h1 id=\"placement-new\"><a href=\"#placement-new\" class=\"headerlink\" title=\"placement new\"></a>placement new</h1><p>通常，placement new指的是：当客户调用new (ptr) Widget时，会有一个特定版本的operator new就会被编译器调用（void* operator new(std::size_t, void*)）。上述形式的operator new被专门用来将Widget对象构造在addr指向的内存处，这件事是由编译器完成的，编译器中实际的placement new方法实现仅仅返回传入的地址即可。</p>\n<p>自定义类可以通过定义一个 static void* operator new(std::size_t, void*) 静态成员方法来替换编译器的默认实现。</p>\n<p>如果使用placement new来在指定的位置构造了一个对象，在需要销毁这个对象时一定要小心，明确能否直接使用delete释放所处内存，如果这片内存不应该在这个对象销毁时被释放，就需要仅调用对象的destroctor，而不可以直接使用delete。</p>\n<p>不过，placement new其实还有另外的意思，事实上C++标准允许我们在常规的operator new的std::size_t参数之后声明任意额外参数，只要在使用new关键字创建堆上对象时，通过括号传入兼容的参数即可（不过除了void*以外的额外参数没有编译器的默认实现）。通常大家在说placement new时，指的都是第一个意思。</p>\n<h1 id=\"Const重载\"><a href=\"#Const重载\" class=\"headerlink\" title=\"Const重载\"></a>Const重载</h1><p>C++中，被声明为const的成员函数和没有被声明为const的成员函数是两个同名的重载函数。</p>\n<p>当调用const对象的方法时，只有被const修饰的成员函数会被考虑；但是当调用没有const修饰的对象的方法时，会优先调用无const修饰的成员函数，如果没有找到，编译器会接着尝试调用有const修饰的成员函数。这非常合理，const是强保证，确保方法调用时不会修改对象上的任何属性，因此const对象只能调用const方法，对于非const对象，有无强保证都无所谓。一般来说，如果实现了const版本的成员函数，就不应该再实现一个非const版本的成员函数了。</p>\n<p>当函数的参数类型中有const时，top-level cv qualifiers都会被移除掉，因为函数参数是按值传递的，顶级cv qualifier没有意义，只有次级cv qualifier会被保留到函数签名中。</p>\n<p>什么是top-level cv qualifier？<a href=\"https://stackoverflow.com/questions/24676824/where-is-the-definition-of-top-level-cv-qualifiers-in-the-c11-standard\">https://stackoverflow.com/questions/24676824/where-is-the-definition-of-top-level-cv-qualifiers-in-the-c11-standard</a></p>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p>C++的异常被抛出时，抛出的异常的类型是在编译时静态确定的，如果通过一个base&amp;抛出一个实际类型是derived类型的异常，最终被抛出的异常类型不是derived，而是base；</p>\n<p>在确定被抛出的异常和哪个catch语句匹配时，C++不会尝试做隐式类型转换，只有两种转换是会自动尝试的：</p>\n<ul>\n<li>子类会与父类catch语句匹配，catch语句参数是by reference, by value, 还是by pointer（如果是by value，会有问题吗？会的，父类以外部分会被“切割”掉，这个对象将表现不出来子类特征）</li>\n<li>指针类型一定会和无类型指针类型的catch语句catch(void *)匹配</li>\n</ul>\n<p>即使catch语句中参数是by reference，被throw的异常对象也会被先拷贝一份，然后被引用的实际上是这个被拷贝的对象，它的生命期就是catch语句块；</p>\n<p>在catch语句块中，throw exception和throw是不同的，前者会导致被catch的exception被复制一份，而后者不会复制，直接将catch到的excepition抛出。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h2 id=\"misc\"><a href=\"#misc\" class=\"headerlink\" title=\"misc\"></a>misc</h2><p>子类实现父类的虚函数时，其返回类型不必和父类虚函数声明完全一致，如果父类虚函数返回类型声明为一个基类的指针或者引用，那么子类可以将返回类型声明为基类的子类的指针或者引用。这样的宽松不会导致类型问题，毕竟一个父类的指针或者引用必然可以接收子类的指针或者引用，并且可以享受到多态性带来的便利。</p>\n<h2 id=\"More-Effective-C\"><a href=\"#More-Effective-C\" class=\"headerlink\" title=\"More Effective C++\"></a>More Effective C++</h2><p>在More Effective C++中，提到了virtual constructor，和virtual copy constructor，这种说法其实不太合适，virtual constructor就是一个普通函数，返回基类指针或引用，根据其参数确定实际返回的类型，factory就是典型的virtual constructor的应用；而virtual copy constructor指的是真正的virtual方法，该virtual方法负责通过copy constructor复制自身，相当于Java中的clone方法。</p>\n<p>类似的，还有virtual non member function也不是指一个真正的虚函数，而是指一种技巧：为了让一个类型的non member function表现出多态行为，需要在这个类型中定义一个虚函数并在这个虚函数中实现non member function的需求，然后再定义一个参数为指定类型的non member function，调用类提供的这个虚函数。</p>\n<h1 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h1><p>说到智能指针，我们应该想到：构造和析构、复制和赋值、解引用。</p>\n<ul>\n<li><p>构造和析构、复制和赋值：如何实现构造函数和复制构造函数？如何实现赋值函数？如何实现析构函数？</p>\n</li>\n<li><p>解引用：如何实现-&gt;和* operator函数？</p>\n</li>\n<li><ul>\n<li>operator*应该返回被指向的真实对象引用（为什么是引用？当然是为了避免将你本来已经指向的对象再复制一份。。）；<ul>\n<li>operator-&gt;应该返回一个定义了operator-&gt;方法的对象（如果调用a-&gt;hello()，其实会被解释成a.(operator-&gt;)-&gt;hello()，也就是说一个对象的operator-&gt;必须返回一个长得向指针的类型，然后编译器会对这个返回的类型调用后面的hello方法），对于智能指针来说就是应该返回指针本身。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>更加有经验的人除了上面的主题，还会想到：如何测试智能指针是否为null？能否判断智能指针是否存在，比如if (ptr) {…}？答案是前者通常要提供一个隐式转换操作符：operator void*，后者要求我们提供另一个隐式转换操作符：operator bool。</p>\n<h1 id=\"数组引用\"><a href=\"#数组引用\" class=\"headerlink\" title=\"数组引用\"></a>数组引用</h1><p>数组也是有引用语法的。学习C和C++时，我们都学过数组作为函数调用的参数传递时，会被隐式转换成一个指针，但其实C++允许我们直接传递数组引用：</p>\n<p>void acceptArrayRef(const int (&amp;arr)[10]) {…}</p>\n<p>这样，就声明并定义了一个能够接受长度为10的数组作为参数的函数。</p>\n<p>不过，作为一个现代的C++程序员，总是应该更倾向于stl容器，而不是原始数组。</p>\n<h1 id=\"模板类型推导\"><a href=\"#模板类型推导\" class=\"headerlink\" title=\"模板类型推导\"></a>模板类型推导</h1><p>模板类型推导往往相当直接，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void test(Param p) &#123;...&#125;    </span><br><span class=\"line\">&#x2F;&#x2F; 当然上边的代码无法编译，因为Param是一个方便我们描述用的符号，实际表示的是T*, const T*等等，</span><br><span class=\"line\">&#x2F;&#x2F; 下面会讨论Param为不同的模板类型时，编译器如何处理</span><br></pre></td></tr></table></figure>\n\n\n<p>当我们调用test时，参数p的类型是什么，那么Param就会被推成什么，而T则是根据Param来推导的。这里面Param其实是一个由T构成的类型修饰，如const T，或者const T&amp;，此时Param分别指的是const T整体和const T&amp;整体的类型。</p>\n<p>果真如此吗？现在考虑三种情况：</p>\n<h2 id=\"Param是个引用或指针\"><a href=\"#Param是个引用或指针\" class=\"headerlink\" title=\"Param是个引用或指针\"></a>Param是个引用或指针</h2><p>如果函数被声明为test(Param&amp; p)或test(Param* p)，那么推导时，Param会保留p的cv限定符。也就是说，当p是一个const Widget*或者const Widget&amp;时，Param成为const Widget。</p>\n<h2 id=\"Param是个万能引用\"><a href=\"#Param是个万能引用\" class=\"headerlink\" title=\"Param是个万能引用\"></a>Param是个万能引用</h2><p>test(Param&amp;&amp; p)</p>\n<p>如果p是个左值，Param会被推导成左值引用；如果p是个右值，Param会被推导成右值引用。</p>\n<p>随后，根据引用合并规则，&amp;&amp;&amp;被视作左值引用，而&amp;&amp;&amp;&amp;被视作右值引用。</p>\n<p>cv限定符会被保留。</p>\n<h2 id=\"Param不是引用或指针\"><a href=\"#Param不是引用或指针\" class=\"headerlink\" title=\"Param不是引用或指针\"></a>Param不是引用或指针</h2><p>此时推导规则会对应按值传递。按值传递时，会发生拷贝构造，传递过来的值一定不是参数本身。</p>\n<p>当p是一个引用时，Param不会被推导成引用。</p>\n<p>p的cv限定符会被忽略，因为p的副本和p不是同一个对象，不需要保留限定。</p>\n<h2 id=\"当p是数组\"><a href=\"#当p是数组\" class=\"headerlink\" title=\"当p是数组\"></a>当p是数组</h2><p>当p是数组时，如果Param是引用，那么Param会被推导成数组引用：如int (&amp;)[10]这样的类型。</p>\n<p>而如果Param不是引用，那么Param一定会被推导成一个指针。</p>\n<p>可以利用这一点实现一个推导数组长度的编译时方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T, std::size_t N&gt;</span><br><span class=\"line\">constexpr std::size_t arraySize(T (&amp;)[N]) noexcept &#123;</span><br><span class=\"line\">    return N;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"当p是函数\"><a href=\"#当p是函数\" class=\"headerlink\" title=\"当p是函数\"></a>当p是函数</h2><p>当p是函数，情况和数组很像，因为函数也是一个可以退化成指针，也可以被直接引用的类型。</p>\n<h1 id=\"模板类型推导和auto\"><a href=\"#模板类型推导和auto\" class=\"headerlink\" title=\"模板类型推导和auto\"></a>模板类型推导和auto</h1><p>auto类型推导的形式如下：</p>\n<p>const auto&amp; a = p;</p>\n<p>可以将const auto&amp;这样的带修饰的类型看作上面模板里的Param，而将auto看作一个裸的类型T，如此，类型推导规则便和模板类型推导对得上了。</p>\n<p>auto类型推导仅有一处和模板不同：initializer-list。</p>\n<p>C++11增加了initializer-list语法，这使得我们可以使用四种方式初始化int：</p>\n<p>int x = 2;</p>\n<p>int x(2);</p>\n<p>int x = {27}; // C++11</p>\n<p>int x{27};   // C++11</p>\n<p>如果将上面的int以auto替换，那么有initializer-list的初始化方式会导致auto被推导为std::initializer_list。</p>\n<p>而如果为一个test(Param p)传入{27, 2, 3}这样的表达式，模板推导规则将无法推导出std::initializer_list。这是C++模板和auto推导规则的唯一不同之处。</p>\n<p>普通的函数不能将参数或返回值声明为auto，毕竟如果你需要auto，那么你可以使用模板函数。</p>\n<p>但是，如果要写lambda表达式，要想使用模板的语法来声明入参类型和返回值就太过麻烦了，毕竟lambda就是用来简化functor的编写的。此时C++规定可以在lambda中使用auto来起到模板函数中的Param及T的效果，但此时auto只是模板函数的一种简写，推导规则依然以模板为准，也就是说，initializer-list此时不受支持。</p>\n<h1 id=\"template-typedef\"><a href=\"#template-typedef\" class=\"headerlink\" title=\"template typedef\"></a>template typedef</h1><p>考虑你有一个模板：</p>\n<p>map&lt;Key, Value&gt;</p>\n<p>如果你想要声明一个模板别名：</p>\n<p>template <typename Value> using IntKeyMap = map&lt;int, Value&gt;;</p>\n<p>你会发现C++编译器阻止你这样做。这不是正确的C++语法。但是，为了达到我们的目的，可以这样做：</p>\n<p>template <typename Value></p>\n<p>struct BindedIntMap {</p>\n<p>using type = map&lt;int, Value&gt;;</p>\n<p>}</p>\n<p>然后，就可以通过BindedIntMap::type来表示前面我们想要的类型了。事实上这种做法在C++标准库中非常普遍，so get used to it!</p>\n<p>上面的写法还导出一个经常被人们忽视的细节：如果我们将BindedIntMap作为模板参数实例化模板，会怎么样？比如：</p>\n<p>template <typename T></p>\n<p>void test() {</p>\n<p>T::type<int> map;</p>\n<p>}</p>\n<p>考虑一下可怜的编译器要怎么理解上面的T::type<int>，T::type是一个static变量？一个类型？还是一个模板？不同的场景上面的语句有不同的解释，编译器要到真正实例化时才能弄清楚这句代码的意图，但那有点太晚了，能不能在编译时期就确定代码的意图？答案：<a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords%E3%80%82\">https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords。</a></p>\n<p>如果T::type是一个类型，那么需要使用typename：</p>\n<p>typename T::type map;</p>\n<p>但是如果T::type是一个模板，语法又稍微有些区别：</p>\n<p>T::template type<int> map;</p>\n<p>上面的两个例子都无法正常编译，因为很多时候这两个技巧要结合起来才是正确的模板类型声明：</p>\n<p>typename T::template type<int> map;</p>\n<p>语言设计上的精巧和持续超出初学者的预期，这就是C++的魅力。。。</p>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>C++标准规定，任何一个函数都可以被隐式的转换成函数指针，给定void test(int)，下面几种写法，最终的结果都会是一个void(*)(int)类型的指针：</p>\n<p>*test</p>\n<p>&amp;test</p>\n<p>test</p>\n<p>****test</p>\n<p>C++允许使用一个函数指针或者函数来进行函数调用，有了一个C++的函数指针：void(*ptrFunc)(int)，下面几种写法都是合法的函数调用：</p>\n<p>(*ptrFunc)(1);</p>\n<p>ptrFunc(1);</p>\n<p>(<strong>**</strong>ptrFunc)(1);</p>\n<p>再次感叹，C++的魅力。</p>\n<h1 id=\"模板重载\"><a href=\"#模板重载\" class=\"headerlink\" title=\"模板重载\"></a>模板重载</h1><p>函数重载指的是拥有不同的参数类型或者数量的不同函数可以拥有同样的名称。当我们说不同类型的参数时，要记得const和volatile也是类型的一部分。</p>\n<p>如果要为不同类型的参数实现一套完全相同的算法，那么可以为每个类型的参数编写函数，不过C++提供了函数模板来简化这个工作。</p>\n<h1 id=\"SFINAE\"><a href=\"#SFINAE\" class=\"headerlink\" title=\"SFINAE\"></a>SFINAE</h1><p>Substitution failure is not an error，替换失败并不是错误。</p>\n<p>指的是在进行模板实例化时，如果编译器遇到了错误，就会认为这种实例化是ill-formed，并放弃进行实例化，转而寻找其他特化。</p>\n<p>需要注意的是，在C++11中，SFINAE只在“immediate context”中生效，也就是模板参数和函数参数/返回类型实例化阶段生效，函数body内部的”substitution failure”依然会导致error。</p>\n<p>要想理解C++11的std标准库提供的各式各样的模板，必须要对SFINAE、函数重载决议、模板特化规则等常规OO风格的C++中不太被提及的方面非常了解和熟悉，然后还要多看些模板元编程的设计惯例、模式，否则生啃标准源码的效率会很低，正常的C++书籍中对于模板编程一般不会有非常详细的讲解。</p>\n<p>利用SFINAE，我们得以通过模板编程技巧指定一个模板可接受的参数类型特征，为模板指定明确的重载规则。</p>\n<h1 id=\"临时对象\"><a href=\"#临时对象\" class=\"headerlink\" title=\"临时对象\"></a>临时对象</h1><p>C++中，一个表达式可能由多个子表达式构成，标准并未明确各个语义上无依赖关系的子表达式的求值顺序，不要认为最左边的表达式会被率先求值。如果多个表达式之间没有语法上的依赖关系，只有语义上的依赖关系，那么必须要将这些表达式放在不同的行，明确指定求值顺序。</p>\n<p>如果子表达式会导致产生临时对象，那么这个临时对象会在整个表达式求值结束后才会被析构、回收内存。不过，标准在这方面有个非常特殊的规定：一个const引用可以短暂地延长临时对象的生命，临时对象若被赋给引用，则这个临时对象的生命期会被延长到引用无效，或者是临时对象所在作用域结束时。</p>\n<h1 id=\"C风格变长参数\"><a href=\"#C风格变长参数\" class=\"headerlink\" title=\"C风格变长参数\"></a>C风格变长参数</h1><p><a href=\"https://zh.cppreference.com/w/c/variadic\">https://zh.cppreference.com/w/c/variadic</a></p>\n<p>C中可以在函数声明中使用…代表任意数量任意类型的参数，但是…前面必须至少存在一个具名参数：</p>\n<p>void test(char* buf, size_t length, …);</p>\n<p>被…代表的参数会经历参数类型提升，整数类型的char和boolean都会被提升为int，而float类型会被提升为double。</p>\n<p>为了在函数体中使用变长参数，必须使用&lt;stdarg.h&gt;库提供的工具方法：</p>\n<ul>\n<li>va_start</li>\n<li>va_arg</li>\n<li>va_end</li>\n<li>va_list</li>\n</ul>\n<p>上面的方法都是宏方法，安全性需要使用者自行保证，如果调用va_arg次数超出了实际传入的变长参数个数，其行为是未定义的。</p>\n<p>文档中对此没有过多解释，直接提供了两个例子：</p>\n<p>如何在函数体中使用变长参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdarg.h&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">void simple_printf(const char* fmt, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    va_list args;</span><br><span class=\"line\">    va_start(args, fmt);</span><br><span class=\"line\"> </span><br><span class=\"line\">    while (*fmt !&#x3D; &#39;\\0&#39;) &#123;</span><br><span class=\"line\">        if (*fmt &#x3D;&#x3D; &#39;d&#39;) &#123;</span><br><span class=\"line\">            int i &#x3D; va_arg(args, int);</span><br><span class=\"line\">            printf(&quot;%d\\n&quot;, i);</span><br><span class=\"line\">        &#125; else if (*fmt &#x3D;&#x3D; &#39;c&#39;) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 将提升 &#39;char&#39; 类型值为 &#39;int&#39;</span><br><span class=\"line\">            &#x2F;&#x2F; C 中字符常量自身为 &#39;int&#39; 类型</span><br><span class=\"line\">            int c &#x3D; va_arg(args, int);</span><br><span class=\"line\">            printf(&quot;%c\\n&quot;, c);</span><br><span class=\"line\">        &#125; else if (*fmt &#x3D;&#x3D; &#39;f&#39;) &#123;</span><br><span class=\"line\">            double d &#x3D; va_arg(args, double);</span><br><span class=\"line\">            printf(&quot;%f\\n&quot;, d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++fmt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    va_end(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    simple_printf(&quot;dcff&quot;, 3, &#39;a&#39;, 1.999, 42.5); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>如何将变长参数转发给另一个接受变长参数的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdarg.h&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">void tlog(const char* fmt,...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char msg[50];</span><br><span class=\"line\">    strftime(msg, sizeof msg, &quot;%T&quot;, localtime(&amp;(time_t)&#123;time(NULL)&#125;));</span><br><span class=\"line\">    printf(&quot;[%s] &quot;, msg);</span><br><span class=\"line\">    va_list args;</span><br><span class=\"line\">    va_start(args, fmt);</span><br><span class=\"line\">    vprintf(fmt, args);</span><br><span class=\"line\">    va_end(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   tlog(&quot;logging %d %d %d...\\n&quot;, 1, 2, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"栈上对象销毁顺序\"><a href=\"#栈上对象销毁顺序\" class=\"headerlink\" title=\"栈上对象销毁顺序\"></a>栈上对象销毁顺序</h1><p>栈上对象总是以和创建顺序相反的顺序被销毁。</p>\n<h1 id=\"委托构造函数\"><a href=\"#委托构造函数\" class=\"headerlink\" title=\"委托构造函数\"></a>委托构造函数</h1><p>C++11起，可以使用委托构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">public: </span><br><span class=\"line\">  Foo(char x, int y) &#123;&#125;</span><br><span class=\"line\">  Foo(int y) : Foo(&#39;a&#39;, y) &#123;&#125; &#x2F;&#x2F; Foo(int) 委托到 Foo(char,int)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"模板特化与实例化\"><a href=\"#模板特化与实例化\" class=\"headerlink\" title=\"模板特化与实例化\"></a>模板特化与实例化</h1><h2 id=\"特化\"><a href=\"#特化\" class=\"headerlink\" title=\"特化\"></a>特化</h2><p>模板特化分为全特化和偏特化，使用template&lt;&gt;关键字进行模板特化，介绍：</p>\n<p><a href=\"https://harttle.land/2015/10/03/cpp-template.html\">https://harttle.land/2015/10/03/cpp-template.html</a></p>\n<h2 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h2><p>实例化分为显式实例化和隐式实例化，隐式实例化就是编译期间按需根据模板头文件生成实际代码，显式实例化则是不论是否需要进行模板实例化，编译时都会生成一份指定的代码参与编译。</p>\n<p>显式实例化使用不带模板类型部分的template关键字进行，在对类进行显式实例化时，必须提供所有static属性的定义，定义static属性时要使用和特化类似的语法：template &lt;&gt; VAR_TYPE TYPE::sVar = …。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<p><strong>学习C++ - 艰难的熟悉过程</strong></p>\n<h1 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a>using声明</h1><p><a href=\"https://en.cppreference.com/w/cpp/language/using_declaration\">https://en.cppreference.com/w/cpp/language/using_declaration</a></p>\n<p>自C++11开始，除了可以使用using引入命名空间所有符号外，还可以使用using来定义类型别名，以及使用using为子类引入父类定义的函数，<strong>包括构造函数</strong>；</p>\n<p>昨天晚上读React-Native源码时，发现调用了一个类的构造函数，但是并没有找到这个构造函数的定义在哪里，找了很久才发现看漏了一行using，原来子类是通过using将父类的构造函数全部引入了进来。</p>\n<p>如果子类使用using引入父类构造函数会有一些需要注意的点，第一个是引入时，会将父类的所有构造函数一次性的全部引入到子类，如果子类中新定义的所有成员都能进行隐式的初始化，那就可以直接使用using引入的父类构造函数方法来实例化子类实例了。</p>\n<p>如果子类自己定义了函数，并且签名和using引入的函数的签名一样，那么using引入的函数会被隐藏。</p>\n<p>例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct B1 &#123;  B1(int, ...) &#123; &#125; &#125;;</span><br><span class=\"line\">struct B2 &#123;  B2(double)   &#123; &#125; &#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">int get();</span><br><span class=\"line\"> </span><br><span class=\"line\">struct D1 : B1 &#123;</span><br><span class=\"line\">  using B1::B1;  &#x2F;&#x2F; inherits B1(int, ...)</span><br><span class=\"line\">  int x;</span><br><span class=\"line\">  int y &#x3D; get();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">void test() &#123;</span><br><span class=\"line\">  D1 d(2, 3, 4); &#x2F;&#x2F; OK: B1 is initialized by calling B1(2, 3, 4),</span><br><span class=\"line\">                 &#x2F;&#x2F; then d.x is default-initialized (no initialization is performed),</span><br><span class=\"line\">                 &#x2F;&#x2F; then d.y is initialized by calling get()</span><br><span class=\"line\">  D1 e;          &#x2F;&#x2F; Error: D1 has no default constructor</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">struct D2 : B2 &#123;</span><br><span class=\"line\">  using B2::B2; &#x2F;&#x2F; inherits B2(double)</span><br><span class=\"line\">  B1 b; &#x2F;&#x2F; unable to implicitly initialize b, parent constructor can&#39;t be used</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\">D2 f(1.0);       &#x2F;&#x2F; error: B1 has no default constructor</span><br></pre></td></tr></table></figure>\n\n\n\n\n<h1 id=\"in-class-initialization\"><a href=\"#in-class-initialization\" class=\"headerlink\" title=\"in-class initialization\"></a>in-class initialization</h1><p>在C++03中，禁止在struct或class定义中为成员指定默认值，只能使用initialization-list进行指定，但从C++11开始，允许在定义时为成员指定默认值了。指定默认值时，可以使用=，也可以使用C++11新提供的initializer-list初始化列表语法。（注意上面的表述中有一个例外：大多数编译器一直允许为static const整型成员指定默认值。）</p>\n<p>如果同时使用了列表初始化和就地初始化，编译器需要保证最终列表初始化覆盖就地初始化。</p>\n<h1 id=\"静态成员变量定义\"><a href=\"#静态成员变量定义\" class=\"headerlink\" title=\"静态成员变量定义\"></a>静态成员变量定义</h1><p>静态成员变量在类的头文件中声明，但必须在实现文件中定义，因为一个符号只能被定义一次，如果将定义放在头文件中，一旦任意两个文件引用了这个头文件，那么该静态变量就会被定义两次，导致链接错误。</p>\n<h1 id=\"C-陷阱\"><a href=\"#C-陷阱\" class=\"headerlink\" title=\"C++陷阱\"></a>C++陷阱</h1><p>在函数调用语法中，C++没有明确规定各个参数表达式的求值顺序，这可能会导致问题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; dont do this</span><br><span class=\"line\">callSomeMethod(new std::shared_ptr&lt;Widget&gt;(new Widget), methodMayThrow());</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; this is ok</span><br><span class=\"line\">std::shared_ptr&lt;Widget&gt; widgetPtr &#x3D; new std::shared_ptr&lt;Widget&gt;(new Widget);</span><br><span class=\"line\">callSomeMethod(widgetPtr, methodMayThrow());</span><br></pre></td></tr></table></figure>\n\n\n<p>如果上面的函数调用中，如果new Widget先被执行了，然后methodMayThrow被执行，最后才轮到shared_ptr的构造，那么一旦methodMayThrow抛出了异常，new Widget占用的资源就永远得不到清理。</p>\n<p>为什么C++不对这种场景进行明确的规定？因为C++的设计哲学中，更多的考虑的是效率、语言能力，规范制定得往往较为宽松，留给编译器实现者充足的优化空间，易用性并不在其中，开发者必须自己识别出代码中的缺陷并加以规避，因此C++是一门初学者很难上手，但在专家手中非常好用的语言。</p>\n<h1 id=\"方法调用的习惯\"><a href=\"#方法调用的习惯\" class=\"headerlink\" title=\"方法调用的习惯\"></a>方法调用的习惯</h1><p>方法参数应该尽量声明成const reference，而不是value，避免不必要的拷贝构造函数调用；</p>\n<p>但是，需要返回新创建的值时，直接返回value一般没什么问题，因为编译器有RVO。</p>\n<h1 id=\"命名空间与名字查找-argument-dependent-lookup\"><a href=\"#命名空间与名字查找-argument-dependent-lookup\" class=\"headerlink\" title=\"命名空间与名字查找(argument-dependent-lookup)\"></a>命名空间与名字查找(argument-dependent-lookup)</h1><p>在函数调用发生时，C++规定编译器应该尝试去参数类型所处的命名空间中查找函数，这使得如下的程序能够通过编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace MyNameSpace &#123;</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    class MyClass &#123;...&#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    void swap(MyClass&lt;T&gt;&amp; lhv, MyClass&lt;T&gt;&amp; rhv) &#123;...&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 初始化myClass1, myClass2</span><br><span class=\"line\">&#x2F;&#x2F; 以下语句可以被编译，相当于MyNameSpace::swap(myClass1, myClass2);</span><br><span class=\"line\">swap(myClass1, myClass2);</span><br></pre></td></tr></table></figure>\n\n\n<p>C++标准规定std命名空间内的template可以被客户全特化，但是禁止添加任何新的template、function、class到std命名空间中去，这意味着我们可以全特化std命名空间中的swap，但是却不能在std中声明一个新的swap模板方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace std &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; ok</span><br><span class=\"line\">    void swap(Widget&lt;MyClass&gt;&amp; a, Widget&lt;MyClass&gt;&amp; b) &#123;...&#125;;   </span><br><span class=\"line\">    &#x2F;&#x2F; 下面这个是标准禁止的</span><br><span class=\"line\">    template &lt;typename T&gt;</span><br><span class=\"line\">    void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b) &#123;...&#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>C++的这种特殊的名字查找规则规定：在查找函数名字时，应先在参数类型所处作用域中查找，在模板编程中为了能够在模板类型定义了自己的swap时，使用模板类型自己的swap，并在其他情况下使用std的标准swap，可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void myFunction(T&amp; a, T&amp; b) &#123;</span><br><span class=\"line\">    using std::swap;</span><br><span class=\"line\">    &#x2F;&#x2F; 如果T所处的命名空间内有合适的swap函数，会优先使用；否则，才会使用上面引入的std命名空间的swap</span><br><span class=\"line\">    swap(a, b);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"降低编译依存关系\"><a href=\"#降低编译依存关系\" class=\"headerlink\" title=\"降低编译依存关系\"></a>降低编译依存关系</h1><p>C++库通常会提供给用户一个头文件，头文件详细描述了库所提供的功能，同时不透露任何实现细节。这可以确保用户只依赖库提供的对外头文件，而不用依赖任何实现的细节。</p>\n<p>通常，这是由如下的技术实现的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; interface.h, 对外接口头文件</span><br><span class=\"line\">&#x2F;&#x2F; 前置声明</span><br><span class=\"line\">class MyInterfaceImpl;</span><br><span class=\"line\">class MyInterface &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">    void b();</span><br><span class=\"line\">private:</span><br><span class=\"line\">    MyInterfaceImpl* impl;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; interface.cpp, 实现文件</span><br><span class=\"line\">class MyInterfaceImpl &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">    void b();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void MyInterface::a() &#123;</span><br><span class=\"line\">    impl-&gt;a();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"CRTP\"><a href=\"#CRTP\" class=\"headerlink\" title=\"CRTP\"></a>CRTP</h1><p>crtp指的是curiously recurring template pattern，奇异递归模板模式。</p>\n<p>维基百科指出，奇异递归模板模式让基类可以调用子类的非virtual方法，用这种模式即兼顾了运行效率，又获得了类似多态的表现；</p>\n<p>而Effective C++指出，如果每个子类都需要独享基类中定义的static成员变量，可以使基类成为一个template类，然后在继承基类时以子类作为模板类型参数实例化基类。</p>\n<h1 id=\"placement-new\"><a href=\"#placement-new\" class=\"headerlink\" title=\"placement new\"></a>placement new</h1><p>通常，placement new指的是：当客户调用new (ptr) Widget时，会有一个特定版本的operator new就会被编译器调用（void* operator new(std::size_t, void*)）。上述形式的operator new被专门用来将Widget对象构造在addr指向的内存处，这件事是由编译器完成的，编译器中实际的placement new方法实现仅仅返回传入的地址即可。</p>\n<p>自定义类可以通过定义一个 static void* operator new(std::size_t, void*) 静态成员方法来替换编译器的默认实现。</p>\n<p>如果使用placement new来在指定的位置构造了一个对象，在需要销毁这个对象时一定要小心，明确能否直接使用delete释放所处内存，如果这片内存不应该在这个对象销毁时被释放，就需要仅调用对象的destroctor，而不可以直接使用delete。</p>\n<p>不过，placement new其实还有另外的意思，事实上C++标准允许我们在常规的operator new的std::size_t参数之后声明任意额外参数，只要在使用new关键字创建堆上对象时，通过括号传入兼容的参数即可（不过除了void*以外的额外参数没有编译器的默认实现）。通常大家在说placement new时，指的都是第一个意思。</p>\n<h1 id=\"Const重载\"><a href=\"#Const重载\" class=\"headerlink\" title=\"Const重载\"></a>Const重载</h1><p>C++中，被声明为const的成员函数和没有被声明为const的成员函数是两个同名的重载函数。</p>\n<p>当调用const对象的方法时，只有被const修饰的成员函数会被考虑；但是当调用没有const修饰的对象的方法时，会优先调用无const修饰的成员函数，如果没有找到，编译器会接着尝试调用有const修饰的成员函数。这非常合理，const是强保证，确保方法调用时不会修改对象上的任何属性，因此const对象只能调用const方法，对于非const对象，有无强保证都无所谓。一般来说，如果实现了const版本的成员函数，就不应该再实现一个非const版本的成员函数了。</p>\n<p>当函数的参数类型中有const时，top-level cv qualifiers都会被移除掉，因为函数参数是按值传递的，顶级cv qualifier没有意义，只有次级cv qualifier会被保留到函数签名中。</p>\n<p>什么是top-level cv qualifier？<a href=\"https://stackoverflow.com/questions/24676824/where-is-the-definition-of-top-level-cv-qualifiers-in-the-c11-standard\">https://stackoverflow.com/questions/24676824/where-is-the-definition-of-top-level-cv-qualifiers-in-the-c11-standard</a></p>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p>C++的异常被抛出时，抛出的异常的类型是在编译时静态确定的，如果通过一个base&amp;抛出一个实际类型是derived类型的异常，最终被抛出的异常类型不是derived，而是base；</p>\n<p>在确定被抛出的异常和哪个catch语句匹配时，C++不会尝试做隐式类型转换，只有两种转换是会自动尝试的：</p>\n<ul>\n<li>子类会与父类catch语句匹配，catch语句参数是by reference, by value, 还是by pointer（如果是by value，会有问题吗？会的，父类以外部分会被“切割”掉，这个对象将表现不出来子类特征）</li>\n<li>指针类型一定会和无类型指针类型的catch语句catch(void *)匹配</li>\n</ul>\n<p>即使catch语句中参数是by reference，被throw的异常对象也会被先拷贝一份，然后被引用的实际上是这个被拷贝的对象，它的生命期就是catch语句块；</p>\n<p>在catch语句块中，throw exception和throw是不同的，前者会导致被catch的exception被复制一份，而后者不会复制，直接将catch到的excepition抛出。</p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><h2 id=\"misc\"><a href=\"#misc\" class=\"headerlink\" title=\"misc\"></a>misc</h2><p>子类实现父类的虚函数时，其返回类型不必和父类虚函数声明完全一致，如果父类虚函数返回类型声明为一个基类的指针或者引用，那么子类可以将返回类型声明为基类的子类的指针或者引用。这样的宽松不会导致类型问题，毕竟一个父类的指针或者引用必然可以接收子类的指针或者引用，并且可以享受到多态性带来的便利。</p>\n<h2 id=\"More-Effective-C\"><a href=\"#More-Effective-C\" class=\"headerlink\" title=\"More Effective C++\"></a>More Effective C++</h2><p>在More Effective C++中，提到了virtual constructor，和virtual copy constructor，这种说法其实不太合适，virtual constructor就是一个普通函数，返回基类指针或引用，根据其参数确定实际返回的类型，factory就是典型的virtual constructor的应用；而virtual copy constructor指的是真正的virtual方法，该virtual方法负责通过copy constructor复制自身，相当于Java中的clone方法。</p>\n<p>类似的，还有virtual non member function也不是指一个真正的虚函数，而是指一种技巧：为了让一个类型的non member function表现出多态行为，需要在这个类型中定义一个虚函数并在这个虚函数中实现non member function的需求，然后再定义一个参数为指定类型的non member function，调用类提供的这个虚函数。</p>\n<h1 id=\"智能指针\"><a href=\"#智能指针\" class=\"headerlink\" title=\"智能指针\"></a>智能指针</h1><p>说到智能指针，我们应该想到：构造和析构、复制和赋值、解引用。</p>\n<ul>\n<li><p>构造和析构、复制和赋值：如何实现构造函数和复制构造函数？如何实现赋值函数？如何实现析构函数？</p>\n</li>\n<li><p>解引用：如何实现-&gt;和* operator函数？</p>\n</li>\n<li><ul>\n<li>operator*应该返回被指向的真实对象引用（为什么是引用？当然是为了避免将你本来已经指向的对象再复制一份。。）；<ul>\n<li>operator-&gt;应该返回一个定义了operator-&gt;方法的对象（如果调用a-&gt;hello()，其实会被解释成a.(operator-&gt;)-&gt;hello()，也就是说一个对象的operator-&gt;必须返回一个长得向指针的类型，然后编译器会对这个返回的类型调用后面的hello方法），对于智能指针来说就是应该返回指针本身。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>更加有经验的人除了上面的主题，还会想到：如何测试智能指针是否为null？能否判断智能指针是否存在，比如if (ptr) {…}？答案是前者通常要提供一个隐式转换操作符：operator void*，后者要求我们提供另一个隐式转换操作符：operator bool。</p>\n<h1 id=\"数组引用\"><a href=\"#数组引用\" class=\"headerlink\" title=\"数组引用\"></a>数组引用</h1><p>数组也是有引用语法的。学习C和C++时，我们都学过数组作为函数调用的参数传递时，会被隐式转换成一个指针，但其实C++允许我们直接传递数组引用：</p>\n<p>void acceptArrayRef(const int (&amp;arr)[10]) {…}</p>\n<p>这样，就声明并定义了一个能够接受长度为10的数组作为参数的函数。</p>\n<p>不过，作为一个现代的C++程序员，总是应该更倾向于stl容器，而不是原始数组。</p>\n<h1 id=\"模板类型推导\"><a href=\"#模板类型推导\" class=\"headerlink\" title=\"模板类型推导\"></a>模板类型推导</h1><p>模板类型推导往往相当直接，比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T&gt;</span><br><span class=\"line\">void test(Param p) &#123;...&#125;    </span><br><span class=\"line\">&#x2F;&#x2F; 当然上边的代码无法编译，因为Param是一个方便我们描述用的符号，实际表示的是T*, const T*等等，</span><br><span class=\"line\">&#x2F;&#x2F; 下面会讨论Param为不同的模板类型时，编译器如何处理</span><br></pre></td></tr></table></figure>\n\n\n<p>当我们调用test时，参数p的类型是什么，那么Param就会被推成什么，而T则是根据Param来推导的。这里面Param其实是一个由T构成的类型修饰，如const T，或者const T&amp;，此时Param分别指的是const T整体和const T&amp;整体的类型。</p>\n<p>果真如此吗？现在考虑三种情况：</p>\n<h2 id=\"Param是个引用或指针\"><a href=\"#Param是个引用或指针\" class=\"headerlink\" title=\"Param是个引用或指针\"></a>Param是个引用或指针</h2><p>如果函数被声明为test(Param&amp; p)或test(Param* p)，那么推导时，Param会保留p的cv限定符。也就是说，当p是一个const Widget*或者const Widget&amp;时，Param成为const Widget。</p>\n<h2 id=\"Param是个万能引用\"><a href=\"#Param是个万能引用\" class=\"headerlink\" title=\"Param是个万能引用\"></a>Param是个万能引用</h2><p>test(Param&amp;&amp; p)</p>\n<p>如果p是个左值，Param会被推导成左值引用；如果p是个右值，Param会被推导成右值引用。</p>\n<p>随后，根据引用合并规则，&amp;&amp;&amp;被视作左值引用，而&amp;&amp;&amp;&amp;被视作右值引用。</p>\n<p>cv限定符会被保留。</p>\n<h2 id=\"Param不是引用或指针\"><a href=\"#Param不是引用或指针\" class=\"headerlink\" title=\"Param不是引用或指针\"></a>Param不是引用或指针</h2><p>此时推导规则会对应按值传递。按值传递时，会发生拷贝构造，传递过来的值一定不是参数本身。</p>\n<p>当p是一个引用时，Param不会被推导成引用。</p>\n<p>p的cv限定符会被忽略，因为p的副本和p不是同一个对象，不需要保留限定。</p>\n<h2 id=\"当p是数组\"><a href=\"#当p是数组\" class=\"headerlink\" title=\"当p是数组\"></a>当p是数组</h2><p>当p是数组时，如果Param是引用，那么Param会被推导成数组引用：如int (&amp;)[10]这样的类型。</p>\n<p>而如果Param不是引用，那么Param一定会被推导成一个指针。</p>\n<p>可以利用这一点实现一个推导数组长度的编译时方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">template &lt;typename T, std::size_t N&gt;</span><br><span class=\"line\">constexpr std::size_t arraySize(T (&amp;)[N]) noexcept &#123;</span><br><span class=\"line\">    return N;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"当p是函数\"><a href=\"#当p是函数\" class=\"headerlink\" title=\"当p是函数\"></a>当p是函数</h2><p>当p是函数，情况和数组很像，因为函数也是一个可以退化成指针，也可以被直接引用的类型。</p>\n<h1 id=\"模板类型推导和auto\"><a href=\"#模板类型推导和auto\" class=\"headerlink\" title=\"模板类型推导和auto\"></a>模板类型推导和auto</h1><p>auto类型推导的形式如下：</p>\n<p>const auto&amp; a = p;</p>\n<p>可以将const auto&amp;这样的带修饰的类型看作上面模板里的Param，而将auto看作一个裸的类型T，如此，类型推导规则便和模板类型推导对得上了。</p>\n<p>auto类型推导仅有一处和模板不同：initializer-list。</p>\n<p>C++11增加了initializer-list语法，这使得我们可以使用四种方式初始化int：</p>\n<p>int x = 2;</p>\n<p>int x(2);</p>\n<p>int x = {27}; // C++11</p>\n<p>int x{27};   // C++11</p>\n<p>如果将上面的int以auto替换，那么有initializer-list的初始化方式会导致auto被推导为std::initializer_list。</p>\n<p>而如果为一个test(Param p)传入{27, 2, 3}这样的表达式，模板推导规则将无法推导出std::initializer_list。这是C++模板和auto推导规则的唯一不同之处。</p>\n<p>普通的函数不能将参数或返回值声明为auto，毕竟如果你需要auto，那么你可以使用模板函数。</p>\n<p>但是，如果要写lambda表达式，要想使用模板的语法来声明入参类型和返回值就太过麻烦了，毕竟lambda就是用来简化functor的编写的。此时C++规定可以在lambda中使用auto来起到模板函数中的Param及T的效果，但此时auto只是模板函数的一种简写，推导规则依然以模板为准，也就是说，initializer-list此时不受支持。</p>\n<h1 id=\"template-typedef\"><a href=\"#template-typedef\" class=\"headerlink\" title=\"template typedef\"></a>template typedef</h1><p>考虑你有一个模板：</p>\n<p>map&lt;Key, Value&gt;</p>\n<p>如果你想要声明一个模板别名：</p>\n<p>template <typename Value> using IntKeyMap = map&lt;int, Value&gt;;</p>\n<p>你会发现C++编译器阻止你这样做。这不是正确的C++语法。但是，为了达到我们的目的，可以这样做：</p>\n<p>template <typename Value></p>\n<p>struct BindedIntMap {</p>\n<p>using type = map&lt;int, Value&gt;;</p>\n<p>}</p>\n<p>然后，就可以通过BindedIntMap::type来表示前面我们想要的类型了。事实上这种做法在C++标准库中非常普遍，so get used to it!</p>\n<p>上面的写法还导出一个经常被人们忽视的细节：如果我们将BindedIntMap作为模板参数实例化模板，会怎么样？比如：</p>\n<p>template <typename T></p>\n<p>void test() {</p>\n<p>T::type<int> map;</p>\n<p>}</p>\n<p>考虑一下可怜的编译器要怎么理解上面的T::type<int>，T::type是一个static变量？一个类型？还是一个模板？不同的场景上面的语句有不同的解释，编译器要到真正实例化时才能弄清楚这句代码的意图，但那有点太晚了，能不能在编译时期就确定代码的意图？答案：<a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords%E3%80%82\">https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords。</a></p>\n<p>如果T::type是一个类型，那么需要使用typename：</p>\n<p>typename T::type map;</p>\n<p>但是如果T::type是一个模板，语法又稍微有些区别：</p>\n<p>T::template type<int> map;</p>\n<p>上面的两个例子都无法正常编译，因为很多时候这两个技巧要结合起来才是正确的模板类型声明：</p>\n<p>typename T::template type<int> map;</p>\n<p>语言设计上的精巧和持续超出初学者的预期，这就是C++的魅力。。。</p>\n<h1 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h1><p>C++标准规定，任何一个函数都可以被隐式的转换成函数指针，给定void test(int)，下面几种写法，最终的结果都会是一个void(*)(int)类型的指针：</p>\n<p>*test</p>\n<p>&amp;test</p>\n<p>test</p>\n<p>****test</p>\n<p>C++允许使用一个函数指针或者函数来进行函数调用，有了一个C++的函数指针：void(*ptrFunc)(int)，下面几种写法都是合法的函数调用：</p>\n<p>(*ptrFunc)(1);</p>\n<p>ptrFunc(1);</p>\n<p>(<strong>**</strong>ptrFunc)(1);</p>\n<p>再次感叹，C++的魅力。</p>\n<h1 id=\"模板重载\"><a href=\"#模板重载\" class=\"headerlink\" title=\"模板重载\"></a>模板重载</h1><p>函数重载指的是拥有不同的参数类型或者数量的不同函数可以拥有同样的名称。当我们说不同类型的参数时，要记得const和volatile也是类型的一部分。</p>\n<p>如果要为不同类型的参数实现一套完全相同的算法，那么可以为每个类型的参数编写函数，不过C++提供了函数模板来简化这个工作。</p>\n<h1 id=\"SFINAE\"><a href=\"#SFINAE\" class=\"headerlink\" title=\"SFINAE\"></a>SFINAE</h1><p>Substitution failure is not an error，替换失败并不是错误。</p>\n<p>指的是在进行模板实例化时，如果编译器遇到了错误，就会认为这种实例化是ill-formed，并放弃进行实例化，转而寻找其他特化。</p>\n<p>需要注意的是，在C++11中，SFINAE只在“immediate context”中生效，也就是模板参数和函数参数/返回类型实例化阶段生效，函数body内部的”substitution failure”依然会导致error。</p>\n<p>要想理解C++11的std标准库提供的各式各样的模板，必须要对SFINAE、函数重载决议、模板特化规则等常规OO风格的C++中不太被提及的方面非常了解和熟悉，然后还要多看些模板元编程的设计惯例、模式，否则生啃标准源码的效率会很低，正常的C++书籍中对于模板编程一般不会有非常详细的讲解。</p>\n<p>利用SFINAE，我们得以通过模板编程技巧指定一个模板可接受的参数类型特征，为模板指定明确的重载规则。</p>\n<h1 id=\"临时对象\"><a href=\"#临时对象\" class=\"headerlink\" title=\"临时对象\"></a>临时对象</h1><p>C++中，一个表达式可能由多个子表达式构成，标准并未明确各个语义上无依赖关系的子表达式的求值顺序，不要认为最左边的表达式会被率先求值。如果多个表达式之间没有语法上的依赖关系，只有语义上的依赖关系，那么必须要将这些表达式放在不同的行，明确指定求值顺序。</p>\n<p>如果子表达式会导致产生临时对象，那么这个临时对象会在整个表达式求值结束后才会被析构、回收内存。不过，标准在这方面有个非常特殊的规定：一个const引用可以短暂地延长临时对象的生命，临时对象若被赋给引用，则这个临时对象的生命期会被延长到引用无效，或者是临时对象所在作用域结束时。</p>\n<h1 id=\"C风格变长参数\"><a href=\"#C风格变长参数\" class=\"headerlink\" title=\"C风格变长参数\"></a>C风格变长参数</h1><p><a href=\"https://zh.cppreference.com/w/c/variadic\">https://zh.cppreference.com/w/c/variadic</a></p>\n<p>C中可以在函数声明中使用…代表任意数量任意类型的参数，但是…前面必须至少存在一个具名参数：</p>\n<p>void test(char* buf, size_t length, …);</p>\n<p>被…代表的参数会经历参数类型提升，整数类型的char和boolean都会被提升为int，而float类型会被提升为double。</p>\n<p>为了在函数体中使用变长参数，必须使用&lt;stdarg.h&gt;库提供的工具方法：</p>\n<ul>\n<li>va_start</li>\n<li>va_arg</li>\n<li>va_end</li>\n<li>va_list</li>\n</ul>\n<p>上面的方法都是宏方法，安全性需要使用者自行保证，如果调用va_arg次数超出了实际传入的变长参数个数，其行为是未定义的。</p>\n<p>文档中对此没有过多解释，直接提供了两个例子：</p>\n<p>如何在函数体中使用变长参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdarg.h&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">void simple_printf(const char* fmt, ...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    va_list args;</span><br><span class=\"line\">    va_start(args, fmt);</span><br><span class=\"line\"> </span><br><span class=\"line\">    while (*fmt !&#x3D; &#39;\\0&#39;) &#123;</span><br><span class=\"line\">        if (*fmt &#x3D;&#x3D; &#39;d&#39;) &#123;</span><br><span class=\"line\">            int i &#x3D; va_arg(args, int);</span><br><span class=\"line\">            printf(&quot;%d\\n&quot;, i);</span><br><span class=\"line\">        &#125; else if (*fmt &#x3D;&#x3D; &#39;c&#39;) &#123;</span><br><span class=\"line\">            &#x2F;&#x2F; 将提升 &#39;char&#39; 类型值为 &#39;int&#39;</span><br><span class=\"line\">            &#x2F;&#x2F; C 中字符常量自身为 &#39;int&#39; 类型</span><br><span class=\"line\">            int c &#x3D; va_arg(args, int);</span><br><span class=\"line\">            printf(&quot;%c\\n&quot;, c);</span><br><span class=\"line\">        &#125; else if (*fmt &#x3D;&#x3D; &#39;f&#39;) &#123;</span><br><span class=\"line\">            double d &#x3D; va_arg(args, double);</span><br><span class=\"line\">            printf(&quot;%f\\n&quot;, d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ++fmt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    va_end(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    simple_printf(&quot;dcff&quot;, 3, &#39;a&#39;, 1.999, 42.5); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>如何将变长参数转发给另一个接受变长参数的函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;time.h&gt;</span><br><span class=\"line\">#include &lt;stdarg.h&gt;</span><br><span class=\"line\"> </span><br><span class=\"line\">void tlog(const char* fmt,...)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    char msg[50];</span><br><span class=\"line\">    strftime(msg, sizeof msg, &quot;%T&quot;, localtime(&amp;(time_t)&#123;time(NULL)&#125;));</span><br><span class=\"line\">    printf(&quot;[%s] &quot;, msg);</span><br><span class=\"line\">    va_list args;</span><br><span class=\"line\">    va_start(args, fmt);</span><br><span class=\"line\">    vprintf(fmt, args);</span><br><span class=\"line\">    va_end(args);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   tlog(&quot;logging %d %d %d...\\n&quot;, 1, 2, 3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"栈上对象销毁顺序\"><a href=\"#栈上对象销毁顺序\" class=\"headerlink\" title=\"栈上对象销毁顺序\"></a>栈上对象销毁顺序</h1><p>栈上对象总是以和创建顺序相反的顺序被销毁。</p>\n<h1 id=\"委托构造函数\"><a href=\"#委托构造函数\" class=\"headerlink\" title=\"委托构造函数\"></a>委托构造函数</h1><p>C++11起，可以使用委托构造函数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">public: </span><br><span class=\"line\">  Foo(char x, int y) &#123;&#125;</span><br><span class=\"line\">  Foo(int y) : Foo(&#39;a&#39;, y) &#123;&#125; &#x2F;&#x2F; Foo(int) 委托到 Foo(char,int)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"模板特化与实例化\"><a href=\"#模板特化与实例化\" class=\"headerlink\" title=\"模板特化与实例化\"></a>模板特化与实例化</h1><h2 id=\"特化\"><a href=\"#特化\" class=\"headerlink\" title=\"特化\"></a>特化</h2><p>模板特化分为全特化和偏特化，使用template&lt;&gt;关键字进行模板特化，介绍：</p>\n<p><a href=\"https://harttle.land/2015/10/03/cpp-template.html\">https://harttle.land/2015/10/03/cpp-template.html</a></p>\n<h2 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h2><p>实例化分为显式实例化和隐式实例化，隐式实例化就是编译期间按需根据模板头文件生成实际代码，显式实例化则是不论是否需要进行模板实例化，编译时都会生成一份指定的代码参与编译。</p>\n<p>显式实例化使用不带模板类型部分的template关键字进行，在对类进行显式实例化时，必须提供所有static属性的定义，定义static属性时要使用和特化类似的语法：template &lt;&gt; VAR_TYPE TYPE::sVar = …。</p>\n"},{"title":"智能指针引用","date":"2020-12-31T15:59:00.000Z","abbrlink":13006,"cover":"img/cpp.png","_content":"# [Passing const shared_ptr& versus just shared_ptr as parameter](https://stackoverflow.com/questions/37610494/passing-const-shared-ptrt-versus-just-shared-ptrt-as-parameter)","source":"_posts/cplus_md/CPlus Basic/智能指针引用.md","raw":"---\ntitle: 智能指针引用\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 使用教程\nabbrlink: 13006\ncover: img/cpp.png\n---\n# [Passing const shared_ptr& versus just shared_ptr as parameter](https://stackoverflow.com/questions/37610494/passing-const-shared-ptrt-versus-just-shared-ptrt-as-parameter)","slug":"cplus_md/CPlus Basic/智能指针引用","published":1,"updated":"2021-04-09T14:06:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6e004dw9q90obwh43p","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"Passing-const-shared-ptr-amp-versus-just-shared-ptr-as-parameter\"><a href=\"#Passing-const-shared-ptr-amp-versus-just-shared-ptr-as-parameter\" class=\"headerlink\" title=\"Passing const shared_ptr&amp; versus just shared_ptr as parameter\"></a><a href=\"https://stackoverflow.com/questions/37610494/passing-const-shared-ptrt-versus-just-shared-ptrt-as-parameter\">Passing const shared_ptr&amp; versus just shared_ptr as parameter</a></h1>","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"Passing-const-shared-ptr-amp-versus-just-shared-ptr-as-parameter\"><a href=\"#Passing-const-shared-ptr-amp-versus-just-shared-ptr-as-parameter\" class=\"headerlink\" title=\"Passing const shared_ptr&amp; versus just shared_ptr as parameter\"></a><a href=\"https://stackoverflow.com/questions/37610494/passing-const-shared-ptrt-versus-just-shared-ptrt-as-parameter\">Passing const shared_ptr&amp; versus just shared_ptr as parameter</a></h1>"},{"title":"C++ 并发编程","date":"2020-12-31T15:59:00.000Z","abbrlink":13003,"cover":"img/cpp.png","_content":"# C++ 并发编程\n\n自C++11标准以来，C++语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。\n\n## 为什么要并发编程\n\n大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。\n\n另一方面，自上个世纪六七十年代英特尔创始人之一 [Gordon Moore](https://en.wikipedia.org/wiki/Gordon_Moore) 提出 [摩尔定义](https://en.wikipedia.org/wiki/Moore's_law) 以来，CPU频率以每18个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。\n\n由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。\n\n本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。\n\n## 并发与并行\n\n并发（Concurrent）与并行（Parallel）都是很常见的术语。\n\nErlang之父Joe Armstrong曾经以人们使用咖啡机的场景为例描述了这两个术语。如下图所示：\n\n![img](C++ 并发编程/con_and_par.jpg)\n\n- **并发**：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。\n- **并行**：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。\n\n这里队列中的每个人类比于计算机的任务，咖啡机类比于计算机处理器。因此：并发和并行都是在多任务的环境下的讨论。\n\n更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。\n\n你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。\n\n在不考虑处理器数量的情况下，我们统称之为“并发”。\n\n## 进程与线程\n\n进程与线程是操作系统的基本概念。无论是桌面系统：MacOS，Linux，Windows，还是移动操作系统：Android，iOS，都存在进程和线程的概念。\n\n> **进程**（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；\n>\n> **线程**（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。\n>\n> – 维基百科\n\n关于这两个概念在任何一本操作系统书上都可以找到定义。网上也有很多文章对它们进行了解释。因此这里不再赘述，这里仅仅提及一下它们与编程的关系。\n\n对于绝大部分编程语言或者编程环境来说，我们所写的程序都会在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为主线程。\n\n在默认的情况下，我们写的代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。\n\n不同编程语言的线程环境会不一样，Java语言在很早就支持了多线程接口。（Java程序在Java虚拟机中运行，虚拟机通常还会包含自己特有的线程，例如垃圾回收线程。）。而对于JavaScript这样的语言来说，它就没有多线程的概念。\n\n当我们只有一个处理器时，所有的进程或线程会分时占用这个处理器。但如果系统中存在多个处理器时，则就可能有多个任务并行的运行在不同的处理器上。\n\n下面两幅图以不同颜色的矩形代表不同的任务（可能是进程，也可能是线程）来描述它们可能在处理器上执行的顺序。\n\n下图是单核处理器的情况：\n\n<img src=\"C++ 并发编程/single_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n下面是四核处理器的情况：\n\n<img src=\"C++ 并发编程/four_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n任务会在何时占有处理器，通常是由操作系统的调度策略决定的。在[《Android系统上的进程管理：进程的调度》](https://paul.pub/android-process-schedule/)一文中，我们介绍过Linux的调度策略。\n\n当我们在开发跨平台的软件时，我们不应当对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。\n\n## 并发系统的性能\n\n开发并发系统最主要的动机就是提升系统性能（事实上，这是以增加复杂度为代价的）。\n\n但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。\n\n因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。\n\n关于这一点，你可能需要了解一下[阿姆达尔定律](https://en.wikipedia.org/wiki/Amdahl's_law)了。对于这个定律，简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。\n\n关于阿姆达尔定律在[Linux系统监测工具sysstat介绍](https://paul.pub/sysstat/#id-阿姆达尔定律)一文中已经介绍过，因此这里不再赘述。\n\n# C++与并发编程\n\n前面我们已经了解到，并非所有的语言都提供了多线程的环境。\n\n即便是C++语言，直到[C++11](https://en.wikipedia.org/wiki/C%2B%2B11)标准之前，也是没有多线程支持的。在这种情况下，Linux/Unix平台下的开发者通常会使用[POSIX Threads](https://en.wikipedia.org/wiki/POSIX_Threads)，Windows上的开发者也会有[相应的接口](https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-cpp-and-mfc?view=vs-2019)。但很明显，这些API都只针对特定的操作系统平台，可移植性较差。如果要同时支持Linux和Windows系统，你可能要写两套代码。\n\n> 相较而言，Java自JDK 1.0就包含了多线程模型。\n\n这个状态在C++ 11标准发布之后得到了改变。并且，在C++ 14和C++ 17标准中又对并发编程机制进行了增强。\n\n下图是最近几个版本的C++标准特性的线路图。\n\n<img src=\"C++ 并发编程/cpp_timeline.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n## 编译器与C++标准\n\n编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。\n\n- GCC对于C++特性的支持请参见这里：[C++ Standards Support in GCC](https://www.gnu.org/software/gcc/projects/cxx-status.html)。\n- Clang对于C++特性的支持请参见这里：[C++ Support in Clang](https://clang.llvm.org/cxx_status.html)。\n\n下面两个表格列出了C++标准和相应编译器的版本对照：\n\n- C++标准与相应的GCC版本要求如下：\n\n| C++版本 | GCC版本 |\n| :------ | :------ |\n| C++11   | 4.8     |\n| C++14   | 5.0     |\n| C++17   | 7.0     |\n\n- C++标准与相应的Clang版本要求如下：\n\n| C++版本 | Clang版本 |\n| :------ | :-------- |\n| C++11   | 3.3       |\n| C++14   | 3.4       |\n| C++17   | 5.0       |\n\n默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数`-std=c++xx`告知编译器，例如：\n\n```shell\ng++ -std=c++17 your_file.cpp -o your_program\n```\n\n# 测试环境\n\n本文的源码可以到下载我的github上获取，地址：[paulQuei/cpp-concurrency](https://github.com/paulQuei/cpp-concurrency)。\n\n你可以直接通过下面这条命令获取源码：\n\n```\ngit clone https://github.com/paulQuei/cpp-concurrency.git\n```\n\n源码下载之后，你可以通过任何文本编辑器浏览源码。如果希望编译和运行程序，你还需要按照下面的内容来准备环境。\n\n本文中的源码使用[cmake](https://cmake.org/)编译，只有cmake 3.8以上的版本才支持C++ 17，所以你需要安装这个或者更新版本的cmake。\n\n另外，截止目前（2019年10月）为止，`clang`编译器还不支持[并行算法](https://paul.pub/cpp-concurrency/#id-并行算法)。\n\n但是[gcc-9](https://gcc.gnu.org/gcc-9/changes.html)是支持的。因此想要编译和运行这部分代码，你需要安装gcc 9.0或更新的版本。并且，gcc-9还要依赖[Intel Threading Building Blocks](https://github.com/intel/tbb)才能使用并行算法以及`<execution>`头文件。\n\n具体的安装方法见下文。\n\n> 具体编译器对于C++特性支持的情况请参见这里：[C++ compiler support](https://en.cppreference.com/w/cpp/compiler_support)。\n\n安装好之后运行根目录下的下面这个命令即可：\n\n```shell\n ./make_all.sh\n```\n\n它会完成所有的编译工作。\n\n本文的源码在下面两个环境中经过测试，环境的准备方法如下。\n\n## MacOS\n\n在Mac上，我使用[brew](https://brew.sh/)工具安装`gcc`以及`tbb`库。\n\n考虑到其他人与我的环境可能会有所差异，所以需要手动告知`tbb`库的安装路径。\n\n读者需要执行下面这些命令来准备环境：\n\n```shell\nbrew install gcc\nbrew install tbb\n\nexport tbb_path=/usr/local/Cellar/tbb/2019_U8/\n./make_all.sh\n```\n\n注意，请通过运行`g++-9`命令以确认gcc的版本是否正确，如果版本较低，则需要通过`brew`命令将其升级到新版本：\n\n```shell\nbrew upgrade gcc\n```\n\n## Ubuntu\n\nUbuntu上，通过下面的命令安装`gcc-9`。\n\n```shell\nsudo add-apt-repository ppa:ubuntu-toolchain-r/test\nsudo apt-get update\nsudo apt install  gcc-9 g++-9\n```\n\n但安装`tbb`库就有些麻烦了。这是因为[Ubuntu 16.04默认关联的版本是较低的](https://launchpad.net/ubuntu/+source/tbb)，直接安装是无法使用的。我们需要安装[更新的版本](https://launchpad.net/ubuntu/+source/tbb/2019~U8-1)。\n\n联网安装的方式[步骤繁琐](https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f)，所以可以通过下载包的方式进行安装，我已经将这需要的两个文件放到的这里：\n\n- [libtbb2_2019~U8-1_amd64.deb](https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb2_2019~U8-1_amd64.deb)\n- [libtbb-dev_2019~U8-1_amd64.deb](https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb-dev_2019~U8-1_amd64.deb)\n\n如果需要，你可以下载后通过`apt`命令安装即可：\n\n```shell\nsudo apt install ~/Downloads/libtbb2_2019~U8-1_amd64.deb \nsudo apt install ~/Downloads/libtbb-dev_2019~U8-1_amd64.deb \n```\n\n# 线程\n\n## 创建线程\n\n创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：\n\n```c++\n// 01_hello_thread.cpp\n\n#include <iostream>\n#include <thread> // ①\n\nusing namespace std; // ②\n\nvoid hello() { // ③\n  cout << \"Hello World from new thread.\" << endl;\n}\n\nint main() {\n  thread t(hello); // ④\n  t.join(); // ⑤\n\n  return 0;\n}\n```\n\n对于这段代码说明如下：\n\n1. 为了使用多线程的接口，我们需要`#include <thread>`头文件。\n2. 为了简化声明，本文中的代码都将`using namespace std;`。\n3. 新建线程的入口是一个普通的函数，它并没有什么特别的地方。\n4. 创建线程的方式就是构造一个`thread`对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。\n5. 关于`join`函数在下文中讲解。\n\n`thread`可以和`callable`类型一起工作，因此如果你熟悉[lambda表达式](https://en.cppreference.com/w/cpp/language/lambda)，你可以直接用它来写线程的逻辑，像这样：\n\n```c++\n// 02_lambda_thread.cpp\n\n#include <iostream>\n#include <thread>\n\nusing namespace std;\n\nint main() {\n  thread t([] {\n    cout << \"Hello World from lambda thread.\" << endl;\n  });\n\n  t.join();\n\n  return 0;\n}\n```\n\n> 为了减少不必要的重复，若无必要，下文中的代码将不贴出`include`指令以及`using`声明。\n\n当然，你可以传递参数给入口函数，像下面这样：\n\n```c++\n// 03_thread_argument.cpp\n\nvoid hello(string name) {\n  cout << \"Welcome to \" << name << endl;\n}\n\nint main() {\n  thread t(hello, \"https://paul.pub\");\n  t.join();\n\n  return 0;\n}\n```\n\n不过需要注意的是，参数是以拷贝的形式进行传递的。因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文`detach`），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。\n\n## join与detach\n\n- 主要API\n\n| API    | 说明               |\n| :----- | :----------------- |\n| join   | 等待线程完成其执行 |\n| detach | 允许线程独立执行   |\n\n一旦启动线程之后，我们必须决定是要等待直接它结束（通过`join`），还是让它独立运行（通过`detach`），我们必须二者选其一。如果在`thread`对象**销毁的时候**我们还没有做决定，则`thread`对象在析构函数出将调用`std::terminate()`从而导致我们的进程异常退出。\n\n> 请思考在上面的代码示例中，`thread`对象在何时会销毁。\n\n需要注意的是：在我们做决定的时候，很可能线程已经执行完了（例如上面的示例中线程的逻辑仅仅是一句打印，执行时间会很短）。新的线程创建之后，究竟是新的线程先执行，还是当前线程的下一条语句先执行这是不确定的，因为这是由操作系统的调度策略决定的。不过这不要紧，我们只要在`thread`对象销毁前做决定即可。\n\n- `join`：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。\n- `detach`：`detach`是让目标线程成为守护线程（daemon threads）。一旦`detach`之后，目标线程将独立执行，即便其对应的`thread`对象销毁也不影响线程的执行。并且，你无法再与之通信。\n\n对于这两个接口，都必须是可执行的线程才有意义。你可以通过`joinable()`接口查询是否可以对它们进行`join`或者`detach`。\n\n## 管理当前线程\n\n- 主要API\n\n| API         | C++标准 | 说明                                 |\n| :---------- | :------ | :----------------------------------- |\n| yield       | C++11   | 让出处理器，重新调度各执行线程       |\n| get_id      | C++11   | 返回当前线程的线程 id                |\n| sleep_for   | C++11   | 使当前线程的执行停止指定的时间段     |\n| sleep_until | C++11   | 使当前线程的执行停止直到指定的时间点 |\n\n上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。\n\n- `yield` 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。\n- `get_id` 返回当前线程的id，可以以此来标识不同的线程。\n- `sleep_for` 是让当前线程停止一段时间。\n- `sleep_until` 和`sleep_for`类似，但是是以具体的时间点为参数。这两个API都以[chrono](https://en.cppreference.com/w/cpp/header/chrono) API（由于篇幅所限，这里不展开这方面内容）为基础。\n\n下面是一个代码示例：\n\n```c++\n// 04_thread_self_manage.cpp\n\nvoid print_time() {\n  auto now = chrono::system_clock::now();\n  auto in_time_t = chrono::system_clock::to_time_t(now);\n\n  std::stringstream ss;\n  ss << put_time(localtime(&in_time_t), \"%Y-%m-%d %X\");\n  cout << \"now is: \" << ss.str() << endl;\n}\n\nvoid sleep_thread() {\n  this_thread::sleep_for(chrono::seconds(3));\n  cout << \"[thread-\" << this_thread::get_id() << \"] is waking up\" << endl;\n}\n\nvoid loop_thread() {\n  for (int i = 0; i < 10; i++) {\n    cout << \"[thread-\" << this_thread::get_id() << \"] print: \" << i << endl;\n  }\n}\n\nint main() {\n  print_time();\n\n  thread t1(sleep_thread);\n  thread t2(loop_thread);\n\n  t1.join();\n  t2.detach();\n\n  print_time();\n  return 0;\n}\n```\n\n这段代码应该还是比较容易理解的，这里创建了两个线程。它们都会有一些输出，其中一个会先停止3秒钟，然后再输出。主线程调用`join`会一直卡住等待它运行结束。\n\n这段程序的输出如下：\n\n```shell\nnow is: 2019-10-13 10:17:48\n[thread-0x70000cdda000] print: 0\n[thread-0x70000cdda000] print: 1\n[thread-0x70000cdda000] print: 2\n[thread-0x70000cdda000] print: 3\n[thread-0x70000cdda000] print: 4\n[thread-0x70000cdda000] print: 5\n[thread-0x70000cdda000] print: 6\n[thread-0x70000cdda000] print: 7\n[thread-0x70000cdda000] print: 8\n[thread-0x70000cdda000] print: 9\n[thread-0x70000cd57000] is waking up\nnow is: 2019-10-13 10:17:51\n```\n\n## 一次调用\n\n- 主要API\n\n| API       | C++标准 | 说明                                           |\n| :-------- | :------ | :--------------------------------------------- |\n| call_once | C++11   | 即便在多线程环境下，也能保证只调用某个函数一次 |\n| once_flag | C++11   | 与`call_once`配合使用                          |\n\n在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。\n\n下面就是一个示例：有三个线程都会使用`init`函数，但是只会有一个线程真正执行它。\n\n```c++\n// 05_call_once.cpp\n\nvoid init() {\n  cout << \"Initialing...\" << endl;\n  // Do something...\n}\n\nvoid worker(once_flag* flag) {\n  call_once(*flag, init);\n}\n\nint main() {\n  once_flag flag;\n\n  thread t1(worker, &flag);\n  thread t2(worker, &flag);\n  thread t3(worker, &flag);\n\n  t1.join();\n  t2.join();\n  t3.join();\n\n  return 0;\n}\n```\n\n我们无法确定具体是哪一个线程会执行`init`。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。\n\n> 请思考一下，为什么要在main函数中创建`once_flag flag`。如果是在`worker`函数中直接声明一个`once_flag`并使用行不行？为什么？\n\n# 并发任务\n\n下面以一个并发任务为示例讲解如何引入多线程。\n\n任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如`[1, 10e8]`。\n\n在单线程模型下，我们的代码可能是这样的：\n\n```c++\n// 06_naive_multithread.cpp\n\nstatic const int MAX = 10e8; // ①\nstatic double sum = 0; // ②\n\nvoid worker(int min, int max) { // ③\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n}\n\nvoid serial_task(int min, int max) { // ④\n  auto start_time = chrono::steady_clock::now();\n  sum = 0;\n  worker(0, MAX);\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Serail task finish, \" << ms << \" ms consumed, Result: \" << sum << endl;\n}\n```\n\n这段代码说明如下：\n\n1. 通过一个常量指定数据范围，这个是为了方便调整。\n2. 通过一个全局变量来存储结果。\n3. 通过一个任务函数来计算值。\n4. 统计任务的执行时间。\n\n这段程序输出如下：\n\n```shell\nSerail task finish, 6406 ms consumed, Result: 2.10819e+13\n```\n\n很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。\n\n下面我们就尝试以多线程的方式来改造原先的程序。\n\n改造后的程序如下：\n\n```c++\n// 06_naive_multithread.cpp\n\nvoid concurrent_task(int min, int max) {\n  auto start_time = chrono::steady_clock::now();\n\n  unsigned concurrent_count = thread::hardware_concurrency(); // ①\n  cout << \"hardware_concurrency: \" << concurrent_count << endl;\n  vector<thread> threads;\n  min = 0;\n  sum = 0;\n  for (int t = 0; t < concurrent_count; t++) { // ②\n    int range = max / concurrent_count * (t + 1);\n    threads.push_back(thread(worker, min, range)); // ③\n    min = range + 1;\n  }\n  for (auto& t : threads) {\n    t.join(); // ④\n  }\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed, Result: \" << sum << endl;\n}\n```\n\n这段代码说明如下：\n\n1. `thread::hardware_concurrency()`可以获取到当前硬件支持多少个线程并行执行。\n2. 根据处理器的情况决定线程的数量。\n3. 对于每一个线程都通过`worker`函数来完成任务，并划分一部分数据给它处理。\n4. 等待每一个线程执行结束。\n\n很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：\n\n```shell\nhardware_concurrency: 16\nConcurrent task finish, 6246 ms consumed, Result: 1.78162e+12\n```\n\n很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。\n\n要搞清楚为什么结果不正确我们需要更多的背景知识。\n\n我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：\n\n> 事实上，目前大部分CPU的缓存已经不只一层。\n\n<img src=\"C++ 并发编程/cpu.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。\n\n事情还远不止这么简单。我们对于全局变量值的修改：`sum += sqrt(i);`这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：\n\n<img src=\"C++ 并发编程/multithread.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n在时间点a的时候，所有线程对于`sum`变量的值是一致的。\n\n但是在时间点b之后，thread3上已经对`sum`进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。\n\n## 竞争条件与临界区\n\n当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为[**竞争条件**（race condition）](https://en.wikipedia.org/wiki/Race_condition)。\n\n访问共享数据的代码片段称之为**临界区**（critical section）。具体到上面这个示例，临界区就是读写`sum`变量的地方。\n\n要避免竞争条件，就需要对临界区进行数据保护。\n\n很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。\n\n那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。\n\n接下来介绍的API提供的就是这样的功能。\n\n# 互斥体与锁\n\n## mutex\n\n开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：\n\n1. 独立的对于划分给自己的数据的处理\n2. 对于处理结果的汇总\n\n其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的`sum`变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。`mutex` 就提供了这样的功能。\n\n`mutex`是**mut**ual **ex**clusion（互斥）的简写。\n\n- 主要API\n\n| API                   | C++标准 | 说明                                             |\n| :-------------------- | :------ | :----------------------------------------------- |\n| mutex                 | C++11   | 提供基本互斥设施                                 |\n| timed_mutex           | C++11   | 提供互斥设施，带有超时功能                       |\n| recursive_mutex       | C++11   | 提供能被同一线程递归锁定的互斥设施               |\n| recursive_timed_mutex | C++11   | 提供能被同一线程递归锁定的互斥设施，带有超时功能 |\n| shared_timed_mutex    | C++14   | 提供共享互斥设施并带有超时功能                   |\n| shared_mutex          | C++17   | 提供共享互斥设施                                 |\n\n很明显，在这些类中，`mutex`是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：\n\n| 方法     | 说明                                 |\n| -------- | ------------------------------------ |\n| lock     | 锁定互斥体，如果不可用，则阻塞       |\n| try_lock | 尝试锁定互斥体，如果不可用，直接返回 |\n| unlock   | 解锁互斥体                           |\n\n这三个方法提供了基础的锁定和解除锁定的功能。使用`lock`意味着你有很强的意愿一定要获取到互斥体，而使用`try_lock`则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。\n\n在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：\n\n- **超时**：`timed_mutex`，`recursive_timed_mutex`，`shared_timed_mutex`的名称都带有`timed`，这意味着它们都支持超时功能。它们都提供了`try_lock_for`和`try_lock_until`方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。\n- **可重入**：`recursive_mutex`和`recursive_timed_mutex`的名称都带有`recursive`。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。\n- **共享**：`shared_timed_mutex`和`shared_mutex`提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在[读者写者模型](https://en.wikipedia.org/wiki/Readers–writers_problem)上。\n\n使用共享锁的接口如下：\n\n| 方法            | 说明                                   |\n| --------------- | -------------------------------------- |\n| lock_shared     | 获取互斥体的共享锁，如果无法获取则阻塞 |\n| try_lock_shared | 尝试获取共享锁，如果不可用，直接返回   |\n| unlock_shared   | 解锁共享锁                             |\n\n接下来，我们就借助刚学到的`mutex`来改造我们的并发系统，改造后的程序如下：\n\n```c++\n// 07_mutex_lock.cpp\n\nstatic const int MAX = 10e8;\nstatic double sum = 0;\n\nstatic mutex exclusive;\n\nvoid concurrent_worker(int min, int max) {\n  for (int i = min; i <= max; i++) {\n    exclusive.lock(); // ①\n    sum += sqrt(i);\n    exclusive.unlock(); // ②\n  }\n}\n\nvoid concurrent_task(int min, int max) {\n  auto start_time = chrono::steady_clock::now();\n\n  unsigned concurrent_count = thread::hardware_concurrency();\n  cout << \"hardware_concurrency: \" << concurrent_count << endl;\n  vector<thread> threads;\n  min = 0;\n  sum = 0;\n  for (int t = 0; t < concurrent_count; t++) {\n    int range = max / concurrent_count * (t + 1);\n    threads.push_back(thread(concurrent_worker, min, range)); // ③\n    min = range + 1;\n  }\n  for (int i = 0; i < threads.size(); i++) {\n    threads[i].join();\n  }\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed, Result: \" << sum << endl;\n}\n```\n\n这里只有三个地方需要关注：\n\n1. 在访问共享数据之前加锁\n2. 访问完成之后解锁\n3. 在多线程中使用带锁的版本\n\n执行之后结果输出如下：\n\n```shell\nhardware_concurrency: 16\nConcurrent task finish, 74232 ms consumed, Result: 2.10819e+13\n```\n\n这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？\n\n这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。\n\n这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。\n\n不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。\n\n于是我们改造`concurrent_worker`，像下面这样：\n\n```c++\n// 08_improved_mutex_lock.cpp\n\nvoid concurrent_worker(int min, int max) {\n  double tmp_sum = 0;\n  for (int i = min; i <= max; i++) {\n    tmp_sum += sqrt(i); // ①\n  }\n  exclusive.lock(); // ②\n  sum += tmp_sum;\n  exclusive.unlock();\n}\n```\n\n这段代码的改变在于两处：\n\n1. 通过一个局部变量保存当前线程的处理结果\n2. 在汇总总结过的时候进行锁保护\n\n运行一下改进后的程序，其结果输出如下：\n\n```shell\nhardware_concurrency: 16\nConcurrent task finish, 451 ms consumed, Result: 2.10819e+13\n```\n\n可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。\n\n我们用锁的**粒度**（granularity）来描述锁的范围。**细粒度**（fine-grained）是指锁保护较小的范围，**粗粒度**（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。\n\n> In general, a lock should be held for only the minimum possible time needed to perform the required operations.\n>\n> –《C++ Concurrency in Action》\n\n## 死锁\n\n死锁是并发系统很常见的一类问题。\n\n死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。\n\n死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。\n\n在成年人的世界里也会发生类似的情况，例如下面这个交通状况：\n\n![img](C++ 并发编程/deadlock.gif)\n\n下面我们来看一个编程示例。\n\n现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。\n\n首先我们创建一个`Account`类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。`Account`类仅仅包含名称和金额两个字段。\n\n另外，为了支持并发，这个类包含了一个`mutex`对象，用来保护账号金额，在读写账号金额时需要先加锁保护。\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nclass Account {\npublic:\n  Account(string name, double money): mName(name), mMoney(money) {};\n\npublic:\n  void changeMoney(double amount) {\n    mMoney += amount;\n  }\n  string getName() {\n    return mName;\n  }\n  double getMoney() {\n    return mMoney;\n  }\n  mutex* getLock() {\n    return &mMoneyLock;\n  }\n\nprivate:\n  string mName;\n  double mMoney;\n  mutex mMoneyLock;\n};\n```\n\n`Account`类很简单，我想就不用多做说明了。\n\n接下来，我们再创建一个描述银行的`Bank`类。\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nclass Bank {\npublic:\n  void addAccount(Account* account) {\n    mAccounts.insert(account);\n  }\n\n  bool transferMoney(Account* accountA, Account* accountB, double amount) {\n    lock_guard guardA(*accountA->getLock()); // ①\n    lock_guard guardB(*accountB->getLock());\n\n    if (amount > accountA->getMoney()) { // ②\n      return false;\n    }\n\n    accountA->changeMoney(-amount); // ③\n    accountB->changeMoney(amount);\n    return true;\n  }\n\n  double totalMoney() const {\n    double sum = 0;\n    for (auto a : mAccounts) {\n      sum += a->getMoney();\n    }\n    return sum;\n  }\n\nprivate:\n  set<Account*> mAccounts;\n};\n```\n\n银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。\n\n这其中，我们最主要要关注转账的实现：`transferMoney`。该方法的几个关键点如下：\n\n1. 为了保证线程安全，在修改每个账号之前，需要获取相应的锁。\n2. 判断转出账户金额是否足够，如果不够此次转账失败。\n3. 进行转账。\n\n有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nvoid randomTransfer(Bank* bank, Account* accountA, Account* accountB) {\n  while(true) {\n    double randomMoney = ((double)rand() / RAND_MAX) * 100;\n    if (bank->transferMoney(accountA, accountB, randomMoney)) {\n      cout << \"Transfer \" << randomMoney << \" from \" << accountA->getName()\n           << \" to \" << accountB->getName()\n           << \", Bank totalMoney: \" << bank->totalMoney() << endl;\n    } else {\n      cout << \"Transfer failed, \"\n           << accountA->getName() << \" has only $\" << accountA->getMoney() << \", but \"\n           << randomMoney << \" required\" << endl;\n    }\n  }\n}\n```\n\n这里每次生成一个随机数，然后通过银行进行转账。\n\n最后我们在`main`函数中创建两个线程，互相在两个账号之间来回转账：\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nint main() {\n  Account a(\"Paul\", 100);\n  Account b(\"Moira\", 100);\n\n  Bank aBank;\n  aBank.addAccount(&a);\n  aBank.addAccount(&b);\n\n  thread t1(randomTransfer, &aBank, &a, &b);\n  thread t2(randomTransfer, &aBank, &b, &a);\n\n  t1.join();\n  t2.join();\n\n  return 0;\n}\n```\n\n至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：\n\n```shell\n...\nTransfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $34.7581, but 66.3208 required\nTransfer failed, Moira has only $34.7581, but \nTransfer 93.191 from 53.9176 required\nTransfer 60.6146 from Moira to Paul, Bank totalMoney: 200\nTransfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: \nTransfer failed, Moira has only $17.6041, but 18.1186 required\nTransfer failed, Moira has only $17.6041, but 18.893 required\nTransfer failed, Moira has only $17.6041, but 34.7078 required\nTransfer failed, Moira has only $17.6041, but 33.9569 required\nTransfer 12.7899 from 200\nMoira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $63.9373, but 80.9038 required\nTransfer 50.933 from Moira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $13.0043, but 30.2056 required\nTransfer failed, Moira has only $Transfer 59.123 from Paul to Moira, Bank totalMoney: 200\nTransfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required\n```\n\n如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？\n\n因为发生了死锁。\n\n我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：\n\n<img src=\"C++ 并发编程/deadlock.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相`join`就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如`mutex`而非`recursive_mutex`）多次加锁也会死锁。\n\n你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。\n\n如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。\n\n下面我们就来逐步解决上面的问题。\n\n对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：\n\n```c++\n// 10_improved_bank_transfer.cpp\n\nmutex sCoutLock;\nvoid randomTransfer(Bank* bank, Account* accountA, Account* accountB) {\n  while(true) {\n    double randomMoney = ((double)rand() / RAND_MAX) * 100;\n    if (bank->transferMoney(accountA, accountB, randomMoney)) {\n      sCoutLock.lock();\n      cout << \"Transfer \" << randomMoney << \" from \" << accountA->getName()\n          << \" to \" << accountB->getName()\n          << \", Bank totalMoney: \" << bank->totalMoney() << endl;\n      sCoutLock.unlock();\n    } else {\n      sCoutLock.lock();\n      cout << \"Transfer failed, \"\n           << accountA->getName() << \" has only \" << accountA->getMoney() << \", but \"\n           << randomMoney << \" required\" << endl;\n      sCoutLock.unlock();\n    }\n  }\n}\n```\n\n> 请思考一下两处`lock`和`unlock`调用，并考虑为什么不在`while(true)`下面写一次整体的加锁和解锁。\n\n## 通用锁定算法\n\n- 主要API\n\n| API      | C++标准 | 说明                                         |\n| :------- | :------ | :------------------------------------------- |\n| lock     | C++11   | 锁定指定的互斥体，若任何一个不可用则阻塞     |\n| try_lock | C++11   | 试图通过重复调用 try_lock 获得互斥体的所有权 |\n\n要避免死锁，需要仔细的思考和设计业务逻辑。\n\n有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁B，才能玩玩具。这样就不会死锁了。\n\n这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。\n\n不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个[Lockable](https://en.cppreference.com/w/cpp/named_req/Lockable)对象。\n\n接下来我们用它来改造之前死锁的转账系统：\n\n```c++\n// 10_improved_bank_transfer.cpp\n\nbool transferMoney(Account* accountA, Account* accountB, double amount) {\n  lock(*accountA->getLock(), *accountB->getLock());    // ①\n  lock_guard lockA(*accountA->getLock(), adopt_lock);  // ②\n  lock_guard lockB(*accountB->getLock(), adopt_lock);  // ③\n\n  if (amount > accountA->getMoney()) {\n    return false;\n  }\n\n  accountA->changeMoney(-amount);\n  accountB->changeMoney(amount);\n  return true;\n}\n```\n\n这里只改动了3行代码。\n\n1. 这里通过`lock`函数来获取两把锁，标准库的实现会保证不会发生死锁。\n2. `lock_guard`在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建`lock_guard`的目的是为了在`transferMoney`结束的时候释放锁，`lockB`也是一样。但需要注意的是，这里传递了 `adopt_lock`表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加`adopt_lock`就是二次锁定了）。\n\n运行一下这个改造后的程序，其输出如下所示：\n\n```shell\n...\nTransfer failed, Paul has only $1.76243, but 17.5974 required\nTransfer failed, Paul has only $1.76243, but 59.2104 required\nTransfer failed, Paul has only $1.76243, but 49.6379 required\nTransfer failed, Paul has only $1.76243, but 63.6373 required\nTransfer failed, Paul has only $1.76243, but 51.8742 required\nTransfer failed, Paul has only $1.76243, but 50.0081 required\nTransfer failed, Paul has only $1.76243, but 86.1041 required\nTransfer failed, Paul has only $1.76243, but 51.3278 required\nTransfer failed, Paul has only $1.76243, but 66.5754 required\nTransfer failed, Paul has only $1.76243, but 32.1867 required\nTransfer failed, Paul has only $1.76243, but 62.0039 required\nTransfer failed, Paul has only $1.76243, but 98.7819 required\nTransfer failed, Paul has only $1.76243, but 27.046 required\nTransfer failed, Paul has only $1.76243, but 62.9155 required\nTransfer 98.8478 from Moira to Paul, Bank totalMoney: 200\nTransfer 80.0722 from Moira to Paul, Bank totalMoney: 200\nTransfer 73.7035 from Moira to Paul, Bank totalMoney: 200\nTransfer 34.4476 from Moira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $10.0142, but 61.3033 required\nTransfer failed, Moira has only $10.0142, but 24.5595 required\n...\n```\n\n现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。\n\n## 通用互斥管理\n\n- 主要API\n\n| API         | C++标准 | 说明                                   |\n| :---------- | :------ | :------------------------------------- |\n| lock_guard  | C++11   | 实现严格基于作用域的互斥体所有权包装器 |\n| unique_lock | C++11   | 实现可移动的互斥体所有权包装器         |\n| shared_lock | C++14   | 实现可移动的共享互斥体所有权封装器     |\n| scoped_lock | C++17   | 用于多个互斥体的免死锁 RAII 封装器     |\n\n| 锁定策略    | C++标准 | 说明                                                |\n| :---------- | :------ | :-------------------------------------------------- |\n| defer_lock  | C++11   | 类型为 `defer_lock_t`，不获得互斥的所有权           |\n| try_to_lock | C++11   | 类型为`try_to_lock_t`，尝试获得互斥的所有权而不阻塞 |\n| adopt_lock  | C++11   | 类型为`adopt_lock_t`，假设调用方已拥有互斥的所有权  |\n\n互斥体（`mutex`相关类）提供了对于资源的保护功能，但是手动的锁定（调用`lock`或者`try_lock`）和解锁（调用`unlock`）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。\n\n鉴于这个原因，标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。\n\n请看下面的例子：\n\n```c++\n// https://en.cppreference.com/w/cpp/thread/lock_guard\n\n#include <thread>\n#include <mutex>\n#include <iostream>\n \nint g_i = 0;\nstd::mutex g_i_mutex;  // ①\n \nvoid safe_increment()\n{\n  std::lock_guard<std::mutex> lock(g_i_mutex);  // ②\n  ++g_i;\n\n  std::cout << std::this_thread::get_id() << \": \" << g_i << '\\n';\n  // ③\n}\n \nint main()\n{\n  std::cout << \"main: \" << g_i << '\\n';\n \n  std::thread t1(safe_increment); // ④\n  std::thread t2(safe_increment);\n \n  t1.join();\n  t2.join();\n \n  std::cout << \"main: \" << g_i << '\\n';\n}\n```\n\n这段代码中：\n\n1. 全局的互斥体`g_i_mutex`用来保护全局变量`g_i`\n2. 这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用`lock`方法，而是直接使用`lock_guard`来锁定互斥体。\n3. 在方法结束的时候，局部变量`std::lock_guard<std::mutex> lock`会被销毁，它对互斥体的锁定也就解除了。\n4. 在多个线程中使用这个方法。\n\n### RAII\n\n上面的几个类（`lock_guard`，`unique_lock`，`shared_lock`，`scoped_lock`）都使用了一个叫做RAII的编程技巧。\n\nRAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。\n\nRAII是一种[C++编程技术](http://www.stroustrup.com/bs_faq2.html#finally)，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。 RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。\n\nRAII 可总结如下:\n\n- 将每个资源封装入一个类，其中：\n    - 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，\n    - 析构函数释放资源并决不抛出异常；\n- 始终经由 RAII 类的实例使用满足要求的资源，该资源\n    - 自身拥有自动存储期或临时生存期，或\n    - 具有与自动或临时对象的生存期绑定的生存期\n\n回想一下上文中的`transferMoney`方法中的三行代码：\n\n```c++\nlock(*accountA->getLock(), *accountB->getLock());\nlock_guard lockA(*accountA->getLock(), adopt_lock);\nlock_guard lockB(*accountB->getLock(), adopt_lock);\n```\n\n如果使用`unique_lock`这三行代码还有一种等价的写法：\n\n```c++\nunique_lock lockA(*accountA->getLock(), defer_lock);\nunique_lock lockB(*accountB->getLock(), defer_lock);\nlock(*accountA->getLock(), *accountB->getLock());\n```\n\n请注意这里`lock`方法的调用位置。这里先定义`unique_lock`指定了`defer_lock`，因此实际没有锁定互斥体，而是到第三行才进行锁定。\n\n最后，借助`scoped_lock`，我们可以将三行代码合成一行，这种写法也是等价的。\n\n```c++\nscoped_lock lockAll(*accountA->getLock(), *accountB->getLock());\n```\n\n`scoped_lock`会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。\n\n目前，只还有`shared_lock`我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。\n\n## 条件变量\n\n| API                       | C++标准 | 说明                                         |\n| :------------------------ | :------ | :------------------------------------------- |\n| condition_variable        | C++ 11  | 提供与 std::unique_lock 关联的条件变量       |\n| condition_variable_any    | C++ 11  | 提供与任何锁类型关联的条件变量               |\n| notify_all_at_thread_exit | C++ 11  | 安排到在此线程完全结束时对 notify_all 的调用 |\n| cv_status                 | C++ 11  | 列出条件变量上定时等待的可能结果             |\n\n至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了`false`。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。\n\n这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。\n\n条件变量提供了一个可以让多个线程间同步协作的功能。这对于[生产者-消费者模型](https://en.wikipedia.org/wiki/Producer–consumer_problem)很有意义。在这个模型下：\n\n- 生产者和消费者共享一个工作区。这个区间的大小是有限的。\n- 生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。\n- 消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。\n\n从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。\n\n下面我们就借助于条件变量，再次改造之前的银行转账系统。\n\n这个改造主要在于账号类。我们重点是要调整`changeMoney`方法。\n\n```c++\n// 11_bank_transfer_wait_notify.cpp\n\nclass Account {\npublic:\n  Account(string name, double money): mName(name), mMoney(money) {};\n\npublic:\n  void changeMoney(double amount) {\n    unique_lock lock(mMoneyLock); // ②\n    mConditionVar.wait(lock, [this, amount] { // ③\n      return mMoney + amount > 0; // ④\n    });\n    mMoney += amount;\n    mConditionVar.notify_all(); // ⑤\n  }\n\n  string getName() {\n    return mName;\n  }\n\n  double getMoney() {\n    return mMoney;\n  }\n\nprivate:\n  string mName;\n  double mMoney;\n  mutex mMoneyLock;\n  condition_variable mConditionVar; // ①\n};\n```\n\n这几处改动说明如下：\n\n1. 这里声明了一个条件变量，用来在多个线程之间协作。\n2. 这里使用的是`unique_lock`，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。\n3. 这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则**此处会解锁互斥体，并让当前线程等待**。**解锁**这一点非常重要，因为只有这样，才能让其他线程获取互斥体。\n4. 这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读[我之前写的文章](https://paul.pub/cpp-lambda-function-bind/)。\n5. 此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用`wait`线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了`notify_all`还有`notify_one`，它只通知一个等待的线程。`wait`和`notify`就构成了线程间互相协作的工具。\n\n请注意：`wait`和`notify_all`虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。\n\n有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：\n\n```c++\n// 11_bank_transfer_wait_notify.cpp\n\nvoid Bank::transferMoney(Account* accountA, Account* accountB, double amount) {\n    accountA->changeMoney(-amount);\n    accountB->changeMoney(amount);\n}\n```\n\n当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。\n\n```c++\n// 11_bank_transfer_wait_notify.cpp\n\nmutex sCoutLock;\nvoid randomTransfer(Bank* bank, Account* accountA, Account* accountB) {\n  while(true) {\n    double randomMoney = ((double)rand() / RAND_MAX) * 100;\n    {\n      lock_guard guard(sCoutLock);\n      cout << \"Try to Transfer \" << randomMoney\n           << \" from \" << accountA->getName() << \"(\" << accountA->getMoney()\n           << \") to \" << accountB->getName() << \"(\" << accountB->getMoney()\n           << \"), Bank totalMoney: \" << bank->totalMoney() << endl;\n    }\n    bank->transferMoney(accountA, accountB, randomMoney);\n  }\n}\n```\n\n修改完之后的程序运行输出如下：\n\n```shell\n...\nTry to Transfer 13.72 from Moira(10.9287) to Paul(189.071), Bank totalMoney: 200\nTry to Transfer 28.6579 from Paul(189.071) to Moira(10.9287), Bank totalMoney: 200\nTry to Transfer 91.8049 from Paul(160.413) to Moira(39.5866), Bank totalMoney: 200\nTry to Transfer 5.56383 from Paul(82.3285) to Moira(117.672), Bank totalMoney: 200\nTry to Transfer 11.3594 from Paul(76.7646) to Moira(123.235), Bank totalMoney: 200\nTry to Transfer 16.9557 from Paul(65.4053) to Moira(134.595), Bank totalMoney: 200\nTry to Transfer 74.998 from Paul(48.4495) to Moira(151.55), Bank totalMoney: 200\nTry to Transfer 65.3005 from Moira(151.55) to Paul(48.4495), Bank totalMoney: 200\nTry to Transfer 90.6084 from Moira(86.25) to Paul(113.75), Bank totalMoney: 125.002\nTry to Transfer 99.6425 from Moira(70.6395) to Paul(129.36), Bank totalMoney: 200\nTry to Transfer 55.2091 from Paul(129.36) to Moira(70.6395), Bank totalMoney: 200\nTry to Transfer 92.259 from Paul(74.1513) to Moira(125.849), Bank totalMoney: 200\n...\n```\n\n这下比之前都要好了。\n\n但是细心的读者会发现，Bank totalMoney的输出有时候是200，有时候不是。但不管怎样，即便这一次不是，下一次又是了。关于这一点，请读者自行思考一下为什么，以及如何改进。\n\n# future\n\n| API           | C++标准 | 说明                                              |\n| :------------ | :------ | :------------------------------------------------ |\n| async         | C++11   | 异步运行一个函数，并返回保有其结果的`std::future` |\n| future        | C++11   | 等待被异步设置的值                                |\n| packaged_task | C++11   | 打包一个函数，存储其返回值以进行异步获取          |\n| promise       | C++11   | 存储一个值以进行异步获取                          |\n| shared_future | C++11   | 等待被异步设置的值（可能为其他 future 所引用）    |\n\n这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于`<future>`头文件中。\n\n## async\n\n很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。\n\n在C++11中，`async`便是完成这样的功能的。下面是一个代码示例：\n\n```c++\n// 12_async_task.cpp\n\nstatic const int MAX = 10e8;\nstatic double sum = 0;\n\nvoid worker(int min, int max) {\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n}\n\nint main() {\n  sum = 0;\n  auto f1 = async(worker, 0, MAX);\n  cout << \"Async task triggered\" << endl;\n  f1.wait();\n  cout << \"Async task finish, result: \" << sum << endl << endl;\n}\n```\n\n这仍然是我们之前熟悉的例子。这里有两个地方需要说明：\n\n1. 这里以异步的方式启动了任务。它会返回一个`future`对象。`future`用来存储异步任务的执行结果，关于`future`我们在后面`packaged_task`的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。\n2. 此处是等待异步任务执行完成。\n\n需要注意的是，默认情况下，`async`是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过`launch::async`来明确说明。`launch`中有两个常量：\n\n- `async`：运行新线程，以异步执行任务。\n- `deferred`：调用方线程上第一次请求其结果时才执行任务，即惰性求值。\n\n除了通过函数来指定异步任务，还可以lambda表达式的方式来指定。如下所示：\n\n```c++\n// 12_async_task.cpp\n\nint main() {\n\n  double result = 0;\n  cout << \"Async task with lambda triggered, thread: \" << this_thread::get_id() << endl;\n  auto f2 = async(launch::async, [&result]() {\n    cout << \"Lambda task in thread: \" << this_thread::get_id() << endl;\n    for (int i = 0; i <= MAX; i++) {\n      result += sqrt(i);\n    }\n  });\n  f2.wait();\n  cout << \"Async task with lambda finish, result: \" << result << endl << endl;\n  \n  return 0;\n}\n```\n\n在上面这段代码中，我们使用一个lambda表达式来编写异步任务的逻辑，并通过`launch::async`明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。\n\n这段代码输出如下：\n\n```shell\nAsync task with lambda triggered, thread: 0x11290d5c0\nLambda task in thread: 0x700007aa1000\nAsync task with lambda finish, result: 2.10819e+13\n```\n\n对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：\n\n```c++\n// 12_async_task.cpp\n\nclass Worker {\npublic:\n  Worker(int min, int max): mMin(min), mMax(max) {} // ①\n  double work() { // ②\n    mResult = 0;\n    for (int i = mMin; i <= mMax; i++) {\n      mResult += sqrt(i);\n    }\n    return mResult;\n  }\n  double getResult() {\n    return mResult;\n  }\n\nprivate:\n  int mMin;\n  int mMax;\n  double mResult;\n};\n\nint main() {\n  Worker w(0, MAX);\n  cout << \"Task in class triggered\" << endl;\n  auto f3 = async(&Worker::work, &w); // ③\n  f3.wait();\n  cout << \"Task in class finish, result: \" << w.getResult() << endl << endl;\n\n  return 0;\n}\n```\n\n这段代码有三处需要说明：\n\n1. 这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。\n2. `work`函数是任务的主体逻辑。\n3. 通过`async`执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是`&w`，因此传递的是对象的指针。如果不写`&`将传入`w`对象的临时复制。\n\n## packaged_task\n\n在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用`packaged_task`来包装任务。\n\n> 如果你了解设计模式，你应该会知道[命令模式](https://en.wikipedia.org/wiki/Command_pattern)。\n\n`packaged_task`绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的`future`来获取任务的结果。调度程序只需要处理`packaged_task`，而非各个函数。\n\n`packaged_task`对象是一个可调用对象，它可以被封装成一个`std::fucntion`，或者作为线程函数传递给`std::thread`，或者直接调用。\n\n下面是一个代码示例：\n\n```c++\n// 13_packaged_task.cpp\n\ndouble concurrent_worker(int min, int max) {\n  double sum = 0;\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n  return sum;\n}\n\ndouble concurrent_task(int min, int max) {\n  vector<future<double>> results; // ①\n\n  unsigned concurrent_count = thread::hardware_concurrency();\n  min = 0;\n  for (int i = 0; i < concurrent_count; i++) { // ②\n    packaged_task<double(int, int)> task(concurrent_worker); // ③\n    results.push_back(task.get_future()); // ④\n\n    int range = max / concurrent_count * (i + 1);\n    thread t(std::move(task), min, range); // ⑤\n    t.detach();\n\n    min = range + 1;\n  }\n\n  cout << \"threads create finish\" << endl;\n  double sum = 0;\n  for (auto& r : results) {\n    sum += r.get(); // ⑥\n  }\n  return sum;\n}\n\nint main() {\n  auto start_time = chrono::steady_clock::now();\n\n  double r = concurrent_task(0, MAX);\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed, Result: \" << r << endl;\n  return 0;\n}\n```\n\n在这段代码中：\n\n1. 首先创建一个集合来存储`future`对象。我们将用它来获取任务的结果。\n2. 同样的，根据CPU的情况来创建线程的数量。\n3. 将任务包装成`packaged_task`。请注意，由于`concurrent_worker`被包装成了任务，我们无法直接获取它的`return`值。而是要通过`future`对象来获取。\n4. 获取任务关联的`future`对象，并将其存入集合中。\n5. 通过一个新的线程来执行任务，并传入需要的参数。\n6. 通过`future`集合，逐个获取每个任务的计算结果，将其累加。这里`r.get()`获取到的就是每个任务中`concurrent_worker`的返回值。\n\n为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于`packaged_task`将任务组装成队列，然后通过[线程池](https://en.wikipedia.org/wiki/Thread_pool)的方式进行调度：\n\n![image-20210305140102303](C++ 并发编程/image-20210305140102303.png)\n\n## promise与future\n\n在上面的例子中，`concurrent_task`的结果是通过`return`返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。\n\n这个时候，就可以将`promise`与`future`配对使用。这样就可以将返回结果和任务结束两个事情分开。\n\n下面是对上面代码示例的改写：\n\n```c++\n// 14_promise_future.cpp\n\ndouble concurrent_worker(int min, int max) {\n  double sum = 0;\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n  return sum;\n}\n\nvoid concurrent_task(int min, int max, promise<double>* result) { // ①\n  vector<future<double>> results;\n\n  unsigned concurrent_count = thread::hardware_concurrency();\n  min = 0;\n  for (int i = 0; i < concurrent_count; i++) {\n    packaged_task<double(int, int)> task(concurrent_worker);\n    results.push_back(task.get_future()); \n\n    int range = max / concurrent_count * (i + 1);\n    thread t(std::move(task), min, range);\n    t.detach();\n\n    min = range + 1;\n  }\n\n  cout << \"threads create finish\" << endl;\n  double sum = 0;\n  for (auto& r : results) {\n    sum += r.get();\n  }\n  result->set_value(sum); // ②\n  cout << \"concurrent_task finish\" << endl;\n}\n\nint main() {\n  auto start_time = chrono::steady_clock::now();\n\n  promise<double> sum; // ③\n  concurrent_task(0, MAX, &sum);\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed.\" << endl;\n  cout << \"Result: \" << sum.get_future().get() << endl; // ④\n  return 0;\n}\n```\n\n这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：\n\n1. `concurrent_task`不再直接返回计算结果，而是增加了一个`promise`对象来存放结果。\n2. 在任务计算完成之后，将总结过设置到`promise`对象上。一旦这里调用了`set_value`，其相关联的`future`对象就会就绪。\n3. 这里是在`main`中创建一个`promoise`来存放结果，并以指针的形式传递进`concurrent_task`中。\n4. 通过`sum.get_future().get()`来获取结果。第2点中已经说了：一旦调用了`set_value`，其相关联的`future`对象就会就绪。\n\n需要注意的是，`future`对象只有被一个线程获取值。并且在调用`get()`之后，就没有可以获取的值了。如果从多个线程调用`get()`会出现数据竞争，其结果是未定义的。\n\n如果真的需要在多个线程中获取`future`的结果，可以使用`shared_future`。\n\n# 并行算法\n\n从C++17开始。[](https://en.cppreference.com/w/cpp/algorithm)和[](https://en.cppreference.com/w/cpp/numeric#Numeric_algorithms) 头文件的中的很多算法都添加了一个新的参数：`sequenced_policy`。\n\n借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。\n\n`sequenced_policy`可能的取值有三种，它们的说明如下：\n\n| 变量                 | 类型                                   | C++版本 | 说明                                 |\n| :------------------- | :------------------------------------- | :------ | :----------------------------------- |\n| execution::seq       | execution::sequenced_policy            | C++17   | 要求并行算法的执行可以不并行化       |\n| execution::par       | execution::parallel_policy             | C++17   | 指示并行算法的执行可以并行化         |\n| execution::par_unseq | execution::parallel_unsequenced_policy | C++17   | 指示并行算法的执行可以并行化、向量化 |\n\n> 注意：[本文的前面](https://paul.pub/cpp-concurrency/#id-测试环境)已经提到，目前clang编译器还不支持这个功能。因此想要编译这部分代码，你需要使用gcc 9.0或更高版本，同时还需要安装[Intel Threading Building Blocks](https://github.com/intel/tbb)。\n\n下面还是通过一个示例来进行说明：\n\n```c++\n// 15_parallel_algorithm.cpp\n\nvoid generateRandomData(vector<double>& collection, int size) {\n  random_device rd;\n  mt19937 mt(rd());\n  uniform_real_distribution<double> dist(1.0, 100.0);\n  for (int i = 0; i < size; i++) {\n    collection.push_back(dist(mt));\n  }\n}\n\nint main() {\n  vector<double> collection;\n  generateRandomData(collection, 10e6); // ①\n\n  vector<double> copy1(collection); // ②\n  vector<double> copy2(collection);\n  vector<double> copy3(collection);\n\n  auto time1 = chrono::steady_clock::now(); // ③\n  sort(execution::seq, copy1.begin(), copy1.end()); // ④\n  auto time2 = chrono::steady_clock::now();\n  auto duration = chrono::duration_cast<chrono::milliseconds>(time2 - time1).count();\n  cout << \"Sequenced sort consuming \" << duration << \"ms.\" << endl; // ⑤\n\n  auto time3 = chrono::steady_clock::now();\n  sort(execution::par, copy2.begin(),copy2.end()); // ⑥\n  auto time4 = chrono::steady_clock::now();\n  duration = chrono::duration_cast<chrono::milliseconds>(time4 - time3).count();\n  cout << \"Parallel sort consuming \" << duration << \"ms.\" << endl;\n\n  auto time5 = chrono::steady_clock::now();\n  sort(execution::par_unseq, copy2.begin(),copy2.end()); // ⑦\n  auto time6 = chrono::steady_clock::now();\n  duration = chrono::duration_cast<chrono::milliseconds>(time6 - time5).count();\n  cout << \"Parallel unsequenced sort consuming \" << duration << \"ms.\" << endl;\n}\n```\n\n这段代码很简单：\n\n1. 通过一个函数生成1000,000个随机数。\n2. 将数据拷贝3份，以备使用。\n3. 接下来将通过三个不同的`parallel_policy`参数来调用同样的`sort`算法。每次调用记录开始和结束的时间。\n4. 第一次调用使用`std::execution::seq`参数。\n5. 输出本次测试所使用的时间。\n6. 第二次调用使用`std::execution::par`参数。\n7. 第三次调用使用`std::execution::par_unseq`参数。\n\n该程序的输出如下：\n\n```c++\nSequenced sort consuming 4464ms.\nParallel sort consuming 459ms.\nParallel unsequenced sort consuming 168ms.\n```\n\n可以看到，性能最好的和最差的相差了超过26倍。\n\n# 结束语\n\n在本篇文章中，我们介绍了C++语言中新增的并发编程API。虽然这部分内容已经不少（大部分人很难一次性搞懂所有这些内容，包括我自己），但实际上还有一个很重要的话题我们没有触及，那就是“内存模型”。\n\nC++内存模型是C++11标准中最重要的特性之一。它是多线程环境能够可靠工作的基础。考虑到这部分内容还需要比较多的篇幅来说明，因此我们会在下一篇文章中继续讨论。\n\n# 参考资料与推荐读物\n\n- [C++ Concurrency in Action 2nd](https://www.amazon.com/C-Concurrency-Action-Anthony-Williams/dp/1617294691/)\n- [Wikipedia](http://wikipedia.org/)\n- [cpprefernce: Thread support library](https://en.cppreference.com/w/cpp/thread)\n- [Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996)\n- [Threads Cannot be Implemented as a Library](https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf)\n- [I’m Proud to Present: Modern C++ Concurrency is available as interactive course](https://www.modernescpp.com/index.php/i-m-proud-to-present-modern-c-concurrency-is-available-as-interactive-course)\n- [How do I enable C++17?](https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000682210-How-do-I-enable-C-17-)\n- [C++17 STL Parallel Algorithms - with GCC 9.1 and Intel TBB on Linux and macOS](https://solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/)\n- [How to install packages from a newer distribution without installing unwanted](https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f)","source":"_posts/cplus_md/CPlus Basic/C++ 并发编程.md","raw":"---\ntitle: C++ 并发编程\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 使用教程\nabbrlink: 13003\ncover: img/cpp.png\n---\n# C++ 并发编程\n\n自C++11标准以来，C++语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。\n\n## 为什么要并发编程\n\n大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。\n\n另一方面，自上个世纪六七十年代英特尔创始人之一 [Gordon Moore](https://en.wikipedia.org/wiki/Gordon_Moore) 提出 [摩尔定义](https://en.wikipedia.org/wiki/Moore's_law) 以来，CPU频率以每18个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。\n\n由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。\n\n本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。\n\n## 并发与并行\n\n并发（Concurrent）与并行（Parallel）都是很常见的术语。\n\nErlang之父Joe Armstrong曾经以人们使用咖啡机的场景为例描述了这两个术语。如下图所示：\n\n![img](C++ 并发编程/con_and_par.jpg)\n\n- **并发**：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。\n- **并行**：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。\n\n这里队列中的每个人类比于计算机的任务，咖啡机类比于计算机处理器。因此：并发和并行都是在多任务的环境下的讨论。\n\n更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。\n\n你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。\n\n在不考虑处理器数量的情况下，我们统称之为“并发”。\n\n## 进程与线程\n\n进程与线程是操作系统的基本概念。无论是桌面系统：MacOS，Linux，Windows，还是移动操作系统：Android，iOS，都存在进程和线程的概念。\n\n> **进程**（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；\n>\n> **线程**（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。\n>\n> – 维基百科\n\n关于这两个概念在任何一本操作系统书上都可以找到定义。网上也有很多文章对它们进行了解释。因此这里不再赘述，这里仅仅提及一下它们与编程的关系。\n\n对于绝大部分编程语言或者编程环境来说，我们所写的程序都会在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为主线程。\n\n在默认的情况下，我们写的代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。\n\n不同编程语言的线程环境会不一样，Java语言在很早就支持了多线程接口。（Java程序在Java虚拟机中运行，虚拟机通常还会包含自己特有的线程，例如垃圾回收线程。）。而对于JavaScript这样的语言来说，它就没有多线程的概念。\n\n当我们只有一个处理器时，所有的进程或线程会分时占用这个处理器。但如果系统中存在多个处理器时，则就可能有多个任务并行的运行在不同的处理器上。\n\n下面两幅图以不同颜色的矩形代表不同的任务（可能是进程，也可能是线程）来描述它们可能在处理器上执行的顺序。\n\n下图是单核处理器的情况：\n\n<img src=\"C++ 并发编程/single_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n下面是四核处理器的情况：\n\n<img src=\"C++ 并发编程/four_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n任务会在何时占有处理器，通常是由操作系统的调度策略决定的。在[《Android系统上的进程管理：进程的调度》](https://paul.pub/android-process-schedule/)一文中，我们介绍过Linux的调度策略。\n\n当我们在开发跨平台的软件时，我们不应当对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。\n\n## 并发系统的性能\n\n开发并发系统最主要的动机就是提升系统性能（事实上，这是以增加复杂度为代价的）。\n\n但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。\n\n因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。\n\n关于这一点，你可能需要了解一下[阿姆达尔定律](https://en.wikipedia.org/wiki/Amdahl's_law)了。对于这个定律，简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。\n\n关于阿姆达尔定律在[Linux系统监测工具sysstat介绍](https://paul.pub/sysstat/#id-阿姆达尔定律)一文中已经介绍过，因此这里不再赘述。\n\n# C++与并发编程\n\n前面我们已经了解到，并非所有的语言都提供了多线程的环境。\n\n即便是C++语言，直到[C++11](https://en.wikipedia.org/wiki/C%2B%2B11)标准之前，也是没有多线程支持的。在这种情况下，Linux/Unix平台下的开发者通常会使用[POSIX Threads](https://en.wikipedia.org/wiki/POSIX_Threads)，Windows上的开发者也会有[相应的接口](https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-cpp-and-mfc?view=vs-2019)。但很明显，这些API都只针对特定的操作系统平台，可移植性较差。如果要同时支持Linux和Windows系统，你可能要写两套代码。\n\n> 相较而言，Java自JDK 1.0就包含了多线程模型。\n\n这个状态在C++ 11标准发布之后得到了改变。并且，在C++ 14和C++ 17标准中又对并发编程机制进行了增强。\n\n下图是最近几个版本的C++标准特性的线路图。\n\n<img src=\"C++ 并发编程/cpp_timeline.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n## 编译器与C++标准\n\n编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。\n\n- GCC对于C++特性的支持请参见这里：[C++ Standards Support in GCC](https://www.gnu.org/software/gcc/projects/cxx-status.html)。\n- Clang对于C++特性的支持请参见这里：[C++ Support in Clang](https://clang.llvm.org/cxx_status.html)。\n\n下面两个表格列出了C++标准和相应编译器的版本对照：\n\n- C++标准与相应的GCC版本要求如下：\n\n| C++版本 | GCC版本 |\n| :------ | :------ |\n| C++11   | 4.8     |\n| C++14   | 5.0     |\n| C++17   | 7.0     |\n\n- C++标准与相应的Clang版本要求如下：\n\n| C++版本 | Clang版本 |\n| :------ | :-------- |\n| C++11   | 3.3       |\n| C++14   | 3.4       |\n| C++17   | 5.0       |\n\n默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数`-std=c++xx`告知编译器，例如：\n\n```shell\ng++ -std=c++17 your_file.cpp -o your_program\n```\n\n# 测试环境\n\n本文的源码可以到下载我的github上获取，地址：[paulQuei/cpp-concurrency](https://github.com/paulQuei/cpp-concurrency)。\n\n你可以直接通过下面这条命令获取源码：\n\n```\ngit clone https://github.com/paulQuei/cpp-concurrency.git\n```\n\n源码下载之后，你可以通过任何文本编辑器浏览源码。如果希望编译和运行程序，你还需要按照下面的内容来准备环境。\n\n本文中的源码使用[cmake](https://cmake.org/)编译，只有cmake 3.8以上的版本才支持C++ 17，所以你需要安装这个或者更新版本的cmake。\n\n另外，截止目前（2019年10月）为止，`clang`编译器还不支持[并行算法](https://paul.pub/cpp-concurrency/#id-并行算法)。\n\n但是[gcc-9](https://gcc.gnu.org/gcc-9/changes.html)是支持的。因此想要编译和运行这部分代码，你需要安装gcc 9.0或更新的版本。并且，gcc-9还要依赖[Intel Threading Building Blocks](https://github.com/intel/tbb)才能使用并行算法以及`<execution>`头文件。\n\n具体的安装方法见下文。\n\n> 具体编译器对于C++特性支持的情况请参见这里：[C++ compiler support](https://en.cppreference.com/w/cpp/compiler_support)。\n\n安装好之后运行根目录下的下面这个命令即可：\n\n```shell\n ./make_all.sh\n```\n\n它会完成所有的编译工作。\n\n本文的源码在下面两个环境中经过测试，环境的准备方法如下。\n\n## MacOS\n\n在Mac上，我使用[brew](https://brew.sh/)工具安装`gcc`以及`tbb`库。\n\n考虑到其他人与我的环境可能会有所差异，所以需要手动告知`tbb`库的安装路径。\n\n读者需要执行下面这些命令来准备环境：\n\n```shell\nbrew install gcc\nbrew install tbb\n\nexport tbb_path=/usr/local/Cellar/tbb/2019_U8/\n./make_all.sh\n```\n\n注意，请通过运行`g++-9`命令以确认gcc的版本是否正确，如果版本较低，则需要通过`brew`命令将其升级到新版本：\n\n```shell\nbrew upgrade gcc\n```\n\n## Ubuntu\n\nUbuntu上，通过下面的命令安装`gcc-9`。\n\n```shell\nsudo add-apt-repository ppa:ubuntu-toolchain-r/test\nsudo apt-get update\nsudo apt install  gcc-9 g++-9\n```\n\n但安装`tbb`库就有些麻烦了。这是因为[Ubuntu 16.04默认关联的版本是较低的](https://launchpad.net/ubuntu/+source/tbb)，直接安装是无法使用的。我们需要安装[更新的版本](https://launchpad.net/ubuntu/+source/tbb/2019~U8-1)。\n\n联网安装的方式[步骤繁琐](https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f)，所以可以通过下载包的方式进行安装，我已经将这需要的两个文件放到的这里：\n\n- [libtbb2_2019~U8-1_amd64.deb](https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb2_2019~U8-1_amd64.deb)\n- [libtbb-dev_2019~U8-1_amd64.deb](https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb-dev_2019~U8-1_amd64.deb)\n\n如果需要，你可以下载后通过`apt`命令安装即可：\n\n```shell\nsudo apt install ~/Downloads/libtbb2_2019~U8-1_amd64.deb \nsudo apt install ~/Downloads/libtbb-dev_2019~U8-1_amd64.deb \n```\n\n# 线程\n\n## 创建线程\n\n创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：\n\n```c++\n// 01_hello_thread.cpp\n\n#include <iostream>\n#include <thread> // ①\n\nusing namespace std; // ②\n\nvoid hello() { // ③\n  cout << \"Hello World from new thread.\" << endl;\n}\n\nint main() {\n  thread t(hello); // ④\n  t.join(); // ⑤\n\n  return 0;\n}\n```\n\n对于这段代码说明如下：\n\n1. 为了使用多线程的接口，我们需要`#include <thread>`头文件。\n2. 为了简化声明，本文中的代码都将`using namespace std;`。\n3. 新建线程的入口是一个普通的函数，它并没有什么特别的地方。\n4. 创建线程的方式就是构造一个`thread`对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。\n5. 关于`join`函数在下文中讲解。\n\n`thread`可以和`callable`类型一起工作，因此如果你熟悉[lambda表达式](https://en.cppreference.com/w/cpp/language/lambda)，你可以直接用它来写线程的逻辑，像这样：\n\n```c++\n// 02_lambda_thread.cpp\n\n#include <iostream>\n#include <thread>\n\nusing namespace std;\n\nint main() {\n  thread t([] {\n    cout << \"Hello World from lambda thread.\" << endl;\n  });\n\n  t.join();\n\n  return 0;\n}\n```\n\n> 为了减少不必要的重复，若无必要，下文中的代码将不贴出`include`指令以及`using`声明。\n\n当然，你可以传递参数给入口函数，像下面这样：\n\n```c++\n// 03_thread_argument.cpp\n\nvoid hello(string name) {\n  cout << \"Welcome to \" << name << endl;\n}\n\nint main() {\n  thread t(hello, \"https://paul.pub\");\n  t.join();\n\n  return 0;\n}\n```\n\n不过需要注意的是，参数是以拷贝的形式进行传递的。因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文`detach`），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。\n\n## join与detach\n\n- 主要API\n\n| API    | 说明               |\n| :----- | :----------------- |\n| join   | 等待线程完成其执行 |\n| detach | 允许线程独立执行   |\n\n一旦启动线程之后，我们必须决定是要等待直接它结束（通过`join`），还是让它独立运行（通过`detach`），我们必须二者选其一。如果在`thread`对象**销毁的时候**我们还没有做决定，则`thread`对象在析构函数出将调用`std::terminate()`从而导致我们的进程异常退出。\n\n> 请思考在上面的代码示例中，`thread`对象在何时会销毁。\n\n需要注意的是：在我们做决定的时候，很可能线程已经执行完了（例如上面的示例中线程的逻辑仅仅是一句打印，执行时间会很短）。新的线程创建之后，究竟是新的线程先执行，还是当前线程的下一条语句先执行这是不确定的，因为这是由操作系统的调度策略决定的。不过这不要紧，我们只要在`thread`对象销毁前做决定即可。\n\n- `join`：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。\n- `detach`：`detach`是让目标线程成为守护线程（daemon threads）。一旦`detach`之后，目标线程将独立执行，即便其对应的`thread`对象销毁也不影响线程的执行。并且，你无法再与之通信。\n\n对于这两个接口，都必须是可执行的线程才有意义。你可以通过`joinable()`接口查询是否可以对它们进行`join`或者`detach`。\n\n## 管理当前线程\n\n- 主要API\n\n| API         | C++标准 | 说明                                 |\n| :---------- | :------ | :----------------------------------- |\n| yield       | C++11   | 让出处理器，重新调度各执行线程       |\n| get_id      | C++11   | 返回当前线程的线程 id                |\n| sleep_for   | C++11   | 使当前线程的执行停止指定的时间段     |\n| sleep_until | C++11   | 使当前线程的执行停止直到指定的时间点 |\n\n上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。\n\n- `yield` 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。\n- `get_id` 返回当前线程的id，可以以此来标识不同的线程。\n- `sleep_for` 是让当前线程停止一段时间。\n- `sleep_until` 和`sleep_for`类似，但是是以具体的时间点为参数。这两个API都以[chrono](https://en.cppreference.com/w/cpp/header/chrono) API（由于篇幅所限，这里不展开这方面内容）为基础。\n\n下面是一个代码示例：\n\n```c++\n// 04_thread_self_manage.cpp\n\nvoid print_time() {\n  auto now = chrono::system_clock::now();\n  auto in_time_t = chrono::system_clock::to_time_t(now);\n\n  std::stringstream ss;\n  ss << put_time(localtime(&in_time_t), \"%Y-%m-%d %X\");\n  cout << \"now is: \" << ss.str() << endl;\n}\n\nvoid sleep_thread() {\n  this_thread::sleep_for(chrono::seconds(3));\n  cout << \"[thread-\" << this_thread::get_id() << \"] is waking up\" << endl;\n}\n\nvoid loop_thread() {\n  for (int i = 0; i < 10; i++) {\n    cout << \"[thread-\" << this_thread::get_id() << \"] print: \" << i << endl;\n  }\n}\n\nint main() {\n  print_time();\n\n  thread t1(sleep_thread);\n  thread t2(loop_thread);\n\n  t1.join();\n  t2.detach();\n\n  print_time();\n  return 0;\n}\n```\n\n这段代码应该还是比较容易理解的，这里创建了两个线程。它们都会有一些输出，其中一个会先停止3秒钟，然后再输出。主线程调用`join`会一直卡住等待它运行结束。\n\n这段程序的输出如下：\n\n```shell\nnow is: 2019-10-13 10:17:48\n[thread-0x70000cdda000] print: 0\n[thread-0x70000cdda000] print: 1\n[thread-0x70000cdda000] print: 2\n[thread-0x70000cdda000] print: 3\n[thread-0x70000cdda000] print: 4\n[thread-0x70000cdda000] print: 5\n[thread-0x70000cdda000] print: 6\n[thread-0x70000cdda000] print: 7\n[thread-0x70000cdda000] print: 8\n[thread-0x70000cdda000] print: 9\n[thread-0x70000cd57000] is waking up\nnow is: 2019-10-13 10:17:51\n```\n\n## 一次调用\n\n- 主要API\n\n| API       | C++标准 | 说明                                           |\n| :-------- | :------ | :--------------------------------------------- |\n| call_once | C++11   | 即便在多线程环境下，也能保证只调用某个函数一次 |\n| once_flag | C++11   | 与`call_once`配合使用                          |\n\n在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。\n\n下面就是一个示例：有三个线程都会使用`init`函数，但是只会有一个线程真正执行它。\n\n```c++\n// 05_call_once.cpp\n\nvoid init() {\n  cout << \"Initialing...\" << endl;\n  // Do something...\n}\n\nvoid worker(once_flag* flag) {\n  call_once(*flag, init);\n}\n\nint main() {\n  once_flag flag;\n\n  thread t1(worker, &flag);\n  thread t2(worker, &flag);\n  thread t3(worker, &flag);\n\n  t1.join();\n  t2.join();\n  t3.join();\n\n  return 0;\n}\n```\n\n我们无法确定具体是哪一个线程会执行`init`。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。\n\n> 请思考一下，为什么要在main函数中创建`once_flag flag`。如果是在`worker`函数中直接声明一个`once_flag`并使用行不行？为什么？\n\n# 并发任务\n\n下面以一个并发任务为示例讲解如何引入多线程。\n\n任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如`[1, 10e8]`。\n\n在单线程模型下，我们的代码可能是这样的：\n\n```c++\n// 06_naive_multithread.cpp\n\nstatic const int MAX = 10e8; // ①\nstatic double sum = 0; // ②\n\nvoid worker(int min, int max) { // ③\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n}\n\nvoid serial_task(int min, int max) { // ④\n  auto start_time = chrono::steady_clock::now();\n  sum = 0;\n  worker(0, MAX);\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Serail task finish, \" << ms << \" ms consumed, Result: \" << sum << endl;\n}\n```\n\n这段代码说明如下：\n\n1. 通过一个常量指定数据范围，这个是为了方便调整。\n2. 通过一个全局变量来存储结果。\n3. 通过一个任务函数来计算值。\n4. 统计任务的执行时间。\n\n这段程序输出如下：\n\n```shell\nSerail task finish, 6406 ms consumed, Result: 2.10819e+13\n```\n\n很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。\n\n下面我们就尝试以多线程的方式来改造原先的程序。\n\n改造后的程序如下：\n\n```c++\n// 06_naive_multithread.cpp\n\nvoid concurrent_task(int min, int max) {\n  auto start_time = chrono::steady_clock::now();\n\n  unsigned concurrent_count = thread::hardware_concurrency(); // ①\n  cout << \"hardware_concurrency: \" << concurrent_count << endl;\n  vector<thread> threads;\n  min = 0;\n  sum = 0;\n  for (int t = 0; t < concurrent_count; t++) { // ②\n    int range = max / concurrent_count * (t + 1);\n    threads.push_back(thread(worker, min, range)); // ③\n    min = range + 1;\n  }\n  for (auto& t : threads) {\n    t.join(); // ④\n  }\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed, Result: \" << sum << endl;\n}\n```\n\n这段代码说明如下：\n\n1. `thread::hardware_concurrency()`可以获取到当前硬件支持多少个线程并行执行。\n2. 根据处理器的情况决定线程的数量。\n3. 对于每一个线程都通过`worker`函数来完成任务，并划分一部分数据给它处理。\n4. 等待每一个线程执行结束。\n\n很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：\n\n```shell\nhardware_concurrency: 16\nConcurrent task finish, 6246 ms consumed, Result: 1.78162e+12\n```\n\n很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。\n\n要搞清楚为什么结果不正确我们需要更多的背景知识。\n\n我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：\n\n> 事实上，目前大部分CPU的缓存已经不只一层。\n\n<img src=\"C++ 并发编程/cpu.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。\n\n事情还远不止这么简单。我们对于全局变量值的修改：`sum += sqrt(i);`这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：\n\n<img src=\"C++ 并发编程/multithread.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n在时间点a的时候，所有线程对于`sum`变量的值是一致的。\n\n但是在时间点b之后，thread3上已经对`sum`进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。\n\n## 竞争条件与临界区\n\n当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为[**竞争条件**（race condition）](https://en.wikipedia.org/wiki/Race_condition)。\n\n访问共享数据的代码片段称之为**临界区**（critical section）。具体到上面这个示例，临界区就是读写`sum`变量的地方。\n\n要避免竞争条件，就需要对临界区进行数据保护。\n\n很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。\n\n那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。\n\n接下来介绍的API提供的就是这样的功能。\n\n# 互斥体与锁\n\n## mutex\n\n开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：\n\n1. 独立的对于划分给自己的数据的处理\n2. 对于处理结果的汇总\n\n其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的`sum`变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。`mutex` 就提供了这样的功能。\n\n`mutex`是**mut**ual **ex**clusion（互斥）的简写。\n\n- 主要API\n\n| API                   | C++标准 | 说明                                             |\n| :-------------------- | :------ | :----------------------------------------------- |\n| mutex                 | C++11   | 提供基本互斥设施                                 |\n| timed_mutex           | C++11   | 提供互斥设施，带有超时功能                       |\n| recursive_mutex       | C++11   | 提供能被同一线程递归锁定的互斥设施               |\n| recursive_timed_mutex | C++11   | 提供能被同一线程递归锁定的互斥设施，带有超时功能 |\n| shared_timed_mutex    | C++14   | 提供共享互斥设施并带有超时功能                   |\n| shared_mutex          | C++17   | 提供共享互斥设施                                 |\n\n很明显，在这些类中，`mutex`是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：\n\n| 方法     | 说明                                 |\n| -------- | ------------------------------------ |\n| lock     | 锁定互斥体，如果不可用，则阻塞       |\n| try_lock | 尝试锁定互斥体，如果不可用，直接返回 |\n| unlock   | 解锁互斥体                           |\n\n这三个方法提供了基础的锁定和解除锁定的功能。使用`lock`意味着你有很强的意愿一定要获取到互斥体，而使用`try_lock`则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。\n\n在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：\n\n- **超时**：`timed_mutex`，`recursive_timed_mutex`，`shared_timed_mutex`的名称都带有`timed`，这意味着它们都支持超时功能。它们都提供了`try_lock_for`和`try_lock_until`方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。\n- **可重入**：`recursive_mutex`和`recursive_timed_mutex`的名称都带有`recursive`。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。\n- **共享**：`shared_timed_mutex`和`shared_mutex`提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在[读者写者模型](https://en.wikipedia.org/wiki/Readers–writers_problem)上。\n\n使用共享锁的接口如下：\n\n| 方法            | 说明                                   |\n| --------------- | -------------------------------------- |\n| lock_shared     | 获取互斥体的共享锁，如果无法获取则阻塞 |\n| try_lock_shared | 尝试获取共享锁，如果不可用，直接返回   |\n| unlock_shared   | 解锁共享锁                             |\n\n接下来，我们就借助刚学到的`mutex`来改造我们的并发系统，改造后的程序如下：\n\n```c++\n// 07_mutex_lock.cpp\n\nstatic const int MAX = 10e8;\nstatic double sum = 0;\n\nstatic mutex exclusive;\n\nvoid concurrent_worker(int min, int max) {\n  for (int i = min; i <= max; i++) {\n    exclusive.lock(); // ①\n    sum += sqrt(i);\n    exclusive.unlock(); // ②\n  }\n}\n\nvoid concurrent_task(int min, int max) {\n  auto start_time = chrono::steady_clock::now();\n\n  unsigned concurrent_count = thread::hardware_concurrency();\n  cout << \"hardware_concurrency: \" << concurrent_count << endl;\n  vector<thread> threads;\n  min = 0;\n  sum = 0;\n  for (int t = 0; t < concurrent_count; t++) {\n    int range = max / concurrent_count * (t + 1);\n    threads.push_back(thread(concurrent_worker, min, range)); // ③\n    min = range + 1;\n  }\n  for (int i = 0; i < threads.size(); i++) {\n    threads[i].join();\n  }\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed, Result: \" << sum << endl;\n}\n```\n\n这里只有三个地方需要关注：\n\n1. 在访问共享数据之前加锁\n2. 访问完成之后解锁\n3. 在多线程中使用带锁的版本\n\n执行之后结果输出如下：\n\n```shell\nhardware_concurrency: 16\nConcurrent task finish, 74232 ms consumed, Result: 2.10819e+13\n```\n\n这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？\n\n这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。\n\n这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。\n\n不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。\n\n于是我们改造`concurrent_worker`，像下面这样：\n\n```c++\n// 08_improved_mutex_lock.cpp\n\nvoid concurrent_worker(int min, int max) {\n  double tmp_sum = 0;\n  for (int i = min; i <= max; i++) {\n    tmp_sum += sqrt(i); // ①\n  }\n  exclusive.lock(); // ②\n  sum += tmp_sum;\n  exclusive.unlock();\n}\n```\n\n这段代码的改变在于两处：\n\n1. 通过一个局部变量保存当前线程的处理结果\n2. 在汇总总结过的时候进行锁保护\n\n运行一下改进后的程序，其结果输出如下：\n\n```shell\nhardware_concurrency: 16\nConcurrent task finish, 451 ms consumed, Result: 2.10819e+13\n```\n\n可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。\n\n我们用锁的**粒度**（granularity）来描述锁的范围。**细粒度**（fine-grained）是指锁保护较小的范围，**粗粒度**（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。\n\n> In general, a lock should be held for only the minimum possible time needed to perform the required operations.\n>\n> –《C++ Concurrency in Action》\n\n## 死锁\n\n死锁是并发系统很常见的一类问题。\n\n死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。\n\n死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。\n\n在成年人的世界里也会发生类似的情况，例如下面这个交通状况：\n\n![img](C++ 并发编程/deadlock.gif)\n\n下面我们来看一个编程示例。\n\n现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。\n\n首先我们创建一个`Account`类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。`Account`类仅仅包含名称和金额两个字段。\n\n另外，为了支持并发，这个类包含了一个`mutex`对象，用来保护账号金额，在读写账号金额时需要先加锁保护。\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nclass Account {\npublic:\n  Account(string name, double money): mName(name), mMoney(money) {};\n\npublic:\n  void changeMoney(double amount) {\n    mMoney += amount;\n  }\n  string getName() {\n    return mName;\n  }\n  double getMoney() {\n    return mMoney;\n  }\n  mutex* getLock() {\n    return &mMoneyLock;\n  }\n\nprivate:\n  string mName;\n  double mMoney;\n  mutex mMoneyLock;\n};\n```\n\n`Account`类很简单，我想就不用多做说明了。\n\n接下来，我们再创建一个描述银行的`Bank`类。\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nclass Bank {\npublic:\n  void addAccount(Account* account) {\n    mAccounts.insert(account);\n  }\n\n  bool transferMoney(Account* accountA, Account* accountB, double amount) {\n    lock_guard guardA(*accountA->getLock()); // ①\n    lock_guard guardB(*accountB->getLock());\n\n    if (amount > accountA->getMoney()) { // ②\n      return false;\n    }\n\n    accountA->changeMoney(-amount); // ③\n    accountB->changeMoney(amount);\n    return true;\n  }\n\n  double totalMoney() const {\n    double sum = 0;\n    for (auto a : mAccounts) {\n      sum += a->getMoney();\n    }\n    return sum;\n  }\n\nprivate:\n  set<Account*> mAccounts;\n};\n```\n\n银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。\n\n这其中，我们最主要要关注转账的实现：`transferMoney`。该方法的几个关键点如下：\n\n1. 为了保证线程安全，在修改每个账号之前，需要获取相应的锁。\n2. 判断转出账户金额是否足够，如果不够此次转账失败。\n3. 进行转账。\n\n有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nvoid randomTransfer(Bank* bank, Account* accountA, Account* accountB) {\n  while(true) {\n    double randomMoney = ((double)rand() / RAND_MAX) * 100;\n    if (bank->transferMoney(accountA, accountB, randomMoney)) {\n      cout << \"Transfer \" << randomMoney << \" from \" << accountA->getName()\n           << \" to \" << accountB->getName()\n           << \", Bank totalMoney: \" << bank->totalMoney() << endl;\n    } else {\n      cout << \"Transfer failed, \"\n           << accountA->getName() << \" has only $\" << accountA->getMoney() << \", but \"\n           << randomMoney << \" required\" << endl;\n    }\n  }\n}\n```\n\n这里每次生成一个随机数，然后通过银行进行转账。\n\n最后我们在`main`函数中创建两个线程，互相在两个账号之间来回转账：\n\n```c++\n// 09_deadlock_bank_transfer.cpp\n\nint main() {\n  Account a(\"Paul\", 100);\n  Account b(\"Moira\", 100);\n\n  Bank aBank;\n  aBank.addAccount(&a);\n  aBank.addAccount(&b);\n\n  thread t1(randomTransfer, &aBank, &a, &b);\n  thread t2(randomTransfer, &aBank, &b, &a);\n\n  t1.join();\n  t2.join();\n\n  return 0;\n}\n```\n\n至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：\n\n```shell\n...\nTransfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $34.7581, but 66.3208 required\nTransfer failed, Moira has only $34.7581, but \nTransfer 93.191 from 53.9176 required\nTransfer 60.6146 from Moira to Paul, Bank totalMoney: 200\nTransfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: \nTransfer failed, Moira has only $17.6041, but 18.1186 required\nTransfer failed, Moira has only $17.6041, but 18.893 required\nTransfer failed, Moira has only $17.6041, but 34.7078 required\nTransfer failed, Moira has only $17.6041, but 33.9569 required\nTransfer 12.7899 from 200\nMoira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $63.9373, but 80.9038 required\nTransfer 50.933 from Moira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $13.0043, but 30.2056 required\nTransfer failed, Moira has only $Transfer 59.123 from Paul to Moira, Bank totalMoney: 200\nTransfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required\n```\n\n如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？\n\n因为发生了死锁。\n\n我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：\n\n<img src=\"C++ 并发编程/deadlock.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相`join`就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如`mutex`而非`recursive_mutex`）多次加锁也会死锁。\n\n你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。\n\n如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。\n\n下面我们就来逐步解决上面的问题。\n\n对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：\n\n```c++\n// 10_improved_bank_transfer.cpp\n\nmutex sCoutLock;\nvoid randomTransfer(Bank* bank, Account* accountA, Account* accountB) {\n  while(true) {\n    double randomMoney = ((double)rand() / RAND_MAX) * 100;\n    if (bank->transferMoney(accountA, accountB, randomMoney)) {\n      sCoutLock.lock();\n      cout << \"Transfer \" << randomMoney << \" from \" << accountA->getName()\n          << \" to \" << accountB->getName()\n          << \", Bank totalMoney: \" << bank->totalMoney() << endl;\n      sCoutLock.unlock();\n    } else {\n      sCoutLock.lock();\n      cout << \"Transfer failed, \"\n           << accountA->getName() << \" has only \" << accountA->getMoney() << \", but \"\n           << randomMoney << \" required\" << endl;\n      sCoutLock.unlock();\n    }\n  }\n}\n```\n\n> 请思考一下两处`lock`和`unlock`调用，并考虑为什么不在`while(true)`下面写一次整体的加锁和解锁。\n\n## 通用锁定算法\n\n- 主要API\n\n| API      | C++标准 | 说明                                         |\n| :------- | :------ | :------------------------------------------- |\n| lock     | C++11   | 锁定指定的互斥体，若任何一个不可用则阻塞     |\n| try_lock | C++11   | 试图通过重复调用 try_lock 获得互斥体的所有权 |\n\n要避免死锁，需要仔细的思考和设计业务逻辑。\n\n有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁B，才能玩玩具。这样就不会死锁了。\n\n这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。\n\n不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个[Lockable](https://en.cppreference.com/w/cpp/named_req/Lockable)对象。\n\n接下来我们用它来改造之前死锁的转账系统：\n\n```c++\n// 10_improved_bank_transfer.cpp\n\nbool transferMoney(Account* accountA, Account* accountB, double amount) {\n  lock(*accountA->getLock(), *accountB->getLock());    // ①\n  lock_guard lockA(*accountA->getLock(), adopt_lock);  // ②\n  lock_guard lockB(*accountB->getLock(), adopt_lock);  // ③\n\n  if (amount > accountA->getMoney()) {\n    return false;\n  }\n\n  accountA->changeMoney(-amount);\n  accountB->changeMoney(amount);\n  return true;\n}\n```\n\n这里只改动了3行代码。\n\n1. 这里通过`lock`函数来获取两把锁，标准库的实现会保证不会发生死锁。\n2. `lock_guard`在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建`lock_guard`的目的是为了在`transferMoney`结束的时候释放锁，`lockB`也是一样。但需要注意的是，这里传递了 `adopt_lock`表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加`adopt_lock`就是二次锁定了）。\n\n运行一下这个改造后的程序，其输出如下所示：\n\n```shell\n...\nTransfer failed, Paul has only $1.76243, but 17.5974 required\nTransfer failed, Paul has only $1.76243, but 59.2104 required\nTransfer failed, Paul has only $1.76243, but 49.6379 required\nTransfer failed, Paul has only $1.76243, but 63.6373 required\nTransfer failed, Paul has only $1.76243, but 51.8742 required\nTransfer failed, Paul has only $1.76243, but 50.0081 required\nTransfer failed, Paul has only $1.76243, but 86.1041 required\nTransfer failed, Paul has only $1.76243, but 51.3278 required\nTransfer failed, Paul has only $1.76243, but 66.5754 required\nTransfer failed, Paul has only $1.76243, but 32.1867 required\nTransfer failed, Paul has only $1.76243, but 62.0039 required\nTransfer failed, Paul has only $1.76243, but 98.7819 required\nTransfer failed, Paul has only $1.76243, but 27.046 required\nTransfer failed, Paul has only $1.76243, but 62.9155 required\nTransfer 98.8478 from Moira to Paul, Bank totalMoney: 200\nTransfer 80.0722 from Moira to Paul, Bank totalMoney: 200\nTransfer 73.7035 from Moira to Paul, Bank totalMoney: 200\nTransfer 34.4476 from Moira to Paul, Bank totalMoney: 200\nTransfer failed, Moira has only $10.0142, but 61.3033 required\nTransfer failed, Moira has only $10.0142, but 24.5595 required\n...\n```\n\n现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。\n\n## 通用互斥管理\n\n- 主要API\n\n| API         | C++标准 | 说明                                   |\n| :---------- | :------ | :------------------------------------- |\n| lock_guard  | C++11   | 实现严格基于作用域的互斥体所有权包装器 |\n| unique_lock | C++11   | 实现可移动的互斥体所有权包装器         |\n| shared_lock | C++14   | 实现可移动的共享互斥体所有权封装器     |\n| scoped_lock | C++17   | 用于多个互斥体的免死锁 RAII 封装器     |\n\n| 锁定策略    | C++标准 | 说明                                                |\n| :---------- | :------ | :-------------------------------------------------- |\n| defer_lock  | C++11   | 类型为 `defer_lock_t`，不获得互斥的所有权           |\n| try_to_lock | C++11   | 类型为`try_to_lock_t`，尝试获得互斥的所有权而不阻塞 |\n| adopt_lock  | C++11   | 类型为`adopt_lock_t`，假设调用方已拥有互斥的所有权  |\n\n互斥体（`mutex`相关类）提供了对于资源的保护功能，但是手动的锁定（调用`lock`或者`try_lock`）和解锁（调用`unlock`）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。\n\n鉴于这个原因，标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。\n\n请看下面的例子：\n\n```c++\n// https://en.cppreference.com/w/cpp/thread/lock_guard\n\n#include <thread>\n#include <mutex>\n#include <iostream>\n \nint g_i = 0;\nstd::mutex g_i_mutex;  // ①\n \nvoid safe_increment()\n{\n  std::lock_guard<std::mutex> lock(g_i_mutex);  // ②\n  ++g_i;\n\n  std::cout << std::this_thread::get_id() << \": \" << g_i << '\\n';\n  // ③\n}\n \nint main()\n{\n  std::cout << \"main: \" << g_i << '\\n';\n \n  std::thread t1(safe_increment); // ④\n  std::thread t2(safe_increment);\n \n  t1.join();\n  t2.join();\n \n  std::cout << \"main: \" << g_i << '\\n';\n}\n```\n\n这段代码中：\n\n1. 全局的互斥体`g_i_mutex`用来保护全局变量`g_i`\n2. 这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用`lock`方法，而是直接使用`lock_guard`来锁定互斥体。\n3. 在方法结束的时候，局部变量`std::lock_guard<std::mutex> lock`会被销毁，它对互斥体的锁定也就解除了。\n4. 在多个线程中使用这个方法。\n\n### RAII\n\n上面的几个类（`lock_guard`，`unique_lock`，`shared_lock`，`scoped_lock`）都使用了一个叫做RAII的编程技巧。\n\nRAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。\n\nRAII是一种[C++编程技术](http://www.stroustrup.com/bs_faq2.html#finally)，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。 RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。\n\nRAII 可总结如下:\n\n- 将每个资源封装入一个类，其中：\n    - 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，\n    - 析构函数释放资源并决不抛出异常；\n- 始终经由 RAII 类的实例使用满足要求的资源，该资源\n    - 自身拥有自动存储期或临时生存期，或\n    - 具有与自动或临时对象的生存期绑定的生存期\n\n回想一下上文中的`transferMoney`方法中的三行代码：\n\n```c++\nlock(*accountA->getLock(), *accountB->getLock());\nlock_guard lockA(*accountA->getLock(), adopt_lock);\nlock_guard lockB(*accountB->getLock(), adopt_lock);\n```\n\n如果使用`unique_lock`这三行代码还有一种等价的写法：\n\n```c++\nunique_lock lockA(*accountA->getLock(), defer_lock);\nunique_lock lockB(*accountB->getLock(), defer_lock);\nlock(*accountA->getLock(), *accountB->getLock());\n```\n\n请注意这里`lock`方法的调用位置。这里先定义`unique_lock`指定了`defer_lock`，因此实际没有锁定互斥体，而是到第三行才进行锁定。\n\n最后，借助`scoped_lock`，我们可以将三行代码合成一行，这种写法也是等价的。\n\n```c++\nscoped_lock lockAll(*accountA->getLock(), *accountB->getLock());\n```\n\n`scoped_lock`会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。\n\n目前，只还有`shared_lock`我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。\n\n## 条件变量\n\n| API                       | C++标准 | 说明                                         |\n| :------------------------ | :------ | :------------------------------------------- |\n| condition_variable        | C++ 11  | 提供与 std::unique_lock 关联的条件变量       |\n| condition_variable_any    | C++ 11  | 提供与任何锁类型关联的条件变量               |\n| notify_all_at_thread_exit | C++ 11  | 安排到在此线程完全结束时对 notify_all 的调用 |\n| cv_status                 | C++ 11  | 列出条件变量上定时等待的可能结果             |\n\n至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了`false`。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。\n\n这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。\n\n条件变量提供了一个可以让多个线程间同步协作的功能。这对于[生产者-消费者模型](https://en.wikipedia.org/wiki/Producer–consumer_problem)很有意义。在这个模型下：\n\n- 生产者和消费者共享一个工作区。这个区间的大小是有限的。\n- 生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。\n- 消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。\n\n从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。\n\n下面我们就借助于条件变量，再次改造之前的银行转账系统。\n\n这个改造主要在于账号类。我们重点是要调整`changeMoney`方法。\n\n```c++\n// 11_bank_transfer_wait_notify.cpp\n\nclass Account {\npublic:\n  Account(string name, double money): mName(name), mMoney(money) {};\n\npublic:\n  void changeMoney(double amount) {\n    unique_lock lock(mMoneyLock); // ②\n    mConditionVar.wait(lock, [this, amount] { // ③\n      return mMoney + amount > 0; // ④\n    });\n    mMoney += amount;\n    mConditionVar.notify_all(); // ⑤\n  }\n\n  string getName() {\n    return mName;\n  }\n\n  double getMoney() {\n    return mMoney;\n  }\n\nprivate:\n  string mName;\n  double mMoney;\n  mutex mMoneyLock;\n  condition_variable mConditionVar; // ①\n};\n```\n\n这几处改动说明如下：\n\n1. 这里声明了一个条件变量，用来在多个线程之间协作。\n2. 这里使用的是`unique_lock`，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。\n3. 这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则**此处会解锁互斥体，并让当前线程等待**。**解锁**这一点非常重要，因为只有这样，才能让其他线程获取互斥体。\n4. 这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读[我之前写的文章](https://paul.pub/cpp-lambda-function-bind/)。\n5. 此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用`wait`线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了`notify_all`还有`notify_one`，它只通知一个等待的线程。`wait`和`notify`就构成了线程间互相协作的工具。\n\n请注意：`wait`和`notify_all`虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。\n\n有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：\n\n```c++\n// 11_bank_transfer_wait_notify.cpp\n\nvoid Bank::transferMoney(Account* accountA, Account* accountB, double amount) {\n    accountA->changeMoney(-amount);\n    accountB->changeMoney(amount);\n}\n```\n\n当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。\n\n```c++\n// 11_bank_transfer_wait_notify.cpp\n\nmutex sCoutLock;\nvoid randomTransfer(Bank* bank, Account* accountA, Account* accountB) {\n  while(true) {\n    double randomMoney = ((double)rand() / RAND_MAX) * 100;\n    {\n      lock_guard guard(sCoutLock);\n      cout << \"Try to Transfer \" << randomMoney\n           << \" from \" << accountA->getName() << \"(\" << accountA->getMoney()\n           << \") to \" << accountB->getName() << \"(\" << accountB->getMoney()\n           << \"), Bank totalMoney: \" << bank->totalMoney() << endl;\n    }\n    bank->transferMoney(accountA, accountB, randomMoney);\n  }\n}\n```\n\n修改完之后的程序运行输出如下：\n\n```shell\n...\nTry to Transfer 13.72 from Moira(10.9287) to Paul(189.071), Bank totalMoney: 200\nTry to Transfer 28.6579 from Paul(189.071) to Moira(10.9287), Bank totalMoney: 200\nTry to Transfer 91.8049 from Paul(160.413) to Moira(39.5866), Bank totalMoney: 200\nTry to Transfer 5.56383 from Paul(82.3285) to Moira(117.672), Bank totalMoney: 200\nTry to Transfer 11.3594 from Paul(76.7646) to Moira(123.235), Bank totalMoney: 200\nTry to Transfer 16.9557 from Paul(65.4053) to Moira(134.595), Bank totalMoney: 200\nTry to Transfer 74.998 from Paul(48.4495) to Moira(151.55), Bank totalMoney: 200\nTry to Transfer 65.3005 from Moira(151.55) to Paul(48.4495), Bank totalMoney: 200\nTry to Transfer 90.6084 from Moira(86.25) to Paul(113.75), Bank totalMoney: 125.002\nTry to Transfer 99.6425 from Moira(70.6395) to Paul(129.36), Bank totalMoney: 200\nTry to Transfer 55.2091 from Paul(129.36) to Moira(70.6395), Bank totalMoney: 200\nTry to Transfer 92.259 from Paul(74.1513) to Moira(125.849), Bank totalMoney: 200\n...\n```\n\n这下比之前都要好了。\n\n但是细心的读者会发现，Bank totalMoney的输出有时候是200，有时候不是。但不管怎样，即便这一次不是，下一次又是了。关于这一点，请读者自行思考一下为什么，以及如何改进。\n\n# future\n\n| API           | C++标准 | 说明                                              |\n| :------------ | :------ | :------------------------------------------------ |\n| async         | C++11   | 异步运行一个函数，并返回保有其结果的`std::future` |\n| future        | C++11   | 等待被异步设置的值                                |\n| packaged_task | C++11   | 打包一个函数，存储其返回值以进行异步获取          |\n| promise       | C++11   | 存储一个值以进行异步获取                          |\n| shared_future | C++11   | 等待被异步设置的值（可能为其他 future 所引用）    |\n\n这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于`<future>`头文件中。\n\n## async\n\n很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。\n\n在C++11中，`async`便是完成这样的功能的。下面是一个代码示例：\n\n```c++\n// 12_async_task.cpp\n\nstatic const int MAX = 10e8;\nstatic double sum = 0;\n\nvoid worker(int min, int max) {\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n}\n\nint main() {\n  sum = 0;\n  auto f1 = async(worker, 0, MAX);\n  cout << \"Async task triggered\" << endl;\n  f1.wait();\n  cout << \"Async task finish, result: \" << sum << endl << endl;\n}\n```\n\n这仍然是我们之前熟悉的例子。这里有两个地方需要说明：\n\n1. 这里以异步的方式启动了任务。它会返回一个`future`对象。`future`用来存储异步任务的执行结果，关于`future`我们在后面`packaged_task`的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。\n2. 此处是等待异步任务执行完成。\n\n需要注意的是，默认情况下，`async`是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过`launch::async`来明确说明。`launch`中有两个常量：\n\n- `async`：运行新线程，以异步执行任务。\n- `deferred`：调用方线程上第一次请求其结果时才执行任务，即惰性求值。\n\n除了通过函数来指定异步任务，还可以lambda表达式的方式来指定。如下所示：\n\n```c++\n// 12_async_task.cpp\n\nint main() {\n\n  double result = 0;\n  cout << \"Async task with lambda triggered, thread: \" << this_thread::get_id() << endl;\n  auto f2 = async(launch::async, [&result]() {\n    cout << \"Lambda task in thread: \" << this_thread::get_id() << endl;\n    for (int i = 0; i <= MAX; i++) {\n      result += sqrt(i);\n    }\n  });\n  f2.wait();\n  cout << \"Async task with lambda finish, result: \" << result << endl << endl;\n  \n  return 0;\n}\n```\n\n在上面这段代码中，我们使用一个lambda表达式来编写异步任务的逻辑，并通过`launch::async`明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。\n\n这段代码输出如下：\n\n```shell\nAsync task with lambda triggered, thread: 0x11290d5c0\nLambda task in thread: 0x700007aa1000\nAsync task with lambda finish, result: 2.10819e+13\n```\n\n对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：\n\n```c++\n// 12_async_task.cpp\n\nclass Worker {\npublic:\n  Worker(int min, int max): mMin(min), mMax(max) {} // ①\n  double work() { // ②\n    mResult = 0;\n    for (int i = mMin; i <= mMax; i++) {\n      mResult += sqrt(i);\n    }\n    return mResult;\n  }\n  double getResult() {\n    return mResult;\n  }\n\nprivate:\n  int mMin;\n  int mMax;\n  double mResult;\n};\n\nint main() {\n  Worker w(0, MAX);\n  cout << \"Task in class triggered\" << endl;\n  auto f3 = async(&Worker::work, &w); // ③\n  f3.wait();\n  cout << \"Task in class finish, result: \" << w.getResult() << endl << endl;\n\n  return 0;\n}\n```\n\n这段代码有三处需要说明：\n\n1. 这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。\n2. `work`函数是任务的主体逻辑。\n3. 通过`async`执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是`&w`，因此传递的是对象的指针。如果不写`&`将传入`w`对象的临时复制。\n\n## packaged_task\n\n在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用`packaged_task`来包装任务。\n\n> 如果你了解设计模式，你应该会知道[命令模式](https://en.wikipedia.org/wiki/Command_pattern)。\n\n`packaged_task`绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的`future`来获取任务的结果。调度程序只需要处理`packaged_task`，而非各个函数。\n\n`packaged_task`对象是一个可调用对象，它可以被封装成一个`std::fucntion`，或者作为线程函数传递给`std::thread`，或者直接调用。\n\n下面是一个代码示例：\n\n```c++\n// 13_packaged_task.cpp\n\ndouble concurrent_worker(int min, int max) {\n  double sum = 0;\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n  return sum;\n}\n\ndouble concurrent_task(int min, int max) {\n  vector<future<double>> results; // ①\n\n  unsigned concurrent_count = thread::hardware_concurrency();\n  min = 0;\n  for (int i = 0; i < concurrent_count; i++) { // ②\n    packaged_task<double(int, int)> task(concurrent_worker); // ③\n    results.push_back(task.get_future()); // ④\n\n    int range = max / concurrent_count * (i + 1);\n    thread t(std::move(task), min, range); // ⑤\n    t.detach();\n\n    min = range + 1;\n  }\n\n  cout << \"threads create finish\" << endl;\n  double sum = 0;\n  for (auto& r : results) {\n    sum += r.get(); // ⑥\n  }\n  return sum;\n}\n\nint main() {\n  auto start_time = chrono::steady_clock::now();\n\n  double r = concurrent_task(0, MAX);\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed, Result: \" << r << endl;\n  return 0;\n}\n```\n\n在这段代码中：\n\n1. 首先创建一个集合来存储`future`对象。我们将用它来获取任务的结果。\n2. 同样的，根据CPU的情况来创建线程的数量。\n3. 将任务包装成`packaged_task`。请注意，由于`concurrent_worker`被包装成了任务，我们无法直接获取它的`return`值。而是要通过`future`对象来获取。\n4. 获取任务关联的`future`对象，并将其存入集合中。\n5. 通过一个新的线程来执行任务，并传入需要的参数。\n6. 通过`future`集合，逐个获取每个任务的计算结果，将其累加。这里`r.get()`获取到的就是每个任务中`concurrent_worker`的返回值。\n\n为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于`packaged_task`将任务组装成队列，然后通过[线程池](https://en.wikipedia.org/wiki/Thread_pool)的方式进行调度：\n\n![image-20210305140102303](C++ 并发编程/image-20210305140102303.png)\n\n## promise与future\n\n在上面的例子中，`concurrent_task`的结果是通过`return`返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。\n\n这个时候，就可以将`promise`与`future`配对使用。这样就可以将返回结果和任务结束两个事情分开。\n\n下面是对上面代码示例的改写：\n\n```c++\n// 14_promise_future.cpp\n\ndouble concurrent_worker(int min, int max) {\n  double sum = 0;\n  for (int i = min; i <= max; i++) {\n    sum += sqrt(i);\n  }\n  return sum;\n}\n\nvoid concurrent_task(int min, int max, promise<double>* result) { // ①\n  vector<future<double>> results;\n\n  unsigned concurrent_count = thread::hardware_concurrency();\n  min = 0;\n  for (int i = 0; i < concurrent_count; i++) {\n    packaged_task<double(int, int)> task(concurrent_worker);\n    results.push_back(task.get_future()); \n\n    int range = max / concurrent_count * (i + 1);\n    thread t(std::move(task), min, range);\n    t.detach();\n\n    min = range + 1;\n  }\n\n  cout << \"threads create finish\" << endl;\n  double sum = 0;\n  for (auto& r : results) {\n    sum += r.get();\n  }\n  result->set_value(sum); // ②\n  cout << \"concurrent_task finish\" << endl;\n}\n\nint main() {\n  auto start_time = chrono::steady_clock::now();\n\n  promise<double> sum; // ③\n  concurrent_task(0, MAX, &sum);\n\n  auto end_time = chrono::steady_clock::now();\n  auto ms = chrono::duration_cast<chrono::milliseconds>(end_time - start_time).count();\n  cout << \"Concurrent task finish, \" << ms << \" ms consumed.\" << endl;\n  cout << \"Result: \" << sum.get_future().get() << endl; // ④\n  return 0;\n}\n```\n\n这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：\n\n1. `concurrent_task`不再直接返回计算结果，而是增加了一个`promise`对象来存放结果。\n2. 在任务计算完成之后，将总结过设置到`promise`对象上。一旦这里调用了`set_value`，其相关联的`future`对象就会就绪。\n3. 这里是在`main`中创建一个`promoise`来存放结果，并以指针的形式传递进`concurrent_task`中。\n4. 通过`sum.get_future().get()`来获取结果。第2点中已经说了：一旦调用了`set_value`，其相关联的`future`对象就会就绪。\n\n需要注意的是，`future`对象只有被一个线程获取值。并且在调用`get()`之后，就没有可以获取的值了。如果从多个线程调用`get()`会出现数据竞争，其结果是未定义的。\n\n如果真的需要在多个线程中获取`future`的结果，可以使用`shared_future`。\n\n# 并行算法\n\n从C++17开始。[](https://en.cppreference.com/w/cpp/algorithm)和[](https://en.cppreference.com/w/cpp/numeric#Numeric_algorithms) 头文件的中的很多算法都添加了一个新的参数：`sequenced_policy`。\n\n借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。\n\n`sequenced_policy`可能的取值有三种，它们的说明如下：\n\n| 变量                 | 类型                                   | C++版本 | 说明                                 |\n| :------------------- | :------------------------------------- | :------ | :----------------------------------- |\n| execution::seq       | execution::sequenced_policy            | C++17   | 要求并行算法的执行可以不并行化       |\n| execution::par       | execution::parallel_policy             | C++17   | 指示并行算法的执行可以并行化         |\n| execution::par_unseq | execution::parallel_unsequenced_policy | C++17   | 指示并行算法的执行可以并行化、向量化 |\n\n> 注意：[本文的前面](https://paul.pub/cpp-concurrency/#id-测试环境)已经提到，目前clang编译器还不支持这个功能。因此想要编译这部分代码，你需要使用gcc 9.0或更高版本，同时还需要安装[Intel Threading Building Blocks](https://github.com/intel/tbb)。\n\n下面还是通过一个示例来进行说明：\n\n```c++\n// 15_parallel_algorithm.cpp\n\nvoid generateRandomData(vector<double>& collection, int size) {\n  random_device rd;\n  mt19937 mt(rd());\n  uniform_real_distribution<double> dist(1.0, 100.0);\n  for (int i = 0; i < size; i++) {\n    collection.push_back(dist(mt));\n  }\n}\n\nint main() {\n  vector<double> collection;\n  generateRandomData(collection, 10e6); // ①\n\n  vector<double> copy1(collection); // ②\n  vector<double> copy2(collection);\n  vector<double> copy3(collection);\n\n  auto time1 = chrono::steady_clock::now(); // ③\n  sort(execution::seq, copy1.begin(), copy1.end()); // ④\n  auto time2 = chrono::steady_clock::now();\n  auto duration = chrono::duration_cast<chrono::milliseconds>(time2 - time1).count();\n  cout << \"Sequenced sort consuming \" << duration << \"ms.\" << endl; // ⑤\n\n  auto time3 = chrono::steady_clock::now();\n  sort(execution::par, copy2.begin(),copy2.end()); // ⑥\n  auto time4 = chrono::steady_clock::now();\n  duration = chrono::duration_cast<chrono::milliseconds>(time4 - time3).count();\n  cout << \"Parallel sort consuming \" << duration << \"ms.\" << endl;\n\n  auto time5 = chrono::steady_clock::now();\n  sort(execution::par_unseq, copy2.begin(),copy2.end()); // ⑦\n  auto time6 = chrono::steady_clock::now();\n  duration = chrono::duration_cast<chrono::milliseconds>(time6 - time5).count();\n  cout << \"Parallel unsequenced sort consuming \" << duration << \"ms.\" << endl;\n}\n```\n\n这段代码很简单：\n\n1. 通过一个函数生成1000,000个随机数。\n2. 将数据拷贝3份，以备使用。\n3. 接下来将通过三个不同的`parallel_policy`参数来调用同样的`sort`算法。每次调用记录开始和结束的时间。\n4. 第一次调用使用`std::execution::seq`参数。\n5. 输出本次测试所使用的时间。\n6. 第二次调用使用`std::execution::par`参数。\n7. 第三次调用使用`std::execution::par_unseq`参数。\n\n该程序的输出如下：\n\n```c++\nSequenced sort consuming 4464ms.\nParallel sort consuming 459ms.\nParallel unsequenced sort consuming 168ms.\n```\n\n可以看到，性能最好的和最差的相差了超过26倍。\n\n# 结束语\n\n在本篇文章中，我们介绍了C++语言中新增的并发编程API。虽然这部分内容已经不少（大部分人很难一次性搞懂所有这些内容，包括我自己），但实际上还有一个很重要的话题我们没有触及，那就是“内存模型”。\n\nC++内存模型是C++11标准中最重要的特性之一。它是多线程环境能够可靠工作的基础。考虑到这部分内容还需要比较多的篇幅来说明，因此我们会在下一篇文章中继续讨论。\n\n# 参考资料与推荐读物\n\n- [C++ Concurrency in Action 2nd](https://www.amazon.com/C-Concurrency-Action-Anthony-Williams/dp/1617294691/)\n- [Wikipedia](http://wikipedia.org/)\n- [cpprefernce: Thread support library](https://en.cppreference.com/w/cpp/thread)\n- [Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14](https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996)\n- [Threads Cannot be Implemented as a Library](https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf)\n- [I’m Proud to Present: Modern C++ Concurrency is available as interactive course](https://www.modernescpp.com/index.php/i-m-proud-to-present-modern-c-concurrency-is-available-as-interactive-course)\n- [How do I enable C++17?](https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000682210-How-do-I-enable-C-17-)\n- [C++17 STL Parallel Algorithms - with GCC 9.1 and Intel TBB on Linux and macOS](https://solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/)\n- [How to install packages from a newer distribution without installing unwanted](https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f)","slug":"cplus_md/CPlus Basic/C++ 并发编程","published":1,"updated":"2021-04-09T14:06:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6e004gw9q96ep143me","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"C-并发编程\"><a href=\"#C-并发编程\" class=\"headerlink\" title=\"C++ 并发编程\"></a>C++ 并发编程</h1><p>自C++11标准以来，C++语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。</p>\n<h2 id=\"为什么要并发编程\"><a href=\"#为什么要并发编程\" class=\"headerlink\" title=\"为什么要并发编程\"></a>为什么要并发编程</h2><p>大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。</p>\n<p>另一方面，自上个世纪六七十年代英特尔创始人之一 <a href=\"https://en.wikipedia.org/wiki/Gordon_Moore\">Gordon Moore</a> 提出 <a href=\"https://en.wikipedia.org/wiki/Moore's_law\">摩尔定义</a> 以来，CPU频率以每18个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。</p>\n<p>由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。</p>\n<p>本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。</p>\n<h2 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h2><p>并发（Concurrent）与并行（Parallel）都是很常见的术语。</p>\n<p>Erlang之父Joe Armstrong曾经以人们使用咖啡机的场景为例描述了这两个术语。如下图所示：</p>\n<p>![img](C++ 并发编程/con_and_par.jpg)</p>\n<ul>\n<li><strong>并发</strong>：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。</li>\n<li><strong>并行</strong>：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。</li>\n</ul>\n<p>这里队列中的每个人类比于计算机的任务，咖啡机类比于计算机处理器。因此：并发和并行都是在多任务的环境下的讨论。</p>\n<p>更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。</p>\n<p>你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。</p>\n<p>在不考虑处理器数量的情况下，我们统称之为“并发”。</p>\n<h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><p>进程与线程是操作系统的基本概念。无论是桌面系统：MacOS，Linux，Windows，还是移动操作系统：Android，iOS，都存在进程和线程的概念。</p>\n<blockquote>\n<p><strong>进程</strong>（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；</p>\n<p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>\n<p>– 维基百科</p>\n</blockquote>\n<p>关于这两个概念在任何一本操作系统书上都可以找到定义。网上也有很多文章对它们进行了解释。因此这里不再赘述，这里仅仅提及一下它们与编程的关系。</p>\n<p>对于绝大部分编程语言或者编程环境来说，我们所写的程序都会在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为主线程。</p>\n<p>在默认的情况下，我们写的代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。</p>\n<p>不同编程语言的线程环境会不一样，Java语言在很早就支持了多线程接口。（Java程序在Java虚拟机中运行，虚拟机通常还会包含自己特有的线程，例如垃圾回收线程。）。而对于JavaScript这样的语言来说，它就没有多线程的概念。</p>\n<p>当我们只有一个处理器时，所有的进程或线程会分时占用这个处理器。但如果系统中存在多个处理器时，则就可能有多个任务并行的运行在不同的处理器上。</p>\n<p>下面两幅图以不同颜色的矩形代表不同的任务（可能是进程，也可能是线程）来描述它们可能在处理器上执行的顺序。</p>\n<p>下图是单核处理器的情况：</p>\n<img src=\"C++ 并发编程/single_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>下面是四核处理器的情况：</p>\n<img src=\"C++ 并发编程/four_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>任务会在何时占有处理器，通常是由操作系统的调度策略决定的。在<a href=\"https://paul.pub/android-process-schedule/\">《Android系统上的进程管理：进程的调度》</a>一文中，我们介绍过Linux的调度策略。</p>\n<p>当我们在开发跨平台的软件时，我们不应当对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。</p>\n<h2 id=\"并发系统的性能\"><a href=\"#并发系统的性能\" class=\"headerlink\" title=\"并发系统的性能\"></a>并发系统的性能</h2><p>开发并发系统最主要的动机就是提升系统性能（事实上，这是以增加复杂度为代价的）。</p>\n<p>但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。</p>\n<p>因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。</p>\n<p>关于这一点，你可能需要了解一下<a href=\"https://en.wikipedia.org/wiki/Amdahl's_law\">阿姆达尔定律</a>了。对于这个定律，简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。</p>\n<p>关于阿姆达尔定律在<a href=\"https://paul.pub/sysstat/#id-%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B\">Linux系统监测工具sysstat介绍</a>一文中已经介绍过，因此这里不再赘述。</p>\n<h1 id=\"C-与并发编程\"><a href=\"#C-与并发编程\" class=\"headerlink\" title=\"C++与并发编程\"></a>C++与并发编程</h1><p>前面我们已经了解到，并非所有的语言都提供了多线程的环境。</p>\n<p>即便是C++语言，直到<a href=\"https://en.wikipedia.org/wiki/C%2B%2B11\">C++11</a>标准之前，也是没有多线程支持的。在这种情况下，Linux/Unix平台下的开发者通常会使用<a href=\"https://en.wikipedia.org/wiki/POSIX_Threads\">POSIX Threads</a>，Windows上的开发者也会有<a href=\"https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-cpp-and-mfc?view=vs-2019\">相应的接口</a>。但很明显，这些API都只针对特定的操作系统平台，可移植性较差。如果要同时支持Linux和Windows系统，你可能要写两套代码。</p>\n<blockquote>\n<p>相较而言，Java自JDK 1.0就包含了多线程模型。</p>\n</blockquote>\n<p>这个状态在C++ 11标准发布之后得到了改变。并且，在C++ 14和C++ 17标准中又对并发编程机制进行了增强。</p>\n<p>下图是最近几个版本的C++标准特性的线路图。</p>\n<img src=\"C++ 并发编程/cpp_timeline.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n<h2 id=\"编译器与C-标准\"><a href=\"#编译器与C-标准\" class=\"headerlink\" title=\"编译器与C++标准\"></a>编译器与C++标准</h2><p>编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。</p>\n<ul>\n<li>GCC对于C++特性的支持请参见这里：<a href=\"https://www.gnu.org/software/gcc/projects/cxx-status.html\">C++ Standards Support in GCC</a>。</li>\n<li>Clang对于C++特性的支持请参见这里：<a href=\"https://clang.llvm.org/cxx_status.html\">C++ Support in Clang</a>。</li>\n</ul>\n<p>下面两个表格列出了C++标准和相应编译器的版本对照：</p>\n<ul>\n<li>C++标准与相应的GCC版本要求如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">C++版本</th>\n<th align=\"left\">GCC版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C++11</td>\n<td align=\"left\">4.8</td>\n</tr>\n<tr>\n<td align=\"left\">C++14</td>\n<td align=\"left\">5.0</td>\n</tr>\n<tr>\n<td align=\"left\">C++17</td>\n<td align=\"left\">7.0</td>\n</tr>\n</tbody></table>\n<ul>\n<li>C++标准与相应的Clang版本要求如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">C++版本</th>\n<th align=\"left\">Clang版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C++11</td>\n<td align=\"left\">3.3</td>\n</tr>\n<tr>\n<td align=\"left\">C++14</td>\n<td align=\"left\">3.4</td>\n</tr>\n<tr>\n<td align=\"left\">C++17</td>\n<td align=\"left\">5.0</td>\n</tr>\n</tbody></table>\n<p>默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数<code>-std=c++xx</code>告知编译器，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -std=c++17 your_file.cpp -o your_program</span><br></pre></td></tr></table></figure>\n<h1 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h1><p>本文的源码可以到下载我的github上获取，地址：<a href=\"https://github.com/paulQuei/cpp-concurrency\">paulQuei/cpp-concurrency</a>。</p>\n<p>你可以直接通过下面这条命令获取源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;paulQuei&#x2F;cpp-concurrency.git</span><br></pre></td></tr></table></figure>\n<p>源码下载之后，你可以通过任何文本编辑器浏览源码。如果希望编译和运行程序，你还需要按照下面的内容来准备环境。</p>\n<p>本文中的源码使用<a href=\"https://cmake.org/\">cmake</a>编译，只有cmake 3.8以上的版本才支持C++ 17，所以你需要安装这个或者更新版本的cmake。</p>\n<p>另外，截止目前（2019年10月）为止，<code>clang</code>编译器还不支持<a href=\"https://paul.pub/cpp-concurrency/#id-%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95\">并行算法</a>。</p>\n<p>但是<a href=\"https://gcc.gnu.org/gcc-9/changes.html\">gcc-9</a>是支持的。因此想要编译和运行这部分代码，你需要安装gcc 9.0或更新的版本。并且，gcc-9还要依赖<a href=\"https://github.com/intel/tbb\">Intel Threading Building Blocks</a>才能使用并行算法以及<code>&lt;execution&gt;</code>头文件。</p>\n<p>具体的安装方法见下文。</p>\n<blockquote>\n<p>具体编译器对于C++特性支持的情况请参见这里：<a href=\"https://en.cppreference.com/w/cpp/compiler_support\">C++ compiler support</a>。</p>\n</blockquote>\n<p>安装好之后运行根目录下的下面这个命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./make_all.sh</span><br></pre></td></tr></table></figure>\n<p>它会完成所有的编译工作。</p>\n<p>本文的源码在下面两个环境中经过测试，环境的准备方法如下。</p>\n<h2 id=\"MacOS\"><a href=\"#MacOS\" class=\"headerlink\" title=\"MacOS\"></a>MacOS</h2><p>在Mac上，我使用<a href=\"https://brew.sh/\">brew</a>工具安装<code>gcc</code>以及<code>tbb</code>库。</p>\n<p>考虑到其他人与我的环境可能会有所差异，所以需要手动告知<code>tbb</code>库的安装路径。</p>\n<p>读者需要执行下面这些命令来准备环境：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install gcc</span><br><span class=\"line\">brew install tbb</span><br><span class=\"line\"></span><br><span class=\"line\">export tbb_path=/usr/local/Cellar/tbb/2019_U8/</span><br><span class=\"line\">./make_all.sh</span><br></pre></td></tr></table></figure>\n<p>注意，请通过运行<code>g++-9</code>命令以确认gcc的版本是否正确，如果版本较低，则需要通过<code>brew</code>命令将其升级到新版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew upgrade gcc</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h2><p>Ubuntu上，通过下面的命令安装<code>gcc-9</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt install  gcc-9 g++-9</span><br></pre></td></tr></table></figure>\n<p>但安装<code>tbb</code>库就有些麻烦了。这是因为<a href=\"https://launchpad.net/ubuntu/+source/tbb\">Ubuntu 16.04默认关联的版本是较低的</a>，直接安装是无法使用的。我们需要安装<a href=\"https://launchpad.net/ubuntu/+source/tbb/2019~U8-1\">更新的版本</a>。</p>\n<p>联网安装的方式<a href=\"https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f\">步骤繁琐</a>，所以可以通过下载包的方式进行安装，我已经将这需要的两个文件放到的这里：</p>\n<ul>\n<li><a href=\"https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb2_2019~U8-1_amd64.deb\">libtbb2_2019~U8-1_amd64.deb</a></li>\n<li><a href=\"https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb-dev_2019~U8-1_amd64.deb\">libtbb-dev_2019~U8-1_amd64.deb</a></li>\n</ul>\n<p>如果需要，你可以下载后通过<code>apt</code>命令安装即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install ~/Downloads/libtbb2_2019~U8-1_amd64.deb </span><br><span class=\"line\">sudo apt install ~/Downloads/libtbb-dev_2019~U8-1_amd64.deb </span><br></pre></td></tr></table></figure>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 01_hello_thread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt; // ①</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Hello World from new thread.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(hello)</span></span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  t.join(); <span class=\"comment\">// ⑤</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这段代码说明如下：</p>\n<ol>\n<li>为了使用多线程的接口，我们需要<code>#include &lt;thread&gt;</code>头文件。</li>\n<li>为了简化声明，本文中的代码都将<code>using namespace std;</code>。</li>\n<li>新建线程的入口是一个普通的函数，它并没有什么特别的地方。</li>\n<li>创建线程的方式就是构造一个<code>thread</code>对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。</li>\n<li>关于<code>join</code>函数在下文中讲解。</li>\n</ol>\n<p><code>thread</code>可以和<code>callable</code>类型一起工作，因此如果你熟悉<a href=\"https://en.cppreference.com/w/cpp/language/lambda\">lambda表达式</a>，你可以直接用它来写线程的逻辑，像这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 02_lambda_thread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">([] &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Hello World from lambda thread.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  &#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为了减少不必要的重复，若无必要，下文中的代码将不贴出<code>include</code>指令以及<code>using</code>声明。</p>\n</blockquote>\n<p>当然，你可以传递参数给入口函数，像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 03_thread_argument.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"built_in\">string</span> name)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Welcome to &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(hello, <span class=\"string\">&quot;https://paul.pub&quot;</span>)</span></span>;</span><br><span class=\"line\">  t.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不过需要注意的是，参数是以拷贝的形式进行传递的。因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文<code>detach</code>），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。</p>\n<h2 id=\"join与detach\"><a href=\"#join与detach\" class=\"headerlink\" title=\"join与detach\"></a>join与detach</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">join</td>\n<td align=\"left\">等待线程完成其执行</td>\n</tr>\n<tr>\n<td align=\"left\">detach</td>\n<td align=\"left\">允许线程独立执行</td>\n</tr>\n</tbody></table>\n<p>一旦启动线程之后，我们必须决定是要等待直接它结束（通过<code>join</code>），还是让它独立运行（通过<code>detach</code>），我们必须二者选其一。如果在<code>thread</code>对象<strong>销毁的时候</strong>我们还没有做决定，则<code>thread</code>对象在析构函数出将调用<code>std::terminate()</code>从而导致我们的进程异常退出。</p>\n<blockquote>\n<p>请思考在上面的代码示例中，<code>thread</code>对象在何时会销毁。</p>\n</blockquote>\n<p>需要注意的是：在我们做决定的时候，很可能线程已经执行完了（例如上面的示例中线程的逻辑仅仅是一句打印，执行时间会很短）。新的线程创建之后，究竟是新的线程先执行，还是当前线程的下一条语句先执行这是不确定的，因为这是由操作系统的调度策略决定的。不过这不要紧，我们只要在<code>thread</code>对象销毁前做决定即可。</p>\n<ul>\n<li><code>join</code>：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</li>\n<li><code>detach</code>：<code>detach</code>是让目标线程成为守护线程（daemon threads）。一旦<code>detach</code>之后，目标线程将独立执行，即便其对应的<code>thread</code>对象销毁也不影响线程的执行。并且，你无法再与之通信。</li>\n</ul>\n<p>对于这两个接口，都必须是可执行的线程才有意义。你可以通过<code>joinable()</code>接口查询是否可以对它们进行<code>join</code>或者<code>detach</code>。</p>\n<h2 id=\"管理当前线程\"><a href=\"#管理当前线程\" class=\"headerlink\" title=\"管理当前线程\"></a>管理当前线程</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">yield</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">让出处理器，重新调度各执行线程</td>\n</tr>\n<tr>\n<td align=\"left\">get_id</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">返回当前线程的线程 id</td>\n</tr>\n<tr>\n<td align=\"left\">sleep_for</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">使当前线程的执行停止指定的时间段</td>\n</tr>\n<tr>\n<td align=\"left\">sleep_until</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">使当前线程的执行停止直到指定的时间点</td>\n</tr>\n</tbody></table>\n<p>上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。</p>\n<ul>\n<li><code>yield</code> 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。</li>\n<li><code>get_id</code> 返回当前线程的id，可以以此来标识不同的线程。</li>\n<li><code>sleep_for</code> 是让当前线程停止一段时间。</li>\n<li><code>sleep_until</code> 和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个API都以<a href=\"https://en.cppreference.com/w/cpp/header/chrono\">chrono</a> API（由于篇幅所限，这里不展开这方面内容）为基础。</li>\n</ul>\n<p>下面是一个代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 04_thread_self_manage.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_time</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> now = chrono::system_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> <span class=\"keyword\">in_time_t</span> = chrono::system_clock::<span class=\"keyword\">to_time_t</span>(now);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">  ss &lt;&lt; put_time(localtime(&amp;<span class=\"keyword\">in_time_t</span>), <span class=\"string\">&quot;%Y-%m-%d %X&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;now is: &quot;</span> &lt;&lt; ss.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleep_thread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  this_thread::sleep_for(chrono::seconds(<span class=\"number\">3</span>));</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;[thread-&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"string\">&quot;] is waking up&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop_thread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;[thread-&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"string\">&quot;] print: &quot;</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  print_time();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(sleep_thread)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(loop_thread)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">  print_time();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码应该还是比较容易理解的，这里创建了两个线程。它们都会有一些输出，其中一个会先停止3秒钟，然后再输出。主线程调用<code>join</code>会一直卡住等待它运行结束。</p>\n<p>这段程序的输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">now is: 2019-10-13 10:17:48</span><br><span class=\"line\">[thread-0x70000cdda000] print: 0</span><br><span class=\"line\">[thread-0x70000cdda000] print: 1</span><br><span class=\"line\">[thread-0x70000cdda000] print: 2</span><br><span class=\"line\">[thread-0x70000cdda000] print: 3</span><br><span class=\"line\">[thread-0x70000cdda000] print: 4</span><br><span class=\"line\">[thread-0x70000cdda000] print: 5</span><br><span class=\"line\">[thread-0x70000cdda000] print: 6</span><br><span class=\"line\">[thread-0x70000cdda000] print: 7</span><br><span class=\"line\">[thread-0x70000cdda000] print: 8</span><br><span class=\"line\">[thread-0x70000cdda000] print: 9</span><br><span class=\"line\">[thread-0x70000cd57000] is waking up</span><br><span class=\"line\">now is: 2019-10-13 10:17:51</span><br></pre></td></tr></table></figure>\n<h2 id=\"一次调用\"><a href=\"#一次调用\" class=\"headerlink\" title=\"一次调用\"></a>一次调用</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">call_once</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">即便在多线程环境下，也能保证只调用某个函数一次</td>\n</tr>\n<tr>\n<td align=\"left\">once_flag</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">与<code>call_once</code>配合使用</td>\n</tr>\n</tbody></table>\n<p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>\n<p>下面就是一个示例：有三个线程都会使用<code>init</code>函数，但是只会有一个线程真正执行它。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 05_call_once.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Initialing...&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">(once_flag* flag)</span> </span>&#123;</span><br><span class=\"line\">  call_once(*flag, init);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  once_flag flag;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(worker, &amp;flag)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(worker, &amp;flag)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t3</span><span class=\"params\">(worker, &amp;flag)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\">  t3.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们无法确定具体是哪一个线程会执行<code>init</code>。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。</p>\n<blockquote>\n<p>请思考一下，为什么要在main函数中创建<code>once_flag flag</code>。如果是在<code>worker</code>函数中直接声明一个<code>once_flag</code>并使用行不行？为什么？</p>\n</blockquote>\n<h1 id=\"并发任务\"><a href=\"#并发任务\" class=\"headerlink\" title=\"并发任务\"></a>并发任务</h1><p>下面以一个并发任务为示例讲解如何引入多线程。</p>\n<p>任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如<code>[1, 10e8]</code>。</p>\n<p>在单线程模型下，我们的代码可能是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 06_naive_multithread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10e8</span>; <span class=\"comment\">// ①</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">serial_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  worker(<span class=\"number\">0</span>, MAX);</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Serail task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码说明如下：</p>\n<ol>\n<li>通过一个常量指定数据范围，这个是为了方便调整。</li>\n<li>通过一个全局变量来存储结果。</li>\n<li>通过一个任务函数来计算值。</li>\n<li>统计任务的执行时间。</li>\n</ol>\n<p>这段程序输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Serail task finish, 6406 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。</p>\n<p>下面我们就尝试以多线程的方式来改造原先的程序。</p>\n<p>改造后的程序如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 06_naive_multithread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency(); <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;thread&gt; threads;</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> t = <span class=\"number\">0</span>; t &lt; concurrent_count; t++) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (t + <span class=\"number\">1</span>);</span><br><span class=\"line\">    threads.push_back(thread(worker, min, range)); <span class=\"comment\">// ③</span></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; t : threads) &#123;</span><br><span class=\"line\">    t.join(); <span class=\"comment\">// ④</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码说明如下：</p>\n<ol>\n<li><code>thread::hardware_concurrency()</code>可以获取到当前硬件支持多少个线程并行执行。</li>\n<li>根据处理器的情况决定线程的数量。</li>\n<li>对于每一个线程都通过<code>worker</code>函数来完成任务，并划分一部分数据给它处理。</li>\n<li>等待每一个线程执行结束。</li>\n</ol>\n<p>很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hardware_concurrency: 16</span><br><span class=\"line\">Concurrent task finish, 6246 ms consumed, Result: 1.78162e+12</span><br></pre></td></tr></table></figure>\n<p>很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。</p>\n<p>要搞清楚为什么结果不正确我们需要更多的背景知识。</p>\n<p>我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：</p>\n<blockquote>\n<p>事实上，目前大部分CPU的缓存已经不只一层。</p>\n</blockquote>\n<img src=\"C++ 并发编程/cpu.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。</p>\n<p>事情还远不止这么简单。我们对于全局变量值的修改：<code>sum += sqrt(i);</code>这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：</p>\n<img src=\"C++ 并发编程/multithread.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>在时间点a的时候，所有线程对于<code>sum</code>变量的值是一致的。</p>\n<p>但是在时间点b之后，thread3上已经对<code>sum</code>进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。</p>\n<h2 id=\"竞争条件与临界区\"><a href=\"#竞争条件与临界区\" class=\"headerlink\" title=\"竞争条件与临界区\"></a>竞争条件与临界区</h2><p>当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为<a href=\"https://en.wikipedia.org/wiki/Race_condition\"><strong>竞争条件</strong>（race condition）</a>。</p>\n<p>访问共享数据的代码片段称之为<strong>临界区</strong>（critical section）。具体到上面这个示例，临界区就是读写<code>sum</code>变量的地方。</p>\n<p>要避免竞争条件，就需要对临界区进行数据保护。</p>\n<p>很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。</p>\n<p>那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。</p>\n<p>接下来介绍的API提供的就是这样的功能。</p>\n<h1 id=\"互斥体与锁\"><a href=\"#互斥体与锁\" class=\"headerlink\" title=\"互斥体与锁\"></a>互斥体与锁</h1><h2 id=\"mutex\"><a href=\"#mutex\" class=\"headerlink\" title=\"mutex\"></a>mutex</h2><p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p>\n<ol>\n<li>独立的对于划分给自己的数据的处理</li>\n<li>对于处理结果的汇总</li>\n</ol>\n<p>其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的<code>sum</code>变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。<code>mutex</code> 就提供了这样的功能。</p>\n<p><code>mutex</code>是<strong>mut</strong>ual <strong>ex</strong>clusion（互斥）的简写。</p>\n<ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供基本互斥设施</td>\n</tr>\n<tr>\n<td align=\"left\">timed_mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供互斥设施，带有超时功能</td>\n</tr>\n<tr>\n<td align=\"left\">recursive_mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供能被同一线程递归锁定的互斥设施</td>\n</tr>\n<tr>\n<td align=\"left\">recursive_timed_mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供能被同一线程递归锁定的互斥设施，带有超时功能</td>\n</tr>\n<tr>\n<td align=\"left\">shared_timed_mutex</td>\n<td align=\"left\">C++14</td>\n<td align=\"left\">提供共享互斥设施并带有超时功能</td>\n</tr>\n<tr>\n<td align=\"left\">shared_mutex</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">提供共享互斥设施</td>\n</tr>\n</tbody></table>\n<p>很明显，在这些类中，<code>mutex</code>是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lock</td>\n<td>锁定互斥体，如果不可用，则阻塞</td>\n</tr>\n<tr>\n<td>try_lock</td>\n<td>尝试锁定互斥体，如果不可用，直接返回</td>\n</tr>\n<tr>\n<td>unlock</td>\n<td>解锁互斥体</td>\n</tr>\n</tbody></table>\n<p>这三个方法提供了基础的锁定和解除锁定的功能。使用<code>lock</code>意味着你有很强的意愿一定要获取到互斥体，而使用<code>try_lock</code>则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。</p>\n<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：</p>\n<ul>\n<li><strong>超时</strong>：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</li>\n<li><strong>可重入</strong>：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</li>\n<li><strong>共享</strong>：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在<a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem\">读者写者模型</a>上。</li>\n</ul>\n<p>使用共享锁的接口如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lock_shared</td>\n<td>获取互斥体的共享锁，如果无法获取则阻塞</td>\n</tr>\n<tr>\n<td>try_lock_shared</td>\n<td>尝试获取共享锁，如果不可用，直接返回</td>\n</tr>\n<tr>\n<td>unlock_shared</td>\n<td>解锁共享锁</td>\n</tr>\n</tbody></table>\n<p>接下来，我们就借助刚学到的<code>mutex</code>来改造我们的并发系统，改造后的程序如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 07_mutex_lock.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10e8</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> mutex exclusive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    exclusive.lock(); <span class=\"comment\">// ①</span></span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">    exclusive.unlock(); <span class=\"comment\">// ②</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;thread&gt; threads;</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> t = <span class=\"number\">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (t + <span class=\"number\">1</span>);</span><br><span class=\"line\">    threads.push_back(thread(concurrent_worker, min, range)); <span class=\"comment\">// ③</span></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threads.size(); i++) &#123;</span><br><span class=\"line\">    threads[i].join();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只有三个地方需要关注：</p>\n<ol>\n<li>在访问共享数据之前加锁</li>\n<li>访问完成之后解锁</li>\n<li>在多线程中使用带锁的版本</li>\n</ol>\n<p>执行之后结果输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hardware_concurrency: 16</span><br><span class=\"line\">Concurrent task finish, 74232 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？</p>\n<p>这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。</p>\n<p>这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。</p>\n<p>不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。</p>\n<p>于是我们改造<code>concurrent_worker</code>，像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 08_improved_mutex_lock.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> tmp_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    tmp_sum += <span class=\"built_in\">sqrt</span>(i); <span class=\"comment\">// ①</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  exclusive.lock(); <span class=\"comment\">// ②</span></span><br><span class=\"line\">  sum += tmp_sum;</span><br><span class=\"line\">  exclusive.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的改变在于两处：</p>\n<ol>\n<li>通过一个局部变量保存当前线程的处理结果</li>\n<li>在汇总总结过的时候进行锁保护</li>\n</ol>\n<p>运行一下改进后的程序，其结果输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hardware_concurrency: 16</span><br><span class=\"line\">Concurrent task finish, 451 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。</p>\n<p>我们用锁的<strong>粒度</strong>（granularity）来描述锁的范围。<strong>细粒度</strong>（fine-grained）是指锁保护较小的范围，<strong>粗粒度</strong>（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。</p>\n<blockquote>\n<p>In general, a lock should be held for only the minimum possible time needed to perform the required operations.</p>\n<p>–《C++ Concurrency in Action》</p>\n</blockquote>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是并发系统很常见的一类问题。</p>\n<p>死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。</p>\n<p>死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。</p>\n<p>在成年人的世界里也会发生类似的情况，例如下面这个交通状况：</p>\n<p>![img](C++ 并发编程/deadlock.gif)</p>\n<p>下面我们来看一个编程示例。</p>\n<p>现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。</p>\n<p>首先我们创建一个<code>Account</code>类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。<code>Account</code>类仅仅包含名称和金额两个字段。</p>\n<p>另外，为了支持并发，这个类包含了一个<code>mutex</code>对象，用来保护账号金额，在读写账号金额时需要先加锁保护。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Account(<span class=\"built_in\">string</span> name, <span class=\"keyword\">double</span> money): mName(name), mMoney(money) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changeMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    mMoney += amount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mMoney;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\">mutex* <span class=\"title\">getLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;mMoneyLock;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">string</span> mName;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> mMoney;</span><br><span class=\"line\">  mutex mMoneyLock;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>Account</code>类很简单，我想就不用多做说明了。</p>\n<p>接下来，我们再创建一个描述银行的<code>Bank</code>类。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addAccount</span><span class=\"params\">(Account* account)</span> </span>&#123;</span><br><span class=\"line\">    mAccounts.insert(account);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">transferMoney</span><span class=\"params\">(Account* accountA, Account* accountB, <span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">lock_guard <span class=\"title\">guardA</span><span class=\"params\">(*accountA-&gt;getLock())</span></span>; <span class=\"comment\">// ①</span></span><br><span class=\"line\">    <span class=\"function\">lock_guard <span class=\"title\">guardB</span><span class=\"params\">(*accountB-&gt;getLock())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount &gt; accountA-&gt;getMoney()) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    accountA-&gt;changeMoney(-amount); <span class=\"comment\">// ③</span></span><br><span class=\"line\">    accountB-&gt;changeMoney(amount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">totalMoney</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> a : mAccounts) &#123;</span><br><span class=\"line\">      sum += a-&gt;getMoney();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">set</span>&lt;Account*&gt; mAccounts;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。</p>\n<p>这其中，我们最主要要关注转账的实现：<code>transferMoney</code>。该方法的几个关键点如下：</p>\n<ol>\n<li>为了保证线程安全，在修改每个账号之前，需要获取相应的锁。</li>\n<li>判断转出账户金额是否足够，如果不够此次转账失败。</li>\n<li>进行转账。</li>\n</ol>\n<p>有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomTransfer</span><span class=\"params\">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> randomMoney = ((<span class=\"keyword\">double</span>)rand() / RAND_MAX) * <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bank-&gt;transferMoney(accountA, accountB, randomMoney)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; from &quot;</span> &lt;&lt; accountA-&gt;getName()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot; to &quot;</span> &lt;&lt; accountB-&gt;getName()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;totalMoney() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer failed, &quot;</span></span><br><span class=\"line\">           &lt;&lt; accountA-&gt;getName() &lt;&lt; <span class=\"string\">&quot; has only $&quot;</span> &lt;&lt; accountA-&gt;getMoney() &lt;&lt; <span class=\"string\">&quot;, but &quot;</span></span><br><span class=\"line\">           &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; required&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里每次生成一个随机数，然后通过银行进行转账。</p>\n<p>最后我们在<code>main</code>函数中创建两个线程，互相在两个账号之间来回转账：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Account <span class=\"title\">a</span><span class=\"params\">(<span class=\"string\">&quot;Paul&quot;</span>, <span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">Account <span class=\"title\">b</span><span class=\"params\">(<span class=\"string\">&quot;Moira&quot;</span>, <span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Bank aBank;</span><br><span class=\"line\">  aBank.addAccount(&amp;a);</span><br><span class=\"line\">  aBank.addAccount(&amp;b);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(randomTransfer, &amp;aBank, &amp;a, &amp;b)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(randomTransfer, &amp;aBank, &amp;b, &amp;a)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Transfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $34.7581, but 66.3208 required</span><br><span class=\"line\">Transfer failed, Moira has only $34.7581, but </span><br><span class=\"line\">Transfer 93.191 from 53.9176 required</span><br><span class=\"line\">Transfer 60.6146 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: </span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 18.1186 required</span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 18.893 required</span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 34.7078 required</span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 33.9569 required</span><br><span class=\"line\">Transfer 12.7899 from 200</span><br><span class=\"line\">Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $63.9373, but 80.9038 required</span><br><span class=\"line\">Transfer 50.933 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $13.0043, but 30.2056 required</span><br><span class=\"line\">Transfer failed, Moira has only $Transfer 59.123 from Paul to Moira, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required</span><br></pre></td></tr></table></figure>\n<p>如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？</p>\n<p>因为发生了死锁。</p>\n<p>我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：</p>\n<img src=\"C++ 并发编程/deadlock.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相<code>join</code>就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如<code>mutex</code>而非<code>recursive_mutex</code>）多次加锁也会死锁。</p>\n<p>你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。</p>\n<p>如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。</p>\n<p>下面我们就来逐步解决上面的问题。</p>\n<p>对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 10_improved_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\">mutex sCoutLock;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomTransfer</span><span class=\"params\">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> randomMoney = ((<span class=\"keyword\">double</span>)rand() / RAND_MAX) * <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bank-&gt;transferMoney(accountA, accountB, randomMoney)) &#123;</span><br><span class=\"line\">      sCoutLock.lock();</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; from &quot;</span> &lt;&lt; accountA-&gt;getName()</span><br><span class=\"line\">          &lt;&lt; <span class=\"string\">&quot; to &quot;</span> &lt;&lt; accountB-&gt;getName()</span><br><span class=\"line\">          &lt;&lt; <span class=\"string\">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;totalMoney() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      sCoutLock.unlock();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      sCoutLock.lock();</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer failed, &quot;</span></span><br><span class=\"line\">           &lt;&lt; accountA-&gt;getName() &lt;&lt; <span class=\"string\">&quot; has only &quot;</span> &lt;&lt; accountA-&gt;getMoney() &lt;&lt; <span class=\"string\">&quot;, but &quot;</span></span><br><span class=\"line\">           &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; required&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      sCoutLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>请思考一下两处<code>lock</code>和<code>unlock</code>调用，并考虑为什么不在<code>while(true)</code>下面写一次整体的加锁和解锁。</p>\n</blockquote>\n<h2 id=\"通用锁定算法\"><a href=\"#通用锁定算法\" class=\"headerlink\" title=\"通用锁定算法\"></a>通用锁定算法</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">锁定指定的互斥体，若任何一个不可用则阻塞</td>\n</tr>\n<tr>\n<td align=\"left\">try_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">试图通过重复调用 try_lock 获得互斥体的所有权</td>\n</tr>\n</tbody></table>\n<p>要避免死锁，需要仔细的思考和设计业务逻辑。</p>\n<p>有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁B，才能玩玩具。这样就不会死锁了。</p>\n<p>这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。</p>\n<p>不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个<a href=\"https://en.cppreference.com/w/cpp/named_req/Lockable\">Lockable</a>对象。</p>\n<p>接下来我们用它来改造之前死锁的转账系统：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 10_improved_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">transferMoney</span><span class=\"params\">(Account* accountA, Account* accountB, <span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">  lock(*accountA-&gt;getLock(), *accountB-&gt;getLock());    <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"function\">lock_guard <span class=\"title\">lockA</span><span class=\"params\">(*accountA-&gt;getLock(), adopt_lock)</span></span>;  <span class=\"comment\">// ②</span></span><br><span class=\"line\">  <span class=\"function\">lock_guard <span class=\"title\">lockB</span><span class=\"params\">(*accountB-&gt;getLock(), adopt_lock)</span></span>;  <span class=\"comment\">// ③</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (amount &gt; accountA-&gt;getMoney()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  accountA-&gt;changeMoney(-amount);</span><br><span class=\"line\">  accountB-&gt;changeMoney(amount);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只改动了3行代码。</p>\n<ol>\n<li>这里通过<code>lock</code>函数来获取两把锁，标准库的实现会保证不会发生死锁。</li>\n<li><code>lock_guard</code>在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建<code>lock_guard</code>的目的是为了在<code>transferMoney</code>结束的时候释放锁，<code>lockB</code>也是一样。但需要注意的是，这里传递了 <code>adopt_lock</code>表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加<code>adopt_lock</code>就是二次锁定了）。</li>\n</ol>\n<p>运行一下这个改造后的程序，其输出如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 17.5974 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 59.2104 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 49.6379 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 63.6373 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 51.8742 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 50.0081 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 86.1041 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 51.3278 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 66.5754 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 32.1867 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 62.0039 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 98.7819 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 27.046 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 62.9155 required</span><br><span class=\"line\">Transfer 98.8478 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 80.0722 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 73.7035 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 34.4476 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $10.0142, but 61.3033 required</span><br><span class=\"line\">Transfer failed, Moira has only $10.0142, but 24.5595 required</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。</p>\n<h2 id=\"通用互斥管理\"><a href=\"#通用互斥管理\" class=\"headerlink\" title=\"通用互斥管理\"></a>通用互斥管理</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">lock_guard</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">实现严格基于作用域的互斥体所有权包装器</td>\n</tr>\n<tr>\n<td align=\"left\">unique_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">实现可移动的互斥体所有权包装器</td>\n</tr>\n<tr>\n<td align=\"left\">shared_lock</td>\n<td align=\"left\">C++14</td>\n<td align=\"left\">实现可移动的共享互斥体所有权封装器</td>\n</tr>\n<tr>\n<td align=\"left\">scoped_lock</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">用于多个互斥体的免死锁 RAII 封装器</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">锁定策略</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">defer_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">类型为 <code>defer_lock_t</code>，不获得互斥的所有权</td>\n</tr>\n<tr>\n<td align=\"left\">try_to_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">类型为<code>try_to_lock_t</code>，尝试获得互斥的所有权而不阻塞</td>\n</tr>\n<tr>\n<td align=\"left\">adopt_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">类型为<code>adopt_lock_t</code>，假设调用方已拥有互斥的所有权</td>\n</tr>\n</tbody></table>\n<p>互斥体（<code>mutex</code>相关类）提供了对于资源的保护功能，但是手动的锁定（调用<code>lock</code>或者<code>try_lock</code>）和解锁（调用<code>unlock</code>）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。</p>\n<p>鉴于这个原因，标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。</p>\n<p>请看下面的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://en.cppreference.com/w/cpp/thread/lock_guard</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> g_i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex g_i_mutex;  <span class=\"comment\">// ①</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">safe_increment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(g_i_mutex)</span></span>;  <span class=\"comment\">// ②</span></span><br><span class=\"line\">  ++g_i;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::this_thread::get_id() &lt;&lt; <span class=\"string\">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ③</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t1</span><span class=\"params\">(safe_increment)</span></span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t2</span><span class=\"params\">(safe_increment)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中：</p>\n<ol>\n<li>全局的互斥体<code>g_i_mutex</code>用来保护全局变量<code>g_i</code></li>\n<li>这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用<code>lock</code>方法，而是直接使用<code>lock_guard</code>来锁定互斥体。</li>\n<li>在方法结束的时候，局部变量<code>std::lock_guard&lt;std::mutex&gt; lock</code>会被销毁，它对互斥体的锁定也就解除了。</li>\n<li>在多个线程中使用这个方法。</li>\n</ol>\n<h3 id=\"RAII\"><a href=\"#RAII\" class=\"headerlink\" title=\"RAII\"></a>RAII</h3><p>上面的几个类（<code>lock_guard</code>，<code>unique_lock</code>，<code>shared_lock</code>，<code>scoped_lock</code>）都使用了一个叫做RAII的编程技巧。</p>\n<p>RAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。</p>\n<p>RAII是一种<a href=\"http://www.stroustrup.com/bs_faq2.html#finally\">C++编程技术</a>，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。 RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。</p>\n<p>RAII 可总结如下:</p>\n<ul>\n<li>将每个资源封装入一个类，其中：<ul>\n<li>构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</li>\n<li>析构函数释放资源并决不抛出异常；</li>\n</ul>\n</li>\n<li>始终经由 RAII 类的实例使用满足要求的资源，该资源<ul>\n<li>自身拥有自动存储期或临时生存期，或</li>\n<li>具有与自动或临时对象的生存期绑定的生存期</li>\n</ul>\n</li>\n</ul>\n<p>回想一下上文中的<code>transferMoney</code>方法中的三行代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock(*accountA-&gt;getLock(), *accountB-&gt;getLock());</span><br><span class=\"line\"><span class=\"function\">lock_guard <span class=\"title\">lockA</span><span class=\"params\">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class=\"line\"><span class=\"function\">lock_guard <span class=\"title\">lockB</span><span class=\"params\">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>如果使用<code>unique_lock</code>这三行代码还有一种等价的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_lock <span class=\"title\">lockA</span><span class=\"params\">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_lock <span class=\"title\">lockB</span><span class=\"params\">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class=\"line\">lock(*accountA-&gt;getLock(), *accountB-&gt;getLock());</span><br></pre></td></tr></table></figure>\n<p>请注意这里<code>lock</code>方法的调用位置。这里先定义<code>unique_lock</code>指定了<code>defer_lock</code>，因此实际没有锁定互斥体，而是到第三行才进行锁定。</p>\n<p>最后，借助<code>scoped_lock</code>，我们可以将三行代码合成一行，这种写法也是等价的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">scoped_lock <span class=\"title\">lockAll</span><span class=\"params\">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>scoped_lock</code>会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。</p>\n<p>目前，只还有<code>shared_lock</code>我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。</p>\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">condition_variable</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">提供与 std::unique_lock 关联的条件变量</td>\n</tr>\n<tr>\n<td align=\"left\">condition_variable_any</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">提供与任何锁类型关联的条件变量</td>\n</tr>\n<tr>\n<td align=\"left\">notify_all_at_thread_exit</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">安排到在此线程完全结束时对 notify_all 的调用</td>\n</tr>\n<tr>\n<td align=\"left\">cv_status</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">列出条件变量上定时等待的可能结果</td>\n</tr>\n</tbody></table>\n<p>至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了<code>false</code>。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。</p>\n<p>这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。</p>\n<p>条件变量提供了一个可以让多个线程间同步协作的功能。这对于<a href=\"https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem\">生产者-消费者模型</a>很有意义。在这个模型下：</p>\n<ul>\n<li>生产者和消费者共享一个工作区。这个区间的大小是有限的。</li>\n<li>生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。</li>\n<li>消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。</li>\n</ul>\n<p>从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。</p>\n<p>下面我们就借助于条件变量，再次改造之前的银行转账系统。</p>\n<p>这个改造主要在于账号类。我们重点是要调整<code>changeMoney</code>方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Account(<span class=\"built_in\">string</span> name, <span class=\"keyword\">double</span> money): mName(name), mMoney(money) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changeMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">unique_lock <span class=\"title\">lock</span><span class=\"params\">(mMoneyLock)</span></span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    mConditionVar.wait(lock, [<span class=\"keyword\">this</span>, amount] &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> mMoney + amount &gt; <span class=\"number\">0</span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    mMoney += amount;</span><br><span class=\"line\">    mConditionVar.notify_all(); <span class=\"comment\">// ⑤</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mMoney;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">string</span> mName;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> mMoney;</span><br><span class=\"line\">  mutex mMoneyLock;</span><br><span class=\"line\">  condition_variable mConditionVar; <span class=\"comment\">// ①</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这几处改动说明如下：</p>\n<ol>\n<li>这里声明了一个条件变量，用来在多个线程之间协作。</li>\n<li>这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。</li>\n<li>这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则<strong>此处会解锁互斥体，并让当前线程等待</strong>。<strong>解锁</strong>这一点非常重要，因为只有这样，才能让其他线程获取互斥体。</li>\n<li>这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读<a href=\"https://paul.pub/cpp-lambda-function-bind/\">我之前写的文章</a>。</li>\n<li>此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。<code>wait</code>和<code>notify</code>就构成了线程间互相协作的工具。</li>\n</ol>\n<p>请注意：<code>wait</code>和<code>notify_all</code>虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。</p>\n<p>有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bank::transferMoney</span><span class=\"params\">(Account* accountA, Account* accountB, <span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    accountA-&gt;changeMoney(-amount);</span><br><span class=\"line\">    accountB-&gt;changeMoney(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\">mutex sCoutLock;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomTransfer</span><span class=\"params\">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> randomMoney = ((<span class=\"keyword\">double</span>)rand() / RAND_MAX) * <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"function\">lock_guard <span class=\"title\">guard</span><span class=\"params\">(sCoutLock)</span></span>;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Try to Transfer &quot;</span> &lt;&lt; randomMoney</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot; from &quot;</span> &lt;&lt; accountA-&gt;getName() &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; accountA-&gt;getMoney()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot;) to &quot;</span> &lt;&lt; accountB-&gt;getName() &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; accountB-&gt;getMoney()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot;), Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;totalMoney() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bank-&gt;transferMoney(accountA, accountB, randomMoney);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改完之后的程序运行输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Try to Transfer 13.72 from Moira(10.9287) to Paul(189.071), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 28.6579 from Paul(189.071) to Moira(10.9287), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 91.8049 from Paul(160.413) to Moira(39.5866), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 5.56383 from Paul(82.3285) to Moira(117.672), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 11.3594 from Paul(76.7646) to Moira(123.235), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 16.9557 from Paul(65.4053) to Moira(134.595), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 74.998 from Paul(48.4495) to Moira(151.55), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 65.3005 from Moira(151.55) to Paul(48.4495), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 90.6084 from Moira(86.25) to Paul(113.75), Bank totalMoney: 125.002</span><br><span class=\"line\">Try to Transfer 99.6425 from Moira(70.6395) to Paul(129.36), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 55.2091 from Paul(129.36) to Moira(70.6395), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 92.259 from Paul(74.1513) to Moira(125.849), Bank totalMoney: 200</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这下比之前都要好了。</p>\n<p>但是细心的读者会发现，Bank totalMoney的输出有时候是200，有时候不是。但不管怎样，即便这一次不是，下一次又是了。关于这一点，请读者自行思考一下为什么，以及如何改进。</p>\n<h1 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h1><table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">async</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">异步运行一个函数，并返回保有其结果的<code>std::future</code></td>\n</tr>\n<tr>\n<td align=\"left\">future</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">等待被异步设置的值</td>\n</tr>\n<tr>\n<td align=\"left\">packaged_task</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">打包一个函数，存储其返回值以进行异步获取</td>\n</tr>\n<tr>\n<td align=\"left\">promise</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">存储一个值以进行异步获取</td>\n</tr>\n<tr>\n<td align=\"left\">shared_future</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">等待被异步设置的值（可能为其他 future 所引用）</td>\n</tr>\n</tbody></table>\n<p>这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于<code>&lt;future&gt;</code>头文件中。</p>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><p>很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。</p>\n<p>在C++11中，<code>async</code>便是完成这样的功能的。下面是一个代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12_async_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10e8</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f1 = async(worker, <span class=\"number\">0</span>, MAX);</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task triggered&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  f1.wait();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task finish, result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这仍然是我们之前熟悉的例子。这里有两个地方需要说明：</p>\n<ol>\n<li>这里以异步的方式启动了任务。它会返回一个<code>future</code>对象。<code>future</code>用来存储异步任务的执行结果，关于<code>future</code>我们在后面<code>packaged_task</code>的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。</li>\n<li>此处是等待异步任务执行完成。</li>\n</ol>\n<p>需要注意的是，默认情况下，<code>async</code>是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过<code>launch::async</code>来明确说明。<code>launch</code>中有两个常量：</p>\n<ul>\n<li><code>async</code>：运行新线程，以异步执行任务。</li>\n<li><code>deferred</code>：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>\n</ul>\n<p>除了通过函数来指定异步任务，还可以lambda表达式的方式来指定。如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12_async_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">double</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task with lambda triggered, thread: &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f2 = async(launch::async, [&amp;result]() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Lambda task in thread: &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class=\"line\">      result += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  f2.wait();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task with lambda finish, result: &quot;</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面这段代码中，我们使用一个lambda表达式来编写异步任务的逻辑，并通过<code>launch::async</code>明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。</p>\n<p>这段代码输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Async task with lambda triggered, thread: 0x11290d5c0</span><br><span class=\"line\">Lambda task in thread: 0x700007aa1000</span><br><span class=\"line\">Async task with lambda finish, result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12_async_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Worker(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max): mMin(min), mMax(max) &#123;&#125; <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">work</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    mResult = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mMin; i &lt;= mMax; i++) &#123;</span><br><span class=\"line\">      mResult += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mMin;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mMax;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> mResult;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Worker <span class=\"title\">w</span><span class=\"params\">(<span class=\"number\">0</span>, MAX)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Task in class triggered&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f3 = async(&amp;Worker::work, &amp;w); <span class=\"comment\">// ③</span></span><br><span class=\"line\">  f3.wait();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Task in class finish, result: &quot;</span> &lt;&lt; w.getResult() &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码有三处需要说明：</p>\n<ol>\n<li>这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。</li>\n<li><code>work</code>函数是任务的主体逻辑。</li>\n<li>通过<code>async</code>执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是<code>&amp;w</code>，因此传递的是对象的指针。如果不写<code>&amp;</code>将传入<code>w</code>对象的临时复制。</li>\n</ol>\n<h2 id=\"packaged-task\"><a href=\"#packaged-task\" class=\"headerlink\" title=\"packaged_task\"></a>packaged_task</h2><p>在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用<code>packaged_task</code>来包装任务。</p>\n<blockquote>\n<p>如果你了解设计模式，你应该会知道<a href=\"https://en.wikipedia.org/wiki/Command_pattern\">命令模式</a>。</p>\n</blockquote>\n<p><code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p>\n<p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p>\n<p>下面是一个代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 13_packaged_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">future</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; results; <span class=\"comment\">// ①</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency();</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; concurrent_count; i++) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    <span class=\"function\">packaged_task&lt;<span class=\"title\">double</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span>&gt; <span class=\"title\">task</span><span class=\"params\">(concurrent_worker)</span></span>; <span class=\"comment\">// ③</span></span><br><span class=\"line\">    results.push_back(task.get_future()); <span class=\"comment\">// ④</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(<span class=\"built_in\">std</span>::move(task), min, range)</span></span>; <span class=\"comment\">// ⑤</span></span><br><span class=\"line\">    t.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;threads create finish&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; r : results) &#123;</span><br><span class=\"line\">    sum += r.get(); <span class=\"comment\">// ⑥</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">double</span> r = concurrent_task(<span class=\"number\">0</span>, MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; r &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中：</p>\n<ol>\n<li>首先创建一个集合来存储<code>future</code>对象。我们将用它来获取任务的结果。</li>\n<li>同样的，根据CPU的情况来创建线程的数量。</li>\n<li>将任务包装成<code>packaged_task</code>。请注意，由于<code>concurrent_worker</code>被包装成了任务，我们无法直接获取它的<code>return</code>值。而是要通过<code>future</code>对象来获取。</li>\n<li>获取任务关联的<code>future</code>对象，并将其存入集合中。</li>\n<li>通过一个新的线程来执行任务，并传入需要的参数。</li>\n<li>通过<code>future</code>集合，逐个获取每个任务的计算结果，将其累加。这里<code>r.get()</code>获取到的就是每个任务中<code>concurrent_worker</code>的返回值。</li>\n</ol>\n<p>为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于<code>packaged_task</code>将任务组装成队列，然后通过<a href=\"https://en.wikipedia.org/wiki/Thread_pool\">线程池</a>的方式进行调度：</p>\n<p>![image-20210305140102303](C++ 并发编程/image-20210305140102303.png)</p>\n<h2 id=\"promise与future\"><a href=\"#promise与future\" class=\"headerlink\" title=\"promise与future\"></a>promise与future</h2><p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>\n<p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>\n<p>下面是对上面代码示例的改写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 14_promise_future.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max, promise&lt;<span class=\"keyword\">double</span>&gt;* result)</span> </span>&#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">future</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; results;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency();</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; concurrent_count; i++) &#123;</span><br><span class=\"line\">    <span class=\"function\">packaged_task&lt;<span class=\"title\">double</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span>&gt; <span class=\"title\">task</span><span class=\"params\">(concurrent_worker)</span></span>;</span><br><span class=\"line\">    results.push_back(task.get_future()); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(<span class=\"built_in\">std</span>::move(task), min, range)</span></span>;</span><br><span class=\"line\">    t.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;threads create finish&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; r : results) &#123;</span><br><span class=\"line\">    sum += r.get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  result-&gt;set_value(sum); <span class=\"comment\">// ②</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;concurrent_task finish&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  promise&lt;<span class=\"keyword\">double</span>&gt; sum; <span class=\"comment\">// ③</span></span><br><span class=\"line\">  concurrent_task(<span class=\"number\">0</span>, MAX, &amp;sum);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Result: &quot;</span> &lt;&lt; sum.get_future().get() &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：</p>\n<ol>\n<li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li>\n<li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>\n<li>这里是在<code>main</code>中创建一个<code>promoise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li>\n<li>通过<code>sum.get_future().get()</code>来获取结果。第2点中已经说了：一旦调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>\n</ol>\n<p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p>\n<p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p>\n<h1 id=\"并行算法\"><a href=\"#并行算法\" class=\"headerlink\" title=\"并行算法\"></a>并行算法</h1><p>从C++17开始。<a href=\"https://en.cppreference.com/w/cpp/algorithm\"></a>和<a href=\"https://en.cppreference.com/w/cpp/numeric#Numeric_algorithms\"></a> 头文件的中的很多算法都添加了一个新的参数：<code>sequenced_policy</code>。</p>\n<p>借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。</p>\n<p><code>sequenced_policy</code>可能的取值有三种，它们的说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">C++版本</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">execution::seq</td>\n<td align=\"left\">execution::sequenced_policy</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">要求并行算法的执行可以不并行化</td>\n</tr>\n<tr>\n<td align=\"left\">execution::par</td>\n<td align=\"left\">execution::parallel_policy</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">指示并行算法的执行可以并行化</td>\n</tr>\n<tr>\n<td align=\"left\">execution::par_unseq</td>\n<td align=\"left\">execution::parallel_unsequenced_policy</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">指示并行算法的执行可以并行化、向量化</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：<a href=\"https://paul.pub/cpp-concurrency/#id-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83\">本文的前面</a>已经提到，目前clang编译器还不支持这个功能。因此想要编译这部分代码，你需要使用gcc 9.0或更高版本，同时还需要安装<a href=\"https://github.com/intel/tbb\">Intel Threading Building Blocks</a>。</p>\n</blockquote>\n<p>下面还是通过一个示例来进行说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 15_parallel_algorithm.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">generateRandomData</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&amp; collection, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">  random_device rd;</span><br><span class=\"line\">  <span class=\"function\">mt19937 <span class=\"title\">mt</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\">  <span class=\"function\">uniform_real_distribution&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(<span class=\"number\">1.0</span>, <span class=\"number\">100.0</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">    collection.push_back(dist(mt));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; collection;</span><br><span class=\"line\">  generateRandomData(collection, <span class=\"number\">10e6</span>); <span class=\"comment\">// ①</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">copy1</span><span class=\"params\">(collection)</span></span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">copy2</span><span class=\"params\">(collection)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">copy3</span><span class=\"params\">(collection)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time1 = chrono::steady_clock::now(); <span class=\"comment\">// ③</span></span><br><span class=\"line\">  sort(execution::seq, copy1.begin(), copy1.end()); <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time2 = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time2 - time1).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Sequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class=\"string\">&quot;ms.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// ⑤</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time3 = chrono::steady_clock::now();</span><br><span class=\"line\">  sort(execution::par, copy2.begin(),copy2.end()); <span class=\"comment\">// ⑥</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time4 = chrono::steady_clock::now();</span><br><span class=\"line\">  duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time4 - time3).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Parallel sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class=\"string\">&quot;ms.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time5 = chrono::steady_clock::now();</span><br><span class=\"line\">  sort(execution::par_unseq, copy2.begin(),copy2.end()); <span class=\"comment\">// ⑦</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time6 = chrono::steady_clock::now();</span><br><span class=\"line\">  duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time6 - time5).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Parallel unsequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class=\"string\">&quot;ms.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单：</p>\n<ol>\n<li>通过一个函数生成1000,000个随机数。</li>\n<li>将数据拷贝3份，以备使用。</li>\n<li>接下来将通过三个不同的<code>parallel_policy</code>参数来调用同样的<code>sort</code>算法。每次调用记录开始和结束的时间。</li>\n<li>第一次调用使用<code>std::execution::seq</code>参数。</li>\n<li>输出本次测试所使用的时间。</li>\n<li>第二次调用使用<code>std::execution::par</code>参数。</li>\n<li>第三次调用使用<code>std::execution::par_unseq</code>参数。</li>\n</ol>\n<p>该程序的输出如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sequenced sort consuming <span class=\"number\">4464</span>ms.</span><br><span class=\"line\">Parallel sort consuming <span class=\"number\">459</span>ms.</span><br><span class=\"line\">Parallel unsequenced sort consuming <span class=\"number\">168</span>ms.</span><br></pre></td></tr></table></figure>\n<p>可以看到，性能最好的和最差的相差了超过26倍。</p>\n<h1 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h1><p>在本篇文章中，我们介绍了C++语言中新增的并发编程API。虽然这部分内容已经不少（大部分人很难一次性搞懂所有这些内容，包括我自己），但实际上还有一个很重要的话题我们没有触及，那就是“内存模型”。</p>\n<p>C++内存模型是C++11标准中最重要的特性之一。它是多线程环境能够可靠工作的基础。考虑到这部分内容还需要比较多的篇幅来说明，因此我们会在下一篇文章中继续讨论。</p>\n<h1 id=\"参考资料与推荐读物\"><a href=\"#参考资料与推荐读物\" class=\"headerlink\" title=\"参考资料与推荐读物\"></a>参考资料与推荐读物</h1><ul>\n<li><a href=\"https://www.amazon.com/C-Concurrency-Action-Anthony-Williams/dp/1617294691/\">C++ Concurrency in Action 2nd</a></li>\n<li><a href=\"http://wikipedia.org/\">Wikipedia</a></li>\n<li><a href=\"https://en.cppreference.com/w/cpp/thread\">cpprefernce: Thread support library</a></li>\n<li><a href=\"https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996\">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</a></li>\n<li><a href=\"https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf\">Threads Cannot be Implemented as a Library</a></li>\n<li><a href=\"https://www.modernescpp.com/index.php/i-m-proud-to-present-modern-c-concurrency-is-available-as-interactive-course\">I’m Proud to Present: Modern C++ Concurrency is available as interactive course</a></li>\n<li><a href=\"https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000682210-How-do-I-enable-C-17-\">How do I enable C++17?</a></li>\n<li><a href=\"https://solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/\">C++17 STL Parallel Algorithms - with GCC 9.1 and Intel TBB on Linux and macOS</a></li>\n<li><a href=\"https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f\">How to install packages from a newer distribution without installing unwanted</a></li>\n</ul>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"C-并发编程\"><a href=\"#C-并发编程\" class=\"headerlink\" title=\"C++ 并发编程\"></a>C++ 并发编程</h1><p>自C++11标准以来，C++语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。</p>\n<h2 id=\"为什么要并发编程\"><a href=\"#为什么要并发编程\" class=\"headerlink\" title=\"为什么要并发编程\"></a>为什么要并发编程</h2><p>大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。</p>\n<p>另一方面，自上个世纪六七十年代英特尔创始人之一 <a href=\"https://en.wikipedia.org/wiki/Gordon_Moore\">Gordon Moore</a> 提出 <a href=\"https://en.wikipedia.org/wiki/Moore's_law\">摩尔定义</a> 以来，CPU频率以每18个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。</p>\n<p>由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。</p>\n<p>本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。</p>\n<h2 id=\"并发与并行\"><a href=\"#并发与并行\" class=\"headerlink\" title=\"并发与并行\"></a>并发与并行</h2><p>并发（Concurrent）与并行（Parallel）都是很常见的术语。</p>\n<p>Erlang之父Joe Armstrong曾经以人们使用咖啡机的场景为例描述了这两个术语。如下图所示：</p>\n<p>![img](C++ 并发编程/con_and_par.jpg)</p>\n<ul>\n<li><strong>并发</strong>：如果多个队列可以交替使用某台咖啡机，则这一行为就是并发的。</li>\n<li><strong>并行</strong>：如果存在多台咖啡机可以被多个队列交替使用，则就是并行。</li>\n</ul>\n<p>这里队列中的每个人类比于计算机的任务，咖啡机类比于计算机处理器。因此：并发和并行都是在多任务的环境下的讨论。</p>\n<p>更严格的来说：如果一个系统支持多个动作同时存在，那么这个系统就是一个并发系统。如果这个系统还支持多个动作（物理时间上）同时执行，那么这个系统就是一个并行系统。</p>\n<p>你可能已经看出，“并行”其实是“并发”的子集。它们的区别在于是否具有多个处理器。如果存在多个处理器同时执行多个线程，就是并行。</p>\n<p>在不考虑处理器数量的情况下，我们统称之为“并发”。</p>\n<h2 id=\"进程与线程\"><a href=\"#进程与线程\" class=\"headerlink\" title=\"进程与线程\"></a>进程与线程</h2><p>进程与线程是操作系统的基本概念。无论是桌面系统：MacOS，Linux，Windows，还是移动操作系统：Android，iOS，都存在进程和线程的概念。</p>\n<blockquote>\n<p><strong>进程</strong>（英语：process），是指计算机中已运行的程序。进程为曾经是分时系统的基本运作单位。在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，进程是程序的基本执行实体；</p>\n<p><strong>线程</strong>（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。</p>\n<p>– 维基百科</p>\n</blockquote>\n<p>关于这两个概念在任何一本操作系统书上都可以找到定义。网上也有很多文章对它们进行了解释。因此这里不再赘述，这里仅仅提及一下它们与编程的关系。</p>\n<p>对于绝大部分编程语言或者编程环境来说，我们所写的程序都会在一个进程中运行。一个进程至少会包含一个线程。这个线程我们通常称之为主线程。</p>\n<p>在默认的情况下，我们写的代码都是在进程的主线程中运行，除非开发者在程序中创建了新的线程。</p>\n<p>不同编程语言的线程环境会不一样，Java语言在很早就支持了多线程接口。（Java程序在Java虚拟机中运行，虚拟机通常还会包含自己特有的线程，例如垃圾回收线程。）。而对于JavaScript这样的语言来说，它就没有多线程的概念。</p>\n<p>当我们只有一个处理器时，所有的进程或线程会分时占用这个处理器。但如果系统中存在多个处理器时，则就可能有多个任务并行的运行在不同的处理器上。</p>\n<p>下面两幅图以不同颜色的矩形代表不同的任务（可能是进程，也可能是线程）来描述它们可能在处理器上执行的顺序。</p>\n<p>下图是单核处理器的情况：</p>\n<img src=\"C++ 并发编程/single_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>下面是四核处理器的情况：</p>\n<img src=\"C++ 并发编程/four_core.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>任务会在何时占有处理器，通常是由操作系统的调度策略决定的。在<a href=\"https://paul.pub/android-process-schedule/\">《Android系统上的进程管理：进程的调度》</a>一文中，我们介绍过Linux的调度策略。</p>\n<p>当我们在开发跨平台的软件时，我们不应当对调度策略做任何假设，而应该抱有“系统可能以任意顺序来调度我的任务”这样的想法。</p>\n<h2 id=\"并发系统的性能\"><a href=\"#并发系统的性能\" class=\"headerlink\" title=\"并发系统的性能\"></a>并发系统的性能</h2><p>开发并发系统最主要的动机就是提升系统性能（事实上，这是以增加复杂度为代价的）。</p>\n<p>但我们需要知道，单纯的使用多线程并不一定能提升系统性能（当然，也并非线程越多系统的性能就越好）。从上面的两幅图我们就可以直观的感受到：线程（任务）的数量要根据具体的处理器数量来决定。假设只有一个处理器，那么划分太多线程可能会适得其反。因为很多时间都花在任务切换上了。</p>\n<p>因此，在设计并发系统之前，一方面我们需要做好对于硬件性能的了解，另一方面需要对我们的任务有足够的认识。</p>\n<p>关于这一点，你可能需要了解一下<a href=\"https://en.wikipedia.org/wiki/Amdahl's_law\">阿姆达尔定律</a>了。对于这个定律，简单来说：我们想要预先意识到那些任务是可以并行的，那些是无法并行的。只有明确了任务的性质，才能有的放矢的进行优化。这个定律告诉了我们将系统并行之后性能收益的上限。</p>\n<p>关于阿姆达尔定律在<a href=\"https://paul.pub/sysstat/#id-%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B\">Linux系统监测工具sysstat介绍</a>一文中已经介绍过，因此这里不再赘述。</p>\n<h1 id=\"C-与并发编程\"><a href=\"#C-与并发编程\" class=\"headerlink\" title=\"C++与并发编程\"></a>C++与并发编程</h1><p>前面我们已经了解到，并非所有的语言都提供了多线程的环境。</p>\n<p>即便是C++语言，直到<a href=\"https://en.wikipedia.org/wiki/C%2B%2B11\">C++11</a>标准之前，也是没有多线程支持的。在这种情况下，Linux/Unix平台下的开发者通常会使用<a href=\"https://en.wikipedia.org/wiki/POSIX_Threads\">POSIX Threads</a>，Windows上的开发者也会有<a href=\"https://docs.microsoft.com/en-us/cpp/parallel/multithreading-with-cpp-and-mfc?view=vs-2019\">相应的接口</a>。但很明显，这些API都只针对特定的操作系统平台，可移植性较差。如果要同时支持Linux和Windows系统，你可能要写两套代码。</p>\n<blockquote>\n<p>相较而言，Java自JDK 1.0就包含了多线程模型。</p>\n</blockquote>\n<p>这个状态在C++ 11标准发布之后得到了改变。并且，在C++ 14和C++ 17标准中又对并发编程机制进行了增强。</p>\n<p>下图是最近几个版本的C++标准特性的线路图。</p>\n<img src=\"C++ 并发编程/cpp_timeline.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n<h2 id=\"编译器与C-标准\"><a href=\"#编译器与C-标准\" class=\"headerlink\" title=\"编译器与C++标准\"></a>编译器与C++标准</h2><p>编译器对于语言特性的支持是逐步完成的。想要使用特定的特性你需要相应版本的编译器。</p>\n<ul>\n<li>GCC对于C++特性的支持请参见这里：<a href=\"https://www.gnu.org/software/gcc/projects/cxx-status.html\">C++ Standards Support in GCC</a>。</li>\n<li>Clang对于C++特性的支持请参见这里：<a href=\"https://clang.llvm.org/cxx_status.html\">C++ Support in Clang</a>。</li>\n</ul>\n<p>下面两个表格列出了C++标准和相应编译器的版本对照：</p>\n<ul>\n<li>C++标准与相应的GCC版本要求如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">C++版本</th>\n<th align=\"left\">GCC版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C++11</td>\n<td align=\"left\">4.8</td>\n</tr>\n<tr>\n<td align=\"left\">C++14</td>\n<td align=\"left\">5.0</td>\n</tr>\n<tr>\n<td align=\"left\">C++17</td>\n<td align=\"left\">7.0</td>\n</tr>\n</tbody></table>\n<ul>\n<li>C++标准与相应的Clang版本要求如下：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">C++版本</th>\n<th align=\"left\">Clang版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C++11</td>\n<td align=\"left\">3.3</td>\n</tr>\n<tr>\n<td align=\"left\">C++14</td>\n<td align=\"left\">3.4</td>\n</tr>\n<tr>\n<td align=\"left\">C++17</td>\n<td align=\"left\">5.0</td>\n</tr>\n</tbody></table>\n<p>默认情况下编译器是以较低的标准来进行编译的，如果希望使用新的标准，你需要通过编译参数<code>-std=c++xx</code>告知编译器，例如：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ -std=c++17 your_file.cpp -o your_program</span><br></pre></td></tr></table></figure>\n<h1 id=\"测试环境\"><a href=\"#测试环境\" class=\"headerlink\" title=\"测试环境\"></a>测试环境</h1><p>本文的源码可以到下载我的github上获取，地址：<a href=\"https://github.com/paulQuei/cpp-concurrency\">paulQuei/cpp-concurrency</a>。</p>\n<p>你可以直接通过下面这条命令获取源码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https:&#x2F;&#x2F;github.com&#x2F;paulQuei&#x2F;cpp-concurrency.git</span><br></pre></td></tr></table></figure>\n<p>源码下载之后，你可以通过任何文本编辑器浏览源码。如果希望编译和运行程序，你还需要按照下面的内容来准备环境。</p>\n<p>本文中的源码使用<a href=\"https://cmake.org/\">cmake</a>编译，只有cmake 3.8以上的版本才支持C++ 17，所以你需要安装这个或者更新版本的cmake。</p>\n<p>另外，截止目前（2019年10月）为止，<code>clang</code>编译器还不支持<a href=\"https://paul.pub/cpp-concurrency/#id-%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95\">并行算法</a>。</p>\n<p>但是<a href=\"https://gcc.gnu.org/gcc-9/changes.html\">gcc-9</a>是支持的。因此想要编译和运行这部分代码，你需要安装gcc 9.0或更新的版本。并且，gcc-9还要依赖<a href=\"https://github.com/intel/tbb\">Intel Threading Building Blocks</a>才能使用并行算法以及<code>&lt;execution&gt;</code>头文件。</p>\n<p>具体的安装方法见下文。</p>\n<blockquote>\n<p>具体编译器对于C++特性支持的情况请参见这里：<a href=\"https://en.cppreference.com/w/cpp/compiler_support\">C++ compiler support</a>。</p>\n</blockquote>\n<p>安装好之后运行根目录下的下面这个命令即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./make_all.sh</span><br></pre></td></tr></table></figure>\n<p>它会完成所有的编译工作。</p>\n<p>本文的源码在下面两个环境中经过测试，环境的准备方法如下。</p>\n<h2 id=\"MacOS\"><a href=\"#MacOS\" class=\"headerlink\" title=\"MacOS\"></a>MacOS</h2><p>在Mac上，我使用<a href=\"https://brew.sh/\">brew</a>工具安装<code>gcc</code>以及<code>tbb</code>库。</p>\n<p>考虑到其他人与我的环境可能会有所差异，所以需要手动告知<code>tbb</code>库的安装路径。</p>\n<p>读者需要执行下面这些命令来准备环境：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install gcc</span><br><span class=\"line\">brew install tbb</span><br><span class=\"line\"></span><br><span class=\"line\">export tbb_path=/usr/local/Cellar/tbb/2019_U8/</span><br><span class=\"line\">./make_all.sh</span><br></pre></td></tr></table></figure>\n<p>注意，请通过运行<code>g++-9</code>命令以确认gcc的版本是否正确，如果版本较低，则需要通过<code>brew</code>命令将其升级到新版本：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew upgrade gcc</span><br></pre></td></tr></table></figure>\n<h2 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h2><p>Ubuntu上，通过下面的命令安装<code>gcc-9</code>。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:ubuntu-toolchain-r/test</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt install  gcc-9 g++-9</span><br></pre></td></tr></table></figure>\n<p>但安装<code>tbb</code>库就有些麻烦了。这是因为<a href=\"https://launchpad.net/ubuntu/+source/tbb\">Ubuntu 16.04默认关联的版本是较低的</a>，直接安装是无法使用的。我们需要安装<a href=\"https://launchpad.net/ubuntu/+source/tbb/2019~U8-1\">更新的版本</a>。</p>\n<p>联网安装的方式<a href=\"https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f\">步骤繁琐</a>，所以可以通过下载包的方式进行安装，我已经将这需要的两个文件放到的这里：</p>\n<ul>\n<li><a href=\"https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb2_2019~U8-1_amd64.deb\">libtbb2_2019~U8-1_amd64.deb</a></li>\n<li><a href=\"https://paul-pub.oss-cn-beijing.aliyuncs.com/2019/2019-11-26-cpp-concurrency/libtbb-dev_2019~U8-1_amd64.deb\">libtbb-dev_2019~U8-1_amd64.deb</a></li>\n</ul>\n<p>如果需要，你可以下载后通过<code>apt</code>命令安装即可：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt install ~/Downloads/libtbb2_2019~U8-1_amd64.deb </span><br><span class=\"line\">sudo apt install ~/Downloads/libtbb-dev_2019~U8-1_amd64.deb </span><br></pre></td></tr></table></figure>\n<h1 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h1><h2 id=\"创建线程\"><a href=\"#创建线程\" class=\"headerlink\" title=\"创建线程\"></a>创建线程</h2><p>创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 01_hello_thread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt; // ①</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Hello World from new thread.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(hello)</span></span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  t.join(); <span class=\"comment\">// ⑤</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于这段代码说明如下：</p>\n<ol>\n<li>为了使用多线程的接口，我们需要<code>#include &lt;thread&gt;</code>头文件。</li>\n<li>为了简化声明，本文中的代码都将<code>using namespace std;</code>。</li>\n<li>新建线程的入口是一个普通的函数，它并没有什么特别的地方。</li>\n<li>创建线程的方式就是构造一个<code>thread</code>对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。</li>\n<li>关于<code>join</code>函数在下文中讲解。</li>\n</ol>\n<p><code>thread</code>可以和<code>callable</code>类型一起工作，因此如果你熟悉<a href=\"https://en.cppreference.com/w/cpp/language/lambda\">lambda表达式</a>，你可以直接用它来写线程的逻辑，像这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 02_lambda_thread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">([] &#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Hello World from lambda thread.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  &#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>为了减少不必要的重复，若无必要，下文中的代码将不贴出<code>include</code>指令以及<code>using</code>声明。</p>\n</blockquote>\n<p>当然，你可以传递参数给入口函数，像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 03_thread_argument.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">hello</span><span class=\"params\">(<span class=\"built_in\">string</span> name)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Welcome to &quot;</span> &lt;&lt; name &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(hello, <span class=\"string\">&quot;https://paul.pub&quot;</span>)</span></span>;</span><br><span class=\"line\">  t.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>不过需要注意的是，参数是以拷贝的形式进行传递的。因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文<code>detach</code>），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。</p>\n<h2 id=\"join与detach\"><a href=\"#join与detach\" class=\"headerlink\" title=\"join与detach\"></a>join与detach</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">join</td>\n<td align=\"left\">等待线程完成其执行</td>\n</tr>\n<tr>\n<td align=\"left\">detach</td>\n<td align=\"left\">允许线程独立执行</td>\n</tr>\n</tbody></table>\n<p>一旦启动线程之后，我们必须决定是要等待直接它结束（通过<code>join</code>），还是让它独立运行（通过<code>detach</code>），我们必须二者选其一。如果在<code>thread</code>对象<strong>销毁的时候</strong>我们还没有做决定，则<code>thread</code>对象在析构函数出将调用<code>std::terminate()</code>从而导致我们的进程异常退出。</p>\n<blockquote>\n<p>请思考在上面的代码示例中，<code>thread</code>对象在何时会销毁。</p>\n</blockquote>\n<p>需要注意的是：在我们做决定的时候，很可能线程已经执行完了（例如上面的示例中线程的逻辑仅仅是一句打印，执行时间会很短）。新的线程创建之后，究竟是新的线程先执行，还是当前线程的下一条语句先执行这是不确定的，因为这是由操作系统的调度策略决定的。不过这不要紧，我们只要在<code>thread</code>对象销毁前做决定即可。</p>\n<ul>\n<li><code>join</code>：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</li>\n<li><code>detach</code>：<code>detach</code>是让目标线程成为守护线程（daemon threads）。一旦<code>detach</code>之后，目标线程将独立执行，即便其对应的<code>thread</code>对象销毁也不影响线程的执行。并且，你无法再与之通信。</li>\n</ul>\n<p>对于这两个接口，都必须是可执行的线程才有意义。你可以通过<code>joinable()</code>接口查询是否可以对它们进行<code>join</code>或者<code>detach</code>。</p>\n<h2 id=\"管理当前线程\"><a href=\"#管理当前线程\" class=\"headerlink\" title=\"管理当前线程\"></a>管理当前线程</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">yield</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">让出处理器，重新调度各执行线程</td>\n</tr>\n<tr>\n<td align=\"left\">get_id</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">返回当前线程的线程 id</td>\n</tr>\n<tr>\n<td align=\"left\">sleep_for</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">使当前线程的执行停止指定的时间段</td>\n</tr>\n<tr>\n<td align=\"left\">sleep_until</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">使当前线程的执行停止直到指定的时间点</td>\n</tr>\n</tbody></table>\n<p>上面是一些在线程内部使用的API，它们用来对当前线程做一些控制。</p>\n<ul>\n<li><code>yield</code> 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。</li>\n<li><code>get_id</code> 返回当前线程的id，可以以此来标识不同的线程。</li>\n<li><code>sleep_for</code> 是让当前线程停止一段时间。</li>\n<li><code>sleep_until</code> 和<code>sleep_for</code>类似，但是是以具体的时间点为参数。这两个API都以<a href=\"https://en.cppreference.com/w/cpp/header/chrono\">chrono</a> API（由于篇幅所限，这里不展开这方面内容）为基础。</li>\n</ul>\n<p>下面是一个代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 04_thread_self_manage.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_time</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> now = chrono::system_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> <span class=\"keyword\">in_time_t</span> = chrono::system_clock::<span class=\"keyword\">to_time_t</span>(now);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">  ss &lt;&lt; put_time(localtime(&amp;<span class=\"keyword\">in_time_t</span>), <span class=\"string\">&quot;%Y-%m-%d %X&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;now is: &quot;</span> &lt;&lt; ss.str() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sleep_thread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  this_thread::sleep_for(chrono::seconds(<span class=\"number\">3</span>));</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;[thread-&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"string\">&quot;] is waking up&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">loop_thread</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;[thread-&quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"string\">&quot;] print: &quot;</span> &lt;&lt; i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  print_time();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(sleep_thread)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(loop_thread)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">  print_time();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码应该还是比较容易理解的，这里创建了两个线程。它们都会有一些输出，其中一个会先停止3秒钟，然后再输出。主线程调用<code>join</code>会一直卡住等待它运行结束。</p>\n<p>这段程序的输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">now is: 2019-10-13 10:17:48</span><br><span class=\"line\">[thread-0x70000cdda000] print: 0</span><br><span class=\"line\">[thread-0x70000cdda000] print: 1</span><br><span class=\"line\">[thread-0x70000cdda000] print: 2</span><br><span class=\"line\">[thread-0x70000cdda000] print: 3</span><br><span class=\"line\">[thread-0x70000cdda000] print: 4</span><br><span class=\"line\">[thread-0x70000cdda000] print: 5</span><br><span class=\"line\">[thread-0x70000cdda000] print: 6</span><br><span class=\"line\">[thread-0x70000cdda000] print: 7</span><br><span class=\"line\">[thread-0x70000cdda000] print: 8</span><br><span class=\"line\">[thread-0x70000cdda000] print: 9</span><br><span class=\"line\">[thread-0x70000cd57000] is waking up</span><br><span class=\"line\">now is: 2019-10-13 10:17:51</span><br></pre></td></tr></table></figure>\n<h2 id=\"一次调用\"><a href=\"#一次调用\" class=\"headerlink\" title=\"一次调用\"></a>一次调用</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">call_once</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">即便在多线程环境下，也能保证只调用某个函数一次</td>\n</tr>\n<tr>\n<td align=\"left\">once_flag</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">与<code>call_once</code>配合使用</td>\n</tr>\n</tbody></table>\n<p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>\n<p>下面就是一个示例：有三个线程都会使用<code>init</code>函数，但是只会有一个线程真正执行它。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 05_call_once.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Initialing...&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Do something...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">(once_flag* flag)</span> </span>&#123;</span><br><span class=\"line\">  call_once(*flag, init);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  once_flag flag;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(worker, &amp;flag)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(worker, &amp;flag)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t3</span><span class=\"params\">(worker, &amp;flag)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\">  t3.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们无法确定具体是哪一个线程会执行<code>init</code>。而事实上，我们也不关心，因为只要有某个线程完成这个初始化工作就可以了。</p>\n<blockquote>\n<p>请思考一下，为什么要在main函数中创建<code>once_flag flag</code>。如果是在<code>worker</code>函数中直接声明一个<code>once_flag</code>并使用行不行？为什么？</p>\n</blockquote>\n<h1 id=\"并发任务\"><a href=\"#并发任务\" class=\"headerlink\" title=\"并发任务\"></a>并发任务</h1><p>下面以一个并发任务为示例讲解如何引入多线程。</p>\n<p>任务示例：现在假设我们需要计算某个范围内所有自然数的平方根之和，例如<code>[1, 10e8]</code>。</p>\n<p>在单线程模型下，我们的代码可能是这样的：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 06_naive_multithread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10e8</span>; <span class=\"comment\">// ①</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">serial_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  worker(<span class=\"number\">0</span>, MAX);</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Serail task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码说明如下：</p>\n<ol>\n<li>通过一个常量指定数据范围，这个是为了方便调整。</li>\n<li>通过一个全局变量来存储结果。</li>\n<li>通过一个任务函数来计算值。</li>\n<li>统计任务的执行时间。</li>\n</ol>\n<p>这段程序输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Serail task finish, 6406 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>很显然，上面单线程的做法性能太差了。我们的任务完全是可以并发执行的。并且任务很容易划分。</p>\n<p>下面我们就尝试以多线程的方式来改造原先的程序。</p>\n<p>改造后的程序如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 06_naive_multithread.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency(); <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;thread&gt; threads;</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> t = <span class=\"number\">0</span>; t &lt; concurrent_count; t++) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (t + <span class=\"number\">1</span>);</span><br><span class=\"line\">    threads.push_back(thread(worker, min, range)); <span class=\"comment\">// ③</span></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; t : threads) &#123;</span><br><span class=\"line\">    t.join(); <span class=\"comment\">// ④</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码说明如下：</p>\n<ol>\n<li><code>thread::hardware_concurrency()</code>可以获取到当前硬件支持多少个线程并行执行。</li>\n<li>根据处理器的情况决定线程的数量。</li>\n<li>对于每一个线程都通过<code>worker</code>函数来完成任务，并划分一部分数据给它处理。</li>\n<li>等待每一个线程执行结束。</li>\n</ol>\n<p>很好，似乎很简单就完成了并发的改造。然后我们运行一下这个程序：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hardware_concurrency: 16</span><br><span class=\"line\">Concurrent task finish, 6246 ms consumed, Result: 1.78162e+12</span><br></pre></td></tr></table></figure>\n<p>很抱歉，我们会发现这里的性能并没有明显的提升。更严重的是，这里的结果是错误的。</p>\n<p>要搞清楚为什么结果不正确我们需要更多的背景知识。</p>\n<p>我们知道，对于现代的处理器来说，为了加速处理的速度，每个处理器都会有自己的高速缓存（Cache），这个高速缓存是与每个处理器相对应的，如下图所示：</p>\n<blockquote>\n<p>事实上，目前大部分CPU的缓存已经不只一层。</p>\n</blockquote>\n<img src=\"C++ 并发编程/cpu.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>处理器在进行计算的时候，高速缓存会参与其中，例如数据的读和写。而高速缓存和系统主存（Memory）是有可能存在不一致的。即：某个结果计算后保存在处理器的高速缓存中了，但是没有同步到主存中，此时这个值对于其他处理器就是不可见的。</p>\n<p>事情还远不止这么简单。我们对于全局变量值的修改：<code>sum += sqrt(i);</code>这条语句，它并非是原子的。它其实是很多条指令的组合才能完成。假设在某个设备上，这条语句通过下面这几个步骤来完成。它们的时序可能如下所示：</p>\n<img src=\"C++ 并发编程/multithread.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>在时间点a的时候，所有线程对于<code>sum</code>变量的值是一致的。</p>\n<p>但是在时间点b之后，thread3上已经对<code>sum</code>进行了赋值。而这个时候其他几个线程也同时在其他处理器上使用了这个值，那么这个时候它们所使用的值就是旧的（错误的）。最后得到的结果也自然是错的。</p>\n<h2 id=\"竞争条件与临界区\"><a href=\"#竞争条件与临界区\" class=\"headerlink\" title=\"竞争条件与临界区\"></a>竞争条件与临界区</h2><p>当多个进程或者线程同时访问共享数据时，只要有一个任务会修改数据，那么就可能会发生问题。此时结果依赖于这些任务执行的相对时间，这种场景称为<a href=\"https://en.wikipedia.org/wiki/Race_condition\"><strong>竞争条件</strong>（race condition）</a>。</p>\n<p>访问共享数据的代码片段称之为<strong>临界区</strong>（critical section）。具体到上面这个示例，临界区就是读写<code>sum</code>变量的地方。</p>\n<p>要避免竞争条件，就需要对临界区进行数据保护。</p>\n<p>很自然的，现在我们能够理解发生竞争条件是因为这些线程在同时访问共享数据，其中有些线程的改动没有让其他线程知道，导致其他线程在错误的基础上进行处理，结果自然也就是错误的。</p>\n<p>那么，如果一次只让一个线程访问共享数据，访问完了再让其他线程接着访问，这样就可以避免问题的发生了。</p>\n<p>接下来介绍的API提供的就是这样的功能。</p>\n<h1 id=\"互斥体与锁\"><a href=\"#互斥体与锁\" class=\"headerlink\" title=\"互斥体与锁\"></a>互斥体与锁</h1><h2 id=\"mutex\"><a href=\"#mutex\" class=\"headerlink\" title=\"mutex\"></a>mutex</h2><p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p>\n<ol>\n<li>独立的对于划分给自己的数据的处理</li>\n<li>对于处理结果的汇总</li>\n</ol>\n<p>其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的<code>sum</code>变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。<code>mutex</code> 就提供了这样的功能。</p>\n<p><code>mutex</code>是<strong>mut</strong>ual <strong>ex</strong>clusion（互斥）的简写。</p>\n<ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供基本互斥设施</td>\n</tr>\n<tr>\n<td align=\"left\">timed_mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供互斥设施，带有超时功能</td>\n</tr>\n<tr>\n<td align=\"left\">recursive_mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供能被同一线程递归锁定的互斥设施</td>\n</tr>\n<tr>\n<td align=\"left\">recursive_timed_mutex</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">提供能被同一线程递归锁定的互斥设施，带有超时功能</td>\n</tr>\n<tr>\n<td align=\"left\">shared_timed_mutex</td>\n<td align=\"left\">C++14</td>\n<td align=\"left\">提供共享互斥设施并带有超时功能</td>\n</tr>\n<tr>\n<td align=\"left\">shared_mutex</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">提供共享互斥设施</td>\n</tr>\n</tbody></table>\n<p>很明显，在这些类中，<code>mutex</code>是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lock</td>\n<td>锁定互斥体，如果不可用，则阻塞</td>\n</tr>\n<tr>\n<td>try_lock</td>\n<td>尝试锁定互斥体，如果不可用，直接返回</td>\n</tr>\n<tr>\n<td>unlock</td>\n<td>解锁互斥体</td>\n</tr>\n</tbody></table>\n<p>这三个方法提供了基础的锁定和解除锁定的功能。使用<code>lock</code>意味着你有很强的意愿一定要获取到互斥体，而使用<code>try_lock</code>则是进行一次尝试。这意味着如果失败了，你通常还有其他的路径可以走。</p>\n<p>在这些基础功能之上，其他的类分别在下面三个方面进行了扩展：</p>\n<ul>\n<li><strong>超时</strong>：<code>timed_mutex</code>，<code>recursive_timed_mutex</code>，<code>shared_timed_mutex</code>的名称都带有<code>timed</code>，这意味着它们都支持超时功能。它们都提供了<code>try_lock_for</code>和<code>try_lock_until</code>方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</li>\n<li><strong>可重入</strong>：<code>recursive_mutex</code>和<code>recursive_timed_mutex</code>的名称都带有<code>recursive</code>。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</li>\n<li><strong>共享</strong>：<code>shared_timed_mutex</code>和<code>shared_mutex</code>提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在<a href=\"https://en.wikipedia.org/wiki/Readers%E2%80%93writers_problem\">读者写者模型</a>上。</li>\n</ul>\n<p>使用共享锁的接口如下：</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>lock_shared</td>\n<td>获取互斥体的共享锁，如果无法获取则阻塞</td>\n</tr>\n<tr>\n<td>try_lock_shared</td>\n<td>尝试获取共享锁，如果不可用，直接返回</td>\n</tr>\n<tr>\n<td>unlock_shared</td>\n<td>解锁共享锁</td>\n</tr>\n</tbody></table>\n<p>接下来，我们就借助刚学到的<code>mutex</code>来改造我们的并发系统，改造后的程序如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 07_mutex_lock.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10e8</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> mutex exclusive;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    exclusive.lock(); <span class=\"comment\">// ①</span></span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">    exclusive.unlock(); <span class=\"comment\">// ②</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;hardware_concurrency: &quot;</span> &lt;&lt; concurrent_count &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;thread&gt; threads;</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> t = <span class=\"number\">0</span>; t &lt; concurrent_count; t++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (t + <span class=\"number\">1</span>);</span><br><span class=\"line\">    threads.push_back(thread(concurrent_worker, min, range)); <span class=\"comment\">// ③</span></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; threads.size(); i++) &#123;</span><br><span class=\"line\">    threads[i].join();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只有三个地方需要关注：</p>\n<ol>\n<li>在访问共享数据之前加锁</li>\n<li>访问完成之后解锁</li>\n<li>在多线程中使用带锁的版本</li>\n</ol>\n<p>执行之后结果输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hardware_concurrency: 16</span><br><span class=\"line\">Concurrent task finish, 74232 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>这下结果是对了，但是我们却发现这个版本比原先单线程的版本性能还要差很多。这是为什么？</p>\n<p>这是因为加锁和解锁是有代价的，这里计算最耗时的地方在锁里面，每次只能有一个线程串行执行，相比于单线程模型，它不但是串行的，还增加了锁的负担，因此就更慢了。</p>\n<p>这就是为什么前面说多线程系统会增加系统的复杂度，而且并非多线程系统一定就有更好的性能。</p>\n<p>不过，对于这里的问题是可以改进的。我们仔细思考一下：我们划分给每个线程的数据其实是独立的，对于数据的处理是耗时的，但其实这部分逻辑每个线程可以单独处理，没必要加锁。只有在最后汇总数据的时候进行一次锁保护就可以了。</p>\n<p>于是我们改造<code>concurrent_worker</code>，像下面这样：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 08_improved_mutex_lock.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> tmp_sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    tmp_sum += <span class=\"built_in\">sqrt</span>(i); <span class=\"comment\">// ①</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  exclusive.lock(); <span class=\"comment\">// ②</span></span><br><span class=\"line\">  sum += tmp_sum;</span><br><span class=\"line\">  exclusive.unlock();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码的改变在于两处：</p>\n<ol>\n<li>通过一个局部变量保存当前线程的处理结果</li>\n<li>在汇总总结过的时候进行锁保护</li>\n</ol>\n<p>运行一下改进后的程序，其结果输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hardware_concurrency: 16</span><br><span class=\"line\">Concurrent task finish, 451 ms consumed, Result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>可以看到，性能一下就提升了好多倍。我们终于体验到多线程带来的好处了。</p>\n<p>我们用锁的<strong>粒度</strong>（granularity）来描述锁的范围。<strong>细粒度</strong>（fine-grained）是指锁保护较小的范围，<strong>粗粒度</strong>（coarse-grained）是指锁保护较大的范围。出于性能的考虑，我们应该保证锁的粒度尽可能的细。并且，不应该在获取锁的范围内执行耗时的操作，例如执行IO。如果是耗时的运算，也应该尽可能的移到锁的外面。</p>\n<blockquote>\n<p>In general, a lock should be held for only the minimum possible time needed to perform the required operations.</p>\n<p>–《C++ Concurrency in Action》</p>\n</blockquote>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>死锁是并发系统很常见的一类问题。</p>\n<p>死锁是指：两个或以上的运算单元，每一方都在等待其他方释放资源，但是所有方都不愿意释放资源。结果是没有任何一方能继续推进下去，于是整个系统无法再继续运转。</p>\n<p>死锁在现实中也很常见，例如：两个孩子分别拿着玩具的一半然后哭着要从对方手里得到另外一半玩具，但是谁都不肯让步。</p>\n<p>在成年人的世界里也会发生类似的情况，例如下面这个交通状况：</p>\n<p>![img](C++ 并发编程/deadlock.gif)</p>\n<p>下面我们来看一个编程示例。</p>\n<p>现在假设我们在开发一个银行的系统，这个系统包含了转账的功能。</p>\n<p>首先我们创建一个<code>Account</code>类来描述银行账号。由于这仅仅是一个演示使用的代码，所以我们希望代码足够的简单。<code>Account</code>类仅仅包含名称和金额两个字段。</p>\n<p>另外，为了支持并发，这个类包含了一个<code>mutex</code>对象，用来保护账号金额，在读写账号金额时需要先加锁保护。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Account(<span class=\"built_in\">string</span> name, <span class=\"keyword\">double</span> money): mName(name), mMoney(money) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changeMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    mMoney += amount;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mMoney;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\">mutex* <span class=\"title\">getLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &amp;mMoneyLock;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">string</span> mName;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> mMoney;</span><br><span class=\"line\">  mutex mMoneyLock;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><code>Account</code>类很简单，我想就不用多做说明了。</p>\n<p>接下来，我们再创建一个描述银行的<code>Bank</code>类。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bank</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addAccount</span><span class=\"params\">(Account* account)</span> </span>&#123;</span><br><span class=\"line\">    mAccounts.insert(account);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">transferMoney</span><span class=\"params\">(Account* accountA, Account* accountB, <span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">lock_guard <span class=\"title\">guardA</span><span class=\"params\">(*accountA-&gt;getLock())</span></span>; <span class=\"comment\">// ①</span></span><br><span class=\"line\">    <span class=\"function\">lock_guard <span class=\"title\">guardB</span><span class=\"params\">(*accountB-&gt;getLock())</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (amount &gt; accountA-&gt;getMoney()) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    accountA-&gt;changeMoney(-amount); <span class=\"comment\">// ③</span></span><br><span class=\"line\">    accountB-&gt;changeMoney(amount);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">totalMoney</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> a : mAccounts) &#123;</span><br><span class=\"line\">      sum += a-&gt;getMoney();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">set</span>&lt;Account*&gt; mAccounts;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>银行类中记录了所有的账号，并且提供了一个方法用来查询整个银行的总金额。</p>\n<p>这其中，我们最主要要关注转账的实现：<code>transferMoney</code>。该方法的几个关键点如下：</p>\n<ol>\n<li>为了保证线程安全，在修改每个账号之前，需要获取相应的锁。</li>\n<li>判断转出账户金额是否足够，如果不够此次转账失败。</li>\n<li>进行转账。</li>\n</ol>\n<p>有了银行和账户结构之后就可以开发转账系统了，同样的，由于是为了演示所用，我们的转账系统也会尽可能的简单：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomTransfer</span><span class=\"params\">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> randomMoney = ((<span class=\"keyword\">double</span>)rand() / RAND_MAX) * <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bank-&gt;transferMoney(accountA, accountB, randomMoney)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; from &quot;</span> &lt;&lt; accountA-&gt;getName()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot; to &quot;</span> &lt;&lt; accountB-&gt;getName()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;totalMoney() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer failed, &quot;</span></span><br><span class=\"line\">           &lt;&lt; accountA-&gt;getName() &lt;&lt; <span class=\"string\">&quot; has only $&quot;</span> &lt;&lt; accountA-&gt;getMoney() &lt;&lt; <span class=\"string\">&quot;, but &quot;</span></span><br><span class=\"line\">           &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; required&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里每次生成一个随机数，然后通过银行进行转账。</p>\n<p>最后我们在<code>main</code>函数中创建两个线程，互相在两个账号之间来回转账：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 09_deadlock_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Account <span class=\"title\">a</span><span class=\"params\">(<span class=\"string\">&quot;Paul&quot;</span>, <span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">Account <span class=\"title\">b</span><span class=\"params\">(<span class=\"string\">&quot;Moira&quot;</span>, <span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  Bank aBank;</span><br><span class=\"line\">  aBank.addAccount(&amp;a);</span><br><span class=\"line\">  aBank.addAccount(&amp;b);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t1</span><span class=\"params\">(randomTransfer, &amp;aBank, &amp;a, &amp;b)</span></span>;</span><br><span class=\"line\">  <span class=\"function\">thread <span class=\"title\">t2</span><span class=\"params\">(randomTransfer, &amp;aBank, &amp;b, &amp;a)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>至此，我们的银行转账系统就开发完成了。然后编译并运行，其结果可能像下面这样：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Transfer 13.2901 from Paul to Moira, Bank totalMoney: 20042.6259 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $34.7581, but 66.3208 required</span><br><span class=\"line\">Transfer failed, Moira has only $34.7581, but </span><br><span class=\"line\">Transfer 93.191 from 53.9176 required</span><br><span class=\"line\">Transfer 60.6146 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 49.7304 from Moira to Paul, Bank totalMoney: 200Paul to Moira, Bank totalMoney: </span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 18.1186 required</span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 18.893 required</span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 34.7078 required</span><br><span class=\"line\">Transfer failed, Moira has only $17.6041, but 33.9569 required</span><br><span class=\"line\">Transfer 12.7899 from 200</span><br><span class=\"line\">Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $63.9373, but 80.9038 required</span><br><span class=\"line\">Transfer 50.933 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $13.0043, but 30.2056 required</span><br><span class=\"line\">Transfer failed, Moira has only $Transfer 59.123 from Paul to Moira, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 29.0486 from Paul to Moira, Bank totalMoney: 20013.0043, but 64.7307 required</span><br></pre></td></tr></table></figure>\n<p>如果你运行了这个程序，你会发现很快它就卡住不动了。为什么？</p>\n<p>因为发生了死锁。</p>\n<p>我们仔细思考一下这两个线程的逻辑：这两个线程可能会同时获取其中一个账号的锁，然后又想获取另外一个账号的锁，此时就发生了死锁。如下图所示：</p>\n<img src=\"C++ 并发编程/deadlock.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>当然，发生死锁的原因远不止上面这一种情况。如果两个线程互相<code>join</code>就可能发生死锁。还有在一个线程中对一个不可重入的互斥体（例如<code>mutex</code>而非<code>recursive_mutex</code>）多次加锁也会死锁。</p>\n<p>你可能会觉得，我可不会这么傻，写出这样的代码。但实际上，很多时候是由于代码的深层次嵌套导致了死锁的发生，由于调用关系的复杂导致发现这类问题并不容易。</p>\n<p>如果仔细看一下上面的输出，我们会发现还有另外一个问题：这里的输出是乱的。两个线程的输出混杂在一起了。究其原因也很容易理解：两个线程可能会同时输出，没有做好隔离。</p>\n<p>下面我们就来逐步解决上面的问题。</p>\n<p>对于输出混乱的问题很好解决，专门用一把锁来保护输出逻辑即可：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 10_improved_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\">mutex sCoutLock;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomTransfer</span><span class=\"params\">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> randomMoney = ((<span class=\"keyword\">double</span>)rand() / RAND_MAX) * <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (bank-&gt;transferMoney(accountA, accountB, randomMoney)) &#123;</span><br><span class=\"line\">      sCoutLock.lock();</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer &quot;</span> &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; from &quot;</span> &lt;&lt; accountA-&gt;getName()</span><br><span class=\"line\">          &lt;&lt; <span class=\"string\">&quot; to &quot;</span> &lt;&lt; accountB-&gt;getName()</span><br><span class=\"line\">          &lt;&lt; <span class=\"string\">&quot;, Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;totalMoney() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      sCoutLock.unlock();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      sCoutLock.lock();</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Transfer failed, &quot;</span></span><br><span class=\"line\">           &lt;&lt; accountA-&gt;getName() &lt;&lt; <span class=\"string\">&quot; has only &quot;</span> &lt;&lt; accountA-&gt;getMoney() &lt;&lt; <span class=\"string\">&quot;, but &quot;</span></span><br><span class=\"line\">           &lt;&lt; randomMoney &lt;&lt; <span class=\"string\">&quot; required&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">      sCoutLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>请思考一下两处<code>lock</code>和<code>unlock</code>调用，并考虑为什么不在<code>while(true)</code>下面写一次整体的加锁和解锁。</p>\n</blockquote>\n<h2 id=\"通用锁定算法\"><a href=\"#通用锁定算法\" class=\"headerlink\" title=\"通用锁定算法\"></a>通用锁定算法</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">锁定指定的互斥体，若任何一个不可用则阻塞</td>\n</tr>\n<tr>\n<td align=\"left\">try_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">试图通过重复调用 try_lock 获得互斥体的所有权</td>\n</tr>\n</tbody></table>\n<p>要避免死锁，需要仔细的思考和设计业务逻辑。</p>\n<p>有一个比较简单的原则可以避免死锁，即：对所有的锁进行排序，每次一定要按照顺序来获取锁，不允许乱序。例如：要获取某个玩具，一定要先拿到锁A，再拿到锁B，才能玩玩具。这样就不会死锁了。</p>\n<p>这个原则虽然简单，但却不容易遵守。因为数据常常是分散在很多地方的。</p>\n<p>不过好消息是，C++ 11标准中为我们提供了一些工具来避免因为多把锁而导致的死锁。我们只要直接调用这些接口就可以了。这个就是上面提到的两个函数。它们都支持传入多个<a href=\"https://en.cppreference.com/w/cpp/named_req/Lockable\">Lockable</a>对象。</p>\n<p>接下来我们用它来改造之前死锁的转账系统：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 10_improved_bank_transfer.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">transferMoney</span><span class=\"params\">(Account* accountA, Account* accountB, <span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">  lock(*accountA-&gt;getLock(), *accountB-&gt;getLock());    <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"function\">lock_guard <span class=\"title\">lockA</span><span class=\"params\">(*accountA-&gt;getLock(), adopt_lock)</span></span>;  <span class=\"comment\">// ②</span></span><br><span class=\"line\">  <span class=\"function\">lock_guard <span class=\"title\">lockB</span><span class=\"params\">(*accountB-&gt;getLock(), adopt_lock)</span></span>;  <span class=\"comment\">// ③</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (amount &gt; accountA-&gt;getMoney()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  accountA-&gt;changeMoney(-amount);</span><br><span class=\"line\">  accountB-&gt;changeMoney(amount);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里只改动了3行代码。</p>\n<ol>\n<li>这里通过<code>lock</code>函数来获取两把锁，标准库的实现会保证不会发生死锁。</li>\n<li><code>lock_guard</code>在下面我们还会详细介绍。这里只要知道它会在自身对象生命周期的范围内锁定互斥体即可。创建<code>lock_guard</code>的目的是为了在<code>transferMoney</code>结束的时候释放锁，<code>lockB</code>也是一样。但需要注意的是，这里传递了 <code>adopt_lock</code>表示：现在是已经获取到互斥体了的状态了，不用再次加锁（如果不加<code>adopt_lock</code>就是二次锁定了）。</li>\n</ol>\n<p>运行一下这个改造后的程序，其输出如下所示：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 17.5974 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 59.2104 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 49.6379 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 63.6373 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 51.8742 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 50.0081 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 86.1041 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 51.3278 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 66.5754 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 32.1867 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 62.0039 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 98.7819 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 27.046 required</span><br><span class=\"line\">Transfer failed, Paul has only $1.76243, but 62.9155 required</span><br><span class=\"line\">Transfer 98.8478 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 80.0722 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 73.7035 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer 34.4476 from Moira to Paul, Bank totalMoney: 200</span><br><span class=\"line\">Transfer failed, Moira has only $10.0142, but 61.3033 required</span><br><span class=\"line\">Transfer failed, Moira has only $10.0142, but 24.5595 required</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>现在这个转账程序会一直运行下去，不会再死锁了。输出也是正常的了。</p>\n<h2 id=\"通用互斥管理\"><a href=\"#通用互斥管理\" class=\"headerlink\" title=\"通用互斥管理\"></a>通用互斥管理</h2><ul>\n<li>主要API</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">lock_guard</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">实现严格基于作用域的互斥体所有权包装器</td>\n</tr>\n<tr>\n<td align=\"left\">unique_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">实现可移动的互斥体所有权包装器</td>\n</tr>\n<tr>\n<td align=\"left\">shared_lock</td>\n<td align=\"left\">C++14</td>\n<td align=\"left\">实现可移动的共享互斥体所有权封装器</td>\n</tr>\n<tr>\n<td align=\"left\">scoped_lock</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">用于多个互斥体的免死锁 RAII 封装器</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th align=\"left\">锁定策略</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">defer_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">类型为 <code>defer_lock_t</code>，不获得互斥的所有权</td>\n</tr>\n<tr>\n<td align=\"left\">try_to_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">类型为<code>try_to_lock_t</code>，尝试获得互斥的所有权而不阻塞</td>\n</tr>\n<tr>\n<td align=\"left\">adopt_lock</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">类型为<code>adopt_lock_t</code>，假设调用方已拥有互斥的所有权</td>\n</tr>\n</tbody></table>\n<p>互斥体（<code>mutex</code>相关类）提供了对于资源的保护功能，但是手动的锁定（调用<code>lock</code>或者<code>try_lock</code>）和解锁（调用<code>unlock</code>）互斥体是要耗费比较大的精力的，我们需要精心考虑和设计代码才行。因为我们需要保证，在任何情况下，解锁要和加锁配对，因为假设出现一条路径导致获取锁之后没有正常释放，就会影响整个系统。如果考虑方法还可以会抛出异常，这样的代码写起来会很费劲。</p>\n<p>鉴于这个原因，标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。</p>\n<p>请看下面的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// https://en.cppreference.com/w/cpp/thread/lock_guard</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;mutex&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">int</span> g_i = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::mutex g_i_mutex;  <span class=\"comment\">// ①</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">safe_increment</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::lock_guard&lt;<span class=\"built_in\">std</span>::mutex&gt; <span class=\"title\">lock</span><span class=\"params\">(g_i_mutex)</span></span>;  <span class=\"comment\">// ②</span></span><br><span class=\"line\">  ++g_i;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">std</span>::this_thread::get_id() &lt;&lt; <span class=\"string\">&quot;: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// ③</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t1</span><span class=\"params\">(safe_increment)</span></span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">std</span>::thread <span class=\"title\">t2</span><span class=\"params\">(safe_increment)</span></span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">  t1.join();</span><br><span class=\"line\">  t2.join();</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;main: &quot;</span> &lt;&lt; g_i &lt;&lt; <span class=\"string\">&#x27;\\n&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码中：</p>\n<ol>\n<li>全局的互斥体<code>g_i_mutex</code>用来保护全局变量<code>g_i</code></li>\n<li>这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用<code>lock</code>方法，而是直接使用<code>lock_guard</code>来锁定互斥体。</li>\n<li>在方法结束的时候，局部变量<code>std::lock_guard&lt;std::mutex&gt; lock</code>会被销毁，它对互斥体的锁定也就解除了。</li>\n<li>在多个线程中使用这个方法。</li>\n</ol>\n<h3 id=\"RAII\"><a href=\"#RAII\" class=\"headerlink\" title=\"RAII\"></a>RAII</h3><p>上面的几个类（<code>lock_guard</code>，<code>unique_lock</code>，<code>shared_lock</code>，<code>scoped_lock</code>）都使用了一个叫做RAII的编程技巧。</p>\n<p>RAII全称是Resource Acquisition Is Initialization，直译过来就是：资源获取即初始化。</p>\n<p>RAII是一种<a href=\"http://www.stroustrup.com/bs_faq2.html#finally\">C++编程技术</a>，它将必须在使用前请求的资源（例如：分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期与一个对象的生存周期相绑定。 RAII保证资源可用于任何会访问该对象的函数。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性以消除内存泄漏并保证异常安全。</p>\n<p>RAII 可总结如下:</p>\n<ul>\n<li>将每个资源封装入一个类，其中：<ul>\n<li>构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常，</li>\n<li>析构函数释放资源并决不抛出异常；</li>\n</ul>\n</li>\n<li>始终经由 RAII 类的实例使用满足要求的资源，该资源<ul>\n<li>自身拥有自动存储期或临时生存期，或</li>\n<li>具有与自动或临时对象的生存期绑定的生存期</li>\n</ul>\n</li>\n</ul>\n<p>回想一下上文中的<code>transferMoney</code>方法中的三行代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lock(*accountA-&gt;getLock(), *accountB-&gt;getLock());</span><br><span class=\"line\"><span class=\"function\">lock_guard <span class=\"title\">lockA</span><span class=\"params\">(*accountA-&gt;getLock(), adopt_lock)</span></span>;</span><br><span class=\"line\"><span class=\"function\">lock_guard <span class=\"title\">lockB</span><span class=\"params\">(*accountB-&gt;getLock(), adopt_lock)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>如果使用<code>unique_lock</code>这三行代码还有一种等价的写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">unique_lock <span class=\"title\">lockA</span><span class=\"params\">(*accountA-&gt;getLock(), defer_lock)</span></span>;</span><br><span class=\"line\"><span class=\"function\">unique_lock <span class=\"title\">lockB</span><span class=\"params\">(*accountB-&gt;getLock(), defer_lock)</span></span>;</span><br><span class=\"line\">lock(*accountA-&gt;getLock(), *accountB-&gt;getLock());</span><br></pre></td></tr></table></figure>\n<p>请注意这里<code>lock</code>方法的调用位置。这里先定义<code>unique_lock</code>指定了<code>defer_lock</code>，因此实际没有锁定互斥体，而是到第三行才进行锁定。</p>\n<p>最后，借助<code>scoped_lock</code>，我们可以将三行代码合成一行，这种写法也是等价的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">scoped_lock <span class=\"title\">lockAll</span><span class=\"params\">(*accountA-&gt;getLock(), *accountB-&gt;getLock())</span></span>;</span><br></pre></td></tr></table></figure>\n<p><code>scoped_lock</code>会在其生命周期范围内锁定互斥体，销毁的时候解锁。同时，它可以锁定多个互斥体，并且避免死锁。</p>\n<p>目前，只还有<code>shared_lock</code>我们没有提到。它与其他几个类的区别在于：它是以共享的方式锁定互斥体。</p>\n<h2 id=\"条件变量\"><a href=\"#条件变量\" class=\"headerlink\" title=\"条件变量\"></a>条件变量</h2><table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">condition_variable</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">提供与 std::unique_lock 关联的条件变量</td>\n</tr>\n<tr>\n<td align=\"left\">condition_variable_any</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">提供与任何锁类型关联的条件变量</td>\n</tr>\n<tr>\n<td align=\"left\">notify_all_at_thread_exit</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">安排到在此线程完全结束时对 notify_all 的调用</td>\n</tr>\n<tr>\n<td align=\"left\">cv_status</td>\n<td align=\"left\">C++ 11</td>\n<td align=\"left\">列出条件变量上定时等待的可能结果</td>\n</tr>\n</tbody></table>\n<p>至此，我们还有一个地方可以改进。那就是：转账金额不足的时候，程序直接返回了<code>false</code>。这很难说是一个好的策略。因为，即便虽然当前账号金额不足以转账，但只要别的账号又转账进来之后，当前这个转账操作也许就可以继续执行了。</p>\n<p>这在很多业务中是很常见的一个需求：每一次操作都要正确执行，如果条件不满足就停下来等待，直到条件满足之后再继续。而不是直接返回。</p>\n<p>条件变量提供了一个可以让多个线程间同步协作的功能。这对于<a href=\"https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem\">生产者-消费者模型</a>很有意义。在这个模型下：</p>\n<ul>\n<li>生产者和消费者共享一个工作区。这个区间的大小是有限的。</li>\n<li>生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。</li>\n<li>消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。</li>\n</ul>\n<p>从上面可以看到，无论是生产者还是消费者，当它们工作的条件不满足时，它们并不是直接报错返回，而是停下来等待，直到条件满足。</p>\n<p>下面我们就借助于条件变量，再次改造之前的银行转账系统。</p>\n<p>这个改造主要在于账号类。我们重点是要调整<code>changeMoney</code>方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Account</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Account(<span class=\"built_in\">string</span> name, <span class=\"keyword\">double</span> money): mName(name), mMoney(money) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">changeMoney</span><span class=\"params\">(<span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">unique_lock <span class=\"title\">lock</span><span class=\"params\">(mMoneyLock)</span></span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    mConditionVar.wait(lock, [<span class=\"keyword\">this</span>, amount] &#123; <span class=\"comment\">// ③</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> mMoney + amount &gt; <span class=\"number\">0</span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    mMoney += amount;</span><br><span class=\"line\">    mConditionVar.notify_all(); <span class=\"comment\">// ⑤</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mName;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getMoney</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mMoney;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"built_in\">string</span> mName;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> mMoney;</span><br><span class=\"line\">  mutex mMoneyLock;</span><br><span class=\"line\">  condition_variable mConditionVar; <span class=\"comment\">// ①</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这几处改动说明如下：</p>\n<ol>\n<li>这里声明了一个条件变量，用来在多个线程之间协作。</li>\n<li>这里使用的是<code>unique_lock</code>，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。</li>\n<li>这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则<strong>此处会解锁互斥体，并让当前线程等待</strong>。<strong>解锁</strong>这一点非常重要，因为只有这样，才能让其他线程获取互斥体。</li>\n<li>这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读<a href=\"https://paul.pub/cpp-lambda-function-bind/\">我之前写的文章</a>。</li>\n<li>此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用<code>wait</code>线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了<code>notify_all</code>还有<code>notify_one</code>，它只通知一个等待的线程。<code>wait</code>和<code>notify</code>就构成了线程间互相协作的工具。</li>\n</ol>\n<p>请注意：<code>wait</code>和<code>notify_all</code>虽然是写在一个函数中的，但是在运行时它们是在多线程环境中执行的，因此对于这段代码，需要能够从不同线程的角度去思考代码的逻辑。这也是开发并发系统比较难的地方。</p>\n<p>有了上面的改动之后，银行的转账方法实现起来就很简单了，不用再考虑数据保护的问题了：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Bank::transferMoney</span><span class=\"params\">(Account* accountA, Account* accountB, <span class=\"keyword\">double</span> amount)</span> </span>&#123;</span><br><span class=\"line\">    accountA-&gt;changeMoney(-amount);</span><br><span class=\"line\">    accountB-&gt;changeMoney(amount);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然，转账逻辑也会变得简单，不用再管转账失败的情况发生。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 11_bank_transfer_wait_notify.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\">mutex sCoutLock;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">randomTransfer</span><span class=\"params\">(Bank* bank, Account* accountA, Account* accountB)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> randomMoney = ((<span class=\"keyword\">double</span>)rand() / RAND_MAX) * <span class=\"number\">100</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"function\">lock_guard <span class=\"title\">guard</span><span class=\"params\">(sCoutLock)</span></span>;</span><br><span class=\"line\">      <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Try to Transfer &quot;</span> &lt;&lt; randomMoney</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot; from &quot;</span> &lt;&lt; accountA-&gt;getName() &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; accountA-&gt;getMoney()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot;) to &quot;</span> &lt;&lt; accountB-&gt;getName() &lt;&lt; <span class=\"string\">&quot;(&quot;</span> &lt;&lt; accountB-&gt;getMoney()</span><br><span class=\"line\">           &lt;&lt; <span class=\"string\">&quot;), Bank totalMoney: &quot;</span> &lt;&lt; bank-&gt;totalMoney() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bank-&gt;transferMoney(accountA, accountB, randomMoney);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改完之后的程序运行输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Try to Transfer 13.72 from Moira(10.9287) to Paul(189.071), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 28.6579 from Paul(189.071) to Moira(10.9287), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 91.8049 from Paul(160.413) to Moira(39.5866), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 5.56383 from Paul(82.3285) to Moira(117.672), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 11.3594 from Paul(76.7646) to Moira(123.235), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 16.9557 from Paul(65.4053) to Moira(134.595), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 74.998 from Paul(48.4495) to Moira(151.55), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 65.3005 from Moira(151.55) to Paul(48.4495), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 90.6084 from Moira(86.25) to Paul(113.75), Bank totalMoney: 125.002</span><br><span class=\"line\">Try to Transfer 99.6425 from Moira(70.6395) to Paul(129.36), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 55.2091 from Paul(129.36) to Moira(70.6395), Bank totalMoney: 200</span><br><span class=\"line\">Try to Transfer 92.259 from Paul(74.1513) to Moira(125.849), Bank totalMoney: 200</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>这下比之前都要好了。</p>\n<p>但是细心的读者会发现，Bank totalMoney的输出有时候是200，有时候不是。但不管怎样，即便这一次不是，下一次又是了。关于这一点，请读者自行思考一下为什么，以及如何改进。</p>\n<h1 id=\"future\"><a href=\"#future\" class=\"headerlink\" title=\"future\"></a>future</h1><table>\n<thead>\n<tr>\n<th align=\"left\">API</th>\n<th align=\"left\">C++标准</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">async</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">异步运行一个函数，并返回保有其结果的<code>std::future</code></td>\n</tr>\n<tr>\n<td align=\"left\">future</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">等待被异步设置的值</td>\n</tr>\n<tr>\n<td align=\"left\">packaged_task</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">打包一个函数，存储其返回值以进行异步获取</td>\n</tr>\n<tr>\n<td align=\"left\">promise</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">存储一个值以进行异步获取</td>\n</tr>\n<tr>\n<td align=\"left\">shared_future</td>\n<td align=\"left\">C++11</td>\n<td align=\"left\">等待被异步设置的值（可能为其他 future 所引用）</td>\n</tr>\n</tbody></table>\n<p>这一小节中，我们来熟悉更多的可以在并发环境中使用的工具，它们都位于<code>&lt;future&gt;</code>头文件中。</p>\n<h2 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h2><p>很多语言都提供了异步的机制。异步使得耗时的操作不影响当前主线程的执行流。</p>\n<p>在C++11中，<code>async</code>便是完成这样的功能的。下面是一个代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12_async_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> MAX = <span class=\"number\">10e8</span>;</span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f1 = async(worker, <span class=\"number\">0</span>, MAX);</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task triggered&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  f1.wait();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task finish, result: &quot;</span> &lt;&lt; sum &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这仍然是我们之前熟悉的例子。这里有两个地方需要说明：</p>\n<ol>\n<li>这里以异步的方式启动了任务。它会返回一个<code>future</code>对象。<code>future</code>用来存储异步任务的执行结果，关于<code>future</code>我们在后面<code>packaged_task</code>的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。</li>\n<li>此处是等待异步任务执行完成。</li>\n</ol>\n<p>需要注意的是，默认情况下，<code>async</code>是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过<code>launch::async</code>来明确说明。<code>launch</code>中有两个常量：</p>\n<ul>\n<li><code>async</code>：运行新线程，以异步执行任务。</li>\n<li><code>deferred</code>：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>\n</ul>\n<p>除了通过函数来指定异步任务，还可以lambda表达式的方式来指定。如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12_async_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">double</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task with lambda triggered, thread: &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f2 = async(launch::async, [&amp;result]() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Lambda task in thread: &quot;</span> &lt;&lt; this_thread::get_id() &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= MAX; i++) &#123;</span><br><span class=\"line\">      result += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  f2.wait();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Async task with lambda finish, result: &quot;</span> &lt;&lt; result &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在上面这段代码中，我们使用一个lambda表达式来编写异步任务的逻辑，并通过<code>launch::async</code>明确指定要通过独立的线程来执行任务，同时我们打印出了线程的id。</p>\n<p>这段代码输出如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Async task with lambda triggered, thread: 0x11290d5c0</span><br><span class=\"line\">Lambda task in thread: 0x700007aa1000</span><br><span class=\"line\">Async task with lambda finish, result: 2.10819e+13</span><br></pre></td></tr></table></figure>\n<p>对于面向对象编程来说，很多时候肯定希望以对象的方法来指定异步任务。下面是一个示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 12_async_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  Worker(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max): mMin(min), mMax(max) &#123;&#125; <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">work</span><span class=\"params\">()</span> </span>&#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    mResult = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = mMin; i &lt;= mMax; i++) &#123;</span><br><span class=\"line\">      mResult += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">getResult</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> mResult;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mMin;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> mMax;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> mResult;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\">Worker <span class=\"title\">w</span><span class=\"params\">(<span class=\"number\">0</span>, MAX)</span></span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Task in class triggered&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> f3 = async(&amp;Worker::work, &amp;w); <span class=\"comment\">// ③</span></span><br><span class=\"line\">  f3.wait();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Task in class finish, result: &quot;</span> &lt;&lt; w.getResult() &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码有三处需要说明：</p>\n<ol>\n<li>这里通过一个类来描述任务。这个类是对前面提到的任务的封装。它包含了任务的输入参数，和输出结果。</li>\n<li><code>work</code>函数是任务的主体逻辑。</li>\n<li>通过<code>async</code>执行任务：这里指定了具体的任务函数以及相应的对象。请注意这里是<code>&amp;w</code>，因此传递的是对象的指针。如果不写<code>&amp;</code>将传入<code>w</code>对象的临时复制。</li>\n</ol>\n<h2 id=\"packaged-task\"><a href=\"#packaged-task\" class=\"headerlink\" title=\"packaged_task\"></a>packaged_task</h2><p>在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用<code>packaged_task</code>来包装任务。</p>\n<blockquote>\n<p>如果你了解设计模式，你应该会知道<a href=\"https://en.wikipedia.org/wiki/Command_pattern\">命令模式</a>。</p>\n</blockquote>\n<p><code>packaged_task</code>绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的<code>future</code>来获取任务的结果。调度程序只需要处理<code>packaged_task</code>，而非各个函数。</p>\n<p><code>packaged_task</code>对象是一个可调用对象，它可以被封装成一个<code>std::fucntion</code>，或者作为线程函数传递给<code>std::thread</code>，或者直接调用。</p>\n<p>下面是一个代码示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 13_packaged_task.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">future</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; results; <span class=\"comment\">// ①</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency();</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; concurrent_count; i++) &#123; <span class=\"comment\">// ②</span></span><br><span class=\"line\">    <span class=\"function\">packaged_task&lt;<span class=\"title\">double</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span>&gt; <span class=\"title\">task</span><span class=\"params\">(concurrent_worker)</span></span>; <span class=\"comment\">// ③</span></span><br><span class=\"line\">    results.push_back(task.get_future()); <span class=\"comment\">// ④</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(<span class=\"built_in\">std</span>::move(task), min, range)</span></span>; <span class=\"comment\">// ⑤</span></span><br><span class=\"line\">    t.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;threads create finish&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; r : results) &#123;</span><br><span class=\"line\">    sum += r.get(); <span class=\"comment\">// ⑥</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">double</span> r = concurrent_task(<span class=\"number\">0</span>, MAX);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed, Result: &quot;</span> &lt;&lt; r &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在这段代码中：</p>\n<ol>\n<li>首先创建一个集合来存储<code>future</code>对象。我们将用它来获取任务的结果。</li>\n<li>同样的，根据CPU的情况来创建线程的数量。</li>\n<li>将任务包装成<code>packaged_task</code>。请注意，由于<code>concurrent_worker</code>被包装成了任务，我们无法直接获取它的<code>return</code>值。而是要通过<code>future</code>对象来获取。</li>\n<li>获取任务关联的<code>future</code>对象，并将其存入集合中。</li>\n<li>通过一个新的线程来执行任务，并传入需要的参数。</li>\n<li>通过<code>future</code>集合，逐个获取每个任务的计算结果，将其累加。这里<code>r.get()</code>获取到的就是每个任务中<code>concurrent_worker</code>的返回值。</li>\n</ol>\n<p>为了简单起见，这里的示例只使用了我们熟悉的例子和结构。但在实际上的工程中，调用关系通常更复杂，你可以借助于<code>packaged_task</code>将任务组装成队列，然后通过<a href=\"https://en.wikipedia.org/wiki/Thread_pool\">线程池</a>的方式进行调度：</p>\n<p>![image-20210305140102303](C++ 并发编程/image-20210305140102303.png)</p>\n<h2 id=\"promise与future\"><a href=\"#promise与future\" class=\"headerlink\" title=\"promise与future\"></a>promise与future</h2><p>在上面的例子中，<code>concurrent_task</code>的结果是通过<code>return</code>返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>\n<p>这个时候，就可以将<code>promise</code>与<code>future</code>配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>\n<p>下面是对上面代码示例的改写：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 14_promise_future.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">concurrent_worker</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = min; i &lt;= max; i++) &#123;</span><br><span class=\"line\">    sum += <span class=\"built_in\">sqrt</span>(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">concurrent_task</span><span class=\"params\">(<span class=\"keyword\">int</span> min, <span class=\"keyword\">int</span> max, promise&lt;<span class=\"keyword\">double</span>&gt;* result)</span> </span>&#123; <span class=\"comment\">// ①</span></span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">future</span>&lt;<span class=\"keyword\">double</span>&gt;&gt; results;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> concurrent_count = thread::hardware_concurrency();</span><br><span class=\"line\">  min = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; concurrent_count; i++) &#123;</span><br><span class=\"line\">    <span class=\"function\">packaged_task&lt;<span class=\"title\">double</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span>&gt; <span class=\"title\">task</span><span class=\"params\">(concurrent_worker)</span></span>;</span><br><span class=\"line\">    results.push_back(task.get_future()); </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> range = max / concurrent_count * (i + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"function\">thread <span class=\"title\">t</span><span class=\"params\">(<span class=\"built_in\">std</span>::move(task), min, range)</span></span>;</span><br><span class=\"line\">    t.detach();</span><br><span class=\"line\"></span><br><span class=\"line\">    min = range + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;threads create finish&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span>&amp; r : results) &#123;</span><br><span class=\"line\">    sum += r.get();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  result-&gt;set_value(sum); <span class=\"comment\">// ②</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;concurrent_task finish&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> start_time = chrono::steady_clock::now();</span><br><span class=\"line\"></span><br><span class=\"line\">  promise&lt;<span class=\"keyword\">double</span>&gt; sum; <span class=\"comment\">// ③</span></span><br><span class=\"line\">  concurrent_task(<span class=\"number\">0</span>, MAX, &amp;sum);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> end_time = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> ms = chrono::duration_cast&lt;chrono::milliseconds&gt;(end_time - start_time).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Concurrent task finish, &quot;</span> &lt;&lt; ms &lt;&lt; <span class=\"string\">&quot; ms consumed.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Result: &quot;</span> &lt;&lt; sum.get_future().get() &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：</p>\n<ol>\n<li><code>concurrent_task</code>不再直接返回计算结果，而是增加了一个<code>promise</code>对象来存放结果。</li>\n<li>在任务计算完成之后，将总结过设置到<code>promise</code>对象上。一旦这里调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>\n<li>这里是在<code>main</code>中创建一个<code>promoise</code>来存放结果，并以指针的形式传递进<code>concurrent_task</code>中。</li>\n<li>通过<code>sum.get_future().get()</code>来获取结果。第2点中已经说了：一旦调用了<code>set_value</code>，其相关联的<code>future</code>对象就会就绪。</li>\n</ol>\n<p>需要注意的是，<code>future</code>对象只有被一个线程获取值。并且在调用<code>get()</code>之后，就没有可以获取的值了。如果从多个线程调用<code>get()</code>会出现数据竞争，其结果是未定义的。</p>\n<p>如果真的需要在多个线程中获取<code>future</code>的结果，可以使用<code>shared_future</code>。</p>\n<h1 id=\"并行算法\"><a href=\"#并行算法\" class=\"headerlink\" title=\"并行算法\"></a>并行算法</h1><p>从C++17开始。<a href=\"https://en.cppreference.com/w/cpp/algorithm\"></a>和<a href=\"https://en.cppreference.com/w/cpp/numeric#Numeric_algorithms\"></a> 头文件的中的很多算法都添加了一个新的参数：<code>sequenced_policy</code>。</p>\n<p>借助这个参数，开发者可以直接使用这些算法的并行版本，不用再自己创建并发系统和划分数据来调度这些算法。</p>\n<p><code>sequenced_policy</code>可能的取值有三种，它们的说明如下：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">变量</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">C++版本</th>\n<th align=\"left\">说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">execution::seq</td>\n<td align=\"left\">execution::sequenced_policy</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">要求并行算法的执行可以不并行化</td>\n</tr>\n<tr>\n<td align=\"left\">execution::par</td>\n<td align=\"left\">execution::parallel_policy</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">指示并行算法的执行可以并行化</td>\n</tr>\n<tr>\n<td align=\"left\">execution::par_unseq</td>\n<td align=\"left\">execution::parallel_unsequenced_policy</td>\n<td align=\"left\">C++17</td>\n<td align=\"left\">指示并行算法的执行可以并行化、向量化</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：<a href=\"https://paul.pub/cpp-concurrency/#id-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83\">本文的前面</a>已经提到，目前clang编译器还不支持这个功能。因此想要编译这部分代码，你需要使用gcc 9.0或更高版本，同时还需要安装<a href=\"https://github.com/intel/tbb\">Intel Threading Building Blocks</a>。</p>\n</blockquote>\n<p>下面还是通过一个示例来进行说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 15_parallel_algorithm.cpp</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">generateRandomData</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt;&amp; collection, <span class=\"keyword\">int</span> size)</span> </span>&#123;</span><br><span class=\"line\">  random_device rd;</span><br><span class=\"line\">  <span class=\"function\">mt19937 <span class=\"title\">mt</span><span class=\"params\">(rd())</span></span>;</span><br><span class=\"line\">  <span class=\"function\">uniform_real_distribution&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">dist</span><span class=\"params\">(<span class=\"number\">1.0</span>, <span class=\"number\">100.0</span>)</span></span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) &#123;</span><br><span class=\"line\">    collection.push_back(dist(mt));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; collection;</span><br><span class=\"line\">  generateRandomData(collection, <span class=\"number\">10e6</span>); <span class=\"comment\">// ①</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">copy1</span><span class=\"params\">(collection)</span></span>; <span class=\"comment\">// ②</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">copy2</span><span class=\"params\">(collection)</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">double</span>&gt; <span class=\"title\">copy3</span><span class=\"params\">(collection)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time1 = chrono::steady_clock::now(); <span class=\"comment\">// ③</span></span><br><span class=\"line\">  sort(execution::seq, copy1.begin(), copy1.end()); <span class=\"comment\">// ④</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time2 = chrono::steady_clock::now();</span><br><span class=\"line\">  <span class=\"keyword\">auto</span> duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time2 - time1).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Sequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class=\"string\">&quot;ms.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>; <span class=\"comment\">// ⑤</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time3 = chrono::steady_clock::now();</span><br><span class=\"line\">  sort(execution::par, copy2.begin(),copy2.end()); <span class=\"comment\">// ⑥</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time4 = chrono::steady_clock::now();</span><br><span class=\"line\">  duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time4 - time3).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Parallel sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class=\"string\">&quot;ms.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time5 = chrono::steady_clock::now();</span><br><span class=\"line\">  sort(execution::par_unseq, copy2.begin(),copy2.end()); <span class=\"comment\">// ⑦</span></span><br><span class=\"line\">  <span class=\"keyword\">auto</span> time6 = chrono::steady_clock::now();</span><br><span class=\"line\">  duration = chrono::duration_cast&lt;chrono::milliseconds&gt;(time6 - time5).count();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">&quot;Parallel unsequenced sort consuming &quot;</span> &lt;&lt; duration &lt;&lt; <span class=\"string\">&quot;ms.&quot;</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很简单：</p>\n<ol>\n<li>通过一个函数生成1000,000个随机数。</li>\n<li>将数据拷贝3份，以备使用。</li>\n<li>接下来将通过三个不同的<code>parallel_policy</code>参数来调用同样的<code>sort</code>算法。每次调用记录开始和结束的时间。</li>\n<li>第一次调用使用<code>std::execution::seq</code>参数。</li>\n<li>输出本次测试所使用的时间。</li>\n<li>第二次调用使用<code>std::execution::par</code>参数。</li>\n<li>第三次调用使用<code>std::execution::par_unseq</code>参数。</li>\n</ol>\n<p>该程序的输出如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sequenced sort consuming <span class=\"number\">4464</span>ms.</span><br><span class=\"line\">Parallel sort consuming <span class=\"number\">459</span>ms.</span><br><span class=\"line\">Parallel unsequenced sort consuming <span class=\"number\">168</span>ms.</span><br></pre></td></tr></table></figure>\n<p>可以看到，性能最好的和最差的相差了超过26倍。</p>\n<h1 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h1><p>在本篇文章中，我们介绍了C++语言中新增的并发编程API。虽然这部分内容已经不少（大部分人很难一次性搞懂所有这些内容，包括我自己），但实际上还有一个很重要的话题我们没有触及，那就是“内存模型”。</p>\n<p>C++内存模型是C++11标准中最重要的特性之一。它是多线程环境能够可靠工作的基础。考虑到这部分内容还需要比较多的篇幅来说明，因此我们会在下一篇文章中继续讨论。</p>\n<h1 id=\"参考资料与推荐读物\"><a href=\"#参考资料与推荐读物\" class=\"headerlink\" title=\"参考资料与推荐读物\"></a>参考资料与推荐读物</h1><ul>\n<li><a href=\"https://www.amazon.com/C-Concurrency-Action-Anthony-Williams/dp/1617294691/\">C++ Concurrency in Action 2nd</a></li>\n<li><a href=\"http://wikipedia.org/\">Wikipedia</a></li>\n<li><a href=\"https://en.cppreference.com/w/cpp/thread\">cpprefernce: Thread support library</a></li>\n<li><a href=\"https://www.amazon.com/Effective-Modern-Specific-Ways-Improve/dp/1491903996\">Effective Modern C++: 42 Specific Ways to Improve Your Use of C++11 and C++14</a></li>\n<li><a href=\"https://www.hpl.hp.com/techreports/2004/HPL-2004-209.pdf\">Threads Cannot be Implemented as a Library</a></li>\n<li><a href=\"https://www.modernescpp.com/index.php/i-m-proud-to-present-modern-c-concurrency-is-available-as-interactive-course\">I’m Proud to Present: Modern C++ Concurrency is available as interactive course</a></li>\n<li><a href=\"https://intellij-support.jetbrains.com/hc/en-us/community/posts/115000682210-How-do-I-enable-C-17-\">How do I enable C++17?</a></li>\n<li><a href=\"https://solarianprogrammer.com/2019/05/09/cpp-17-stl-parallel-algorithms-gcc-intel-tbb-linux-macos/\">C++17 STL Parallel Algorithms - with GCC 9.1 and Intel TBB on Linux and macOS</a></li>\n<li><a href=\"https://medium.com/@george.shuklin/how-to-install-packages-from-a-newer-distribution-without-installing-unwanted-6584fa93208f\">How to install packages from a newer distribution without installing unwanted</a></li>\n</ul>\n"},{"title":"深入理解C++11","date":"2020-12-31T15:59:00.000Z","abbrlink":13007,"cover":"img/cpp.png","_content":"# **深入理解C++11**\n\n## 1. 前言\n\n### 1.1 说到C++11，应该想到什么？\n\n- 什么是 lambda，及怎么样使用它是最好的？\n- decltype 和 auto 类型推导有什么关系？\n- 什么是移动语义，以及(右值引用)是如何解决转发问题的？\n- default/deleted 函数以及 override 是怎么回事?\n- 异常描述符被什么替代了? noexcept 是如何工作的?\n- 什么是原子类型以及新的内存模型?\n- 如何在 C++11 中做并行编程?\n\n### 1.2 语言的哪些关键字和C++11有关？\n\n- alignas\n- alignof decltype\n- auto(重新定义)\n- static_assert\n- using(重新定义)\n- noexcept\n- export(弃用，不过未来可能留作他用)\n- nullptr\n- constexpr\n- thread_local\n\n## 2. 保证稳定性和兼容性\n\n### 2.1 将C99标准纳入C++11\n\n#### 2.1.1 确定编译环境的预定义宏\n\n- __STDC_HOSTED__：编译器的目标系统环境中是否包含完整的C库\n- __STDC__：编译器对于标准C库的实现是否和C标准一致（是否定义、如何定义由编译器决定）\n-  __STDC_VERSION__：编译器支持的C标准的版本（是否定义、如何定义由编译器决定）\n- __STDC_ISO_10646__：yyyymmL格式的整数常量，表示C++编译环境符合某个版本的ISO/IEC 10646标准\n\n#### 2.1.2 __func__ 预定义标识符\n\n函数中可以使用__func__标识符函数名称，编译器会在函数定义开始时隐式地插入__func__标识符定义：\n\n> static const char* __func__ = \"<函数名称>\";\n\n#### 2.1.3 _Pragma 操作符\n\n在之前的C/C++标准中已经规定了可以使用#pragma预处理指令向编译器传递信息，比如可以通过在头文件首行放置#pragma once来告诉编译器这个头文件只应该被include一次。\n\nC++11中，规定了一个新的操作符_Pragma，它的作用与#pragma完全相同，_Pragma(\"once\")就相当于#pragma once。但是，_Pragma由于是一个操作符而不是预处理指令，它的使用更为灵活，可以在宏中展开。\n\n#### 2.1.4 不定参数宏定义以及 __VA_ARGS__\n\nC99规定宏定义中，在参数列表的最后，可以使用...省略参数定义，而__VA_ARGS__可以用来替换被省略号代表的字符串。\n\n#### 2.1.5 宽窄字符串连接\n\n### 2.2 long long整形\n\n### 2.3 扩展的整形\n\n### 2.4 宏__cplusplus\n\n一般会和extern \"C\"配合使用，来让一个头文件即可以同时被include到C和C++中编译，使用extern \"C\"避免C++对符号名称进行重整，确保C++编译器编译出的目标文件中的符号名维持原样。\n\n```cpp\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n// 一些代码\n#ifdef __cplusplus \n}\n#endif\n```\n\n### 2.5 静态断言\n\n标准C库assert.h中，提供了assert函数来进行运行时的断言，表明某些情况一定不会发生。（在 C++ 中，程序员也可以定义宏 NDEBUG 来禁用 assert 宏。这对发布程序来说还是必 要的。因为程序用户对程序退出总是敏感的，而且部分的程序错误也未必会导致程序全部功 能失效。那么通过定义 NDEBUG 宏发布程序就可以尽量避免程序退出的状况。而当程序有 问题时，通过没有定义宏 NDEBUG 的版本，程序员则可以比较容易地找到出问题的位置。）\n\n如果希望在预处理时确定某些情况一定不会发生，也可以使用#if进行判断，使用#error终止编译流程并给出错误提示。\n\nC++11引入static_assert来补充编译时断言。之前Boost库也实现了类似的功能，它是利用编译器在编译时会检查除以0这个特性，如果条件为假就构建一个除以0的语句迫使编译器报错来实现的，虽然可以达成编译时检查的目的，但报错信息比较不明确。使用C++11的static_assert，在断言失败时，可以得到明确的错误提示。\n\n### 2.6 noexcept修饰符与noexcept操作符\n\n#### 2.6.1 作为修饰符\n\nnoexcept作为修饰符可以用来表明函数是否会抛出异常，noexcept修饰符后面可以跟随一个常量表达式，当常量表达式可以转为true时表示不会抛出异常，false则表示会抛出异常。被noexcept修饰符标记为不会抛出异常的函数如果运行时抛出异常，会直接导致程序调用std::terminate终止执行，异常不会继续沿栈传播。\n\n#### 2.6.2 作为操作符\n\nnoexcept作为操作符可以用来判断某个表达式是否会抛出异常。该操作符帮助我们在进行泛型编程时通过noexcept操作符判断一个依赖模板参数的表达式是否会抛出异常。\n\n```cpp\ntemplate <class T>\nvoid fun() noexcept(noexcept(T())) {}\n```\n\n#### 2.6.3 替代废弃的throw\n\nC++98曾经定义了throw修饰符，用来表明表达式是否会抛出异常，一个空的throw()就和noexcept(true)表达的意思一样，但throw要求明确指出会抛出哪些类型的异常，实际编程中大家很少需要了解异常类型，只希望了解是否会抛出异常，因此新的noexcept(false)用于替代throw(<异常类型>)。\n\n### 2.7 快速初始化成员变量\n\nC++98中，允许直接在类的静态常量整型成员声明时使用“=”对其初始化，这种声明+初始化的做法被叫做“就地”声明。这种声明方式很便捷，但仅能对【静态】【常量】【整型】成员进行这样的声明，使用场景很少，语法也不一致。\n\nC++11中允许对非静态成员进行就地的初始化，不再必须在构造函数中通过initializer-list进行初始化了。可以使用等号或者一对花括号{}进行就地初始化，其他形式无法通过编译。\n\n在成员同时使用就地初始化，并且在构造函数的初始化列表中进行初始化时，最终仅会以初始化列表为准对其进行初始化。\n\n### 2.8 非静态成员的sizeof\n\nC++98中，sizeof可以作用于类的静态成员，但对于非静态成员，必须通过一个类实例来引用，因此之前为了获取一个非静态成员的大小，同时避免创建无用的类实例，通常会使用下面的技巧：\n\n> sizeof(((People*)0)->hand);\n\nC++11后，sizeof可以直接作用于类成员表达式了，上面的技巧可以简化成：\n\n> sizeof(People::hand)\n\n### 2.9 扩展的friend语法\n\n在C++98，如果要指定另一个类是当前类的友元，必须要使用friend class/struct <友元类>这样的写法，并且无法使用模板参数作为友元类，C++11允许省略class，而且可以使用模板参数作为友元类。\n\nhttps://zh.cppreference.com/w/cpp/language/friend\n\n### 2.10 final/override\n\nfinal用于在继承关系的中间终止一个虚函数被子类重载的可能性。override用于显式声明某个函数是父类虚函数的重载，提升了代码可读性和健壮性（因为virtual修饰符只有在顶级父类声明虚函数时才是必须的，子类为同名虚函数添加virtual修饰符会被忽略，而override修饰符会被编=‘译器检查以确保函数的确重载了虚函数）。它们都在函数声明的参数列表之后。\n\n为了尽可能兼容已有程序，C++11没有将final和override规定为关键字，因此可以在代码中使用final，override变量，但最好别这么做。\n\n### 2.11 模板函数的默认模板参数\n\nC++98允许为类模板参数指定默认参数，但却禁止为函数模板参数指定默认参数，语法上不一致，逻辑上不合理。\n\nC++11放宽了这一限制，可以为函数模板指定默认模板参数了。\n\n### 2.12 外部模板\n\nC++中，如果多个源文件都使用了同一个模板，会对该模板进行多次实例化，但最后编译时，编译器会仅保留一份模板实例化产生的代码。在一些比较大的项目中，冗余的模板实例化会明显拖慢编译速度，可以使用“外部模板”技术告诉编译器不需要对模板进行实例化，在某一个源文件中仅进行一次显式实例化。\n\n> template void fun<int>(int); // 显示地实例化\n>\n> extern template void fun<int>(int); // 外部模板的声明\n\n### 2.13 局部和匿名类型作为模板实参\n\nC++98禁止局部或者匿名的类型作为模板参数，这个限制没什么道理，因此C++11放宽了该限制。\n\n```cpp\n// C++98中，只有A或者a可以作为模板参数\nstruct A {int a;} a;\n// 匿名类型\ntypedef struct {int a;} B;\n// 匿名类型变量\nstruct {int a;} b;\n\nvoid test() {\n    // 局部类型\n    struct C {int a;} c;\n}\n```\n\n## 3. 通用为本，专用为末\n\n### 3.1 继承构造函数\n\n继承关系中，子类可以自动或得父类的成员和接口，但构造函数无法自动地被子类继承。因为通常子类也有自己的成员，我们要定义子类自己的构造函数，在子类构造函数中去调用父类构造函数以及初始化自己的成员。\n\n但是，如果子类中没有任何成员，或者其成员都用C++11的新特性“快速初始化成员变量”进行了初始化乃至于没有必要再用构造函数初始化了，那这时候我们很可能希望直接将父类的构造函数继承到子类，毕竟这时候只需要初始化父类成员。C++11允许我们使用using <父类名>::<父类名>来将所有父类构造函数引入子类，被using引入的父类构造函数是隐式声明的（也就是说，只有用到的函数才会被生成，以节省生成的代码）。\n\n（书中这一节很多描述都和XCode实验现象对不上，很可能是因为成书时还无实验环境，导致描述有误）\n\n### 3.2 委派构造函数\n\n可以在构造函数的initializer-list中调用另一个构造函数来完成构造，这种将构造委托给另一个构造函数的行为   就叫委派构造函数。\n\n一旦在initializer-list中进行了委派构造，就不能再用正常的initializer-list初始化成员变量了。因此，通常被委派的构造函数会负责初始化类的所有成员变量。\n\n### 3.3 右值引用\n\n可以使用两个引用符号 && 来声明并定义一个右值引用。和左值引用一样，右值引用的声明和定义必须在一块。\n\n在C++98中，已经对右值有了一些描述，C++11对右值进行了更进一步的定义：右值就是将亡值。\n\n**C++98中，可以使用常量左值引用来引用右值**，比如：\n\n> const MyCls &myRef = getTemp();\n\n这样的常量左值引用的确引用了getTemp返回的临时变量，延长了它的声明周期，但由于C++98对于右值的定义是“不可被改变的常量”，因此之前只能使用对const的引用来引用右值。\n\nC++11改变了对右值的定义，因此使用C++11的右值引用方式引用的右值，其内容可以被修改。\n\n### 3.4 移动语意\n\n在C++中，如果自定义类中含有指针，通常需要自定义拷贝构造函数和赋值运算符，在对指针进行赋值时，要为指针开辟新的堆内存，并将原指针内容拷贝过来，不要使用编译器生成的默认函数。因为默认函数在赋值时通通采用浅拷贝，会导致两个对象的指针指向同一地址，几乎一定会导致野指针问题。\n\n但是，有时候我们拷贝或赋值时，比如a = b，其中b如果是一个右值，那么直接将b的指针赋值给a，并且阻止b对象在析构函数被调用时释放指针内存，是更合适的做法。因此如果b是一个右值，这意味着b马上就要被析构了，与其为a的指针开辟一片内存，不如直接利用b的指针现在使用的内存。**这种做法就被称作“移动”b的资源到a，也就是“移动语意”。**\n\nC++11中可以通过声明移动构造函数/赋值函数实现移动语意，这样的函数和普通函数的区别在于它们接受的参数类型是右值引用，因此当这样的函数被调用时，可以确保被引用的值马上就要被销毁，可以直接移动其资源。\n\n移动构造函数应该是不会抛出异常的，因为如果移动到一半被终止了，会导致对象的一部分指针成员变成悬挂指针。标准库提供了move_if_noexcept函数，它会判断对象是否实现了noexcept的移动构造函数，如果实现了才返回右值引用，不然就返回左值引用，避免使用移动语意，退化为使用普通的拷贝。\n\n### 3.5 完美转发\n\n#### 3.5.1 右值引用的问题\n\n有了右值引用，看起来我们可以完美地实现移动语意了，但是，需要留意的是，我们在将右值赋给一个右值引用后，这个右值引用其实会被当成一个左值引用（毕竟移动语意本身就要求对右值引用进行修改）！类似的，右值引用的成员也是一个左值。\n\n因此，在访问右值引用，或者在访问右值引用的成员时，必须将其转换成右值引用，否则就会被当成普通的左值引用。\n\n```cpp\n// 像这样的声明赋值没有意义，实际上，a依然会成为一个左值引用\n// A &&a = getTemp();\nA &a = getTemp();\nacceptRValueRef(std::move(a));  // OK，这里使用move把一个被当作左值引用的右值引用转成右值引用\naccestRValueRef(std::forward<A>(a));    // OK，forward也能起到转为右值引用的作用\n```\n\n这个现象要求我们在创建移动构造函数时，必须要使用标准库<utility>中提供的std::move对右值引用的每一个成员转为右值引用，来保证移动语意。std::move会将其参数转化为一个右值引用。之所以可以进行这样的转换，是因为我们已经知道了拥有成员的对象是一个右值引用，既然成员对象的拥有者本身马上就要被销毁，那么成员对象也一定马上就会被销毁，此时将成员对象转为左值处理才是正确的。\n\n在将右值引用传入参数为右值引用的函数时，编译器会报错，因为右值引用实际上一旦被赋给引用变量，就会被当成左值引用。要让编译器重新将其重新当成一个右值引用，必须使用std::move，std::forward将其转成右值引用。\n\n#### 3.5.2 引用折叠\n\n为了在模板编程时，让模板能够同时处理左值和右值引用，C++11引入了引用折叠的规则：\n\n```cpp\nusing MyClsLRef = MyCls&;\nusing MyClsRRef = MyCls&&;\n\n// C++11中被引用折叠规则理解为左值引用\nMyClsLRef&& lRef = getMyCls();\n// 下面两行是一样的，其中第一行在C++11中被引用折叠规则理解为右值引用\nMyClsRRef&& rRef = getMyCls();\nMyClsRRef rRef = getMyCls();\n\n// 利用引用折叠规则，可以在模板编写中将参数声明为左值引用类型，这样的模板函数实际上可以同时接收\n// 左值引用和右值引用\ntemplate <typename T>\nvoid test(T&& t) { ... }\n// 当T是一个右值引用时，T&&&&被折叠成右值引用\n// 当T是一个左值引用时，T&&&被折叠成左值引用\n// 不用考虑T不是一个引用，会有这样的考虑说明对C++不够熟悉，函数参数被声明为引用，传进来的肯定是引用\n```\n\n除了std::move，标准库还提供了std::forward，它的作用其实和std::move有重叠，都可以用来将变量转换为右值引用的。只不过它被规定应该专门用于“转发”场景，并且在调用时必须指定模板参数，从而可以利用引用折叠规则，将参数的左右值引用保留下来：\n\n```cpp\nA getTemp() {\n    return A();\n}\n\n// 转发函数\nvoid forwardToTest(A&& a) {\n    // do something\n//    test(a);  无法通过编译，因为一旦右值引用被赋给变量，这个变量就表现成了左值引用\n    test(std::forward<A&&>(a));\n}\n\n// 转发函数\ntemplate<typename T>\nvoid forwardToTestTemplate(T&& a) {\n//    test(a);  同样无法通过编译\n    test(std::forward<T>(a));\n}\n\ntemplate<typename T>\nvoid test(T&& a) {\n    \n}\n          \n\nint main() {\n    forwardToTest(getTemp());\n    forwardToTestTemplate(getTemp());\n    A a;\n//    forwardToTest(a); 无法通过编译，因为a不是右值引用\n    forwardToTestTemplate(a);   // 可以通过编译，因为模板方法有引用折叠规则\n}\n```\n\n### 3.6 move和forward的区别\n\n- move调用时不需要提供模板参数，它仅被用于将参数强制转为右值引用；\n- forward调用时必须要提供模板参数，通常会提供这样的模板参数：forward<T&&>，这样的好处是T如果被声明为左值，转换后还是左值，T如果被声明为右值，转换后还是右值。\n\n### 3.7 explicit 显示转换操作符\n\n默认情况下，C++编译器会在函数调用的参数和函数声明不匹配时，想方设法地将参数转为匹配的类型，让函数调用能够通过，这中间会检查：\n\n- 实参的类型转换运算符，如果有转换为目标类型的转换运算符就调用；\n- 目标类型的构造函数，看是否有接收实参类型的构造函数，如果有就调用；\n\n有时这很方便，但更多场景下这样的行为只会导致语意上的混乱。为了避免编译器的隐式转换，可以使用explicit修饰类型转换运算符或构造函数，这样编译器就不会尝试使用对应函数进行转换。\n\n### 3.8 initializer_list 初始化列表\n\n#### 3.8.1 如何使用初始化列表\n\nC++98中，仅允许使用initializer-list初始化数组，C++11扩展了initializer-list的概念，使得普通类型也可以使用initializer-list初始化（不要把它和类的成员初始化搞混，它们的确都叫initializer-list，要区分时，可以将类的成员初始化叫做member initializer list）：\n\n```cpp\nint a[]={1,3,5};//C++98通过，C++11通过\nint b[]{2,4,6};//C++98失败，C++11通过\nvector<int> c{1,3,5};//C++98失败，C++11通过\nmap<int,float> d = {{1,1.0f},{2,2.0f},{5,3.2f}};//C++98失败，C++11通过\n```\n\n如果要让自定义的类支持这种初始化方式，只要声明一个接收在<initializer_list>中定义的initializer_list类型的构造函数就可以了。该类型是一个Iterable类型，可以使用begin, end等标准遍历方法。\n\n### 3.8.2 防止类型收窄\n\n使用初始化列表还可以促使编译器检查类型收窄的情况。初始化列表是目前唯一一种检查类型收窄的方式（不过事实上现在的大多数编译器在没有使用初始化列表时也会检查类型收窄并给出警告，但使用初始化列表编译器会直接给出错误）。\n\n### 3.9 POD类型\n\nPOD，也就是Plain Ordinary Data，纯数据类型。\n\nC++11对POD的定义是：平凡的，且是标准布局的。定义上，比C++98更宽容了，C++98只规定了C风格的struct是POD，但从POD的定义上，只要类对象布局是标准的，这样的类应该都是POD类。\n\n（但是，对POD定义得更宽容似乎并没有什么意义？C++11更多的是对于哪些情况会导致对象布局变化进行了更进一步的明确，只有不导致对象布局变化的类定义才是POD类。）\n\n### 3.10 union 非受限联合体\n\nC++11将C++98对union的一些限制移除了。\n\n- 在C++98，union中只能包含基础类型和POD类型，并且不能包含静态方法，但在C++11中，union中可以包含任意非引用类型。\n- C++11中，如果union任何一个成员拥有非平凡的构造函数，那么编译器就不会为union生成默认构造函数。\n- C++11中，允许在类定义使用union声明成员变量，用这种方式声明的union不需要有类型名称，被称为匿名的非受限联合体，此时联合体内的所有成员都会自动的成为类的“变长成员”，即实际上它们共享同一处内存，应该只使用它们中的某一个。\n\n### 3.11 用户定义字面量\n\n#### 3.11.1 字面量操作符\n\n- 接收字符串：<用户类型> operator \"\" _<后缀字符>(const char* col, size_t size)\n- 接收整数：<用户类型> operator \"\" _<后缀字符>(unsigned long long val)\n- 接收整数，但整数越界，此时会传入'\\0'结尾的char*：<用户类型> operator \"\" _<后缀字符>(const char*)\n- 接收浮点：<用户类型> operator \"\" _<后缀字符>(long double val)\n- 接收字符：<用户类型> operator \"\" _<后缀字符>(char val)\n\n### 3.12 内联名字空间\n\nC++11规定可以在namespace前加上inline，将名字空间默认导出到声明名字空间的作用域。\n\n这样的行为和C++98就有的匿名名字空间非常类似，除了内联名字空间有自己的名字以外。不过，它们被创建出来的目的是不同的：\n\n- 匿名名字空间在C++98中用于替代static修饰符，因为C++为类引入了static成员后，static的语意变得非常模糊且矛盾，因此在原本使用static声明文件作用域的变量的地方，可以改成使用匿名名字空间来包围这些变量起到同样的效果；\n- 内联名字空间则是被标准库用于和宏配合使用，根据当前编译环境决定默认导出同一个功能的哪一个版本的实现，这样做的好处是不关心具体实现的用户可以直接使用默认导出的功能，而了解更全面的细节的用户也可以使用名字空间来指定使用的是哪一个版本的功能。\n\n### 3.13 使用using声明模板别名\n\n在C++11中，已经可以使用using完全替代typedef了。\n\nusing不仅有更清晰的语意，还可以部分声明模板参数：\n\n```cpp\ntemplate <typename T> using StringObjectMap = std::map<string, T>;\nStringObjectMap<MyCls> myMap;\n```\n\n### 3.14 SFINAE规则\n\nSFINAE，就是Substitution Failure Is Not An Error。\n\n指的是，编译器在尝试模板参数匹配时，只要能够最终找到合适的匹配，中间尝试过的任何匹配失败都不会报错。\n\n只不过，C++98对于模板参数中使用表达式的情况支持的不友好，C++11明确了任何在编译期合法的表达式都能够作为模板参数，比如下面的这个例子就在C++98中无法通过编译，而在C++11中可以：\n\n```cpp\ntemplate<int I> struct A{};\nchar xxx(int);\nchar xxx(float);\ntemplate <class T> A<sizeof(xxx((T)0))> f(T){}\n```\n\n## 4. 新手易学，老兵易用\n\n### 4.1 右尖括号的改进\n\nC++98曾经规定应该把 >> 优先判定为右移操作符，但这个规定在C++11被取消了，C++11规定编译器可以自行智能地判断>>是否是右移操作符。\n\n### 4.2 auto类型推导\n\n在C++98中，auto其实是用于声明一个变量具有“自动存储期”，但实际上除了static以外的变量都是默认具有自动存储期的，因此过去的auto几乎没有人使用。\n\nC++11中，auto被赋予了新的含义，以前的auto含义被取消了。auto成为了新的类型指示符，auto声明的变量的类型必须在编译期由编译器推导出来。\n\n### 4.3 decltype\n\ndecltype是在编译时对表达式进行类型推导，推导出的类型可用于定义新的变量。decltype主要是为了解决泛型编程中由于泛型参数类型不确定，导致和泛型参数相关的表达式类型无法确定的问题的。比如：\n\nt1是泛型Type1类型，t2是泛型Type2类型，由于开发泛型代码时无法确定Type1和Type2的类型，自然无法确定t1 + t2的类型，但该类型其实是可以由编译器推导出来的，decltype如今即可用在此处：\n\nauto add(t1, t2) -> decltype(t1 + t2) {return t1 + t2;}\n\n或者可以声明原本无法声明的变量：decltype(t1 + t2) addResult = t1 + t2;（当然，auto也可以完成此工作）。\n\n有时会将decltype和auto搭配使用：decltype(auto)。这是因为一方面，我们希望依赖C++11的类型推导能力（auto的作用），但另一方面，又想保留cv限定符和引用（decltype的作用）（auto的类型推导规则和模板类似，如果不把auto声明为auto&或者auto*，auto就会被视为不具备cv限定符的值类型，如果auto被声明为auto&或者auto*，auto推导出的类型才会保留cv限定符）。但是使用这样的写法时要小心：decltype在推导类型时，如果表达式是一个简单的名字，它会推导出名字的类型，但如果表达式不只是一个名字，比如decltype((x))，那么即使x只是一个int，该decltype也会推导出引用类型：int&。\n\n### 4.4 追踪返回类型\n\nauto func(char* a,int b) -> int;\n\n### 4.5 基于范围的for循环\n\n自定义集合类型要想支持这样的for循环，需要实现begin, end, ++, ==四个函数。\n\n## 5. 提高类型安全\n\n### 5.1 强类型枚举\n\nC++98: enum X {...};\n\nC++11: enum class X {...};\n\n### 5.2 堆内存管理：智能指针与垃圾回收\n\n## 6. 提高性能及操作硬件的能力\n\n### 6.1 常量表达式\n\nC++11规定使用constexpr修饰符来修饰常量表达式。常量表达式可以是函数或者值。常量表达式函数中不可以出现非常量表达式。常量表达式可以在编译期使用，但如果常量表达式并没有一定要在编译期被计算出来，标准规定编译器在这种情况下可以将常量表达式编译成普通的表达式，表达式会在运行时被计算。\n\n### 6.2 变长模板\n\n过去，C++可以使用C风格的方法来实现可变参函数，但这种实现方式是类型不安全的。\n\n现在，C++11为可变参函数提出了更合理（类型安全）的解决方案：变长模板。可以使用变长模板来声明变长模板函数或者变长模板类。\n\n### 6.3 模板参数包与递归\n\n使用template <typename... Elements>这种方式可以声明一个变长模板参数，使用Elements...这种方式可以将变长模板参数展开成实际的多个参数类型；\n\n不定长的变长模板类可以通过模板类的递归来解包：\n\n```cpp\ntemplate <typename... Elements> class tuple;    // 变长模板声明\n// 以下是两个模板偏特化定义，利用模板偏特化会被优先匹配的规则，让变长模板参数递归地被解包\n// 对于类型，可以使用递归的继承\ntemplate <typename Head, typename... Tail> \nclass tuple <Head, Tail...> : private tuple<Tail...> {\n    Head head;\n}\ntemplate <> class tuple {};\n\n// 对于函数，可以使用递归的函数调用\n// 下面实现一个更强大的Printf，不论%后面跟的是什么符号，这个Printf总是会打印正确的类型\nvoid Printf(const char* s) {\n    while (*s) {\n        if (*s == '%' && ++s != '%') {\n               throw runtime_error(\"invalide format\");\n        }\n        cout *s++;\n    }\n}\n\ntemplate <typename T, typename... Args>\nvoid Printf(char* s, T value, Args... args) {\n    while(*s) {\n        if (*s == '%' && *s++ != '%') {\n            cout << value;\n            return Printf(++s, args...);\n        }\n        cout << *s++;\n    }\n    // 若百分号的数量和参数数量对不上，就抛异常\n    throw runtime_error(\"extra arguments provided\");\n}\n```\n\n## 7. 进阶\n\n### 7.1 引用类型\n\n定义了模板参数包后，还可以在展开模板参数包时使用引用标记：Args&&...，这样的写法是合法的；\n\n### 7.2 特殊展开\n\n解包时，有些非常特殊的规则，需要特别说明一下：\n\n```cpp\ntemplate <typename... Args> class MyCls: private A<Args>... {};\n// 上面的表达式在解包时会解包成多继承：\nT<Parent1, Parent2>  t; // t的类型是：class MyCls: private A<Parent1>, A<Parent2>\n\ntemplate <typename Args...> class MyCls: private A<Args...> {};\n// 而这个表达式在解包时，会在泛型参数表达式中直接展开\nT<Parent1, Parent2>  t; // t的类型是：class MyCls: private A<Parent1, Parent2>\n\ntemplate <typename Args...> void test(Args... args) {\n    // 下面这个会被展开成call(a(arg1), a(arg2), ...)\n    call(a(args)...);\n    // 而下面这个会被展开成call(a(arg1, arg2, ...))\n    call(a(args...));\n}\n```\n\n### 7.3 获取变长参数包长度\n\n可以使用sizeof...获取模板参数包的长度；\n\n### 7.4 模板的模板（的模板的模板...）\n\n变长参数的模板类型本身也可以是一个模板，这一点和以前的非变长模板参数一样。\n\n### 7.5 原子类型和原子操作\n\nC++11以前，已经有很多使用多线程能力的C++程序了，但之前语言本身并没有定义任何同多线程有关的内容，这些多线程能力来自于多线程接口pthread。pthread是一套C的接口。\n\n通常情况下，如果我们不需要太精细的互斥控制，可以直接使用posix提供的mutex互斥锁API，而如果想达到更优化的性能，可能会考虑为不同处理器编写内敛汇编代码。\n\nC++11标准为多线程程序在标准库中添加了原子类型，并允许指定原子类型的内存访问顺序一致性，让开发者可以不必操心操作系统和处理器的底层细节，也可以获得最优化的性能。\n\n### 7.6 线程局部存储\n\nC++11定义了thread_local关键字来定义线程局部存储变量，这样的变量生命期是线程启动到线程结束，除了本线程外，没有其他线程可以访问到这样的变量。\n\nC++11仅规定了线程局部存储的行为，而没有规定其具体实现，不同的编译器在不同的环境中可能会有不同的实现方式。\n\n### 7.7 快速退出：quick_exit, at_quick_exit\n\n在过去，大体上有三种退出程序的方式：terminate(), abort(), exit()。\n\n- terminate是有未处理的异常时会被调用的方法，可以使用set_terminate方法更改默认行为，terminate默认调用abort；\n- abort是进程不得不终止时，被调用的函数，它会向本进程发送一个SIGABRT信号，该信号默认会导致操作系统直接释放该进程的所有资源并终止进程；\n- exit是进程自发调用的退出函数，它代表着进程运行到了某个节点，该退出了，它会导致每一个自动变量的析构函数被调用（是的，仅自动变量，也就是栈变量会被调用析构函数，至于单例什么的需要自己处理），并调用at_exit注册的函数，然后才会回收进程；\n\nC++11新增了quick_exit标准方法，该方法语意上和exit一样，都是程序自发终止，但和exit不同的是，它不会进行本进程的清理工作，在多线程环境下也不会先等待线程结束，而是直接让操作系统终止进程并回收资源。\n\n## 8. 为改变思想方式而改变\n\n### 8.1 指针空值-nullptr\n\nC++11定义了nullptr_t和nullptr，前者是类型，后者是该类型的值。\n\nnullptr可以隐式转换为任何指针，但无法被隐式转换为bool类型，无法使用if (nullptr)这样的表达式；此外它所属的nullptr_t是一个基础类型，nullptr无法被推导为T*这样的模板参数。\n\n### 8.2 默认函数的控制\n\nC++11规定可以使用 = default 来使编译器生成默认版本的成员函数，可以由编译器生成的函数包括：\n\n- 空构造函数\n- 拷贝构造函数\n- 拷贝赋值函数\n- 移动构造函数\n- 移动拷贝函数\n- 析构函数\n\n此外，编译器还为所有自定义类型提供以下全局默认操作符函数：\n\n- operator, \n- operator&\n- operator&&\n- operator*\n- operator->\n- operator->*\n- operator new\n- operator delete\n\n### 8.3 lambda函数\n\nlambda语法：\n\n[<捕获外部变量>]<(可选)mutable>(<(可选)参数列表>) -> <(可选)返回值> {<函数体>}\n\n- 捕获外部变量：变量需要用&或者=开头来引用，直接写&或者=后面不跟变量表示捕获所有外部变量，=表示按值捕获，&表示引用捕获；\n- mutable：labmda默认是内联的const函数，不可以修改任何捕获的外部的按值捕获的变量（因为目前lambda的语意其实和仿函数完全一致，在仿函数中，所有捕获的外部变量都是仿函数类的成员，因此const函数不可以修改类成员，到lambda这里变成了lambda不可以修改捕获变量），但是引用捕获的变量则可以修改（这个行为也是和仿函数一致的，const函数内可以调用任意成员引用的方法，修改其属性，因为将引用声明成const，和将指针声明成const类似，都仅仅是禁止修改引用本身，但并没有限制对引用或者指针指向的变量进行修改）。如果希望lambda不是一个const函数，就要添加mutable声明；\n- 参数列表：\n- 返回值：当能够从函数体中推测出明确的返回值类型时，可以忽略；\n- 函数体：\n\n## 9. 融入实际应用\n\n### 9.1 对齐支持\n\nC和C++都是具备直接操作底层硬件能力的语言，因此某些开发者会对数据结构的对齐方式特别关注。\n\nC++11规定了alignof和alignas关键字，前者可以查询某个类型的对齐方式（一般来说都是32位-4字节或者64位-8字节对齐），而后者可以规定某个自定义类的对齐方式。比如如果我们想要使用内联汇编的向量指令（可以同时处理4组处理器位数的数据）来优化处理速度，就可能想要将数据对齐到4*处理器位数的位置处。\n\n需要注意的是，之前很多编译器也规定了指定数据对齐方式的方式，比如GNU就规定可以使用如下方式规定对齐字节：__attribute__((__aligned__(8)))；\n\n需要注意的是，虽然标准规定了指定对齐的方式，但每个平台具体支持对齐到多少是不确定的。如果使用alignas(2^64)，那显然是不合法的。不幸的是，目前标准似乎没办法查询每个平台支持的最大对齐字节。不过一般来说我们也用不到太大的对齐字节。\n\n### 9.2 通用属性\n\n有时C/C++提供的语言能力无法完全满足开发者的需求，编译器厂商为了解决这些问题，提供了一系列的语言扩展来扩展C/C++的语法。这其中最常见的就是“属性”，可以告诉编译器一个符号的额外信息，让编译器做一些语言规范之外的处理。\n\n- GNU使用__attribute__((<属性列表>))来声明属性；\n- Windows使用__declspec(<属性列表>)来声明属性\n\nC++11也规定了类似的属性，之所以在语言中添加属性，是为了避免再给C++增加更多的关键字。C++11的属性和之前各个平台的编译器实现的属性的目的是一致的，它们提供的能力都是一般用不到，可以忽略的能力，语言规范不会考虑使用关键字来实现这些能力，因此将它们定义到通用属性里。C++规定通用属性的写法是：[[<属性列表>]]，这样的通用属性可以用来修饰任何语言元素。不过目前C++11只定义了两个通用属性：[[noreturn]]和[[carries_dependency]]。\n\n### 9.3 Unicode支持\n\n#### 9.3.1 字符集和编码\n\nASCII码是最早的编码，使用7位二进制位来表示所有英文字母和在英文排版印刷中用到的字符，后来ISO和Unicode组织共同制定了一套能够唯一的表示世界上所有字符的标准字符集，称为ISO/Unicode字符集或者Unicode字符集。Unicode规定了每个字符在整个字符集中的具体值（范围0x0-0x10FFFFF），但并没有规定计算机中如何存储这样的值，UTF-8 UTF-16 UTF-32是Unicode字符集事实上的编码标准。\n\nUTF-8使用1～6字节的变长编码方式来编码Unicode，由于UTF-8较为节约存储空间，因此使用的比较广泛。\n\n{% asset_img 1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png %}\n\n![屏幕快照 2019-08-18 上午12.57.01.png](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C++11/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png)\n\nGB2312早于Unicode被定义，是和Unicode不同的一种编码（不过Unicode汉字部分编码其实就是GB2312的变种），采用2字节表示一个中文字符，和Unicode不一样的是，GB2312既是字符集，又是字符编码。\n\n#### 9.3.2 C++中的Unicode支持\n\nC++98已经规定了wchar_t类型，但是C++98对wchar_t的定义不够明确，不同的编译器中wchar_t的位数不一致，导致移植性问题。\n\nC++11重新规定了char16_t char32_t，用于存储UTF-16 UTF-32编码的Unicode数据，UTF-8的数据则直接使用char来存储。C++中可以在字符串常量前加前缀来让编译器产生不同编码的数据：\n\n- u8 - UTF8\n- u - UTF-16\n- U - UTF-32\n- L - wchar_t\n\n之所以没有为UTF-8规定类型，是因为UTF-16和UTF-32都是定长编码，而UTF-8是变长编码（有误，过去某段时间Unicode还比较少，当时UTF16编码Unicode的确是事实上的定长编码，但现在Unicode字符集已经收录了更多字符，早已超出了UTF-16的表示范围，UTF-16已经成为了事实上的变长编码，一些历史程序如果还假定UTF-16是定长编码的话，遇到超出UTF-16表示范围的字符时就会出问题。），变长编码会导致很多算法变得极其复杂（比如无法确定一个utf_8[]中的第N个字符究竟被存储在数组中的哪个位置）。对于语言来说，定长编码处理起来更自然，且增加的内存占用和减少的程序设计复杂度也大体可以认为相互抵消，可以使用定长编码进行处理，需要保存时再存成变长编码以节省存储空间。\n\nC++中，影响Unicode字符能够正确保存和输出的因素有以下三点：\n\n- 文件编码\n- 编译器编码设置\n- 输出设备\n\n为了确保得到正确的输出，需要确保源文件的编码同系统编码一致、并且用于输出的设备支持被输出的编码（比如不少shell就只支持UTF-8编码，非UTF-8编码的会直接输出十六进制的编码值）。\n\n#### 9.3.3 标准库支持\n\nC++11新增了几个字符类型，也同步地在标准库中新增了字符类型的转换函数。","source":"_posts/cplus_md/CPlus Basic/深入理解C++11.md","raw":"---\ntitle: 深入理解C++11\ndate: '2020/12/31 23:59'\ntags:\n - baisc\ncategories:\n - 使用教程\nabbrlink: 13007\ncover: img/cpp.png\n---\n# **深入理解C++11**\n\n## 1. 前言\n\n### 1.1 说到C++11，应该想到什么？\n\n- 什么是 lambda，及怎么样使用它是最好的？\n- decltype 和 auto 类型推导有什么关系？\n- 什么是移动语义，以及(右值引用)是如何解决转发问题的？\n- default/deleted 函数以及 override 是怎么回事?\n- 异常描述符被什么替代了? noexcept 是如何工作的?\n- 什么是原子类型以及新的内存模型?\n- 如何在 C++11 中做并行编程?\n\n### 1.2 语言的哪些关键字和C++11有关？\n\n- alignas\n- alignof decltype\n- auto(重新定义)\n- static_assert\n- using(重新定义)\n- noexcept\n- export(弃用，不过未来可能留作他用)\n- nullptr\n- constexpr\n- thread_local\n\n## 2. 保证稳定性和兼容性\n\n### 2.1 将C99标准纳入C++11\n\n#### 2.1.1 确定编译环境的预定义宏\n\n- __STDC_HOSTED__：编译器的目标系统环境中是否包含完整的C库\n- __STDC__：编译器对于标准C库的实现是否和C标准一致（是否定义、如何定义由编译器决定）\n-  __STDC_VERSION__：编译器支持的C标准的版本（是否定义、如何定义由编译器决定）\n- __STDC_ISO_10646__：yyyymmL格式的整数常量，表示C++编译环境符合某个版本的ISO/IEC 10646标准\n\n#### 2.1.2 __func__ 预定义标识符\n\n函数中可以使用__func__标识符函数名称，编译器会在函数定义开始时隐式地插入__func__标识符定义：\n\n> static const char* __func__ = \"<函数名称>\";\n\n#### 2.1.3 _Pragma 操作符\n\n在之前的C/C++标准中已经规定了可以使用#pragma预处理指令向编译器传递信息，比如可以通过在头文件首行放置#pragma once来告诉编译器这个头文件只应该被include一次。\n\nC++11中，规定了一个新的操作符_Pragma，它的作用与#pragma完全相同，_Pragma(\"once\")就相当于#pragma once。但是，_Pragma由于是一个操作符而不是预处理指令，它的使用更为灵活，可以在宏中展开。\n\n#### 2.1.4 不定参数宏定义以及 __VA_ARGS__\n\nC99规定宏定义中，在参数列表的最后，可以使用...省略参数定义，而__VA_ARGS__可以用来替换被省略号代表的字符串。\n\n#### 2.1.5 宽窄字符串连接\n\n### 2.2 long long整形\n\n### 2.3 扩展的整形\n\n### 2.4 宏__cplusplus\n\n一般会和extern \"C\"配合使用，来让一个头文件即可以同时被include到C和C++中编译，使用extern \"C\"避免C++对符号名称进行重整，确保C++编译器编译出的目标文件中的符号名维持原样。\n\n```cpp\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n// 一些代码\n#ifdef __cplusplus \n}\n#endif\n```\n\n### 2.5 静态断言\n\n标准C库assert.h中，提供了assert函数来进行运行时的断言，表明某些情况一定不会发生。（在 C++ 中，程序员也可以定义宏 NDEBUG 来禁用 assert 宏。这对发布程序来说还是必 要的。因为程序用户对程序退出总是敏感的，而且部分的程序错误也未必会导致程序全部功 能失效。那么通过定义 NDEBUG 宏发布程序就可以尽量避免程序退出的状况。而当程序有 问题时，通过没有定义宏 NDEBUG 的版本，程序员则可以比较容易地找到出问题的位置。）\n\n如果希望在预处理时确定某些情况一定不会发生，也可以使用#if进行判断，使用#error终止编译流程并给出错误提示。\n\nC++11引入static_assert来补充编译时断言。之前Boost库也实现了类似的功能，它是利用编译器在编译时会检查除以0这个特性，如果条件为假就构建一个除以0的语句迫使编译器报错来实现的，虽然可以达成编译时检查的目的，但报错信息比较不明确。使用C++11的static_assert，在断言失败时，可以得到明确的错误提示。\n\n### 2.6 noexcept修饰符与noexcept操作符\n\n#### 2.6.1 作为修饰符\n\nnoexcept作为修饰符可以用来表明函数是否会抛出异常，noexcept修饰符后面可以跟随一个常量表达式，当常量表达式可以转为true时表示不会抛出异常，false则表示会抛出异常。被noexcept修饰符标记为不会抛出异常的函数如果运行时抛出异常，会直接导致程序调用std::terminate终止执行，异常不会继续沿栈传播。\n\n#### 2.6.2 作为操作符\n\nnoexcept作为操作符可以用来判断某个表达式是否会抛出异常。该操作符帮助我们在进行泛型编程时通过noexcept操作符判断一个依赖模板参数的表达式是否会抛出异常。\n\n```cpp\ntemplate <class T>\nvoid fun() noexcept(noexcept(T())) {}\n```\n\n#### 2.6.3 替代废弃的throw\n\nC++98曾经定义了throw修饰符，用来表明表达式是否会抛出异常，一个空的throw()就和noexcept(true)表达的意思一样，但throw要求明确指出会抛出哪些类型的异常，实际编程中大家很少需要了解异常类型，只希望了解是否会抛出异常，因此新的noexcept(false)用于替代throw(<异常类型>)。\n\n### 2.7 快速初始化成员变量\n\nC++98中，允许直接在类的静态常量整型成员声明时使用“=”对其初始化，这种声明+初始化的做法被叫做“就地”声明。这种声明方式很便捷，但仅能对【静态】【常量】【整型】成员进行这样的声明，使用场景很少，语法也不一致。\n\nC++11中允许对非静态成员进行就地的初始化，不再必须在构造函数中通过initializer-list进行初始化了。可以使用等号或者一对花括号{}进行就地初始化，其他形式无法通过编译。\n\n在成员同时使用就地初始化，并且在构造函数的初始化列表中进行初始化时，最终仅会以初始化列表为准对其进行初始化。\n\n### 2.8 非静态成员的sizeof\n\nC++98中，sizeof可以作用于类的静态成员，但对于非静态成员，必须通过一个类实例来引用，因此之前为了获取一个非静态成员的大小，同时避免创建无用的类实例，通常会使用下面的技巧：\n\n> sizeof(((People*)0)->hand);\n\nC++11后，sizeof可以直接作用于类成员表达式了，上面的技巧可以简化成：\n\n> sizeof(People::hand)\n\n### 2.9 扩展的friend语法\n\n在C++98，如果要指定另一个类是当前类的友元，必须要使用friend class/struct <友元类>这样的写法，并且无法使用模板参数作为友元类，C++11允许省略class，而且可以使用模板参数作为友元类。\n\nhttps://zh.cppreference.com/w/cpp/language/friend\n\n### 2.10 final/override\n\nfinal用于在继承关系的中间终止一个虚函数被子类重载的可能性。override用于显式声明某个函数是父类虚函数的重载，提升了代码可读性和健壮性（因为virtual修饰符只有在顶级父类声明虚函数时才是必须的，子类为同名虚函数添加virtual修饰符会被忽略，而override修饰符会被编=‘译器检查以确保函数的确重载了虚函数）。它们都在函数声明的参数列表之后。\n\n为了尽可能兼容已有程序，C++11没有将final和override规定为关键字，因此可以在代码中使用final，override变量，但最好别这么做。\n\n### 2.11 模板函数的默认模板参数\n\nC++98允许为类模板参数指定默认参数，但却禁止为函数模板参数指定默认参数，语法上不一致，逻辑上不合理。\n\nC++11放宽了这一限制，可以为函数模板指定默认模板参数了。\n\n### 2.12 外部模板\n\nC++中，如果多个源文件都使用了同一个模板，会对该模板进行多次实例化，但最后编译时，编译器会仅保留一份模板实例化产生的代码。在一些比较大的项目中，冗余的模板实例化会明显拖慢编译速度，可以使用“外部模板”技术告诉编译器不需要对模板进行实例化，在某一个源文件中仅进行一次显式实例化。\n\n> template void fun<int>(int); // 显示地实例化\n>\n> extern template void fun<int>(int); // 外部模板的声明\n\n### 2.13 局部和匿名类型作为模板实参\n\nC++98禁止局部或者匿名的类型作为模板参数，这个限制没什么道理，因此C++11放宽了该限制。\n\n```cpp\n// C++98中，只有A或者a可以作为模板参数\nstruct A {int a;} a;\n// 匿名类型\ntypedef struct {int a;} B;\n// 匿名类型变量\nstruct {int a;} b;\n\nvoid test() {\n    // 局部类型\n    struct C {int a;} c;\n}\n```\n\n## 3. 通用为本，专用为末\n\n### 3.1 继承构造函数\n\n继承关系中，子类可以自动或得父类的成员和接口，但构造函数无法自动地被子类继承。因为通常子类也有自己的成员，我们要定义子类自己的构造函数，在子类构造函数中去调用父类构造函数以及初始化自己的成员。\n\n但是，如果子类中没有任何成员，或者其成员都用C++11的新特性“快速初始化成员变量”进行了初始化乃至于没有必要再用构造函数初始化了，那这时候我们很可能希望直接将父类的构造函数继承到子类，毕竟这时候只需要初始化父类成员。C++11允许我们使用using <父类名>::<父类名>来将所有父类构造函数引入子类，被using引入的父类构造函数是隐式声明的（也就是说，只有用到的函数才会被生成，以节省生成的代码）。\n\n（书中这一节很多描述都和XCode实验现象对不上，很可能是因为成书时还无实验环境，导致描述有误）\n\n### 3.2 委派构造函数\n\n可以在构造函数的initializer-list中调用另一个构造函数来完成构造，这种将构造委托给另一个构造函数的行为   就叫委派构造函数。\n\n一旦在initializer-list中进行了委派构造，就不能再用正常的initializer-list初始化成员变量了。因此，通常被委派的构造函数会负责初始化类的所有成员变量。\n\n### 3.3 右值引用\n\n可以使用两个引用符号 && 来声明并定义一个右值引用。和左值引用一样，右值引用的声明和定义必须在一块。\n\n在C++98中，已经对右值有了一些描述，C++11对右值进行了更进一步的定义：右值就是将亡值。\n\n**C++98中，可以使用常量左值引用来引用右值**，比如：\n\n> const MyCls &myRef = getTemp();\n\n这样的常量左值引用的确引用了getTemp返回的临时变量，延长了它的声明周期，但由于C++98对于右值的定义是“不可被改变的常量”，因此之前只能使用对const的引用来引用右值。\n\nC++11改变了对右值的定义，因此使用C++11的右值引用方式引用的右值，其内容可以被修改。\n\n### 3.4 移动语意\n\n在C++中，如果自定义类中含有指针，通常需要自定义拷贝构造函数和赋值运算符，在对指针进行赋值时，要为指针开辟新的堆内存，并将原指针内容拷贝过来，不要使用编译器生成的默认函数。因为默认函数在赋值时通通采用浅拷贝，会导致两个对象的指针指向同一地址，几乎一定会导致野指针问题。\n\n但是，有时候我们拷贝或赋值时，比如a = b，其中b如果是一个右值，那么直接将b的指针赋值给a，并且阻止b对象在析构函数被调用时释放指针内存，是更合适的做法。因此如果b是一个右值，这意味着b马上就要被析构了，与其为a的指针开辟一片内存，不如直接利用b的指针现在使用的内存。**这种做法就被称作“移动”b的资源到a，也就是“移动语意”。**\n\nC++11中可以通过声明移动构造函数/赋值函数实现移动语意，这样的函数和普通函数的区别在于它们接受的参数类型是右值引用，因此当这样的函数被调用时，可以确保被引用的值马上就要被销毁，可以直接移动其资源。\n\n移动构造函数应该是不会抛出异常的，因为如果移动到一半被终止了，会导致对象的一部分指针成员变成悬挂指针。标准库提供了move_if_noexcept函数，它会判断对象是否实现了noexcept的移动构造函数，如果实现了才返回右值引用，不然就返回左值引用，避免使用移动语意，退化为使用普通的拷贝。\n\n### 3.5 完美转发\n\n#### 3.5.1 右值引用的问题\n\n有了右值引用，看起来我们可以完美地实现移动语意了，但是，需要留意的是，我们在将右值赋给一个右值引用后，这个右值引用其实会被当成一个左值引用（毕竟移动语意本身就要求对右值引用进行修改）！类似的，右值引用的成员也是一个左值。\n\n因此，在访问右值引用，或者在访问右值引用的成员时，必须将其转换成右值引用，否则就会被当成普通的左值引用。\n\n```cpp\n// 像这样的声明赋值没有意义，实际上，a依然会成为一个左值引用\n// A &&a = getTemp();\nA &a = getTemp();\nacceptRValueRef(std::move(a));  // OK，这里使用move把一个被当作左值引用的右值引用转成右值引用\naccestRValueRef(std::forward<A>(a));    // OK，forward也能起到转为右值引用的作用\n```\n\n这个现象要求我们在创建移动构造函数时，必须要使用标准库<utility>中提供的std::move对右值引用的每一个成员转为右值引用，来保证移动语意。std::move会将其参数转化为一个右值引用。之所以可以进行这样的转换，是因为我们已经知道了拥有成员的对象是一个右值引用，既然成员对象的拥有者本身马上就要被销毁，那么成员对象也一定马上就会被销毁，此时将成员对象转为左值处理才是正确的。\n\n在将右值引用传入参数为右值引用的函数时，编译器会报错，因为右值引用实际上一旦被赋给引用变量，就会被当成左值引用。要让编译器重新将其重新当成一个右值引用，必须使用std::move，std::forward将其转成右值引用。\n\n#### 3.5.2 引用折叠\n\n为了在模板编程时，让模板能够同时处理左值和右值引用，C++11引入了引用折叠的规则：\n\n```cpp\nusing MyClsLRef = MyCls&;\nusing MyClsRRef = MyCls&&;\n\n// C++11中被引用折叠规则理解为左值引用\nMyClsLRef&& lRef = getMyCls();\n// 下面两行是一样的，其中第一行在C++11中被引用折叠规则理解为右值引用\nMyClsRRef&& rRef = getMyCls();\nMyClsRRef rRef = getMyCls();\n\n// 利用引用折叠规则，可以在模板编写中将参数声明为左值引用类型，这样的模板函数实际上可以同时接收\n// 左值引用和右值引用\ntemplate <typename T>\nvoid test(T&& t) { ... }\n// 当T是一个右值引用时，T&&&&被折叠成右值引用\n// 当T是一个左值引用时，T&&&被折叠成左值引用\n// 不用考虑T不是一个引用，会有这样的考虑说明对C++不够熟悉，函数参数被声明为引用，传进来的肯定是引用\n```\n\n除了std::move，标准库还提供了std::forward，它的作用其实和std::move有重叠，都可以用来将变量转换为右值引用的。只不过它被规定应该专门用于“转发”场景，并且在调用时必须指定模板参数，从而可以利用引用折叠规则，将参数的左右值引用保留下来：\n\n```cpp\nA getTemp() {\n    return A();\n}\n\n// 转发函数\nvoid forwardToTest(A&& a) {\n    // do something\n//    test(a);  无法通过编译，因为一旦右值引用被赋给变量，这个变量就表现成了左值引用\n    test(std::forward<A&&>(a));\n}\n\n// 转发函数\ntemplate<typename T>\nvoid forwardToTestTemplate(T&& a) {\n//    test(a);  同样无法通过编译\n    test(std::forward<T>(a));\n}\n\ntemplate<typename T>\nvoid test(T&& a) {\n    \n}\n          \n\nint main() {\n    forwardToTest(getTemp());\n    forwardToTestTemplate(getTemp());\n    A a;\n//    forwardToTest(a); 无法通过编译，因为a不是右值引用\n    forwardToTestTemplate(a);   // 可以通过编译，因为模板方法有引用折叠规则\n}\n```\n\n### 3.6 move和forward的区别\n\n- move调用时不需要提供模板参数，它仅被用于将参数强制转为右值引用；\n- forward调用时必须要提供模板参数，通常会提供这样的模板参数：forward<T&&>，这样的好处是T如果被声明为左值，转换后还是左值，T如果被声明为右值，转换后还是右值。\n\n### 3.7 explicit 显示转换操作符\n\n默认情况下，C++编译器会在函数调用的参数和函数声明不匹配时，想方设法地将参数转为匹配的类型，让函数调用能够通过，这中间会检查：\n\n- 实参的类型转换运算符，如果有转换为目标类型的转换运算符就调用；\n- 目标类型的构造函数，看是否有接收实参类型的构造函数，如果有就调用；\n\n有时这很方便，但更多场景下这样的行为只会导致语意上的混乱。为了避免编译器的隐式转换，可以使用explicit修饰类型转换运算符或构造函数，这样编译器就不会尝试使用对应函数进行转换。\n\n### 3.8 initializer_list 初始化列表\n\n#### 3.8.1 如何使用初始化列表\n\nC++98中，仅允许使用initializer-list初始化数组，C++11扩展了initializer-list的概念，使得普通类型也可以使用initializer-list初始化（不要把它和类的成员初始化搞混，它们的确都叫initializer-list，要区分时，可以将类的成员初始化叫做member initializer list）：\n\n```cpp\nint a[]={1,3,5};//C++98通过，C++11通过\nint b[]{2,4,6};//C++98失败，C++11通过\nvector<int> c{1,3,5};//C++98失败，C++11通过\nmap<int,float> d = {{1,1.0f},{2,2.0f},{5,3.2f}};//C++98失败，C++11通过\n```\n\n如果要让自定义的类支持这种初始化方式，只要声明一个接收在<initializer_list>中定义的initializer_list类型的构造函数就可以了。该类型是一个Iterable类型，可以使用begin, end等标准遍历方法。\n\n### 3.8.2 防止类型收窄\n\n使用初始化列表还可以促使编译器检查类型收窄的情况。初始化列表是目前唯一一种检查类型收窄的方式（不过事实上现在的大多数编译器在没有使用初始化列表时也会检查类型收窄并给出警告，但使用初始化列表编译器会直接给出错误）。\n\n### 3.9 POD类型\n\nPOD，也就是Plain Ordinary Data，纯数据类型。\n\nC++11对POD的定义是：平凡的，且是标准布局的。定义上，比C++98更宽容了，C++98只规定了C风格的struct是POD，但从POD的定义上，只要类对象布局是标准的，这样的类应该都是POD类。\n\n（但是，对POD定义得更宽容似乎并没有什么意义？C++11更多的是对于哪些情况会导致对象布局变化进行了更进一步的明确，只有不导致对象布局变化的类定义才是POD类。）\n\n### 3.10 union 非受限联合体\n\nC++11将C++98对union的一些限制移除了。\n\n- 在C++98，union中只能包含基础类型和POD类型，并且不能包含静态方法，但在C++11中，union中可以包含任意非引用类型。\n- C++11中，如果union任何一个成员拥有非平凡的构造函数，那么编译器就不会为union生成默认构造函数。\n- C++11中，允许在类定义使用union声明成员变量，用这种方式声明的union不需要有类型名称，被称为匿名的非受限联合体，此时联合体内的所有成员都会自动的成为类的“变长成员”，即实际上它们共享同一处内存，应该只使用它们中的某一个。\n\n### 3.11 用户定义字面量\n\n#### 3.11.1 字面量操作符\n\n- 接收字符串：<用户类型> operator \"\" _<后缀字符>(const char* col, size_t size)\n- 接收整数：<用户类型> operator \"\" _<后缀字符>(unsigned long long val)\n- 接收整数，但整数越界，此时会传入'\\0'结尾的char*：<用户类型> operator \"\" _<后缀字符>(const char*)\n- 接收浮点：<用户类型> operator \"\" _<后缀字符>(long double val)\n- 接收字符：<用户类型> operator \"\" _<后缀字符>(char val)\n\n### 3.12 内联名字空间\n\nC++11规定可以在namespace前加上inline，将名字空间默认导出到声明名字空间的作用域。\n\n这样的行为和C++98就有的匿名名字空间非常类似，除了内联名字空间有自己的名字以外。不过，它们被创建出来的目的是不同的：\n\n- 匿名名字空间在C++98中用于替代static修饰符，因为C++为类引入了static成员后，static的语意变得非常模糊且矛盾，因此在原本使用static声明文件作用域的变量的地方，可以改成使用匿名名字空间来包围这些变量起到同样的效果；\n- 内联名字空间则是被标准库用于和宏配合使用，根据当前编译环境决定默认导出同一个功能的哪一个版本的实现，这样做的好处是不关心具体实现的用户可以直接使用默认导出的功能，而了解更全面的细节的用户也可以使用名字空间来指定使用的是哪一个版本的功能。\n\n### 3.13 使用using声明模板别名\n\n在C++11中，已经可以使用using完全替代typedef了。\n\nusing不仅有更清晰的语意，还可以部分声明模板参数：\n\n```cpp\ntemplate <typename T> using StringObjectMap = std::map<string, T>;\nStringObjectMap<MyCls> myMap;\n```\n\n### 3.14 SFINAE规则\n\nSFINAE，就是Substitution Failure Is Not An Error。\n\n指的是，编译器在尝试模板参数匹配时，只要能够最终找到合适的匹配，中间尝试过的任何匹配失败都不会报错。\n\n只不过，C++98对于模板参数中使用表达式的情况支持的不友好，C++11明确了任何在编译期合法的表达式都能够作为模板参数，比如下面的这个例子就在C++98中无法通过编译，而在C++11中可以：\n\n```cpp\ntemplate<int I> struct A{};\nchar xxx(int);\nchar xxx(float);\ntemplate <class T> A<sizeof(xxx((T)0))> f(T){}\n```\n\n## 4. 新手易学，老兵易用\n\n### 4.1 右尖括号的改进\n\nC++98曾经规定应该把 >> 优先判定为右移操作符，但这个规定在C++11被取消了，C++11规定编译器可以自行智能地判断>>是否是右移操作符。\n\n### 4.2 auto类型推导\n\n在C++98中，auto其实是用于声明一个变量具有“自动存储期”，但实际上除了static以外的变量都是默认具有自动存储期的，因此过去的auto几乎没有人使用。\n\nC++11中，auto被赋予了新的含义，以前的auto含义被取消了。auto成为了新的类型指示符，auto声明的变量的类型必须在编译期由编译器推导出来。\n\n### 4.3 decltype\n\ndecltype是在编译时对表达式进行类型推导，推导出的类型可用于定义新的变量。decltype主要是为了解决泛型编程中由于泛型参数类型不确定，导致和泛型参数相关的表达式类型无法确定的问题的。比如：\n\nt1是泛型Type1类型，t2是泛型Type2类型，由于开发泛型代码时无法确定Type1和Type2的类型，自然无法确定t1 + t2的类型，但该类型其实是可以由编译器推导出来的，decltype如今即可用在此处：\n\nauto add(t1, t2) -> decltype(t1 + t2) {return t1 + t2;}\n\n或者可以声明原本无法声明的变量：decltype(t1 + t2) addResult = t1 + t2;（当然，auto也可以完成此工作）。\n\n有时会将decltype和auto搭配使用：decltype(auto)。这是因为一方面，我们希望依赖C++11的类型推导能力（auto的作用），但另一方面，又想保留cv限定符和引用（decltype的作用）（auto的类型推导规则和模板类似，如果不把auto声明为auto&或者auto*，auto就会被视为不具备cv限定符的值类型，如果auto被声明为auto&或者auto*，auto推导出的类型才会保留cv限定符）。但是使用这样的写法时要小心：decltype在推导类型时，如果表达式是一个简单的名字，它会推导出名字的类型，但如果表达式不只是一个名字，比如decltype((x))，那么即使x只是一个int，该decltype也会推导出引用类型：int&。\n\n### 4.4 追踪返回类型\n\nauto func(char* a,int b) -> int;\n\n### 4.5 基于范围的for循环\n\n自定义集合类型要想支持这样的for循环，需要实现begin, end, ++, ==四个函数。\n\n## 5. 提高类型安全\n\n### 5.1 强类型枚举\n\nC++98: enum X {...};\n\nC++11: enum class X {...};\n\n### 5.2 堆内存管理：智能指针与垃圾回收\n\n## 6. 提高性能及操作硬件的能力\n\n### 6.1 常量表达式\n\nC++11规定使用constexpr修饰符来修饰常量表达式。常量表达式可以是函数或者值。常量表达式函数中不可以出现非常量表达式。常量表达式可以在编译期使用，但如果常量表达式并没有一定要在编译期被计算出来，标准规定编译器在这种情况下可以将常量表达式编译成普通的表达式，表达式会在运行时被计算。\n\n### 6.2 变长模板\n\n过去，C++可以使用C风格的方法来实现可变参函数，但这种实现方式是类型不安全的。\n\n现在，C++11为可变参函数提出了更合理（类型安全）的解决方案：变长模板。可以使用变长模板来声明变长模板函数或者变长模板类。\n\n### 6.3 模板参数包与递归\n\n使用template <typename... Elements>这种方式可以声明一个变长模板参数，使用Elements...这种方式可以将变长模板参数展开成实际的多个参数类型；\n\n不定长的变长模板类可以通过模板类的递归来解包：\n\n```cpp\ntemplate <typename... Elements> class tuple;    // 变长模板声明\n// 以下是两个模板偏特化定义，利用模板偏特化会被优先匹配的规则，让变长模板参数递归地被解包\n// 对于类型，可以使用递归的继承\ntemplate <typename Head, typename... Tail> \nclass tuple <Head, Tail...> : private tuple<Tail...> {\n    Head head;\n}\ntemplate <> class tuple {};\n\n// 对于函数，可以使用递归的函数调用\n// 下面实现一个更强大的Printf，不论%后面跟的是什么符号，这个Printf总是会打印正确的类型\nvoid Printf(const char* s) {\n    while (*s) {\n        if (*s == '%' && ++s != '%') {\n               throw runtime_error(\"invalide format\");\n        }\n        cout *s++;\n    }\n}\n\ntemplate <typename T, typename... Args>\nvoid Printf(char* s, T value, Args... args) {\n    while(*s) {\n        if (*s == '%' && *s++ != '%') {\n            cout << value;\n            return Printf(++s, args...);\n        }\n        cout << *s++;\n    }\n    // 若百分号的数量和参数数量对不上，就抛异常\n    throw runtime_error(\"extra arguments provided\");\n}\n```\n\n## 7. 进阶\n\n### 7.1 引用类型\n\n定义了模板参数包后，还可以在展开模板参数包时使用引用标记：Args&&...，这样的写法是合法的；\n\n### 7.2 特殊展开\n\n解包时，有些非常特殊的规则，需要特别说明一下：\n\n```cpp\ntemplate <typename... Args> class MyCls: private A<Args>... {};\n// 上面的表达式在解包时会解包成多继承：\nT<Parent1, Parent2>  t; // t的类型是：class MyCls: private A<Parent1>, A<Parent2>\n\ntemplate <typename Args...> class MyCls: private A<Args...> {};\n// 而这个表达式在解包时，会在泛型参数表达式中直接展开\nT<Parent1, Parent2>  t; // t的类型是：class MyCls: private A<Parent1, Parent2>\n\ntemplate <typename Args...> void test(Args... args) {\n    // 下面这个会被展开成call(a(arg1), a(arg2), ...)\n    call(a(args)...);\n    // 而下面这个会被展开成call(a(arg1, arg2, ...))\n    call(a(args...));\n}\n```\n\n### 7.3 获取变长参数包长度\n\n可以使用sizeof...获取模板参数包的长度；\n\n### 7.4 模板的模板（的模板的模板...）\n\n变长参数的模板类型本身也可以是一个模板，这一点和以前的非变长模板参数一样。\n\n### 7.5 原子类型和原子操作\n\nC++11以前，已经有很多使用多线程能力的C++程序了，但之前语言本身并没有定义任何同多线程有关的内容，这些多线程能力来自于多线程接口pthread。pthread是一套C的接口。\n\n通常情况下，如果我们不需要太精细的互斥控制，可以直接使用posix提供的mutex互斥锁API，而如果想达到更优化的性能，可能会考虑为不同处理器编写内敛汇编代码。\n\nC++11标准为多线程程序在标准库中添加了原子类型，并允许指定原子类型的内存访问顺序一致性，让开发者可以不必操心操作系统和处理器的底层细节，也可以获得最优化的性能。\n\n### 7.6 线程局部存储\n\nC++11定义了thread_local关键字来定义线程局部存储变量，这样的变量生命期是线程启动到线程结束，除了本线程外，没有其他线程可以访问到这样的变量。\n\nC++11仅规定了线程局部存储的行为，而没有规定其具体实现，不同的编译器在不同的环境中可能会有不同的实现方式。\n\n### 7.7 快速退出：quick_exit, at_quick_exit\n\n在过去，大体上有三种退出程序的方式：terminate(), abort(), exit()。\n\n- terminate是有未处理的异常时会被调用的方法，可以使用set_terminate方法更改默认行为，terminate默认调用abort；\n- abort是进程不得不终止时，被调用的函数，它会向本进程发送一个SIGABRT信号，该信号默认会导致操作系统直接释放该进程的所有资源并终止进程；\n- exit是进程自发调用的退出函数，它代表着进程运行到了某个节点，该退出了，它会导致每一个自动变量的析构函数被调用（是的，仅自动变量，也就是栈变量会被调用析构函数，至于单例什么的需要自己处理），并调用at_exit注册的函数，然后才会回收进程；\n\nC++11新增了quick_exit标准方法，该方法语意上和exit一样，都是程序自发终止，但和exit不同的是，它不会进行本进程的清理工作，在多线程环境下也不会先等待线程结束，而是直接让操作系统终止进程并回收资源。\n\n## 8. 为改变思想方式而改变\n\n### 8.1 指针空值-nullptr\n\nC++11定义了nullptr_t和nullptr，前者是类型，后者是该类型的值。\n\nnullptr可以隐式转换为任何指针，但无法被隐式转换为bool类型，无法使用if (nullptr)这样的表达式；此外它所属的nullptr_t是一个基础类型，nullptr无法被推导为T*这样的模板参数。\n\n### 8.2 默认函数的控制\n\nC++11规定可以使用 = default 来使编译器生成默认版本的成员函数，可以由编译器生成的函数包括：\n\n- 空构造函数\n- 拷贝构造函数\n- 拷贝赋值函数\n- 移动构造函数\n- 移动拷贝函数\n- 析构函数\n\n此外，编译器还为所有自定义类型提供以下全局默认操作符函数：\n\n- operator, \n- operator&\n- operator&&\n- operator*\n- operator->\n- operator->*\n- operator new\n- operator delete\n\n### 8.3 lambda函数\n\nlambda语法：\n\n[<捕获外部变量>]<(可选)mutable>(<(可选)参数列表>) -> <(可选)返回值> {<函数体>}\n\n- 捕获外部变量：变量需要用&或者=开头来引用，直接写&或者=后面不跟变量表示捕获所有外部变量，=表示按值捕获，&表示引用捕获；\n- mutable：labmda默认是内联的const函数，不可以修改任何捕获的外部的按值捕获的变量（因为目前lambda的语意其实和仿函数完全一致，在仿函数中，所有捕获的外部变量都是仿函数类的成员，因此const函数不可以修改类成员，到lambda这里变成了lambda不可以修改捕获变量），但是引用捕获的变量则可以修改（这个行为也是和仿函数一致的，const函数内可以调用任意成员引用的方法，修改其属性，因为将引用声明成const，和将指针声明成const类似，都仅仅是禁止修改引用本身，但并没有限制对引用或者指针指向的变量进行修改）。如果希望lambda不是一个const函数，就要添加mutable声明；\n- 参数列表：\n- 返回值：当能够从函数体中推测出明确的返回值类型时，可以忽略；\n- 函数体：\n\n## 9. 融入实际应用\n\n### 9.1 对齐支持\n\nC和C++都是具备直接操作底层硬件能力的语言，因此某些开发者会对数据结构的对齐方式特别关注。\n\nC++11规定了alignof和alignas关键字，前者可以查询某个类型的对齐方式（一般来说都是32位-4字节或者64位-8字节对齐），而后者可以规定某个自定义类的对齐方式。比如如果我们想要使用内联汇编的向量指令（可以同时处理4组处理器位数的数据）来优化处理速度，就可能想要将数据对齐到4*处理器位数的位置处。\n\n需要注意的是，之前很多编译器也规定了指定数据对齐方式的方式，比如GNU就规定可以使用如下方式规定对齐字节：__attribute__((__aligned__(8)))；\n\n需要注意的是，虽然标准规定了指定对齐的方式，但每个平台具体支持对齐到多少是不确定的。如果使用alignas(2^64)，那显然是不合法的。不幸的是，目前标准似乎没办法查询每个平台支持的最大对齐字节。不过一般来说我们也用不到太大的对齐字节。\n\n### 9.2 通用属性\n\n有时C/C++提供的语言能力无法完全满足开发者的需求，编译器厂商为了解决这些问题，提供了一系列的语言扩展来扩展C/C++的语法。这其中最常见的就是“属性”，可以告诉编译器一个符号的额外信息，让编译器做一些语言规范之外的处理。\n\n- GNU使用__attribute__((<属性列表>))来声明属性；\n- Windows使用__declspec(<属性列表>)来声明属性\n\nC++11也规定了类似的属性，之所以在语言中添加属性，是为了避免再给C++增加更多的关键字。C++11的属性和之前各个平台的编译器实现的属性的目的是一致的，它们提供的能力都是一般用不到，可以忽略的能力，语言规范不会考虑使用关键字来实现这些能力，因此将它们定义到通用属性里。C++规定通用属性的写法是：[[<属性列表>]]，这样的通用属性可以用来修饰任何语言元素。不过目前C++11只定义了两个通用属性：[[noreturn]]和[[carries_dependency]]。\n\n### 9.3 Unicode支持\n\n#### 9.3.1 字符集和编码\n\nASCII码是最早的编码，使用7位二进制位来表示所有英文字母和在英文排版印刷中用到的字符，后来ISO和Unicode组织共同制定了一套能够唯一的表示世界上所有字符的标准字符集，称为ISO/Unicode字符集或者Unicode字符集。Unicode规定了每个字符在整个字符集中的具体值（范围0x0-0x10FFFFF），但并没有规定计算机中如何存储这样的值，UTF-8 UTF-16 UTF-32是Unicode字符集事实上的编码标准。\n\nUTF-8使用1～6字节的变长编码方式来编码Unicode，由于UTF-8较为节约存储空间，因此使用的比较广泛。\n\n{% asset_img 1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png %}\n\n![屏幕快照 2019-08-18 上午12.57.01.png](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C++11/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png)\n\nGB2312早于Unicode被定义，是和Unicode不同的一种编码（不过Unicode汉字部分编码其实就是GB2312的变种），采用2字节表示一个中文字符，和Unicode不一样的是，GB2312既是字符集，又是字符编码。\n\n#### 9.3.2 C++中的Unicode支持\n\nC++98已经规定了wchar_t类型，但是C++98对wchar_t的定义不够明确，不同的编译器中wchar_t的位数不一致，导致移植性问题。\n\nC++11重新规定了char16_t char32_t，用于存储UTF-16 UTF-32编码的Unicode数据，UTF-8的数据则直接使用char来存储。C++中可以在字符串常量前加前缀来让编译器产生不同编码的数据：\n\n- u8 - UTF8\n- u - UTF-16\n- U - UTF-32\n- L - wchar_t\n\n之所以没有为UTF-8规定类型，是因为UTF-16和UTF-32都是定长编码，而UTF-8是变长编码（有误，过去某段时间Unicode还比较少，当时UTF16编码Unicode的确是事实上的定长编码，但现在Unicode字符集已经收录了更多字符，早已超出了UTF-16的表示范围，UTF-16已经成为了事实上的变长编码，一些历史程序如果还假定UTF-16是定长编码的话，遇到超出UTF-16表示范围的字符时就会出问题。），变长编码会导致很多算法变得极其复杂（比如无法确定一个utf_8[]中的第N个字符究竟被存储在数组中的哪个位置）。对于语言来说，定长编码处理起来更自然，且增加的内存占用和减少的程序设计复杂度也大体可以认为相互抵消，可以使用定长编码进行处理，需要保存时再存成变长编码以节省存储空间。\n\nC++中，影响Unicode字符能够正确保存和输出的因素有以下三点：\n\n- 文件编码\n- 编译器编码设置\n- 输出设备\n\n为了确保得到正确的输出，需要确保源文件的编码同系统编码一致、并且用于输出的设备支持被输出的编码（比如不少shell就只支持UTF-8编码，非UTF-8编码的会直接输出十六进制的编码值）。\n\n#### 9.3.3 标准库支持\n\nC++11新增了几个字符类型，也同步地在标准库中新增了字符类型的转换函数。","slug":"cplus_md/CPlus Basic/深入理解C++11","published":1,"updated":"2021-04-09T14:06:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckns3cr6e004jw9q9317b8xgh","content":"<script src=\"/Blog/assets/js/APlayer.min.js\"> </script><h1 id=\"深入理解C-11\"><a href=\"#深入理解C-11\" class=\"headerlink\" title=\"深入理解C++11\"></a><strong>深入理解C++11</strong></h1><h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><h3 id=\"1-1-说到C-11，应该想到什么？\"><a href=\"#1-1-说到C-11，应该想到什么？\" class=\"headerlink\" title=\"1.1 说到C++11，应该想到什么？\"></a>1.1 说到C++11，应该想到什么？</h3><ul>\n<li>什么是 lambda，及怎么样使用它是最好的？</li>\n<li>decltype 和 auto 类型推导有什么关系？</li>\n<li>什么是移动语义，以及(右值引用)是如何解决转发问题的？</li>\n<li>default/deleted 函数以及 override 是怎么回事?</li>\n<li>异常描述符被什么替代了? noexcept 是如何工作的?</li>\n<li>什么是原子类型以及新的内存模型?</li>\n<li>如何在 C++11 中做并行编程?</li>\n</ul>\n<h3 id=\"1-2-语言的哪些关键字和C-11有关？\"><a href=\"#1-2-语言的哪些关键字和C-11有关？\" class=\"headerlink\" title=\"1.2 语言的哪些关键字和C++11有关？\"></a>1.2 语言的哪些关键字和C++11有关？</h3><ul>\n<li>alignas</li>\n<li>alignof decltype</li>\n<li>auto(重新定义)</li>\n<li>static_assert</li>\n<li>using(重新定义)</li>\n<li>noexcept</li>\n<li>export(弃用，不过未来可能留作他用)</li>\n<li>nullptr</li>\n<li>constexpr</li>\n<li>thread_local</li>\n</ul>\n<h2 id=\"2-保证稳定性和兼容性\"><a href=\"#2-保证稳定性和兼容性\" class=\"headerlink\" title=\"2. 保证稳定性和兼容性\"></a>2. 保证稳定性和兼容性</h2><h3 id=\"2-1-将C99标准纳入C-11\"><a href=\"#2-1-将C99标准纳入C-11\" class=\"headerlink\" title=\"2.1 将C99标准纳入C++11\"></a>2.1 将C99标准纳入C++11</h3><h4 id=\"2-1-1-确定编译环境的预定义宏\"><a href=\"#2-1-1-确定编译环境的预定义宏\" class=\"headerlink\" title=\"2.1.1 确定编译环境的预定义宏\"></a>2.1.1 确定编译环境的预定义宏</h4><ul>\n<li>__STDC_HOSTED__：编译器的目标系统环境中是否包含完整的C库</li>\n<li>__STDC__：编译器对于标准C库的实现是否和C标准一致（是否定义、如何定义由编译器决定）</li>\n<li> __STDC_VERSION__：编译器支持的C标准的版本（是否定义、如何定义由编译器决定）</li>\n<li>__STDC_ISO_10646__：yyyymmL格式的整数常量，表示C++编译环境符合某个版本的ISO/IEC 10646标准</li>\n</ul>\n<h4 id=\"2-1-2-func-预定义标识符\"><a href=\"#2-1-2-func-预定义标识符\" class=\"headerlink\" title=\"2.1.2 func 预定义标识符\"></a>2.1.2 <strong>func</strong> 预定义标识符</h4><p>函数中可以使用__func__标识符函数名称，编译器会在函数定义开始时隐式地插入__func__标识符定义：</p>\n<blockquote>\n<p>static const char* <strong>func</strong> = “&lt;函数名称&gt;”;</p>\n</blockquote>\n<h4 id=\"2-1-3-Pragma-操作符\"><a href=\"#2-1-3-Pragma-操作符\" class=\"headerlink\" title=\"2.1.3 _Pragma 操作符\"></a>2.1.3 _Pragma 操作符</h4><p>在之前的C/C++标准中已经规定了可以使用#pragma预处理指令向编译器传递信息，比如可以通过在头文件首行放置#pragma once来告诉编译器这个头文件只应该被include一次。</p>\n<p>C++11中，规定了一个新的操作符_Pragma，它的作用与#pragma完全相同，_Pragma(“once”)就相当于#pragma once。但是，_Pragma由于是一个操作符而不是预处理指令，它的使用更为灵活，可以在宏中展开。</p>\n<h4 id=\"2-1-4-不定参数宏定义以及-VA-ARGS\"><a href=\"#2-1-4-不定参数宏定义以及-VA-ARGS\" class=\"headerlink\" title=\"2.1.4 不定参数宏定义以及 __VA_ARGS__\"></a>2.1.4 不定参数宏定义以及 __VA_ARGS__</h4><p>C99规定宏定义中，在参数列表的最后，可以使用…省略参数定义，而__VA_ARGS__可以用来替换被省略号代表的字符串。</p>\n<h4 id=\"2-1-5-宽窄字符串连接\"><a href=\"#2-1-5-宽窄字符串连接\" class=\"headerlink\" title=\"2.1.5 宽窄字符串连接\"></a>2.1.5 宽窄字符串连接</h4><h3 id=\"2-2-long-long整形\"><a href=\"#2-2-long-long整形\" class=\"headerlink\" title=\"2.2 long long整形\"></a>2.2 long long整形</h3><h3 id=\"2-3-扩展的整形\"><a href=\"#2-3-扩展的整形\" class=\"headerlink\" title=\"2.3 扩展的整形\"></a>2.3 扩展的整形</h3><h3 id=\"2-4-宏-cplusplus\"><a href=\"#2-4-宏-cplusplus\" class=\"headerlink\" title=\"2.4 宏__cplusplus\"></a>2.4 宏__cplusplus</h3><p>一般会和extern “C”配合使用，来让一个头文件即可以同时被include到C和C++中编译，使用extern “C”避免C++对符号名称进行重整，确保C++编译器编译出的目标文件中的符号名维持原样。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">// 一些代码</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-静态断言\"><a href=\"#2-5-静态断言\" class=\"headerlink\" title=\"2.5 静态断言\"></a>2.5 静态断言</h3><p>标准C库assert.h中，提供了assert函数来进行运行时的断言，表明某些情况一定不会发生。（在 C++ 中，程序员也可以定义宏 NDEBUG 来禁用 assert 宏。这对发布程序来说还是必 要的。因为程序用户对程序退出总是敏感的，而且部分的程序错误也未必会导致程序全部功 能失效。那么通过定义 NDEBUG 宏发布程序就可以尽量避免程序退出的状况。而当程序有 问题时，通过没有定义宏 NDEBUG 的版本，程序员则可以比较容易地找到出问题的位置。）</p>\n<p>如果希望在预处理时确定某些情况一定不会发生，也可以使用#if进行判断，使用#error终止编译流程并给出错误提示。</p>\n<p>C++11引入static_assert来补充编译时断言。之前Boost库也实现了类似的功能，它是利用编译器在编译时会检查除以0这个特性，如果条件为假就构建一个除以0的语句迫使编译器报错来实现的，虽然可以达成编译时检查的目的，但报错信息比较不明确。使用C++11的static_assert，在断言失败时，可以得到明确的错误提示。</p>\n<h3 id=\"2-6-noexcept修饰符与noexcept操作符\"><a href=\"#2-6-noexcept修饰符与noexcept操作符\" class=\"headerlink\" title=\"2.6 noexcept修饰符与noexcept操作符\"></a>2.6 noexcept修饰符与noexcept操作符</h3><h4 id=\"2-6-1-作为修饰符\"><a href=\"#2-6-1-作为修饰符\" class=\"headerlink\" title=\"2.6.1 作为修饰符\"></a>2.6.1 作为修饰符</h4><p>noexcept作为修饰符可以用来表明函数是否会抛出异常，noexcept修饰符后面可以跟随一个常量表达式，当常量表达式可以转为true时表示不会抛出异常，false则表示会抛出异常。被noexcept修饰符标记为不会抛出异常的函数如果运行时抛出异常，会直接导致程序调用std::terminate终止执行，异常不会继续沿栈传播。</p>\n<h4 id=\"2-6-2-作为操作符\"><a href=\"#2-6-2-作为操作符\" class=\"headerlink\" title=\"2.6.2 作为操作符\"></a>2.6.2 作为操作符</h4><p>noexcept作为操作符可以用来判断某个表达式是否会抛出异常。该操作符帮助我们在进行泛型编程时通过noexcept操作符判断一个依赖模板参数的表达式是否会抛出异常。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> <span class=\"title\">noexcept</span><span class=\"params\">(<span class=\"keyword\">noexcept</span>(T()))</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-6-3-替代废弃的throw\"><a href=\"#2-6-3-替代废弃的throw\" class=\"headerlink\" title=\"2.6.3 替代废弃的throw\"></a>2.6.3 替代废弃的throw</h4><p>C++98曾经定义了throw修饰符，用来表明表达式是否会抛出异常，一个空的throw()就和noexcept(true)表达的意思一样，但throw要求明确指出会抛出哪些类型的异常，实际编程中大家很少需要了解异常类型，只希望了解是否会抛出异常，因此新的noexcept(false)用于替代throw(&lt;异常类型&gt;)。</p>\n<h3 id=\"2-7-快速初始化成员变量\"><a href=\"#2-7-快速初始化成员变量\" class=\"headerlink\" title=\"2.7 快速初始化成员变量\"></a>2.7 快速初始化成员变量</h3><p>C++98中，允许直接在类的静态常量整型成员声明时使用“=”对其初始化，这种声明+初始化的做法被叫做“就地”声明。这种声明方式很便捷，但仅能对【静态】【常量】【整型】成员进行这样的声明，使用场景很少，语法也不一致。</p>\n<p>C++11中允许对非静态成员进行就地的初始化，不再必须在构造函数中通过initializer-list进行初始化了。可以使用等号或者一对花括号{}进行就地初始化，其他形式无法通过编译。</p>\n<p>在成员同时使用就地初始化，并且在构造函数的初始化列表中进行初始化时，最终仅会以初始化列表为准对其进行初始化。</p>\n<h3 id=\"2-8-非静态成员的sizeof\"><a href=\"#2-8-非静态成员的sizeof\" class=\"headerlink\" title=\"2.8 非静态成员的sizeof\"></a>2.8 非静态成员的sizeof</h3><p>C++98中，sizeof可以作用于类的静态成员，但对于非静态成员，必须通过一个类实例来引用，因此之前为了获取一个非静态成员的大小，同时避免创建无用的类实例，通常会使用下面的技巧：</p>\n<blockquote>\n<p>sizeof(((People*)0)-&gt;hand);</p>\n</blockquote>\n<p>C++11后，sizeof可以直接作用于类成员表达式了，上面的技巧可以简化成：</p>\n<blockquote>\n<p>sizeof(People::hand)</p>\n</blockquote>\n<h3 id=\"2-9-扩展的friend语法\"><a href=\"#2-9-扩展的friend语法\" class=\"headerlink\" title=\"2.9 扩展的friend语法\"></a>2.9 扩展的friend语法</h3><p>在C++98，如果要指定另一个类是当前类的友元，必须要使用friend class/struct &lt;友元类&gt;这样的写法，并且无法使用模板参数作为友元类，C++11允许省略class，而且可以使用模板参数作为友元类。</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/language/friend\">https://zh.cppreference.com/w/cpp/language/friend</a></p>\n<h3 id=\"2-10-final-override\"><a href=\"#2-10-final-override\" class=\"headerlink\" title=\"2.10 final/override\"></a>2.10 final/override</h3><p>final用于在继承关系的中间终止一个虚函数被子类重载的可能性。override用于显式声明某个函数是父类虚函数的重载，提升了代码可读性和健壮性（因为virtual修饰符只有在顶级父类声明虚函数时才是必须的，子类为同名虚函数添加virtual修饰符会被忽略，而override修饰符会被编=‘译器检查以确保函数的确重载了虚函数）。它们都在函数声明的参数列表之后。</p>\n<p>为了尽可能兼容已有程序，C++11没有将final和override规定为关键字，因此可以在代码中使用final，override变量，但最好别这么做。</p>\n<h3 id=\"2-11-模板函数的默认模板参数\"><a href=\"#2-11-模板函数的默认模板参数\" class=\"headerlink\" title=\"2.11 模板函数的默认模板参数\"></a>2.11 模板函数的默认模板参数</h3><p>C++98允许为类模板参数指定默认参数，但却禁止为函数模板参数指定默认参数，语法上不一致，逻辑上不合理。</p>\n<p>C++11放宽了这一限制，可以为函数模板指定默认模板参数了。</p>\n<h3 id=\"2-12-外部模板\"><a href=\"#2-12-外部模板\" class=\"headerlink\" title=\"2.12 外部模板\"></a>2.12 外部模板</h3><p>C++中，如果多个源文件都使用了同一个模板，会对该模板进行多次实例化，但最后编译时，编译器会仅保留一份模板实例化产生的代码。在一些比较大的项目中，冗余的模板实例化会明显拖慢编译速度，可以使用“外部模板”技术告诉编译器不需要对模板进行实例化，在某一个源文件中仅进行一次显式实例化。</p>\n<blockquote>\n<p>template void fun<int>(int); // 显示地实例化</p>\n<p>extern template void fun<int>(int); // 外部模板的声明</p>\n</blockquote>\n<h3 id=\"2-13-局部和匿名类型作为模板实参\"><a href=\"#2-13-局部和匿名类型作为模板实参\" class=\"headerlink\" title=\"2.13 局部和匿名类型作为模板实参\"></a>2.13 局部和匿名类型作为模板实参</h3><p>C++98禁止局部或者匿名的类型作为模板参数，这个限制没什么道理，因此C++11放宽了该限制。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++98中，只有A或者a可以作为模板参数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; a;</span><br><span class=\"line\"><span class=\"comment\">// 匿名类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; B;</span><br><span class=\"line\"><span class=\"comment\">// 匿名类型变量</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 局部类型</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-通用为本，专用为末\"><a href=\"#3-通用为本，专用为末\" class=\"headerlink\" title=\"3. 通用为本，专用为末\"></a>3. 通用为本，专用为末</h2><h3 id=\"3-1-继承构造函数\"><a href=\"#3-1-继承构造函数\" class=\"headerlink\" title=\"3.1 继承构造函数\"></a>3.1 继承构造函数</h3><p>继承关系中，子类可以自动或得父类的成员和接口，但构造函数无法自动地被子类继承。因为通常子类也有自己的成员，我们要定义子类自己的构造函数，在子类构造函数中去调用父类构造函数以及初始化自己的成员。</p>\n<p>但是，如果子类中没有任何成员，或者其成员都用C++11的新特性“快速初始化成员变量”进行了初始化乃至于没有必要再用构造函数初始化了，那这时候我们很可能希望直接将父类的构造函数继承到子类，毕竟这时候只需要初始化父类成员。C++11允许我们使用using &lt;父类名&gt;::&lt;父类名&gt;来将所有父类构造函数引入子类，被using引入的父类构造函数是隐式声明的（也就是说，只有用到的函数才会被生成，以节省生成的代码）。</p>\n<p>（书中这一节很多描述都和XCode实验现象对不上，很可能是因为成书时还无实验环境，导致描述有误）</p>\n<h3 id=\"3-2-委派构造函数\"><a href=\"#3-2-委派构造函数\" class=\"headerlink\" title=\"3.2 委派构造函数\"></a>3.2 委派构造函数</h3><p>可以在构造函数的initializer-list中调用另一个构造函数来完成构造，这种将构造委托给另一个构造函数的行为   就叫委派构造函数。</p>\n<p>一旦在initializer-list中进行了委派构造，就不能再用正常的initializer-list初始化成员变量了。因此，通常被委派的构造函数会负责初始化类的所有成员变量。</p>\n<h3 id=\"3-3-右值引用\"><a href=\"#3-3-右值引用\" class=\"headerlink\" title=\"3.3 右值引用\"></a>3.3 右值引用</h3><p>可以使用两个引用符号 &amp;&amp; 来声明并定义一个右值引用。和左值引用一样，右值引用的声明和定义必须在一块。</p>\n<p>在C++98中，已经对右值有了一些描述，C++11对右值进行了更进一步的定义：右值就是将亡值。</p>\n<p><strong>C++98中，可以使用常量左值引用来引用右值</strong>，比如：</p>\n<blockquote>\n<p>const MyCls &amp;myRef = getTemp();</p>\n</blockquote>\n<p>这样的常量左值引用的确引用了getTemp返回的临时变量，延长了它的声明周期，但由于C++98对于右值的定义是“不可被改变的常量”，因此之前只能使用对const的引用来引用右值。</p>\n<p>C++11改变了对右值的定义，因此使用C++11的右值引用方式引用的右值，其内容可以被修改。</p>\n<h3 id=\"3-4-移动语意\"><a href=\"#3-4-移动语意\" class=\"headerlink\" title=\"3.4 移动语意\"></a>3.4 移动语意</h3><p>在C++中，如果自定义类中含有指针，通常需要自定义拷贝构造函数和赋值运算符，在对指针进行赋值时，要为指针开辟新的堆内存，并将原指针内容拷贝过来，不要使用编译器生成的默认函数。因为默认函数在赋值时通通采用浅拷贝，会导致两个对象的指针指向同一地址，几乎一定会导致野指针问题。</p>\n<p>但是，有时候我们拷贝或赋值时，比如a = b，其中b如果是一个右值，那么直接将b的指针赋值给a，并且阻止b对象在析构函数被调用时释放指针内存，是更合适的做法。因此如果b是一个右值，这意味着b马上就要被析构了，与其为a的指针开辟一片内存，不如直接利用b的指针现在使用的内存。<strong>这种做法就被称作“移动”b的资源到a，也就是“移动语意”。</strong></p>\n<p>C++11中可以通过声明移动构造函数/赋值函数实现移动语意，这样的函数和普通函数的区别在于它们接受的参数类型是右值引用，因此当这样的函数被调用时，可以确保被引用的值马上就要被销毁，可以直接移动其资源。</p>\n<p>移动构造函数应该是不会抛出异常的，因为如果移动到一半被终止了，会导致对象的一部分指针成员变成悬挂指针。标准库提供了move_if_noexcept函数，它会判断对象是否实现了noexcept的移动构造函数，如果实现了才返回右值引用，不然就返回左值引用，避免使用移动语意，退化为使用普通的拷贝。</p>\n<h3 id=\"3-5-完美转发\"><a href=\"#3-5-完美转发\" class=\"headerlink\" title=\"3.5 完美转发\"></a>3.5 完美转发</h3><h4 id=\"3-5-1-右值引用的问题\"><a href=\"#3-5-1-右值引用的问题\" class=\"headerlink\" title=\"3.5.1 右值引用的问题\"></a>3.5.1 右值引用的问题</h4><p>有了右值引用，看起来我们可以完美地实现移动语意了，但是，需要留意的是，我们在将右值赋给一个右值引用后，这个右值引用其实会被当成一个左值引用（毕竟移动语意本身就要求对右值引用进行修改）！类似的，右值引用的成员也是一个左值。</p>\n<p>因此，在访问右值引用，或者在访问右值引用的成员时，必须将其转换成右值引用，否则就会被当成普通的左值引用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 像这样的声明赋值没有意义，实际上，a依然会成为一个左值引用</span></span><br><span class=\"line\"><span class=\"comment\">// A &amp;&amp;a = getTemp();</span></span><br><span class=\"line\">A &amp;a = getTemp();</span><br><span class=\"line\">acceptRValueRef(<span class=\"built_in\">std</span>::move(a));  <span class=\"comment\">// OK，这里使用move把一个被当作左值引用的右值引用转成右值引用</span></span><br><span class=\"line\">accestRValueRef(<span class=\"built_in\">std</span>::forward&lt;A&gt;(a));    <span class=\"comment\">// OK，forward也能起到转为右值引用的作用</span></span><br></pre></td></tr></table></figure>\n<p>这个现象要求我们在创建移动构造函数时，必须要使用标准库<utility>中提供的std::move对右值引用的每一个成员转为右值引用，来保证移动语意。std::move会将其参数转化为一个右值引用。之所以可以进行这样的转换，是因为我们已经知道了拥有成员的对象是一个右值引用，既然成员对象的拥有者本身马上就要被销毁，那么成员对象也一定马上就会被销毁，此时将成员对象转为左值处理才是正确的。</p>\n<p>在将右值引用传入参数为右值引用的函数时，编译器会报错，因为右值引用实际上一旦被赋给引用变量，就会被当成左值引用。要让编译器重新将其重新当成一个右值引用，必须使用std::move，std::forward将其转成右值引用。</p>\n<h4 id=\"3-5-2-引用折叠\"><a href=\"#3-5-2-引用折叠\" class=\"headerlink\" title=\"3.5.2 引用折叠\"></a>3.5.2 引用折叠</h4><p>为了在模板编程时，让模板能够同时处理左值和右值引用，C++11引入了引用折叠的规则：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> MyClsLRef = MyCls&amp;;</span><br><span class=\"line\"><span class=\"keyword\">using</span> MyClsRRef = MyCls&amp;&amp;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C++11中被引用折叠规则理解为左值引用</span></span><br><span class=\"line\">MyClsLRef&amp;&amp; lRef = getMyCls();</span><br><span class=\"line\"><span class=\"comment\">// 下面两行是一样的，其中第一行在C++11中被引用折叠规则理解为右值引用</span></span><br><span class=\"line\">MyClsRRef&amp;&amp; rRef = getMyCls();</span><br><span class=\"line\">MyClsRRef rRef = getMyCls();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用引用折叠规则，可以在模板编写中将参数声明为左值引用类型，这样的模板函数实际上可以同时接收</span></span><br><span class=\"line\"><span class=\"comment\">// 左值引用和右值引用</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(T&amp;&amp; t)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"comment\">// 当T是一个右值引用时，T&amp;&amp;&amp;&amp;被折叠成右值引用</span></span><br><span class=\"line\"><span class=\"comment\">// 当T是一个左值引用时，T&amp;&amp;&amp;被折叠成左值引用</span></span><br><span class=\"line\"><span class=\"comment\">// 不用考虑T不是一个引用，会有这样的考虑说明对C++不够熟悉，函数参数被声明为引用，传进来的肯定是引用</span></span><br></pre></td></tr></table></figure>\n<p>除了std::move，标准库还提供了std::forward，它的作用其实和std::move有重叠，都可以用来将变量转换为右值引用的。只不过它被规定应该专门用于“转发”场景，并且在调用时必须指定模板参数，从而可以利用引用折叠规则，将参数的左右值引用保留下来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">A <span class=\"title\">getTemp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转发函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forwardToTest</span><span class=\"params\">(A&amp;&amp; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\"><span class=\"comment\">//    test(a);  无法通过编译，因为一旦右值引用被赋给变量，这个变量就表现成了左值引用</span></span><br><span class=\"line\">    test(<span class=\"built_in\">std</span>::forward&lt;A&amp;&amp;&gt;(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转发函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forwardToTestTemplate</span><span class=\"params\">(T&amp;&amp; a)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    test(a);  同样无法通过编译</span></span><br><span class=\"line\">    test(<span class=\"built_in\">std</span>::forward&lt;T&gt;(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(T&amp;&amp; a)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    forwardToTest(getTemp());</span><br><span class=\"line\">    forwardToTestTemplate(getTemp());</span><br><span class=\"line\">    A a;</span><br><span class=\"line\"><span class=\"comment\">//    forwardToTest(a); 无法通过编译，因为a不是右值引用</span></span><br><span class=\"line\">    forwardToTestTemplate(a);   <span class=\"comment\">// 可以通过编译，因为模板方法有引用折叠规则</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-move和forward的区别\"><a href=\"#3-6-move和forward的区别\" class=\"headerlink\" title=\"3.6 move和forward的区别\"></a>3.6 move和forward的区别</h3><ul>\n<li>move调用时不需要提供模板参数，它仅被用于将参数强制转为右值引用；</li>\n<li>forward调用时必须要提供模板参数，通常会提供这样的模板参数：forward&lt;T&amp;&amp;&gt;，这样的好处是T如果被声明为左值，转换后还是左值，T如果被声明为右值，转换后还是右值。</li>\n</ul>\n<h3 id=\"3-7-explicit-显示转换操作符\"><a href=\"#3-7-explicit-显示转换操作符\" class=\"headerlink\" title=\"3.7 explicit 显示转换操作符\"></a>3.7 explicit 显示转换操作符</h3><p>默认情况下，C++编译器会在函数调用的参数和函数声明不匹配时，想方设法地将参数转为匹配的类型，让函数调用能够通过，这中间会检查：</p>\n<ul>\n<li>实参的类型转换运算符，如果有转换为目标类型的转换运算符就调用；</li>\n<li>目标类型的构造函数，看是否有接收实参类型的构造函数，如果有就调用；</li>\n</ul>\n<p>有时这很方便，但更多场景下这样的行为只会导致语意上的混乱。为了避免编译器的隐式转换，可以使用explicit修饰类型转换运算符或构造函数，这样编译器就不会尝试使用对应函数进行转换。</p>\n<h3 id=\"3-8-initializer-list-初始化列表\"><a href=\"#3-8-initializer-list-初始化列表\" class=\"headerlink\" title=\"3.8 initializer_list 初始化列表\"></a>3.8 initializer_list 初始化列表</h3><h4 id=\"3-8-1-如何使用初始化列表\"><a href=\"#3-8-1-如何使用初始化列表\" class=\"headerlink\" title=\"3.8.1 如何使用初始化列表\"></a>3.8.1 如何使用初始化列表</h4><p>C++98中，仅允许使用initializer-list初始化数组，C++11扩展了initializer-list的概念，使得普通类型也可以使用initializer-list初始化（不要把它和类的成员初始化搞混，它们的确都叫initializer-list，要区分时，可以将类的成员初始化叫做member initializer list）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;<span class=\"comment\">//C++98通过，C++11通过</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b[]&#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>&#125;;<span class=\"comment\">//C++98失败，C++11通过</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; c&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;<span class=\"comment\">//C++98失败，C++11通过</span></span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">float</span>&gt; d = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">1.0f</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">2.0f</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">3.2f</span>&#125;&#125;;<span class=\"comment\">//C++98失败，C++11通过</span></span><br></pre></td></tr></table></figure>\n<p>如果要让自定义的类支持这种初始化方式，只要声明一个接收在<initializer_list>中定义的initializer_list类型的构造函数就可以了。该类型是一个Iterable类型，可以使用begin, end等标准遍历方法。</p>\n<h3 id=\"3-8-2-防止类型收窄\"><a href=\"#3-8-2-防止类型收窄\" class=\"headerlink\" title=\"3.8.2 防止类型收窄\"></a>3.8.2 防止类型收窄</h3><p>使用初始化列表还可以促使编译器检查类型收窄的情况。初始化列表是目前唯一一种检查类型收窄的方式（不过事实上现在的大多数编译器在没有使用初始化列表时也会检查类型收窄并给出警告，但使用初始化列表编译器会直接给出错误）。</p>\n<h3 id=\"3-9-POD类型\"><a href=\"#3-9-POD类型\" class=\"headerlink\" title=\"3.9 POD类型\"></a>3.9 POD类型</h3><p>POD，也就是Plain Ordinary Data，纯数据类型。</p>\n<p>C++11对POD的定义是：平凡的，且是标准布局的。定义上，比C++98更宽容了，C++98只规定了C风格的struct是POD，但从POD的定义上，只要类对象布局是标准的，这样的类应该都是POD类。</p>\n<p>（但是，对POD定义得更宽容似乎并没有什么意义？C++11更多的是对于哪些情况会导致对象布局变化进行了更进一步的明确，只有不导致对象布局变化的类定义才是POD类。）</p>\n<h3 id=\"3-10-union-非受限联合体\"><a href=\"#3-10-union-非受限联合体\" class=\"headerlink\" title=\"3.10 union 非受限联合体\"></a>3.10 union 非受限联合体</h3><p>C++11将C++98对union的一些限制移除了。</p>\n<ul>\n<li>在C++98，union中只能包含基础类型和POD类型，并且不能包含静态方法，但在C++11中，union中可以包含任意非引用类型。</li>\n<li>C++11中，如果union任何一个成员拥有非平凡的构造函数，那么编译器就不会为union生成默认构造函数。</li>\n<li>C++11中，允许在类定义使用union声明成员变量，用这种方式声明的union不需要有类型名称，被称为匿名的非受限联合体，此时联合体内的所有成员都会自动的成为类的“变长成员”，即实际上它们共享同一处内存，应该只使用它们中的某一个。</li>\n</ul>\n<h3 id=\"3-11-用户定义字面量\"><a href=\"#3-11-用户定义字面量\" class=\"headerlink\" title=\"3.11 用户定义字面量\"></a>3.11 用户定义字面量</h3><h4 id=\"3-11-1-字面量操作符\"><a href=\"#3-11-1-字面量操作符\" class=\"headerlink\" title=\"3.11.1 字面量操作符\"></a>3.11.1 字面量操作符</h4><ul>\n<li>接收字符串：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(const char* col, size_t size)</li>\n<li>接收整数：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(unsigned long long val)</li>\n<li>接收整数，但整数越界，此时会传入’\\0’结尾的char<em>：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(const char</em>)</li>\n<li>接收浮点：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(long double val)</li>\n<li>接收字符：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(char val)</li>\n</ul>\n<h3 id=\"3-12-内联名字空间\"><a href=\"#3-12-内联名字空间\" class=\"headerlink\" title=\"3.12 内联名字空间\"></a>3.12 内联名字空间</h3><p>C++11规定可以在namespace前加上inline，将名字空间默认导出到声明名字空间的作用域。</p>\n<p>这样的行为和C++98就有的匿名名字空间非常类似，除了内联名字空间有自己的名字以外。不过，它们被创建出来的目的是不同的：</p>\n<ul>\n<li>匿名名字空间在C++98中用于替代static修饰符，因为C++为类引入了static成员后，static的语意变得非常模糊且矛盾，因此在原本使用static声明文件作用域的变量的地方，可以改成使用匿名名字空间来包围这些变量起到同样的效果；</li>\n<li>内联名字空间则是被标准库用于和宏配合使用，根据当前编译环境决定默认导出同一个功能的哪一个版本的实现，这样做的好处是不关心具体实现的用户可以直接使用默认导出的功能，而了解更全面的细节的用户也可以使用名字空间来指定使用的是哪一个版本的功能。</li>\n</ul>\n<h3 id=\"3-13-使用using声明模板别名\"><a href=\"#3-13-使用using声明模板别名\" class=\"headerlink\" title=\"3.13 使用using声明模板别名\"></a>3.13 使用using声明模板别名</h3><p>在C++11中，已经可以使用using完全替代typedef了。</p>\n<p>using不仅有更清晰的语意，还可以部分声明模板参数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">using</span> StringObjectMap = <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, T&gt;;</span><br><span class=\"line\">StringObjectMap&lt;MyCls&gt; myMap;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-14-SFINAE规则\"><a href=\"#3-14-SFINAE规则\" class=\"headerlink\" title=\"3.14 SFINAE规则\"></a>3.14 SFINAE规则</h3><p>SFINAE，就是Substitution Failure Is Not An Error。</p>\n<p>指的是，编译器在尝试模板参数匹配时，只要能够最终找到合适的匹配，中间尝试过的任何匹配失败都不会报错。</p>\n<p>只不过，C++98对于模板参数中使用表达式的情况支持的不友好，C++11明确了任何在编译期合法的表达式都能够作为模板参数，比如下面的这个例子就在C++98中无法通过编译，而在C++11中可以：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> I&gt; <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">xxx</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">xxx</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span> <span class=\"function\">A&lt;<span class=\"title\">sizeof</span><span class=\"params\">(xxx((T)<span class=\"number\">0</span>))</span>&gt; <span class=\"title\">f</span><span class=\"params\">(T)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-新手易学，老兵易用\"><a href=\"#4-新手易学，老兵易用\" class=\"headerlink\" title=\"4. 新手易学，老兵易用\"></a>4. 新手易学，老兵易用</h2><h3 id=\"4-1-右尖括号的改进\"><a href=\"#4-1-右尖括号的改进\" class=\"headerlink\" title=\"4.1 右尖括号的改进\"></a>4.1 右尖括号的改进</h3><p>C++98曾经规定应该把 &gt;&gt; 优先判定为右移操作符，但这个规定在C++11被取消了，C++11规定编译器可以自行智能地判断&gt;&gt;是否是右移操作符。</p>\n<h3 id=\"4-2-auto类型推导\"><a href=\"#4-2-auto类型推导\" class=\"headerlink\" title=\"4.2 auto类型推导\"></a>4.2 auto类型推导</h3><p>在C++98中，auto其实是用于声明一个变量具有“自动存储期”，但实际上除了static以外的变量都是默认具有自动存储期的，因此过去的auto几乎没有人使用。</p>\n<p>C++11中，auto被赋予了新的含义，以前的auto含义被取消了。auto成为了新的类型指示符，auto声明的变量的类型必须在编译期由编译器推导出来。</p>\n<h3 id=\"4-3-decltype\"><a href=\"#4-3-decltype\" class=\"headerlink\" title=\"4.3 decltype\"></a>4.3 decltype</h3><p>decltype是在编译时对表达式进行类型推导，推导出的类型可用于定义新的变量。decltype主要是为了解决泛型编程中由于泛型参数类型不确定，导致和泛型参数相关的表达式类型无法确定的问题的。比如：</p>\n<p>t1是泛型Type1类型，t2是泛型Type2类型，由于开发泛型代码时无法确定Type1和Type2的类型，自然无法确定t1 + t2的类型，但该类型其实是可以由编译器推导出来的，decltype如今即可用在此处：</p>\n<p>auto add(t1, t2) -&gt; decltype(t1 + t2) {return t1 + t2;}</p>\n<p>或者可以声明原本无法声明的变量：decltype(t1 + t2) addResult = t1 + t2;（当然，auto也可以完成此工作）。</p>\n<p>有时会将decltype和auto搭配使用：decltype(auto)。这是因为一方面，我们希望依赖C++11的类型推导能力（auto的作用），但另一方面，又想保留cv限定符和引用（decltype的作用）（auto的类型推导规则和模板类似，如果不把auto声明为auto&amp;或者auto<em>，auto就会被视为不具备cv限定符的值类型，如果auto被声明为auto&amp;或者auto</em>，auto推导出的类型才会保留cv限定符）。但是使用这样的写法时要小心：decltype在推导类型时，如果表达式是一个简单的名字，它会推导出名字的类型，但如果表达式不只是一个名字，比如decltype((x))，那么即使x只是一个int，该decltype也会推导出引用类型：int&amp;。</p>\n<h3 id=\"4-4-追踪返回类型\"><a href=\"#4-4-追踪返回类型\" class=\"headerlink\" title=\"4.4 追踪返回类型\"></a>4.4 追踪返回类型</h3><p>auto func(char* a,int b) -&gt; int;</p>\n<h3 id=\"4-5-基于范围的for循环\"><a href=\"#4-5-基于范围的for循环\" class=\"headerlink\" title=\"4.5 基于范围的for循环\"></a>4.5 基于范围的for循环</h3><p>自定义集合类型要想支持这样的for循环，需要实现begin, end, ++, ==四个函数。</p>\n<h2 id=\"5-提高类型安全\"><a href=\"#5-提高类型安全\" class=\"headerlink\" title=\"5. 提高类型安全\"></a>5. 提高类型安全</h2><h3 id=\"5-1-强类型枚举\"><a href=\"#5-1-强类型枚举\" class=\"headerlink\" title=\"5.1 强类型枚举\"></a>5.1 强类型枚举</h3><p>C++98: enum X {…};</p>\n<p>C++11: enum class X {…};</p>\n<h3 id=\"5-2-堆内存管理：智能指针与垃圾回收\"><a href=\"#5-2-堆内存管理：智能指针与垃圾回收\" class=\"headerlink\" title=\"5.2 堆内存管理：智能指针与垃圾回收\"></a>5.2 堆内存管理：智能指针与垃圾回收</h3><h2 id=\"6-提高性能及操作硬件的能力\"><a href=\"#6-提高性能及操作硬件的能力\" class=\"headerlink\" title=\"6. 提高性能及操作硬件的能力\"></a>6. 提高性能及操作硬件的能力</h2><h3 id=\"6-1-常量表达式\"><a href=\"#6-1-常量表达式\" class=\"headerlink\" title=\"6.1 常量表达式\"></a>6.1 常量表达式</h3><p>C++11规定使用constexpr修饰符来修饰常量表达式。常量表达式可以是函数或者值。常量表达式函数中不可以出现非常量表达式。常量表达式可以在编译期使用，但如果常量表达式并没有一定要在编译期被计算出来，标准规定编译器在这种情况下可以将常量表达式编译成普通的表达式，表达式会在运行时被计算。</p>\n<h3 id=\"6-2-变长模板\"><a href=\"#6-2-变长模板\" class=\"headerlink\" title=\"6.2 变长模板\"></a>6.2 变长模板</h3><p>过去，C++可以使用C风格的方法来实现可变参函数，但这种实现方式是类型不安全的。</p>\n<p>现在，C++11为可变参函数提出了更合理（类型安全）的解决方案：变长模板。可以使用变长模板来声明变长模板函数或者变长模板类。</p>\n<h3 id=\"6-3-模板参数包与递归\"><a href=\"#6-3-模板参数包与递归\" class=\"headerlink\" title=\"6.3 模板参数包与递归\"></a>6.3 模板参数包与递归</h3><p>使用template &lt;typename… Elements&gt;这种方式可以声明一个变长模板参数，使用Elements…这种方式可以将变长模板参数展开成实际的多个参数类型；</p>\n<p>不定长的变长模板类可以通过模板类的递归来解包：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Elements&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>;</span>    <span class=\"comment\">// 变长模板声明</span></span><br><span class=\"line\"><span class=\"comment\">// 以下是两个模板偏特化定义，利用模板偏特化会被优先匹配的规则，让变长模板参数递归地被解包</span></span><br><span class=\"line\"><span class=\"comment\">// 对于类型，可以使用递归的继承</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Head, <span class=\"keyword\">typename</span>... Tail&gt; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span> &lt;</span>Head, Tail...&gt; : <span class=\"keyword\">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class=\"line\">    Head head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span> &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于函数，可以使用递归的函数调用</span></span><br><span class=\"line\"><span class=\"comment\">// 下面实现一个更强大的Printf，不论%后面跟的是什么符号，这个Printf总是会打印正确的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Printf</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*s == <span class=\"string\">&#x27;%&#x27;</span> &amp;&amp; ++s != <span class=\"string\">&#x27;%&#x27;</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> runtime_error(<span class=\"string\">&quot;invalide format&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Printf</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, T value, Args... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*s == <span class=\"string\">&#x27;%&#x27;</span> &amp;&amp; *s++ != <span class=\"string\">&#x27;%&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Printf(++s, args...);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若百分号的数量和参数数量对不上，就抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> runtime_error(<span class=\"string\">&quot;extra arguments provided&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-进阶\"><a href=\"#7-进阶\" class=\"headerlink\" title=\"7. 进阶\"></a>7. 进阶</h2><h3 id=\"7-1-引用类型\"><a href=\"#7-1-引用类型\" class=\"headerlink\" title=\"7.1 引用类型\"></a>7.1 引用类型</h3><p>定义了模板参数包后，还可以在展开模板参数包时使用引用标记：Args&amp;&amp;…，这样的写法是合法的；</p>\n<h3 id=\"7-2-特殊展开\"><a href=\"#7-2-特殊展开\" class=\"headerlink\" title=\"7.2 特殊展开\"></a>7.2 特殊展开</h3><p>解包时，有些非常特殊的规则，需要特别说明一下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Args&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCls</span>:</span> <span class=\"keyword\">private</span> A&lt;Args&gt;... &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 上面的表达式在解包时会解包成多继承：</span></span><br><span class=\"line\">T&lt;Parent1, Parent2&gt;  t; <span class=\"comment\">// t的类型是：class MyCls: private A&lt;Parent1&gt;, A&lt;Parent2&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Args...&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCls</span>:</span> <span class=\"keyword\">private</span> A&lt;Args...&gt; &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 而这个表达式在解包时，会在泛型参数表达式中直接展开</span></span><br><span class=\"line\">T&lt;Parent1, Parent2&gt;  t; <span class=\"comment\">// t的类型是：class MyCls: private A&lt;Parent1, Parent2&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Args...&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Args... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下面这个会被展开成call(a(arg1), a(arg2), ...)</span></span><br><span class=\"line\">    call(a(args)...);</span><br><span class=\"line\">    <span class=\"comment\">// 而下面这个会被展开成call(a(arg1, arg2, ...))</span></span><br><span class=\"line\">    call(a(args...));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-3-获取变长参数包长度\"><a href=\"#7-3-获取变长参数包长度\" class=\"headerlink\" title=\"7.3 获取变长参数包长度\"></a>7.3 获取变长参数包长度</h3><p>可以使用sizeof…获取模板参数包的长度；</p>\n<h3 id=\"7-4-模板的模板（的模板的模板…）\"><a href=\"#7-4-模板的模板（的模板的模板…）\" class=\"headerlink\" title=\"7.4 模板的模板（的模板的模板…）\"></a>7.4 模板的模板（的模板的模板…）</h3><p>变长参数的模板类型本身也可以是一个模板，这一点和以前的非变长模板参数一样。</p>\n<h3 id=\"7-5-原子类型和原子操作\"><a href=\"#7-5-原子类型和原子操作\" class=\"headerlink\" title=\"7.5 原子类型和原子操作\"></a>7.5 原子类型和原子操作</h3><p>C++11以前，已经有很多使用多线程能力的C++程序了，但之前语言本身并没有定义任何同多线程有关的内容，这些多线程能力来自于多线程接口pthread。pthread是一套C的接口。</p>\n<p>通常情况下，如果我们不需要太精细的互斥控制，可以直接使用posix提供的mutex互斥锁API，而如果想达到更优化的性能，可能会考虑为不同处理器编写内敛汇编代码。</p>\n<p>C++11标准为多线程程序在标准库中添加了原子类型，并允许指定原子类型的内存访问顺序一致性，让开发者可以不必操心操作系统和处理器的底层细节，也可以获得最优化的性能。</p>\n<h3 id=\"7-6-线程局部存储\"><a href=\"#7-6-线程局部存储\" class=\"headerlink\" title=\"7.6 线程局部存储\"></a>7.6 线程局部存储</h3><p>C++11定义了thread_local关键字来定义线程局部存储变量，这样的变量生命期是线程启动到线程结束，除了本线程外，没有其他线程可以访问到这样的变量。</p>\n<p>C++11仅规定了线程局部存储的行为，而没有规定其具体实现，不同的编译器在不同的环境中可能会有不同的实现方式。</p>\n<h3 id=\"7-7-快速退出：quick-exit-at-quick-exit\"><a href=\"#7-7-快速退出：quick-exit-at-quick-exit\" class=\"headerlink\" title=\"7.7 快速退出：quick_exit, at_quick_exit\"></a>7.7 快速退出：quick_exit, at_quick_exit</h3><p>在过去，大体上有三种退出程序的方式：terminate(), abort(), exit()。</p>\n<ul>\n<li>terminate是有未处理的异常时会被调用的方法，可以使用set_terminate方法更改默认行为，terminate默认调用abort；</li>\n<li>abort是进程不得不终止时，被调用的函数，它会向本进程发送一个SIGABRT信号，该信号默认会导致操作系统直接释放该进程的所有资源并终止进程；</li>\n<li>exit是进程自发调用的退出函数，它代表着进程运行到了某个节点，该退出了，它会导致每一个自动变量的析构函数被调用（是的，仅自动变量，也就是栈变量会被调用析构函数，至于单例什么的需要自己处理），并调用at_exit注册的函数，然后才会回收进程；</li>\n</ul>\n<p>C++11新增了quick_exit标准方法，该方法语意上和exit一样，都是程序自发终止，但和exit不同的是，它不会进行本进程的清理工作，在多线程环境下也不会先等待线程结束，而是直接让操作系统终止进程并回收资源。</p>\n<h2 id=\"8-为改变思想方式而改变\"><a href=\"#8-为改变思想方式而改变\" class=\"headerlink\" title=\"8. 为改变思想方式而改变\"></a>8. 为改变思想方式而改变</h2><h3 id=\"8-1-指针空值-nullptr\"><a href=\"#8-1-指针空值-nullptr\" class=\"headerlink\" title=\"8.1 指针空值-nullptr\"></a>8.1 指针空值-nullptr</h3><p>C++11定义了nullptr_t和nullptr，前者是类型，后者是该类型的值。</p>\n<p>nullptr可以隐式转换为任何指针，但无法被隐式转换为bool类型，无法使用if (nullptr)这样的表达式；此外它所属的nullptr_t是一个基础类型，nullptr无法被推导为T*这样的模板参数。</p>\n<h3 id=\"8-2-默认函数的控制\"><a href=\"#8-2-默认函数的控制\" class=\"headerlink\" title=\"8.2 默认函数的控制\"></a>8.2 默认函数的控制</h3><p>C++11规定可以使用 = default 来使编译器生成默认版本的成员函数，可以由编译器生成的函数包括：</p>\n<ul>\n<li>空构造函数</li>\n<li>拷贝构造函数</li>\n<li>拷贝赋值函数</li>\n<li>移动构造函数</li>\n<li>移动拷贝函数</li>\n<li>析构函数</li>\n</ul>\n<p>此外，编译器还为所有自定义类型提供以下全局默认操作符函数：</p>\n<ul>\n<li>operator, </li>\n<li>operator&amp;</li>\n<li>operator&amp;&amp;</li>\n<li>operator*</li>\n<li>operator-&gt;</li>\n<li>operator-&gt;*</li>\n<li>operator new</li>\n<li>operator delete</li>\n</ul>\n<h3 id=\"8-3-lambda函数\"><a href=\"#8-3-lambda函数\" class=\"headerlink\" title=\"8.3 lambda函数\"></a>8.3 lambda函数</h3><p>lambda语法：</p>\n<p>[&lt;捕获外部变量&gt;]&lt;(可选)mutable&gt;(&lt;(可选)参数列表&gt;) -&gt; &lt;(可选)返回值&gt; {&lt;函数体&gt;}</p>\n<ul>\n<li>捕获外部变量：变量需要用&amp;或者=开头来引用，直接写&amp;或者=后面不跟变量表示捕获所有外部变量，=表示按值捕获，&amp;表示引用捕获；</li>\n<li>mutable：labmda默认是内联的const函数，不可以修改任何捕获的外部的按值捕获的变量（因为目前lambda的语意其实和仿函数完全一致，在仿函数中，所有捕获的外部变量都是仿函数类的成员，因此const函数不可以修改类成员，到lambda这里变成了lambda不可以修改捕获变量），但是引用捕获的变量则可以修改（这个行为也是和仿函数一致的，const函数内可以调用任意成员引用的方法，修改其属性，因为将引用声明成const，和将指针声明成const类似，都仅仅是禁止修改引用本身，但并没有限制对引用或者指针指向的变量进行修改）。如果希望lambda不是一个const函数，就要添加mutable声明；</li>\n<li>参数列表：</li>\n<li>返回值：当能够从函数体中推测出明确的返回值类型时，可以忽略；</li>\n<li>函数体：</li>\n</ul>\n<h2 id=\"9-融入实际应用\"><a href=\"#9-融入实际应用\" class=\"headerlink\" title=\"9. 融入实际应用\"></a>9. 融入实际应用</h2><h3 id=\"9-1-对齐支持\"><a href=\"#9-1-对齐支持\" class=\"headerlink\" title=\"9.1 对齐支持\"></a>9.1 对齐支持</h3><p>C和C++都是具备直接操作底层硬件能力的语言，因此某些开发者会对数据结构的对齐方式特别关注。</p>\n<p>C++11规定了alignof和alignas关键字，前者可以查询某个类型的对齐方式（一般来说都是32位-4字节或者64位-8字节对齐），而后者可以规定某个自定义类的对齐方式。比如如果我们想要使用内联汇编的向量指令（可以同时处理4组处理器位数的数据）来优化处理速度，就可能想要将数据对齐到4*处理器位数的位置处。</p>\n<p>需要注意的是，之前很多编译器也规定了指定数据对齐方式的方式，比如GNU就规定可以使用如下方式规定对齐字节：<strong>attribute</strong>((<strong>aligned</strong>(8)))；</p>\n<p>需要注意的是，虽然标准规定了指定对齐的方式，但每个平台具体支持对齐到多少是不确定的。如果使用alignas(2^64)，那显然是不合法的。不幸的是，目前标准似乎没办法查询每个平台支持的最大对齐字节。不过一般来说我们也用不到太大的对齐字节。</p>\n<h3 id=\"9-2-通用属性\"><a href=\"#9-2-通用属性\" class=\"headerlink\" title=\"9.2 通用属性\"></a>9.2 通用属性</h3><p>有时C/C++提供的语言能力无法完全满足开发者的需求，编译器厂商为了解决这些问题，提供了一系列的语言扩展来扩展C/C++的语法。这其中最常见的就是“属性”，可以告诉编译器一个符号的额外信息，让编译器做一些语言规范之外的处理。</p>\n<ul>\n<li>GNU使用<strong>attribute</strong>((&lt;属性列表&gt;))来声明属性；</li>\n<li>Windows使用__declspec(&lt;属性列表&gt;)来声明属性</li>\n</ul>\n<p>C++11也规定了类似的属性，之所以在语言中添加属性，是为了避免再给C++增加更多的关键字。C++11的属性和之前各个平台的编译器实现的属性的目的是一致的，它们提供的能力都是一般用不到，可以忽略的能力，语言规范不会考虑使用关键字来实现这些能力，因此将它们定义到通用属性里。C++规定通用属性的写法是：[[&lt;属性列表&gt;]]，这样的通用属性可以用来修饰任何语言元素。不过目前C++11只定义了两个通用属性：[[noreturn]]和[[carries_dependency]]。</p>\n<h3 id=\"9-3-Unicode支持\"><a href=\"#9-3-Unicode支持\" class=\"headerlink\" title=\"9.3 Unicode支持\"></a>9.3 Unicode支持</h3><h4 id=\"9-3-1-字符集和编码\"><a href=\"#9-3-1-字符集和编码\" class=\"headerlink\" title=\"9.3.1 字符集和编码\"></a>9.3.1 字符集和编码</h4><p>ASCII码是最早的编码，使用7位二进制位来表示所有英文字母和在英文排版印刷中用到的字符，后来ISO和Unicode组织共同制定了一套能够唯一的表示世界上所有字符的标准字符集，称为ISO/Unicode字符集或者Unicode字符集。Unicode规定了每个字符在整个字符集中的具体值（范围0x0-0x10FFFFF），但并没有规定计算机中如何存储这样的值，UTF-8 UTF-16 UTF-32是Unicode字符集事实上的编码标准。</p>\n<p>UTF-8使用1～6字节的变长编码方式来编码Unicode，由于UTF-8较为节约存储空间，因此使用的比较广泛。</p>\n<img src=\"/Blog/posts/13007/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png\" class=\"\">\n\n<p><img src=\"%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C++11/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png\" alt=\"屏幕快照 2019-08-18 上午12.57.01.png\"></p>\n<p>GB2312早于Unicode被定义，是和Unicode不同的一种编码（不过Unicode汉字部分编码其实就是GB2312的变种），采用2字节表示一个中文字符，和Unicode不一样的是，GB2312既是字符集，又是字符编码。</p>\n<h4 id=\"9-3-2-C-中的Unicode支持\"><a href=\"#9-3-2-C-中的Unicode支持\" class=\"headerlink\" title=\"9.3.2 C++中的Unicode支持\"></a>9.3.2 C++中的Unicode支持</h4><p>C++98已经规定了wchar_t类型，但是C++98对wchar_t的定义不够明确，不同的编译器中wchar_t的位数不一致，导致移植性问题。</p>\n<p>C++11重新规定了char16_t char32_t，用于存储UTF-16 UTF-32编码的Unicode数据，UTF-8的数据则直接使用char来存储。C++中可以在字符串常量前加前缀来让编译器产生不同编码的数据：</p>\n<ul>\n<li>u8 - UTF8</li>\n<li>u - UTF-16</li>\n<li>U - UTF-32</li>\n<li>L - wchar_t</li>\n</ul>\n<p>之所以没有为UTF-8规定类型，是因为UTF-16和UTF-32都是定长编码，而UTF-8是变长编码（有误，过去某段时间Unicode还比较少，当时UTF16编码Unicode的确是事实上的定长编码，但现在Unicode字符集已经收录了更多字符，早已超出了UTF-16的表示范围，UTF-16已经成为了事实上的变长编码，一些历史程序如果还假定UTF-16是定长编码的话，遇到超出UTF-16表示范围的字符时就会出问题。），变长编码会导致很多算法变得极其复杂（比如无法确定一个utf_8[]中的第N个字符究竟被存储在数组中的哪个位置）。对于语言来说，定长编码处理起来更自然，且增加的内存占用和减少的程序设计复杂度也大体可以认为相互抵消，可以使用定长编码进行处理，需要保存时再存成变长编码以节省存储空间。</p>\n<p>C++中，影响Unicode字符能够正确保存和输出的因素有以下三点：</p>\n<ul>\n<li>文件编码</li>\n<li>编译器编码设置</li>\n<li>输出设备</li>\n</ul>\n<p>为了确保得到正确的输出，需要确保源文件的编码同系统编码一致、并且用于输出的设备支持被输出的编码（比如不少shell就只支持UTF-8编码，非UTF-8编码的会直接输出十六进制的编码值）。</p>\n<h4 id=\"9-3-3-标准库支持\"><a href=\"#9-3-3-标准库支持\" class=\"headerlink\" title=\"9.3.3 标准库支持\"></a>9.3.3 标准库支持</h4><p>C++11新增了几个字符类型，也同步地在标准库中新增了字符类型的转换函数。</p>\n","site":{"data":{"link":[{"class_name":"友情鏈接","class_desc":"那些人，那些事","link_list":[{"name":"JerryC","link":"https://jerryc.me/","avatar":"https://jerryc.me/image/avatar.png","descr":"今日事,今日畢"},{"name":"Hexo","link":"https://hexo.io/zh-tw/","avatar":"https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg","descr":"快速、簡單且強大的網誌框架"}]},{"class_name":"網站","class_desc":"值得推薦的網站","link_list":[{"name":"Youtube","link":"https://www.youtube.com/","avatar":"https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png","descr":"視頻網站"},{"name":"Weibo","link":"https://www.weibo.com/","avatar":"https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png","descr":"中國最大社交分享平台"},{"name":"Twitter","link":"https://twitter.com/","avatar":"https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png","descr":"社交分享平台"}]}]}},"excerpt":"","more":"<h1 id=\"深入理解C-11\"><a href=\"#深入理解C-11\" class=\"headerlink\" title=\"深入理解C++11\"></a><strong>深入理解C++11</strong></h1><h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1. 前言\"></a>1. 前言</h2><h3 id=\"1-1-说到C-11，应该想到什么？\"><a href=\"#1-1-说到C-11，应该想到什么？\" class=\"headerlink\" title=\"1.1 说到C++11，应该想到什么？\"></a>1.1 说到C++11，应该想到什么？</h3><ul>\n<li>什么是 lambda，及怎么样使用它是最好的？</li>\n<li>decltype 和 auto 类型推导有什么关系？</li>\n<li>什么是移动语义，以及(右值引用)是如何解决转发问题的？</li>\n<li>default/deleted 函数以及 override 是怎么回事?</li>\n<li>异常描述符被什么替代了? noexcept 是如何工作的?</li>\n<li>什么是原子类型以及新的内存模型?</li>\n<li>如何在 C++11 中做并行编程?</li>\n</ul>\n<h3 id=\"1-2-语言的哪些关键字和C-11有关？\"><a href=\"#1-2-语言的哪些关键字和C-11有关？\" class=\"headerlink\" title=\"1.2 语言的哪些关键字和C++11有关？\"></a>1.2 语言的哪些关键字和C++11有关？</h3><ul>\n<li>alignas</li>\n<li>alignof decltype</li>\n<li>auto(重新定义)</li>\n<li>static_assert</li>\n<li>using(重新定义)</li>\n<li>noexcept</li>\n<li>export(弃用，不过未来可能留作他用)</li>\n<li>nullptr</li>\n<li>constexpr</li>\n<li>thread_local</li>\n</ul>\n<h2 id=\"2-保证稳定性和兼容性\"><a href=\"#2-保证稳定性和兼容性\" class=\"headerlink\" title=\"2. 保证稳定性和兼容性\"></a>2. 保证稳定性和兼容性</h2><h3 id=\"2-1-将C99标准纳入C-11\"><a href=\"#2-1-将C99标准纳入C-11\" class=\"headerlink\" title=\"2.1 将C99标准纳入C++11\"></a>2.1 将C99标准纳入C++11</h3><h4 id=\"2-1-1-确定编译环境的预定义宏\"><a href=\"#2-1-1-确定编译环境的预定义宏\" class=\"headerlink\" title=\"2.1.1 确定编译环境的预定义宏\"></a>2.1.1 确定编译环境的预定义宏</h4><ul>\n<li>__STDC_HOSTED__：编译器的目标系统环境中是否包含完整的C库</li>\n<li>__STDC__：编译器对于标准C库的实现是否和C标准一致（是否定义、如何定义由编译器决定）</li>\n<li> __STDC_VERSION__：编译器支持的C标准的版本（是否定义、如何定义由编译器决定）</li>\n<li>__STDC_ISO_10646__：yyyymmL格式的整数常量，表示C++编译环境符合某个版本的ISO/IEC 10646标准</li>\n</ul>\n<h4 id=\"2-1-2-func-预定义标识符\"><a href=\"#2-1-2-func-预定义标识符\" class=\"headerlink\" title=\"2.1.2 func 预定义标识符\"></a>2.1.2 <strong>func</strong> 预定义标识符</h4><p>函数中可以使用__func__标识符函数名称，编译器会在函数定义开始时隐式地插入__func__标识符定义：</p>\n<blockquote>\n<p>static const char* <strong>func</strong> = “&lt;函数名称&gt;”;</p>\n</blockquote>\n<h4 id=\"2-1-3-Pragma-操作符\"><a href=\"#2-1-3-Pragma-操作符\" class=\"headerlink\" title=\"2.1.3 _Pragma 操作符\"></a>2.1.3 _Pragma 操作符</h4><p>在之前的C/C++标准中已经规定了可以使用#pragma预处理指令向编译器传递信息，比如可以通过在头文件首行放置#pragma once来告诉编译器这个头文件只应该被include一次。</p>\n<p>C++11中，规定了一个新的操作符_Pragma，它的作用与#pragma完全相同，_Pragma(“once”)就相当于#pragma once。但是，_Pragma由于是一个操作符而不是预处理指令，它的使用更为灵活，可以在宏中展开。</p>\n<h4 id=\"2-1-4-不定参数宏定义以及-VA-ARGS\"><a href=\"#2-1-4-不定参数宏定义以及-VA-ARGS\" class=\"headerlink\" title=\"2.1.4 不定参数宏定义以及 __VA_ARGS__\"></a>2.1.4 不定参数宏定义以及 __VA_ARGS__</h4><p>C99规定宏定义中，在参数列表的最后，可以使用…省略参数定义，而__VA_ARGS__可以用来替换被省略号代表的字符串。</p>\n<h4 id=\"2-1-5-宽窄字符串连接\"><a href=\"#2-1-5-宽窄字符串连接\" class=\"headerlink\" title=\"2.1.5 宽窄字符串连接\"></a>2.1.5 宽窄字符串连接</h4><h3 id=\"2-2-long-long整形\"><a href=\"#2-2-long-long整形\" class=\"headerlink\" title=\"2.2 long long整形\"></a>2.2 long long整形</h3><h3 id=\"2-3-扩展的整形\"><a href=\"#2-3-扩展的整形\" class=\"headerlink\" title=\"2.3 扩展的整形\"></a>2.3 扩展的整形</h3><h3 id=\"2-4-宏-cplusplus\"><a href=\"#2-4-宏-cplusplus\" class=\"headerlink\" title=\"2.4 宏__cplusplus\"></a>2.4 宏__cplusplus</h3><p>一般会和extern “C”配合使用，来让一个头文件即可以同时被include到C和C++中编译，使用extern “C”避免C++对符号名称进行重整，确保C++编译器编译出的目标文件中的符号名维持原样。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">// 一些代码</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-5-静态断言\"><a href=\"#2-5-静态断言\" class=\"headerlink\" title=\"2.5 静态断言\"></a>2.5 静态断言</h3><p>标准C库assert.h中，提供了assert函数来进行运行时的断言，表明某些情况一定不会发生。（在 C++ 中，程序员也可以定义宏 NDEBUG 来禁用 assert 宏。这对发布程序来说还是必 要的。因为程序用户对程序退出总是敏感的，而且部分的程序错误也未必会导致程序全部功 能失效。那么通过定义 NDEBUG 宏发布程序就可以尽量避免程序退出的状况。而当程序有 问题时，通过没有定义宏 NDEBUG 的版本，程序员则可以比较容易地找到出问题的位置。）</p>\n<p>如果希望在预处理时确定某些情况一定不会发生，也可以使用#if进行判断，使用#error终止编译流程并给出错误提示。</p>\n<p>C++11引入static_assert来补充编译时断言。之前Boost库也实现了类似的功能，它是利用编译器在编译时会检查除以0这个特性，如果条件为假就构建一个除以0的语句迫使编译器报错来实现的，虽然可以达成编译时检查的目的，但报错信息比较不明确。使用C++11的static_assert，在断言失败时，可以得到明确的错误提示。</p>\n<h3 id=\"2-6-noexcept修饰符与noexcept操作符\"><a href=\"#2-6-noexcept修饰符与noexcept操作符\" class=\"headerlink\" title=\"2.6 noexcept修饰符与noexcept操作符\"></a>2.6 noexcept修饰符与noexcept操作符</h3><h4 id=\"2-6-1-作为修饰符\"><a href=\"#2-6-1-作为修饰符\" class=\"headerlink\" title=\"2.6.1 作为修饰符\"></a>2.6.1 作为修饰符</h4><p>noexcept作为修饰符可以用来表明函数是否会抛出异常，noexcept修饰符后面可以跟随一个常量表达式，当常量表达式可以转为true时表示不会抛出异常，false则表示会抛出异常。被noexcept修饰符标记为不会抛出异常的函数如果运行时抛出异常，会直接导致程序调用std::terminate终止执行，异常不会继续沿栈传播。</p>\n<h4 id=\"2-6-2-作为操作符\"><a href=\"#2-6-2-作为操作符\" class=\"headerlink\" title=\"2.6.2 作为操作符\"></a>2.6.2 作为操作符</h4><p>noexcept作为操作符可以用来判断某个表达式是否会抛出异常。该操作符帮助我们在进行泛型编程时通过noexcept操作符判断一个依赖模板参数的表达式是否会抛出异常。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">fun</span><span class=\"params\">()</span> <span class=\"title\">noexcept</span><span class=\"params\">(<span class=\"keyword\">noexcept</span>(T()))</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-6-3-替代废弃的throw\"><a href=\"#2-6-3-替代废弃的throw\" class=\"headerlink\" title=\"2.6.3 替代废弃的throw\"></a>2.6.3 替代废弃的throw</h4><p>C++98曾经定义了throw修饰符，用来表明表达式是否会抛出异常，一个空的throw()就和noexcept(true)表达的意思一样，但throw要求明确指出会抛出哪些类型的异常，实际编程中大家很少需要了解异常类型，只希望了解是否会抛出异常，因此新的noexcept(false)用于替代throw(&lt;异常类型&gt;)。</p>\n<h3 id=\"2-7-快速初始化成员变量\"><a href=\"#2-7-快速初始化成员变量\" class=\"headerlink\" title=\"2.7 快速初始化成员变量\"></a>2.7 快速初始化成员变量</h3><p>C++98中，允许直接在类的静态常量整型成员声明时使用“=”对其初始化，这种声明+初始化的做法被叫做“就地”声明。这种声明方式很便捷，但仅能对【静态】【常量】【整型】成员进行这样的声明，使用场景很少，语法也不一致。</p>\n<p>C++11中允许对非静态成员进行就地的初始化，不再必须在构造函数中通过initializer-list进行初始化了。可以使用等号或者一对花括号{}进行就地初始化，其他形式无法通过编译。</p>\n<p>在成员同时使用就地初始化，并且在构造函数的初始化列表中进行初始化时，最终仅会以初始化列表为准对其进行初始化。</p>\n<h3 id=\"2-8-非静态成员的sizeof\"><a href=\"#2-8-非静态成员的sizeof\" class=\"headerlink\" title=\"2.8 非静态成员的sizeof\"></a>2.8 非静态成员的sizeof</h3><p>C++98中，sizeof可以作用于类的静态成员，但对于非静态成员，必须通过一个类实例来引用，因此之前为了获取一个非静态成员的大小，同时避免创建无用的类实例，通常会使用下面的技巧：</p>\n<blockquote>\n<p>sizeof(((People*)0)-&gt;hand);</p>\n</blockquote>\n<p>C++11后，sizeof可以直接作用于类成员表达式了，上面的技巧可以简化成：</p>\n<blockquote>\n<p>sizeof(People::hand)</p>\n</blockquote>\n<h3 id=\"2-9-扩展的friend语法\"><a href=\"#2-9-扩展的friend语法\" class=\"headerlink\" title=\"2.9 扩展的friend语法\"></a>2.9 扩展的friend语法</h3><p>在C++98，如果要指定另一个类是当前类的友元，必须要使用friend class/struct &lt;友元类&gt;这样的写法，并且无法使用模板参数作为友元类，C++11允许省略class，而且可以使用模板参数作为友元类。</p>\n<p><a href=\"https://zh.cppreference.com/w/cpp/language/friend\">https://zh.cppreference.com/w/cpp/language/friend</a></p>\n<h3 id=\"2-10-final-override\"><a href=\"#2-10-final-override\" class=\"headerlink\" title=\"2.10 final/override\"></a>2.10 final/override</h3><p>final用于在继承关系的中间终止一个虚函数被子类重载的可能性。override用于显式声明某个函数是父类虚函数的重载，提升了代码可读性和健壮性（因为virtual修饰符只有在顶级父类声明虚函数时才是必须的，子类为同名虚函数添加virtual修饰符会被忽略，而override修饰符会被编=‘译器检查以确保函数的确重载了虚函数）。它们都在函数声明的参数列表之后。</p>\n<p>为了尽可能兼容已有程序，C++11没有将final和override规定为关键字，因此可以在代码中使用final，override变量，但最好别这么做。</p>\n<h3 id=\"2-11-模板函数的默认模板参数\"><a href=\"#2-11-模板函数的默认模板参数\" class=\"headerlink\" title=\"2.11 模板函数的默认模板参数\"></a>2.11 模板函数的默认模板参数</h3><p>C++98允许为类模板参数指定默认参数，但却禁止为函数模板参数指定默认参数，语法上不一致，逻辑上不合理。</p>\n<p>C++11放宽了这一限制，可以为函数模板指定默认模板参数了。</p>\n<h3 id=\"2-12-外部模板\"><a href=\"#2-12-外部模板\" class=\"headerlink\" title=\"2.12 外部模板\"></a>2.12 外部模板</h3><p>C++中，如果多个源文件都使用了同一个模板，会对该模板进行多次实例化，但最后编译时，编译器会仅保留一份模板实例化产生的代码。在一些比较大的项目中，冗余的模板实例化会明显拖慢编译速度，可以使用“外部模板”技术告诉编译器不需要对模板进行实例化，在某一个源文件中仅进行一次显式实例化。</p>\n<blockquote>\n<p>template void fun<int>(int); // 显示地实例化</p>\n<p>extern template void fun<int>(int); // 外部模板的声明</p>\n</blockquote>\n<h3 id=\"2-13-局部和匿名类型作为模板实参\"><a href=\"#2-13-局部和匿名类型作为模板实参\" class=\"headerlink\" title=\"2.13 局部和匿名类型作为模板实参\"></a>2.13 局部和匿名类型作为模板实参</h3><p>C++98禁止局部或者匿名的类型作为模板参数，这个限制没什么道理，因此C++11放宽了该限制。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// C++98中，只有A或者a可以作为模板参数</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; a;</span><br><span class=\"line\"><span class=\"comment\">// 匿名类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; B;</span><br><span class=\"line\"><span class=\"comment\">// 匿名类型变量</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 局部类型</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">C</span> &#123;</span><span class=\"keyword\">int</span> a;&#125; c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-通用为本，专用为末\"><a href=\"#3-通用为本，专用为末\" class=\"headerlink\" title=\"3. 通用为本，专用为末\"></a>3. 通用为本，专用为末</h2><h3 id=\"3-1-继承构造函数\"><a href=\"#3-1-继承构造函数\" class=\"headerlink\" title=\"3.1 继承构造函数\"></a>3.1 继承构造函数</h3><p>继承关系中，子类可以自动或得父类的成员和接口，但构造函数无法自动地被子类继承。因为通常子类也有自己的成员，我们要定义子类自己的构造函数，在子类构造函数中去调用父类构造函数以及初始化自己的成员。</p>\n<p>但是，如果子类中没有任何成员，或者其成员都用C++11的新特性“快速初始化成员变量”进行了初始化乃至于没有必要再用构造函数初始化了，那这时候我们很可能希望直接将父类的构造函数继承到子类，毕竟这时候只需要初始化父类成员。C++11允许我们使用using &lt;父类名&gt;::&lt;父类名&gt;来将所有父类构造函数引入子类，被using引入的父类构造函数是隐式声明的（也就是说，只有用到的函数才会被生成，以节省生成的代码）。</p>\n<p>（书中这一节很多描述都和XCode实验现象对不上，很可能是因为成书时还无实验环境，导致描述有误）</p>\n<h3 id=\"3-2-委派构造函数\"><a href=\"#3-2-委派构造函数\" class=\"headerlink\" title=\"3.2 委派构造函数\"></a>3.2 委派构造函数</h3><p>可以在构造函数的initializer-list中调用另一个构造函数来完成构造，这种将构造委托给另一个构造函数的行为   就叫委派构造函数。</p>\n<p>一旦在initializer-list中进行了委派构造，就不能再用正常的initializer-list初始化成员变量了。因此，通常被委派的构造函数会负责初始化类的所有成员变量。</p>\n<h3 id=\"3-3-右值引用\"><a href=\"#3-3-右值引用\" class=\"headerlink\" title=\"3.3 右值引用\"></a>3.3 右值引用</h3><p>可以使用两个引用符号 &amp;&amp; 来声明并定义一个右值引用。和左值引用一样，右值引用的声明和定义必须在一块。</p>\n<p>在C++98中，已经对右值有了一些描述，C++11对右值进行了更进一步的定义：右值就是将亡值。</p>\n<p><strong>C++98中，可以使用常量左值引用来引用右值</strong>，比如：</p>\n<blockquote>\n<p>const MyCls &amp;myRef = getTemp();</p>\n</blockquote>\n<p>这样的常量左值引用的确引用了getTemp返回的临时变量，延长了它的声明周期，但由于C++98对于右值的定义是“不可被改变的常量”，因此之前只能使用对const的引用来引用右值。</p>\n<p>C++11改变了对右值的定义，因此使用C++11的右值引用方式引用的右值，其内容可以被修改。</p>\n<h3 id=\"3-4-移动语意\"><a href=\"#3-4-移动语意\" class=\"headerlink\" title=\"3.4 移动语意\"></a>3.4 移动语意</h3><p>在C++中，如果自定义类中含有指针，通常需要自定义拷贝构造函数和赋值运算符，在对指针进行赋值时，要为指针开辟新的堆内存，并将原指针内容拷贝过来，不要使用编译器生成的默认函数。因为默认函数在赋值时通通采用浅拷贝，会导致两个对象的指针指向同一地址，几乎一定会导致野指针问题。</p>\n<p>但是，有时候我们拷贝或赋值时，比如a = b，其中b如果是一个右值，那么直接将b的指针赋值给a，并且阻止b对象在析构函数被调用时释放指针内存，是更合适的做法。因此如果b是一个右值，这意味着b马上就要被析构了，与其为a的指针开辟一片内存，不如直接利用b的指针现在使用的内存。<strong>这种做法就被称作“移动”b的资源到a，也就是“移动语意”。</strong></p>\n<p>C++11中可以通过声明移动构造函数/赋值函数实现移动语意，这样的函数和普通函数的区别在于它们接受的参数类型是右值引用，因此当这样的函数被调用时，可以确保被引用的值马上就要被销毁，可以直接移动其资源。</p>\n<p>移动构造函数应该是不会抛出异常的，因为如果移动到一半被终止了，会导致对象的一部分指针成员变成悬挂指针。标准库提供了move_if_noexcept函数，它会判断对象是否实现了noexcept的移动构造函数，如果实现了才返回右值引用，不然就返回左值引用，避免使用移动语意，退化为使用普通的拷贝。</p>\n<h3 id=\"3-5-完美转发\"><a href=\"#3-5-完美转发\" class=\"headerlink\" title=\"3.5 完美转发\"></a>3.5 完美转发</h3><h4 id=\"3-5-1-右值引用的问题\"><a href=\"#3-5-1-右值引用的问题\" class=\"headerlink\" title=\"3.5.1 右值引用的问题\"></a>3.5.1 右值引用的问题</h4><p>有了右值引用，看起来我们可以完美地实现移动语意了，但是，需要留意的是，我们在将右值赋给一个右值引用后，这个右值引用其实会被当成一个左值引用（毕竟移动语意本身就要求对右值引用进行修改）！类似的，右值引用的成员也是一个左值。</p>\n<p>因此，在访问右值引用，或者在访问右值引用的成员时，必须将其转换成右值引用，否则就会被当成普通的左值引用。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 像这样的声明赋值没有意义，实际上，a依然会成为一个左值引用</span></span><br><span class=\"line\"><span class=\"comment\">// A &amp;&amp;a = getTemp();</span></span><br><span class=\"line\">A &amp;a = getTemp();</span><br><span class=\"line\">acceptRValueRef(<span class=\"built_in\">std</span>::move(a));  <span class=\"comment\">// OK，这里使用move把一个被当作左值引用的右值引用转成右值引用</span></span><br><span class=\"line\">accestRValueRef(<span class=\"built_in\">std</span>::forward&lt;A&gt;(a));    <span class=\"comment\">// OK，forward也能起到转为右值引用的作用</span></span><br></pre></td></tr></table></figure>\n<p>这个现象要求我们在创建移动构造函数时，必须要使用标准库<utility>中提供的std::move对右值引用的每一个成员转为右值引用，来保证移动语意。std::move会将其参数转化为一个右值引用。之所以可以进行这样的转换，是因为我们已经知道了拥有成员的对象是一个右值引用，既然成员对象的拥有者本身马上就要被销毁，那么成员对象也一定马上就会被销毁，此时将成员对象转为左值处理才是正确的。</p>\n<p>在将右值引用传入参数为右值引用的函数时，编译器会报错，因为右值引用实际上一旦被赋给引用变量，就会被当成左值引用。要让编译器重新将其重新当成一个右值引用，必须使用std::move，std::forward将其转成右值引用。</p>\n<h4 id=\"3-5-2-引用折叠\"><a href=\"#3-5-2-引用折叠\" class=\"headerlink\" title=\"3.5.2 引用折叠\"></a>3.5.2 引用折叠</h4><p>为了在模板编程时，让模板能够同时处理左值和右值引用，C++11引入了引用折叠的规则：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> MyClsLRef = MyCls&amp;;</span><br><span class=\"line\"><span class=\"keyword\">using</span> MyClsRRef = MyCls&amp;&amp;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// C++11中被引用折叠规则理解为左值引用</span></span><br><span class=\"line\">MyClsLRef&amp;&amp; lRef = getMyCls();</span><br><span class=\"line\"><span class=\"comment\">// 下面两行是一样的，其中第一行在C++11中被引用折叠规则理解为右值引用</span></span><br><span class=\"line\">MyClsRRef&amp;&amp; rRef = getMyCls();</span><br><span class=\"line\">MyClsRRef rRef = getMyCls();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 利用引用折叠规则，可以在模板编写中将参数声明为左值引用类型，这样的模板函数实际上可以同时接收</span></span><br><span class=\"line\"><span class=\"comment\">// 左值引用和右值引用</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(T&amp;&amp; t)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"><span class=\"comment\">// 当T是一个右值引用时，T&amp;&amp;&amp;&amp;被折叠成右值引用</span></span><br><span class=\"line\"><span class=\"comment\">// 当T是一个左值引用时，T&amp;&amp;&amp;被折叠成左值引用</span></span><br><span class=\"line\"><span class=\"comment\">// 不用考虑T不是一个引用，会有这样的考虑说明对C++不够熟悉，函数参数被声明为引用，传进来的肯定是引用</span></span><br></pre></td></tr></table></figure>\n<p>除了std::move，标准库还提供了std::forward，它的作用其实和std::move有重叠，都可以用来将变量转换为右值引用的。只不过它被规定应该专门用于“转发”场景，并且在调用时必须指定模板参数，从而可以利用引用折叠规则，将参数的左右值引用保留下来：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">A <span class=\"title\">getTemp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> A();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转发函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forwardToTest</span><span class=\"params\">(A&amp;&amp; a)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something</span></span><br><span class=\"line\"><span class=\"comment\">//    test(a);  无法通过编译，因为一旦右值引用被赋给变量，这个变量就表现成了左值引用</span></span><br><span class=\"line\">    test(<span class=\"built_in\">std</span>::forward&lt;A&amp;&amp;&gt;(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 转发函数</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">forwardToTestTemplate</span><span class=\"params\">(T&amp;&amp; a)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//    test(a);  同样无法通过编译</span></span><br><span class=\"line\">    test(<span class=\"built_in\">std</span>::forward&lt;T&gt;(a));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(T&amp;&amp; a)</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">          </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    forwardToTest(getTemp());</span><br><span class=\"line\">    forwardToTestTemplate(getTemp());</span><br><span class=\"line\">    A a;</span><br><span class=\"line\"><span class=\"comment\">//    forwardToTest(a); 无法通过编译，因为a不是右值引用</span></span><br><span class=\"line\">    forwardToTestTemplate(a);   <span class=\"comment\">// 可以通过编译，因为模板方法有引用折叠规则</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-move和forward的区别\"><a href=\"#3-6-move和forward的区别\" class=\"headerlink\" title=\"3.6 move和forward的区别\"></a>3.6 move和forward的区别</h3><ul>\n<li>move调用时不需要提供模板参数，它仅被用于将参数强制转为右值引用；</li>\n<li>forward调用时必须要提供模板参数，通常会提供这样的模板参数：forward&lt;T&amp;&amp;&gt;，这样的好处是T如果被声明为左值，转换后还是左值，T如果被声明为右值，转换后还是右值。</li>\n</ul>\n<h3 id=\"3-7-explicit-显示转换操作符\"><a href=\"#3-7-explicit-显示转换操作符\" class=\"headerlink\" title=\"3.7 explicit 显示转换操作符\"></a>3.7 explicit 显示转换操作符</h3><p>默认情况下，C++编译器会在函数调用的参数和函数声明不匹配时，想方设法地将参数转为匹配的类型，让函数调用能够通过，这中间会检查：</p>\n<ul>\n<li>实参的类型转换运算符，如果有转换为目标类型的转换运算符就调用；</li>\n<li>目标类型的构造函数，看是否有接收实参类型的构造函数，如果有就调用；</li>\n</ul>\n<p>有时这很方便，但更多场景下这样的行为只会导致语意上的混乱。为了避免编译器的隐式转换，可以使用explicit修饰类型转换运算符或构造函数，这样编译器就不会尝试使用对应函数进行转换。</p>\n<h3 id=\"3-8-initializer-list-初始化列表\"><a href=\"#3-8-initializer-list-初始化列表\" class=\"headerlink\" title=\"3.8 initializer_list 初始化列表\"></a>3.8 initializer_list 初始化列表</h3><h4 id=\"3-8-1-如何使用初始化列表\"><a href=\"#3-8-1-如何使用初始化列表\" class=\"headerlink\" title=\"3.8.1 如何使用初始化列表\"></a>3.8.1 如何使用初始化列表</h4><p>C++98中，仅允许使用initializer-list初始化数组，C++11扩展了initializer-list的概念，使得普通类型也可以使用initializer-list初始化（不要把它和类的成员初始化搞混，它们的确都叫initializer-list，要区分时，可以将类的成员初始化叫做member initializer list）：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a[]=&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;<span class=\"comment\">//C++98通过，C++11通过</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> b[]&#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>&#125;;<span class=\"comment\">//C++98失败，C++11通过</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; c&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>&#125;;<span class=\"comment\">//C++98失败，C++11通过</span></span><br><span class=\"line\"><span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>,<span class=\"keyword\">float</span>&gt; d = &#123;&#123;<span class=\"number\">1</span>,<span class=\"number\">1.0f</span>&#125;,&#123;<span class=\"number\">2</span>,<span class=\"number\">2.0f</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">3.2f</span>&#125;&#125;;<span class=\"comment\">//C++98失败，C++11通过</span></span><br></pre></td></tr></table></figure>\n<p>如果要让自定义的类支持这种初始化方式，只要声明一个接收在<initializer_list>中定义的initializer_list类型的构造函数就可以了。该类型是一个Iterable类型，可以使用begin, end等标准遍历方法。</p>\n<h3 id=\"3-8-2-防止类型收窄\"><a href=\"#3-8-2-防止类型收窄\" class=\"headerlink\" title=\"3.8.2 防止类型收窄\"></a>3.8.2 防止类型收窄</h3><p>使用初始化列表还可以促使编译器检查类型收窄的情况。初始化列表是目前唯一一种检查类型收窄的方式（不过事实上现在的大多数编译器在没有使用初始化列表时也会检查类型收窄并给出警告，但使用初始化列表编译器会直接给出错误）。</p>\n<h3 id=\"3-9-POD类型\"><a href=\"#3-9-POD类型\" class=\"headerlink\" title=\"3.9 POD类型\"></a>3.9 POD类型</h3><p>POD，也就是Plain Ordinary Data，纯数据类型。</p>\n<p>C++11对POD的定义是：平凡的，且是标准布局的。定义上，比C++98更宽容了，C++98只规定了C风格的struct是POD，但从POD的定义上，只要类对象布局是标准的，这样的类应该都是POD类。</p>\n<p>（但是，对POD定义得更宽容似乎并没有什么意义？C++11更多的是对于哪些情况会导致对象布局变化进行了更进一步的明确，只有不导致对象布局变化的类定义才是POD类。）</p>\n<h3 id=\"3-10-union-非受限联合体\"><a href=\"#3-10-union-非受限联合体\" class=\"headerlink\" title=\"3.10 union 非受限联合体\"></a>3.10 union 非受限联合体</h3><p>C++11将C++98对union的一些限制移除了。</p>\n<ul>\n<li>在C++98，union中只能包含基础类型和POD类型，并且不能包含静态方法，但在C++11中，union中可以包含任意非引用类型。</li>\n<li>C++11中，如果union任何一个成员拥有非平凡的构造函数，那么编译器就不会为union生成默认构造函数。</li>\n<li>C++11中，允许在类定义使用union声明成员变量，用这种方式声明的union不需要有类型名称，被称为匿名的非受限联合体，此时联合体内的所有成员都会自动的成为类的“变长成员”，即实际上它们共享同一处内存，应该只使用它们中的某一个。</li>\n</ul>\n<h3 id=\"3-11-用户定义字面量\"><a href=\"#3-11-用户定义字面量\" class=\"headerlink\" title=\"3.11 用户定义字面量\"></a>3.11 用户定义字面量</h3><h4 id=\"3-11-1-字面量操作符\"><a href=\"#3-11-1-字面量操作符\" class=\"headerlink\" title=\"3.11.1 字面量操作符\"></a>3.11.1 字面量操作符</h4><ul>\n<li>接收字符串：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(const char* col, size_t size)</li>\n<li>接收整数：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(unsigned long long val)</li>\n<li>接收整数，但整数越界，此时会传入’\\0’结尾的char<em>：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(const char</em>)</li>\n<li>接收浮点：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(long double val)</li>\n<li>接收字符：&lt;用户类型&gt; operator “” _&lt;后缀字符&gt;(char val)</li>\n</ul>\n<h3 id=\"3-12-内联名字空间\"><a href=\"#3-12-内联名字空间\" class=\"headerlink\" title=\"3.12 内联名字空间\"></a>3.12 内联名字空间</h3><p>C++11规定可以在namespace前加上inline，将名字空间默认导出到声明名字空间的作用域。</p>\n<p>这样的行为和C++98就有的匿名名字空间非常类似，除了内联名字空间有自己的名字以外。不过，它们被创建出来的目的是不同的：</p>\n<ul>\n<li>匿名名字空间在C++98中用于替代static修饰符，因为C++为类引入了static成员后，static的语意变得非常模糊且矛盾，因此在原本使用static声明文件作用域的变量的地方，可以改成使用匿名名字空间来包围这些变量起到同样的效果；</li>\n<li>内联名字空间则是被标准库用于和宏配合使用，根据当前编译环境决定默认导出同一个功能的哪一个版本的实现，这样做的好处是不关心具体实现的用户可以直接使用默认导出的功能，而了解更全面的细节的用户也可以使用名字空间来指定使用的是哪一个版本的功能。</li>\n</ul>\n<h3 id=\"3-13-使用using声明模板别名\"><a href=\"#3-13-使用using声明模板别名\" class=\"headerlink\" title=\"3.13 使用using声明模板别名\"></a>3.13 使用using声明模板别名</h3><p>在C++11中，已经可以使用using完全替代typedef了。</p>\n<p>using不仅有更清晰的语意，还可以部分声明模板参数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T&gt; <span class=\"keyword\">using</span> StringObjectMap = <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"built_in\">string</span>, T&gt;;</span><br><span class=\"line\">StringObjectMap&lt;MyCls&gt; myMap;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-14-SFINAE规则\"><a href=\"#3-14-SFINAE规则\" class=\"headerlink\" title=\"3.14 SFINAE规则\"></a>3.14 SFINAE规则</h3><p>SFINAE，就是Substitution Failure Is Not An Error。</p>\n<p>指的是，编译器在尝试模板参数匹配时，只要能够最终找到合适的匹配，中间尝试过的任何匹配失败都不会报错。</p>\n<p>只不过，C++98对于模板参数中使用表达式的情况支持的不友好，C++11明确了任何在编译期合法的表达式都能够作为模板参数，比如下面的这个例子就在C++98中无法通过编译，而在C++11中可以：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">int</span> I&gt; <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">A</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">xxx</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> <span class=\"title\">xxx</span><span class=\"params\">(<span class=\"keyword\">float</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">T</span>&gt;</span> <span class=\"function\">A&lt;<span class=\"title\">sizeof</span><span class=\"params\">(xxx((T)<span class=\"number\">0</span>))</span>&gt; <span class=\"title\">f</span><span class=\"params\">(T)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-新手易学，老兵易用\"><a href=\"#4-新手易学，老兵易用\" class=\"headerlink\" title=\"4. 新手易学，老兵易用\"></a>4. 新手易学，老兵易用</h2><h3 id=\"4-1-右尖括号的改进\"><a href=\"#4-1-右尖括号的改进\" class=\"headerlink\" title=\"4.1 右尖括号的改进\"></a>4.1 右尖括号的改进</h3><p>C++98曾经规定应该把 &gt;&gt; 优先判定为右移操作符，但这个规定在C++11被取消了，C++11规定编译器可以自行智能地判断&gt;&gt;是否是右移操作符。</p>\n<h3 id=\"4-2-auto类型推导\"><a href=\"#4-2-auto类型推导\" class=\"headerlink\" title=\"4.2 auto类型推导\"></a>4.2 auto类型推导</h3><p>在C++98中，auto其实是用于声明一个变量具有“自动存储期”，但实际上除了static以外的变量都是默认具有自动存储期的，因此过去的auto几乎没有人使用。</p>\n<p>C++11中，auto被赋予了新的含义，以前的auto含义被取消了。auto成为了新的类型指示符，auto声明的变量的类型必须在编译期由编译器推导出来。</p>\n<h3 id=\"4-3-decltype\"><a href=\"#4-3-decltype\" class=\"headerlink\" title=\"4.3 decltype\"></a>4.3 decltype</h3><p>decltype是在编译时对表达式进行类型推导，推导出的类型可用于定义新的变量。decltype主要是为了解决泛型编程中由于泛型参数类型不确定，导致和泛型参数相关的表达式类型无法确定的问题的。比如：</p>\n<p>t1是泛型Type1类型，t2是泛型Type2类型，由于开发泛型代码时无法确定Type1和Type2的类型，自然无法确定t1 + t2的类型，但该类型其实是可以由编译器推导出来的，decltype如今即可用在此处：</p>\n<p>auto add(t1, t2) -&gt; decltype(t1 + t2) {return t1 + t2;}</p>\n<p>或者可以声明原本无法声明的变量：decltype(t1 + t2) addResult = t1 + t2;（当然，auto也可以完成此工作）。</p>\n<p>有时会将decltype和auto搭配使用：decltype(auto)。这是因为一方面，我们希望依赖C++11的类型推导能力（auto的作用），但另一方面，又想保留cv限定符和引用（decltype的作用）（auto的类型推导规则和模板类似，如果不把auto声明为auto&amp;或者auto<em>，auto就会被视为不具备cv限定符的值类型，如果auto被声明为auto&amp;或者auto</em>，auto推导出的类型才会保留cv限定符）。但是使用这样的写法时要小心：decltype在推导类型时，如果表达式是一个简单的名字，它会推导出名字的类型，但如果表达式不只是一个名字，比如decltype((x))，那么即使x只是一个int，该decltype也会推导出引用类型：int&amp;。</p>\n<h3 id=\"4-4-追踪返回类型\"><a href=\"#4-4-追踪返回类型\" class=\"headerlink\" title=\"4.4 追踪返回类型\"></a>4.4 追踪返回类型</h3><p>auto func(char* a,int b) -&gt; int;</p>\n<h3 id=\"4-5-基于范围的for循环\"><a href=\"#4-5-基于范围的for循环\" class=\"headerlink\" title=\"4.5 基于范围的for循环\"></a>4.5 基于范围的for循环</h3><p>自定义集合类型要想支持这样的for循环，需要实现begin, end, ++, ==四个函数。</p>\n<h2 id=\"5-提高类型安全\"><a href=\"#5-提高类型安全\" class=\"headerlink\" title=\"5. 提高类型安全\"></a>5. 提高类型安全</h2><h3 id=\"5-1-强类型枚举\"><a href=\"#5-1-强类型枚举\" class=\"headerlink\" title=\"5.1 强类型枚举\"></a>5.1 强类型枚举</h3><p>C++98: enum X {…};</p>\n<p>C++11: enum class X {…};</p>\n<h3 id=\"5-2-堆内存管理：智能指针与垃圾回收\"><a href=\"#5-2-堆内存管理：智能指针与垃圾回收\" class=\"headerlink\" title=\"5.2 堆内存管理：智能指针与垃圾回收\"></a>5.2 堆内存管理：智能指针与垃圾回收</h3><h2 id=\"6-提高性能及操作硬件的能力\"><a href=\"#6-提高性能及操作硬件的能力\" class=\"headerlink\" title=\"6. 提高性能及操作硬件的能力\"></a>6. 提高性能及操作硬件的能力</h2><h3 id=\"6-1-常量表达式\"><a href=\"#6-1-常量表达式\" class=\"headerlink\" title=\"6.1 常量表达式\"></a>6.1 常量表达式</h3><p>C++11规定使用constexpr修饰符来修饰常量表达式。常量表达式可以是函数或者值。常量表达式函数中不可以出现非常量表达式。常量表达式可以在编译期使用，但如果常量表达式并没有一定要在编译期被计算出来，标准规定编译器在这种情况下可以将常量表达式编译成普通的表达式，表达式会在运行时被计算。</p>\n<h3 id=\"6-2-变长模板\"><a href=\"#6-2-变长模板\" class=\"headerlink\" title=\"6.2 变长模板\"></a>6.2 变长模板</h3><p>过去，C++可以使用C风格的方法来实现可变参函数，但这种实现方式是类型不安全的。</p>\n<p>现在，C++11为可变参函数提出了更合理（类型安全）的解决方案：变长模板。可以使用变长模板来声明变长模板函数或者变长模板类。</p>\n<h3 id=\"6-3-模板参数包与递归\"><a href=\"#6-3-模板参数包与递归\" class=\"headerlink\" title=\"6.3 模板参数包与递归\"></a>6.3 模板参数包与递归</h3><p>使用template &lt;typename… Elements&gt;这种方式可以声明一个变长模板参数，使用Elements…这种方式可以将变长模板参数展开成实际的多个参数类型；</p>\n<p>不定长的变长模板类可以通过模板类的递归来解包：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Elements&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span>;</span>    <span class=\"comment\">// 变长模板声明</span></span><br><span class=\"line\"><span class=\"comment\">// 以下是两个模板偏特化定义，利用模板偏特化会被优先匹配的规则，让变长模板参数递归地被解包</span></span><br><span class=\"line\"><span class=\"comment\">// 对于类型，可以使用递归的继承</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Head, <span class=\"keyword\">typename</span>... Tail&gt; </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span> &lt;</span>Head, Tail...&gt; : <span class=\"keyword\">private</span> tuple&lt;Tail...&gt; &#123;</span><br><span class=\"line\">    Head head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">tuple</span> &#123;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对于函数，可以使用递归的函数调用</span></span><br><span class=\"line\"><span class=\"comment\">// 下面实现一个更强大的Printf，不论%后面跟的是什么符号，这个Printf总是会打印正确的类型</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Printf</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*s == <span class=\"string\">&#x27;%&#x27;</span> &amp;&amp; ++s != <span class=\"string\">&#x27;%&#x27;</span>) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">throw</span> runtime_error(<span class=\"string\">&quot;invalide format&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span>... Args&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Printf</span><span class=\"params\">(<span class=\"keyword\">char</span>* s, T value, Args... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(*s) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*s == <span class=\"string\">&#x27;%&#x27;</span> &amp;&amp; *s++ != <span class=\"string\">&#x27;%&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Printf(++s, args...);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; *s++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若百分号的数量和参数数量对不上，就抛异常</span></span><br><span class=\"line\">    <span class=\"keyword\">throw</span> runtime_error(<span class=\"string\">&quot;extra arguments provided&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-进阶\"><a href=\"#7-进阶\" class=\"headerlink\" title=\"7. 进阶\"></a>7. 进阶</h2><h3 id=\"7-1-引用类型\"><a href=\"#7-1-引用类型\" class=\"headerlink\" title=\"7.1 引用类型\"></a>7.1 引用类型</h3><p>定义了模板参数包后，还可以在展开模板参数包时使用引用标记：Args&amp;&amp;…，这样的写法是合法的；</p>\n<h3 id=\"7-2-特殊展开\"><a href=\"#7-2-特殊展开\" class=\"headerlink\" title=\"7.2 特殊展开\"></a>7.2 特殊展开</h3><p>解包时，有些非常特殊的规则，需要特别说明一下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span>... Args&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCls</span>:</span> <span class=\"keyword\">private</span> A&lt;Args&gt;... &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 上面的表达式在解包时会解包成多继承：</span></span><br><span class=\"line\">T&lt;Parent1, Parent2&gt;  t; <span class=\"comment\">// t的类型是：class MyCls: private A&lt;Parent1&gt;, A&lt;Parent2&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Args...&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyCls</span>:</span> <span class=\"keyword\">private</span> A&lt;Args...&gt; &#123;&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 而这个表达式在解包时，会在泛型参数表达式中直接展开</span></span><br><span class=\"line\">T&lt;Parent1, Parent2&gt;  t; <span class=\"comment\">// t的类型是：class MyCls: private A&lt;Parent1, Parent2&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> Args...&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test</span><span class=\"params\">(Args... args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 下面这个会被展开成call(a(arg1), a(arg2), ...)</span></span><br><span class=\"line\">    call(a(args)...);</span><br><span class=\"line\">    <span class=\"comment\">// 而下面这个会被展开成call(a(arg1, arg2, ...))</span></span><br><span class=\"line\">    call(a(args...));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"7-3-获取变长参数包长度\"><a href=\"#7-3-获取变长参数包长度\" class=\"headerlink\" title=\"7.3 获取变长参数包长度\"></a>7.3 获取变长参数包长度</h3><p>可以使用sizeof…获取模板参数包的长度；</p>\n<h3 id=\"7-4-模板的模板（的模板的模板…）\"><a href=\"#7-4-模板的模板（的模板的模板…）\" class=\"headerlink\" title=\"7.4 模板的模板（的模板的模板…）\"></a>7.4 模板的模板（的模板的模板…）</h3><p>变长参数的模板类型本身也可以是一个模板，这一点和以前的非变长模板参数一样。</p>\n<h3 id=\"7-5-原子类型和原子操作\"><a href=\"#7-5-原子类型和原子操作\" class=\"headerlink\" title=\"7.5 原子类型和原子操作\"></a>7.5 原子类型和原子操作</h3><p>C++11以前，已经有很多使用多线程能力的C++程序了，但之前语言本身并没有定义任何同多线程有关的内容，这些多线程能力来自于多线程接口pthread。pthread是一套C的接口。</p>\n<p>通常情况下，如果我们不需要太精细的互斥控制，可以直接使用posix提供的mutex互斥锁API，而如果想达到更优化的性能，可能会考虑为不同处理器编写内敛汇编代码。</p>\n<p>C++11标准为多线程程序在标准库中添加了原子类型，并允许指定原子类型的内存访问顺序一致性，让开发者可以不必操心操作系统和处理器的底层细节，也可以获得最优化的性能。</p>\n<h3 id=\"7-6-线程局部存储\"><a href=\"#7-6-线程局部存储\" class=\"headerlink\" title=\"7.6 线程局部存储\"></a>7.6 线程局部存储</h3><p>C++11定义了thread_local关键字来定义线程局部存储变量，这样的变量生命期是线程启动到线程结束，除了本线程外，没有其他线程可以访问到这样的变量。</p>\n<p>C++11仅规定了线程局部存储的行为，而没有规定其具体实现，不同的编译器在不同的环境中可能会有不同的实现方式。</p>\n<h3 id=\"7-7-快速退出：quick-exit-at-quick-exit\"><a href=\"#7-7-快速退出：quick-exit-at-quick-exit\" class=\"headerlink\" title=\"7.7 快速退出：quick_exit, at_quick_exit\"></a>7.7 快速退出：quick_exit, at_quick_exit</h3><p>在过去，大体上有三种退出程序的方式：terminate(), abort(), exit()。</p>\n<ul>\n<li>terminate是有未处理的异常时会被调用的方法，可以使用set_terminate方法更改默认行为，terminate默认调用abort；</li>\n<li>abort是进程不得不终止时，被调用的函数，它会向本进程发送一个SIGABRT信号，该信号默认会导致操作系统直接释放该进程的所有资源并终止进程；</li>\n<li>exit是进程自发调用的退出函数，它代表着进程运行到了某个节点，该退出了，它会导致每一个自动变量的析构函数被调用（是的，仅自动变量，也就是栈变量会被调用析构函数，至于单例什么的需要自己处理），并调用at_exit注册的函数，然后才会回收进程；</li>\n</ul>\n<p>C++11新增了quick_exit标准方法，该方法语意上和exit一样，都是程序自发终止，但和exit不同的是，它不会进行本进程的清理工作，在多线程环境下也不会先等待线程结束，而是直接让操作系统终止进程并回收资源。</p>\n<h2 id=\"8-为改变思想方式而改变\"><a href=\"#8-为改变思想方式而改变\" class=\"headerlink\" title=\"8. 为改变思想方式而改变\"></a>8. 为改变思想方式而改变</h2><h3 id=\"8-1-指针空值-nullptr\"><a href=\"#8-1-指针空值-nullptr\" class=\"headerlink\" title=\"8.1 指针空值-nullptr\"></a>8.1 指针空值-nullptr</h3><p>C++11定义了nullptr_t和nullptr，前者是类型，后者是该类型的值。</p>\n<p>nullptr可以隐式转换为任何指针，但无法被隐式转换为bool类型，无法使用if (nullptr)这样的表达式；此外它所属的nullptr_t是一个基础类型，nullptr无法被推导为T*这样的模板参数。</p>\n<h3 id=\"8-2-默认函数的控制\"><a href=\"#8-2-默认函数的控制\" class=\"headerlink\" title=\"8.2 默认函数的控制\"></a>8.2 默认函数的控制</h3><p>C++11规定可以使用 = default 来使编译器生成默认版本的成员函数，可以由编译器生成的函数包括：</p>\n<ul>\n<li>空构造函数</li>\n<li>拷贝构造函数</li>\n<li>拷贝赋值函数</li>\n<li>移动构造函数</li>\n<li>移动拷贝函数</li>\n<li>析构函数</li>\n</ul>\n<p>此外，编译器还为所有自定义类型提供以下全局默认操作符函数：</p>\n<ul>\n<li>operator, </li>\n<li>operator&amp;</li>\n<li>operator&amp;&amp;</li>\n<li>operator*</li>\n<li>operator-&gt;</li>\n<li>operator-&gt;*</li>\n<li>operator new</li>\n<li>operator delete</li>\n</ul>\n<h3 id=\"8-3-lambda函数\"><a href=\"#8-3-lambda函数\" class=\"headerlink\" title=\"8.3 lambda函数\"></a>8.3 lambda函数</h3><p>lambda语法：</p>\n<p>[&lt;捕获外部变量&gt;]&lt;(可选)mutable&gt;(&lt;(可选)参数列表&gt;) -&gt; &lt;(可选)返回值&gt; {&lt;函数体&gt;}</p>\n<ul>\n<li>捕获外部变量：变量需要用&amp;或者=开头来引用，直接写&amp;或者=后面不跟变量表示捕获所有外部变量，=表示按值捕获，&amp;表示引用捕获；</li>\n<li>mutable：labmda默认是内联的const函数，不可以修改任何捕获的外部的按值捕获的变量（因为目前lambda的语意其实和仿函数完全一致，在仿函数中，所有捕获的外部变量都是仿函数类的成员，因此const函数不可以修改类成员，到lambda这里变成了lambda不可以修改捕获变量），但是引用捕获的变量则可以修改（这个行为也是和仿函数一致的，const函数内可以调用任意成员引用的方法，修改其属性，因为将引用声明成const，和将指针声明成const类似，都仅仅是禁止修改引用本身，但并没有限制对引用或者指针指向的变量进行修改）。如果希望lambda不是一个const函数，就要添加mutable声明；</li>\n<li>参数列表：</li>\n<li>返回值：当能够从函数体中推测出明确的返回值类型时，可以忽略；</li>\n<li>函数体：</li>\n</ul>\n<h2 id=\"9-融入实际应用\"><a href=\"#9-融入实际应用\" class=\"headerlink\" title=\"9. 融入实际应用\"></a>9. 融入实际应用</h2><h3 id=\"9-1-对齐支持\"><a href=\"#9-1-对齐支持\" class=\"headerlink\" title=\"9.1 对齐支持\"></a>9.1 对齐支持</h3><p>C和C++都是具备直接操作底层硬件能力的语言，因此某些开发者会对数据结构的对齐方式特别关注。</p>\n<p>C++11规定了alignof和alignas关键字，前者可以查询某个类型的对齐方式（一般来说都是32位-4字节或者64位-8字节对齐），而后者可以规定某个自定义类的对齐方式。比如如果我们想要使用内联汇编的向量指令（可以同时处理4组处理器位数的数据）来优化处理速度，就可能想要将数据对齐到4*处理器位数的位置处。</p>\n<p>需要注意的是，之前很多编译器也规定了指定数据对齐方式的方式，比如GNU就规定可以使用如下方式规定对齐字节：<strong>attribute</strong>((<strong>aligned</strong>(8)))；</p>\n<p>需要注意的是，虽然标准规定了指定对齐的方式，但每个平台具体支持对齐到多少是不确定的。如果使用alignas(2^64)，那显然是不合法的。不幸的是，目前标准似乎没办法查询每个平台支持的最大对齐字节。不过一般来说我们也用不到太大的对齐字节。</p>\n<h3 id=\"9-2-通用属性\"><a href=\"#9-2-通用属性\" class=\"headerlink\" title=\"9.2 通用属性\"></a>9.2 通用属性</h3><p>有时C/C++提供的语言能力无法完全满足开发者的需求，编译器厂商为了解决这些问题，提供了一系列的语言扩展来扩展C/C++的语法。这其中最常见的就是“属性”，可以告诉编译器一个符号的额外信息，让编译器做一些语言规范之外的处理。</p>\n<ul>\n<li>GNU使用<strong>attribute</strong>((&lt;属性列表&gt;))来声明属性；</li>\n<li>Windows使用__declspec(&lt;属性列表&gt;)来声明属性</li>\n</ul>\n<p>C++11也规定了类似的属性，之所以在语言中添加属性，是为了避免再给C++增加更多的关键字。C++11的属性和之前各个平台的编译器实现的属性的目的是一致的，它们提供的能力都是一般用不到，可以忽略的能力，语言规范不会考虑使用关键字来实现这些能力，因此将它们定义到通用属性里。C++规定通用属性的写法是：[[&lt;属性列表&gt;]]，这样的通用属性可以用来修饰任何语言元素。不过目前C++11只定义了两个通用属性：[[noreturn]]和[[carries_dependency]]。</p>\n<h3 id=\"9-3-Unicode支持\"><a href=\"#9-3-Unicode支持\" class=\"headerlink\" title=\"9.3 Unicode支持\"></a>9.3 Unicode支持</h3><h4 id=\"9-3-1-字符集和编码\"><a href=\"#9-3-1-字符集和编码\" class=\"headerlink\" title=\"9.3.1 字符集和编码\"></a>9.3.1 字符集和编码</h4><p>ASCII码是最早的编码，使用7位二进制位来表示所有英文字母和在英文排版印刷中用到的字符，后来ISO和Unicode组织共同制定了一套能够唯一的表示世界上所有字符的标准字符集，称为ISO/Unicode字符集或者Unicode字符集。Unicode规定了每个字符在整个字符集中的具体值（范围0x0-0x10FFFFF），但并没有规定计算机中如何存储这样的值，UTF-8 UTF-16 UTF-32是Unicode字符集事实上的编码标准。</p>\n<p>UTF-8使用1～6字节的变长编码方式来编码Unicode，由于UTF-8较为节约存储空间，因此使用的比较广泛。</p>\n<img src=\"/Blog/posts/13007/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png\" class=\"\">\n\n<p><img src=\"%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3C++11/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png\" alt=\"屏幕快照 2019-08-18 上午12.57.01.png\"></p>\n<p>GB2312早于Unicode被定义，是和Unicode不同的一种编码（不过Unicode汉字部分编码其实就是GB2312的变种），采用2字节表示一个中文字符，和Unicode不一样的是，GB2312既是字符集，又是字符编码。</p>\n<h4 id=\"9-3-2-C-中的Unicode支持\"><a href=\"#9-3-2-C-中的Unicode支持\" class=\"headerlink\" title=\"9.3.2 C++中的Unicode支持\"></a>9.3.2 C++中的Unicode支持</h4><p>C++98已经规定了wchar_t类型，但是C++98对wchar_t的定义不够明确，不同的编译器中wchar_t的位数不一致，导致移植性问题。</p>\n<p>C++11重新规定了char16_t char32_t，用于存储UTF-16 UTF-32编码的Unicode数据，UTF-8的数据则直接使用char来存储。C++中可以在字符串常量前加前缀来让编译器产生不同编码的数据：</p>\n<ul>\n<li>u8 - UTF8</li>\n<li>u - UTF-16</li>\n<li>U - UTF-32</li>\n<li>L - wchar_t</li>\n</ul>\n<p>之所以没有为UTF-8规定类型，是因为UTF-16和UTF-32都是定长编码，而UTF-8是变长编码（有误，过去某段时间Unicode还比较少，当时UTF16编码Unicode的确是事实上的定长编码，但现在Unicode字符集已经收录了更多字符，早已超出了UTF-16的表示范围，UTF-16已经成为了事实上的变长编码，一些历史程序如果还假定UTF-16是定长编码的话，遇到超出UTF-16表示范围的字符时就会出问题。），变长编码会导致很多算法变得极其复杂（比如无法确定一个utf_8[]中的第N个字符究竟被存储在数组中的哪个位置）。对于语言来说，定长编码处理起来更自然，且增加的内存占用和减少的程序设计复杂度也大体可以认为相互抵消，可以使用定长编码进行处理，需要保存时再存成变长编码以节省存储空间。</p>\n<p>C++中，影响Unicode字符能够正确保存和输出的因素有以下三点：</p>\n<ul>\n<li>文件编码</li>\n<li>编译器编码设置</li>\n<li>输出设备</li>\n</ul>\n<p>为了确保得到正确的输出，需要确保源文件的编码同系统编码一致、并且用于输出的设备支持被输出的编码（比如不少shell就只支持UTF-8编码，非UTF-8编码的会直接输出十六进制的编码值）。</p>\n<h4 id=\"9-3-3-标准库支持\"><a href=\"#9-3-3-标准库支持\" class=\"headerlink\" title=\"9.3.3 标准库支持\"></a>9.3.3 标准库支持</h4><p>C++11新增了几个字符类型，也同步地在标准库中新增了字符类型的转换函数。</p>\n"}],"PostAsset":[{"_id":"source/_posts/cloud_md/Jenkinsfile introduce/image-20200729094356824.png","post":"ckns3cr5p0007w9q9g0zgh8cn","slug":"image-20200729094356824.png","modified":1,"renderable":1},{"_id":"source/_posts/cloud_md/Jenkinsfile introduce/image2018-3-19_16-58-55.png","post":"ckns3cr5p0007w9q9g0zgh8cn","slug":"image2018-3-19_16-58-55.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130449855-404730543.png","post":"ckns3cr5q000bw9q9cwzkh50f","slug":"952033-20190505130449855-404730543.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130535776-1276148478.png","post":"ckns3cr5q000bw9q9cwzkh50f","slug":"952033-20190505130535776-1276148478.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130619082-1720959137.png","post":"ckns3cr5q000bw9q9cwzkh50f","slug":"952033-20190505130619082-1720959137.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130707783-39205152.png","post":"ckns3cr5q000bw9q9cwzkh50f","slug":"952033-20190505130707783-39205152.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang flag包简介/952033-20190505130753330-702637440.png","post":"ckns3cr5q000bw9q9cwzkh50f","slug":"952033-20190505130753330-702637440.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang flag包简介/copycode.gif","post":"ckns3cr5q000bw9q9cwzkh50f","slug":"copycode.gif","modified":1,"renderable":1},{"_id":"source/_posts/go_md/用Go编写HTTP服务器/image-20210331100841458.png","post":"ckns3cr5u000ow9q9esbdfdfx","slug":"image-20210331100841458.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTto","post":"ckns3cr5v000uw9q9ant8barb","slug":"bVbGTto","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTuK","post":"ckns3cr5v000uw9q9ant8barb","slug":"bVbGTuK","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTuM","post":"ckns3cr5v000uw9q9ant8barb","slug":"bVbGTuM","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/bVbGTux","post":"ckns3cr5v000uw9q9ant8barb","slug":"bVbGTux","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160629256.png","post":"ckns3cr5v000uw9q9ant8barb","slug":"image-20210330160629256.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160649541.png","post":"ckns3cr5v000uw9q9ant8barb","slug":"image-20210330160649541.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160708936.png","post":"ckns3cr5v000uw9q9ant8barb","slug":"image-20210330160708936.png","modified":1,"renderable":1},{"_id":"source/_posts/go_md/Golang net包简介/image-20210330160725275.png","post":"ckns3cr5v000uw9q9ant8barb","slug":"image-20210330160725275.png","modified":1,"renderable":1},{"_id":"source/_posts/python_md/Python学习之整数比较/int.png","post":"ckns3cr5x0016w9q9g031b257","slug":"int.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/1cb5ae3625df65f6dd793016bd6ba1b8.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"1cb5ae3625df65f6dd793016bd6ba1b8.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/29b980e2bc932adf7464c8f17c5302cd.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"29b980e2bc932adf7464c8f17c5302cd.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/36bf84b3afa4158dd7d0aff0ee6e7a85.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"36bf84b3afa4158dd7d0aff0ee6e7a85.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/5ab2c7d479df91a760c9d4a5a3c910a8.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"5ab2c7d479df91a760c9d4a5a3c910a8.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/67b8b0eb1f1a2653847f192d3419f03d.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"67b8b0eb1f1a2653847f192d3419f03d.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/6bac3d6ecb4de4fb911fdea52ac3b685.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"6bac3d6ecb4de4fb911fdea52ac3b685.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/795f16a399b397a69fe06e8feaea5cbd.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"795f16a399b397a69fe06e8feaea5cbd.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/8d12750add3c38f5500d3df3ce376fd3.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"8d12750add3c38f5500d3df3ce376fd3.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/af59ab58bba48a1b8eb5365af15a3713.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"af59ab58bba48a1b8eb5365af15a3713.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bcf035cdda2f9ec3b303a4246f873571.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"bcf035cdda2f9ec3b303a4246f873571.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/bf51de614427cbe876e34154c0d163ed.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"bf51de614427cbe876e34154c0d163ed.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/c64bae7e63e732efcd28ab9f5698094a.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"c64bae7e63e732efcd28ab9f5698094a.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/f20c49b0c9978b8ef05c5f21b3086abb.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"f20c49b0c9978b8ef05c5f21b3086abb.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/asm goto与JUMP_LABEL/fff4bc0460b6a42964f0707e37e2fdfc.png","post":"ckns3cr60001jw9q931gzhrtm","slug":"fff4bc0460b6a42964f0707e37e2fdfc.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215011301.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215011301.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215025345.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215025345.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215041892.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215041892.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215049945.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215049945.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215056849.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215056849.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215103876.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215103876.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215112625.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215112625.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215118480.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215118480.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215127651.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215127651.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215135031.jpeg","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215135031.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215142219.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215142219.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215150439.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215150439.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215157588.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215157588.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215203155.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215203155.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215211094.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215211094.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215219100.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215219100.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215225519.jpeg","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215225519.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215235412.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215235412.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215243422.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215243422.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215249606.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215249606.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215257440.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215257440.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215306929.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215306929.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215333648.jpeg","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215333648.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215340645.jpeg","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215340645.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215351143.jpeg","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215351143.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215504370.gif","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215504370.gif","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215512581.jpeg","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215512581.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215521174.gif","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215521174.gif","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215527335.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215527335.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215535838.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215535838.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215545396.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215545396.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215552177.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215552177.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215600171.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215600171.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215607387.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215607387.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215615006.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215615006.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215624632.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215624632.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215631492.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215631492.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215637250.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215637250.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png-20210408215645563.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png-20210408215645563.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.gif","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png.gif","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.jpeg","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png.jpeg","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/世上最好的共享内存/format,png.png","post":"ckns3cr60001mw9q92q41a30q","slug":"format,png.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Makefile/automake基础/Makefile基础.png","post":"ckns3cr64002bw9q93zfr149h","slug":"Makefile基础.png","modified":1,"renderable":1},{"_id":"source/_posts/tips_md/怎么修改Logic K580的快捷键/k580.png","post":"ckns3cr62001uw9q9eunz4off","slug":"k580.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0af65e9d09c34b96890eba35cecb648b.png","post":"ckns3cr620021w9q981wk5ffk","slug":"0af65e9d09c34b96890eba35cecb648b.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/0e672cd9bd994dc285f89e617c06305b.png","post":"ckns3cr620021w9q981wk5ffk","slug":"0e672cd9bd994dc285f89e617c06305b.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/1fce6c5c621b4fd09919e87f52c59801.png","post":"ckns3cr620021w9q981wk5ffk","slug":"1fce6c5c621b4fd09919e87f52c59801.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/277dafd9086b4d148de8b617f9252b62.png","post":"ckns3cr620021w9q981wk5ffk","slug":"277dafd9086b4d148de8b617f9252b62.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/36e34f1760bb4ac6a3192f57d58264ca.png","post":"ckns3cr620021w9q981wk5ffk","slug":"36e34f1760bb4ac6a3192f57d58264ca.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5013388ec46043c59f4fb4b3e373e955.png","post":"ckns3cr620021w9q981wk5ffk","slug":"5013388ec46043c59f4fb4b3e373e955.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/539b3cebc6034a6187bb941433906a9a.png","post":"ckns3cr620021w9q981wk5ffk","slug":"539b3cebc6034a6187bb941433906a9a.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/5a7596802fc1411bbbca9f481cc42913.png","post":"ckns3cr620021w9q981wk5ffk","slug":"5a7596802fc1411bbbca9f481cc42913.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/675fef6379254f7fb5c7b3a934c32255.png","post":"ckns3cr620021w9q981wk5ffk","slug":"675fef6379254f7fb5c7b3a934c32255.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/7e632a0669e34ab69bac30c3f5e4dd60.png","post":"ckns3cr620021w9q981wk5ffk","slug":"7e632a0669e34ab69bac30c3f5e4dd60.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/9a7eb6b3c35d45a1a4eaf1b76cc1398c.png","post":"ckns3cr620021w9q981wk5ffk","slug":"9a7eb6b3c35d45a1a4eaf1b76cc1398c.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/a0d3b15c19454faabb33b6fab3704d6f.png","post":"ckns3cr620021w9q981wk5ffk","slug":"a0d3b15c19454faabb33b6fab3704d6f.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/cb54f7e833a743b1962c47dcd996e921.png","post":"ckns3cr620021w9q981wk5ffk","slug":"cb54f7e833a743b1962c47dcd996e921.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/d48bc627be544288b73fe774962b1010.png","post":"ckns3cr620021w9q981wk5ffk","slug":"d48bc627be544288b73fe774962b1010.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Linux Basic/论一切都是文件之匿名inode/e0230f143c434814ba2cdc39c2faaa68.png","post":"ckns3cr620021w9q981wk5ffk","slug":"e0230f143c434814ba2cdc39c2faaa68.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Makefile/SPEC 基础知识/image-20210315162108826.png","post":"ckns3cr6b003uw9q93m6g9yl2","slug":"image-20210315162108826.png","modified":1,"renderable":1},{"_id":"source/_posts/linux_md/Makefile/SPEC 基础知识/image2019-12-5_16-10-23.png","post":"ckns3cr6b003uw9q93m6g9yl2","slug":"image2019-12-5_16-10-23.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/Thread_pool.svg","post":"ckns3cr6e004gw9q96ep143me","slug":"Thread_pool.svg","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/con_and_par.jpg","post":"ckns3cr6e004gw9q96ep143me","slug":"con_and_par.jpg","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/cpp_timeline.png","post":"ckns3cr6e004gw9q96ep143me","slug":"cpp_timeline.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/cpu.png","post":"ckns3cr6e004gw9q96ep143me","slug":"cpu.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/deadlock.gif","post":"ckns3cr6e004gw9q96ep143me","slug":"deadlock.gif","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/deadlock.png","post":"ckns3cr6e004gw9q96ep143me","slug":"deadlock.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/four_core.png","post":"ckns3cr6e004gw9q96ep143me","slug":"four_core.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/image-20210305140102303.png","post":"ckns3cr6e004gw9q96ep143me","slug":"image-20210305140102303.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/multithread.png","post":"ckns3cr6e004gw9q96ep143me","slug":"multithread.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/C++ 并发编程/single_core.png","post":"ckns3cr6e004gw9q96ep143me","slug":"single_core.png","modified":1,"renderable":1},{"_id":"source/_posts/cplus_md/CPlus Basic/深入理解C++11/1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png","post":"ckns3cr6e004jw9q9317b8xgh","slug":"1566061035371-9f65fec1-f23c-4906-b61f-44faa172864d.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckns3cr5m0001w9q94h8r8nq9","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5u000kw9q90pja8dno"},{"post_id":"ckns3cr5q000bw9q9cwzkh50f","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5u000pw9q921bpaf7f"},{"post_id":"ckns3cr5s000gw9q919uw9vf1","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5v000rw9q9ct4o9qn6"},{"post_id":"ckns3cr5o0003w9q96foe0l5y","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5v000vw9q9bj07edq6"},{"post_id":"ckns3cr5t000iw9q99324663o","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5w000yw9q9gpv39e4e"},{"post_id":"ckns3cr5u000ow9q9esbdfdfx","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5x0011w9q99grx9fvq"},{"post_id":"ckns3cr5p0007w9q9g0zgh8cn","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr5x0014w9q96io10ccd"},{"post_id":"ckns3cr5u000qw9q934ly1oyy","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5z0017w9q93bht2kbi"},{"post_id":"ckns3cr5v000uw9q9ant8barb","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr5z001aw9q99q20ebwv"},{"post_id":"ckns3cr5q0009w9q92a505xh4","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr5z001dw9q933clhk1a"},{"post_id":"ckns3cr5w000xw9q9abgm952h","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr60001gw9q910zq1i5q"},{"post_id":"ckns3cr5x0010w9q9hziu8uzg","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr60001kw9q945c57x2z"},{"post_id":"ckns3cr5x0013w9q90ddsbhgi","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr61001nw9q90319120t"},{"post_id":"ckns3cr5x0016w9q9g031b257","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr61001qw9q94564c8j5"},{"post_id":"ckns3cr5z0019w9q905yz2pnd","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr61001tw9q98fr3hzd8"},{"post_id":"ckns3cr5z001cw9q9epzs5fmt","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr62001vw9q91l019gkd"},{"post_id":"ckns3cr60001fw9q9dmoxbnf5","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr62001zw9q90n9qfn7y"},{"post_id":"ckns3cr60001jw9q931gzhrtm","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr630022w9q974fyg7ze"},{"post_id":"ckns3cr60001mw9q92q41a30q","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr630026w9q96bovgpfo"},{"post_id":"ckns3cr61001pw9q924il3pzp","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr630028w9q96eni1s2d"},{"post_id":"ckns3cr61001sw9q9goufew1w","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr64002cw9q95loweu8g"},{"post_id":"ckns3cr62001yw9q9a5nb0kzh","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr64002ew9q9epkh3lbn"},{"post_id":"ckns3cr620021w9q981wk5ffk","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr65002iw9q9a50p17ta"},{"post_id":"ckns3cr630025w9q9615qb8xm","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr65002jw9q9ab8tfajz"},{"post_id":"ckns3cr62001uw9q9eunz4off","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr65002mw9q923sy4b0w"},{"post_id":"ckns3cr630027w9q9huejft8u","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr65002nw9q9hppz9obw"},{"post_id":"ckns3cr64002bw9q93zfr149h","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr65002qw9q9aubvc5fc"},{"post_id":"ckns3cr64002dw9q9ghj1byvr","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr65002rw9q9f7jibrvi"},{"post_id":"ckns3cr65002hw9q9awi17cam","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr66002tw9q92z36cgnl"},{"post_id":"ckns3cr6b003uw9q93m6g9yl2","category_id":"ckns3cr5t000jw9q9bnsm32ue","_id":"ckns3cr6c0041w9q9afyu9mrc"},{"post_id":"ckns3cr6c003zw9q90fik4xi8","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr6d0045w9q9827sc737"},{"post_id":"ckns3cr6b003tw9q953sz4im4","category_id":"ckns3cr6b003vw9q9cjmib0y9","_id":"ckns3cr6d0047w9q9bpimgoyx"},{"post_id":"ckns3cr6c0043w9q9g4wi6bxs","category_id":"ckns3cr5o0004w9q9a67qhck3","_id":"ckns3cr6e004bw9q9e02w91gj"},{"post_id":"ckns3cr6d0044w9q9dw4v4a52","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr6e004ew9q9bnzc8d16"},{"post_id":"ckns3cr6d0046w9q91vck25vy","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr6e004hw9q90l7ihluc"},{"post_id":"ckns3cr6d004aw9q9c9kjbrzw","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr6f004kw9q92699hr0f"},{"post_id":"ckns3cr6e004dw9q90obwh43p","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr6f004mw9q9aaa6e2kd"},{"post_id":"ckns3cr6e004gw9q96ep143me","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr6f004ow9q9bsvzhzbh"},{"post_id":"ckns3cr6e004jw9q9317b8xgh","category_id":"ckns3cr620020w9q9gp6q9whv","_id":"ckns3cr6f004qw9q9a6xs8gd6"}],"PostTag":[{"post_id":"ckns3cr5m0001w9q94h8r8nq9","tag_id":"ckns3cr5p0005w9q9diqvbq1o","_id":"ckns3cr5s000ew9q93hn9bfie"},{"post_id":"ckns3cr5o0003w9q96foe0l5y","tag_id":"ckns3cr5p0005w9q9diqvbq1o","_id":"ckns3cr5u000mw9q9aivwc8v6"},{"post_id":"ckns3cr5p0007w9q9g0zgh8cn","tag_id":"ckns3cr5u000lw9q991bsay9x","_id":"ckns3cr5v000ww9q93otzfyhw"},{"post_id":"ckns3cr5q0009w9q92a505xh4","tag_id":"ckns3cr5v000tw9q90ux03e20","_id":"ckns3cr5x0012w9q9fnjpekb9"},{"post_id":"ckns3cr5q000bw9q9cwzkh50f","tag_id":"ckns3cr5w000zw9q9fpbi7ltb","_id":"ckns3cr5z0018w9q9fawz9z6q"},{"post_id":"ckns3cr5s000gw9q919uw9vf1","tag_id":"ckns3cr5w000zw9q9fpbi7ltb","_id":"ckns3cr60001ew9q9dnyv4u4c"},{"post_id":"ckns3cr5z001cw9q9epzs5fmt","tag_id":"ckns3cr5w000zw9q9fpbi7ltb","_id":"ckns3cr60001hw9q9g7gu57f4"},{"post_id":"ckns3cr5t000iw9q99324663o","tag_id":"ckns3cr5w000zw9q9fpbi7ltb","_id":"ckns3cr60001lw9q906138tym"},{"post_id":"ckns3cr5u000ow9q9esbdfdfx","tag_id":"ckns3cr5w000zw9q9fpbi7ltb","_id":"ckns3cr61001rw9q98zdq7yyl"},{"post_id":"ckns3cr5u000qw9q934ly1oyy","tag_id":"ckns3cr61001ow9q94mh8f50l","_id":"ckns3cr62001xw9q937u01wcx"},{"post_id":"ckns3cr5v000uw9q9ant8barb","tag_id":"ckns3cr5w000zw9q9fpbi7ltb","_id":"ckns3cr630024w9q953u0b62o"},{"post_id":"ckns3cr5w000xw9q9abgm952h","tag_id":"ckns3cr61001ow9q94mh8f50l","_id":"ckns3cr64002aw9q93qv209w5"},{"post_id":"ckns3cr5x0010w9q9hziu8uzg","tag_id":"ckns3cr61001ow9q94mh8f50l","_id":"ckns3cr64002gw9q906un1ugw"},{"post_id":"ckns3cr5x0013w9q90ddsbhgi","tag_id":"ckns3cr61001ow9q94mh8f50l","_id":"ckns3cr65002lw9q92xpb0d4j"},{"post_id":"ckns3cr5x0016w9q9g031b257","tag_id":"ckns3cr61001ow9q94mh8f50l","_id":"ckns3cr65002pw9q9ghvlgbmc"},{"post_id":"ckns3cr5z0019w9q905yz2pnd","tag_id":"ckns3cr61001ow9q94mh8f50l","_id":"ckns3cr66002vw9q95ygm73o3"},{"post_id":"ckns3cr5z0019w9q905yz2pnd","tag_id":"ckns3cr65002sw9q9avq5dgv5","_id":"ckns3cr66002ww9q909i6a0jb"},{"post_id":"ckns3cr60001fw9q9dmoxbnf5","tag_id":"ckns3cr61001ow9q94mh8f50l","_id":"ckns3cr66002yw9q90yw73ri5"},{"post_id":"ckns3cr60001jw9q931gzhrtm","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr660030w9q973744tmg"},{"post_id":"ckns3cr60001mw9q92q41a30q","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr660032w9q96gjf0yjz"},{"post_id":"ckns3cr61001pw9q924il3pzp","tag_id":"ckns3cr660031w9q9hybbg6yk","_id":"ckns3cr660034w9q9f1kk7rsy"},{"post_id":"ckns3cr61001sw9q9goufew1w","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr670037w9q99n583am4"},{"post_id":"ckns3cr61001sw9q9goufew1w","tag_id":"ckns3cr660035w9q9gpt03dyf","_id":"ckns3cr670038w9q92vww9zsf"},{"post_id":"ckns3cr62001uw9q9eunz4off","tag_id":"ckns3cr670036w9q997y8gjs6","_id":"ckns3cr67003aw9q95n1m57ds"},{"post_id":"ckns3cr62001yw9q9a5nb0kzh","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr67003cw9q96cv991r9"},{"post_id":"ckns3cr620021w9q981wk5ffk","tag_id":"ckns3cr660031w9q9hybbg6yk","_id":"ckns3cr67003ew9q9himp6569"},{"post_id":"ckns3cr630025w9q9615qb8xm","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr68003hw9q9gt4t7ia9"},{"post_id":"ckns3cr630025w9q9615qb8xm","tag_id":"ckns3cr660035w9q9gpt03dyf","_id":"ckns3cr68003iw9q9fkle7ufa"},{"post_id":"ckns3cr630027w9q9huejft8u","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr68003kw9q92h7c8u57"},{"post_id":"ckns3cr64002bw9q93zfr149h","tag_id":"ckns3cr68003jw9q93weu6bbj","_id":"ckns3cr68003nw9q90hshf7hp"},{"post_id":"ckns3cr64002bw9q93zfr149h","tag_id":"ckns3cr660031w9q9hybbg6yk","_id":"ckns3cr68003ow9q92c4h11wp"},{"post_id":"ckns3cr64002dw9q9ghj1byvr","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr68003qw9q98jp31dty"},{"post_id":"ckns3cr65002hw9q9awi17cam","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr68003rw9q9g2w10qs2"},{"post_id":"ckns3cr6b003tw9q953sz4im4","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr6b003ww9q95lqahd9o"},{"post_id":"ckns3cr6b003uw9q93m6g9yl2","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr6c003yw9q9eek61set"},{"post_id":"ckns3cr6d0044w9q9dw4v4a52","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr6d0049w9q90t5ja2d3"},{"post_id":"ckns3cr6c003zw9q90fik4xi8","tag_id":"ckns3cr6c0042w9q9b9dl4vqt","_id":"ckns3cr6e004cw9q9e5qkh82h"},{"post_id":"ckns3cr6d0046w9q91vck25vy","tag_id":"ckns3cr6c0042w9q9b9dl4vqt","_id":"ckns3cr6e004fw9q90szfevg9"},{"post_id":"ckns3cr6d004aw9q9c9kjbrzw","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr6e004iw9q9ftykg9dd"},{"post_id":"ckns3cr6c0043w9q9g4wi6bxs","tag_id":"ckns3cr6c0042w9q9b9dl4vqt","_id":"ckns3cr6f004lw9q937hye1kf"},{"post_id":"ckns3cr6e004dw9q90obwh43p","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr6f004nw9q9ffvf3otr"},{"post_id":"ckns3cr6e004gw9q96ep143me","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr6f004pw9q943om03s1"},{"post_id":"ckns3cr6e004jw9q9317b8xgh","tag_id":"ckns3cr66002xw9q99sux9jhu","_id":"ckns3cr6f004rw9q95r63clj2"}],"Tag":[{"name":"algorithm","_id":"ckns3cr5p0005w9q9diqvbq1o"},{"name":"jenkins","_id":"ckns3cr5u000lw9q991bsay9x"},{"name":"helm","_id":"ckns3cr5v000tw9q90ux03e20"},{"name":"go","_id":"ckns3cr5w000zw9q9fpbi7ltb"},{"name":"python","_id":"ckns3cr61001ow9q94mh8f50l"},{"name":"coverage","_id":"ckns3cr65002sw9q9avq5dgv5"},{"name":"baisc","_id":"ckns3cr66002xw9q99sux9jhu"},{"name":"linux","_id":"ckns3cr660031w9q9hybbg6yk"},{"name":"Encrypted","_id":"ckns3cr660035w9q9gpt03dyf"},{"name":"tips","_id":"ckns3cr670036w9q997y8gjs6"},{"name":"automake","_id":"ckns3cr68003jw9q93weu6bbj"},{"name":"cpp","_id":"ckns3cr6c0042w9q9b9dl4vqt"}]}}