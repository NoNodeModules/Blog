<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>因受 - 死锁中的苦行者</title><meta name="keywords" content="因受 苦行"><meta name="author" content="Phoenine"><meta name="copyright" content="Phoenine"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="中年危机 | 码字困难户">
<meta property="og:type" content="website">
<meta property="og:title" content="因受">
<meta property="og:url" content="https://phoenine.github.io/Blog/page/4/index.html">
<meta property="og:site_name" content="因受">
<meta property="og:description" content="中年危机 | 码字困难户">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://phoenine.github.io/Blog/img/avatar.png">
<meta property="article:author" content="Phoenine">
<meta property="article:tag" content="因受 苦行">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://phoenine.github.io/Blog/img/avatar.png"><link rel="shortcut icon" href="/Blog/img/favicon.png"><link rel="canonical" href="https://phoenine.github.io/Blog/page/4/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2021-04-22 07:32:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/static-butterfly/dist/css/index.min.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="/Blog/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/Blog/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/Blog/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/Blog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Blog/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/Blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/Blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Blog/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/Blog/photos/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li><li><a class="site-page child" href="/Blog/message/"><i class="fa-fw fas fa-mail-bulk"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Blog/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/Blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Blog/">因受</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Blog/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/Blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/Blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Blog/artitalk/"><i class="fa-fw fas fa-comments"></i><span> 说说</span></a></li><li><a class="site-page child" href="/Blog/photos/"><i class="fa-fw fas fa-video"></i><span> 照片</span></a></li><li><a class="site-page child" href="/Blog/message/"><i class="fa-fw fas fa-mail-bulk"></i><span> 留言</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/Blog/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/Blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left_radius"><a href="/Blog/posts/13014/" title="SPEC文件基础知识">     <img class="post_bg" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="SPEC文件基础知识"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13014/" title="SPEC文件基础知识">SPEC文件基础知识</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/">个人项目</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/baisc/">baisc</a></span></div><div class="content"> SPEC 文件基础知识制作 rpm 软件包并不是一件复杂的工作，其中的关键在于编写软件包的 spec 描述文件。要想制作一个 rpm 软件包就必须写一个软件包描述文件 spec。这个文件中包含了软件包的诸多信息，如：软件包的名字、版本、类别、说明摘要、创建时要执行什么指令、安装时要执行什么操作、以及软件包所要包含的文件列表等等。在实际过程中，最关键的地方是要清楚虚拟路径的位置，以及宏的定义。
Mandatory parameters to be present in SPEC file to build and generate RPM
Below options are mandatory to be present in SPEC file
Name, Version, Release, Summary, License, description, install and files
1234567891011Name:           test-devVersion:        %&#123;_version&#125;Release:        %&#123;_r ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/Blog/posts/13001/" title="C++11 中的std::function和std::bind">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="C++11 中的std::function和std::bind"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13001/" title="C++11 中的std::function和std::bind">C++11 中的std::function和std::bind</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/cpp/">cpp</a></span></div><div class="content"> C++11 中的std::function和std::bind
可调用对象可调用对象有一下几种定义：

是一个函数指针，参考 C++ 函数指针和函数类型；
是一个具有operator()成员函数的类的对象；
可被转换成函数指针的类对象；
一个类成员函数指针；

C++中可调用对象的虽然都有一个比较统一的操作形式，但是定义方法五花八门，这样就导致使用统一的方式保存可调用对象或者传递可调用对象时，会十分繁琐。C++11中提供了std::function和std::bind统一了可调用对象的各种操作。
不同类型可能具有相同的调用形式，如：
123456789101112// 普通函数int add(int a, int b)&#123;return a+b;&#125; // lambda表达式auto mod = [](int a, int b)&#123; return a % b;&#125;// 函数对象类struct divide&#123;    int operator()(int denominator, int divisor)&#123;        return d ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/Blog/posts/13010/" title="C++ Primer Plus笔记">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="C++ Primer Plus笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13010/" title="C++ Primer Plus笔记">C++ Primer Plus笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/cpp/">cpp</a></span></div><div class="content"> C++ Primer Plus笔记预备知识如何运行C++程序
使用文本编辑器编写程序，保存文件，这个文件就是源代码。

编译源代码。运行程序将源代码翻译为机器语言。翻译后的文件就是目标代码。

将目标代码与其他代码链接起来，生成程序的运行阶段版本。最终产品文件为可执行代码。

链接指的是将目标代码同使用的函数的目标代码以及一些标准的启动代码组合起来，生成程序的运行阶段版本



编程步骤如下图：
​    

从4.2版起，g++要求编译源代码文件时使用标记-std=c++0x： g++ -std=C++11 use_auto.cpp

开始学习C++为什么main()不能使用其他名称？C++程序必须包含一个名为main()的函数， 这是由系统的C++运行时决定的。编译器生成目标系统的可执行文件时，操作系统的启动入口就是C++运行时，然后运行时完成初始化之后就会调用main函数(入口点)。
存在一些例外情况：比如windows上编写DLL模块，是因为DLL模块不是独立的程序。
cin不支持录入空格在C++中，用cin&gt;&gt;str;这种方法来接收字符串那么录入的str不能包含 ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/Blog/posts/13004/" title="学习C++ - 不常见概念解释">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="学习C++ - 不常见概念解释"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13004/" title="学习C++ - 不常见概念解释">学习C++ - 不常见概念解释</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/baisc/">baisc</a></span></div><div class="content"> 学习C++ - 不常见概念解释
模板相关Dependent Namehttps://en.cppreference.com/w/cpp/language/dependent_name
在涉及到模板时，如果引用模板参数中的符号，那么这个符号就是dependent name，即依赖于模板实例化才能确定符号类型。
Binding Rules不依赖模板参数的符号是在模板定义时绑定的。如果绑定时和模板实例化时，同一个符号的含义发生了变化，那程序可能会出问题。
Lookup Rules依赖模板参数的符号是在模板实例化时才去绑定的。
非ADL非ADL的情况下，只会在模板定义的上下文寻找符号定义；
下面的例子中，writeObject方法的模板参数类型并不是用户命名空间中定义的，因此对应非ADL场景，只会在模板定义上下文寻找 operator &lt;&lt; (std::ostream&amp; os, std::vector&amp;) 符号的定义，不会去用户命名空间中查找：
12345678910111213141516171819202122232425262728293031&#x2F;& ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/Blog/posts/13002/" title="C++ Struct的使用">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="C++ Struct的使用"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13002/" title="C++ Struct的使用">C++ Struct的使用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/cpp/">cpp</a></span></div><div class="content"> C++ Struct的使用C++中的结构体在C语言中，结构体不能包含函数。
在面向对象的程序设计中，对象具有状态（属性）和行为，状态保存在成员变量中，行为通过成员方法（函数）来实现。
C语言中的结构体只能描述一个对象的状态，不能描述一个对象的行为。在C++中，考虑到C语言到C++语言过渡的连续性，对结构体进行了扩展,C++的结构体可以包含函数，这样，C++的结构体也具有类的功能，与class不同的是，结构体包含的函数默认为public，而class中默认是private。
C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。
struct能包含成员函数吗？   能！
struct能继承吗？          能！！
struct能实现多态吗？       能！！！
结构体的定义与声明实例代码1：
1234567891011struct tag &#123;    member-list;&#125;variable-list;/*注：struct为结构体关键字；   tag为结构体的标志；   member-l ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/Blog/posts/13005/" title="学习C++ - 艰难的熟悉过程">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="学习C++ - 艰难的熟悉过程"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13005/" title="学习C++ - 艰难的熟悉过程">学习C++ - 艰难的熟悉过程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/baisc/">baisc</a></span></div><div class="content"> 学习C++ - 艰难的熟悉过程
using声明https://en.cppreference.com/w/cpp/language/using_declaration
自C++11开始，除了可以使用using引入命名空间所有符号外，还可以使用using来定义类型别名，以及使用using为子类引入父类定义的函数，包括构造函数；
昨天晚上读React-Native源码时，发现调用了一个类的构造函数，但是并没有找到这个构造函数的定义在哪里，找了很久才发现看漏了一行using，原来子类是通过using将父类的构造函数全部引入了进来。
如果子类使用using引入父类构造函数会有一些需要注意的点，第一个是引入时，会将父类的所有构造函数一次性的全部引入到子类，如果子类中新定义的所有成员都能进行隐式的初始化，那就可以直接使用using引入的父类构造函数方法来实例化子类实例了。
如果子类自己定义了函数，并且签名和using引入的函数的签名一样，那么using引入的函数会被隐藏。
例如：
123456789101112131415161718192021222324struct B1 &#123;  B ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/Blog/posts/13006/" title="智能指针引用">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="智能指针引用"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13006/" title="智能指针引用">智能指针引用</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/baisc/">baisc</a></span></div><div class="content"> Passing const shared_ptr&amp; versus just shared_ptr as parameter</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/Blog/posts/13003/" title="C++ 并发编程">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="C++ 并发编程"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13003/" title="C++ 并发编程">C++ 并发编程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/baisc/">baisc</a></span></div><div class="content"> C++ 并发编程自C++11标准以来，C++语言开始支持多线程模型。借助多线程模型，我们可以开发出更好的并发系统。本文以C++语言为例，讲解如何进行并发编程。并尽可能涉及C++11，C++14以及C++17中的主要内容。
为什么要并发编程大型的软件项目常常包含非常多的任务需要处理。例如：对于大量数据的数据流处理，或者是包含复杂GUI界面的应用程序。如果将所有的任务都以串行的方式执行，则整个系统的效率将会非常低下，应用程序的用户体验会非常的差。
另一方面，自上个世纪六七十年代英特尔创始人之一 Gordon Moore 提出 摩尔定义 以来，CPU频率以每18个月翻一番的指数速度增长。但这一增长在最近的十年已经基本停滞，大家会发现曾经有过一段时间CPU的频率从3G到达4G，但在这之后就停滞不前了。因此最近的新款CPU也基本上都是3G左右的频率。相应的，CPU以更多核的形式在增长。目前的Intel i7有8核的版本，Xeon处理器达到了28核。并且，最近几年手机上使用的CPU也基本上是4核或者8核的了。
由此，掌握并发编程技术，利用多处理器来提升软件项目的性能将是软件工程师的一项基本技能。 ...</div></div></div><div class="recent-post-item"><div class="post_cover left_radius"><a href="/Blog/posts/13007/" title="深入理解C++11">     <img class="post_bg" src="/Blog/img/cpp.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="深入理解C++11"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/13007/" title="深入理解C++11">深入理解C++11</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">使用教程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/Blog/tags/baisc/">baisc</a></span></div><div class="content"> 深入理解C++111. 前言1.1 说到C++11，应该想到什么？
什么是 lambda，及怎么样使用它是最好的？
decltype 和 auto 类型推导有什么关系？
什么是移动语义，以及(右值引用)是如何解决转发问题的？
default/deleted 函数以及 override 是怎么回事?
异常描述符被什么替代了? noexcept 是如何工作的?
什么是原子类型以及新的内存模型?
如何在 C++11 中做并行编程?

1.2 语言的哪些关键字和C++11有关？
alignas
alignof decltype
auto(重新定义)
static_assert
using(重新定义)
noexcept
export(弃用，不过未来可能留作他用)
nullptr
constexpr
thread_local

2. 保证稳定性和兼容性2.1 将C99标准纳入C++112.1.1 确定编译环境的预定义宏
__STDC_HOSTED__：编译器的目标系统环境中是否包含完整的C库
__STDC__：编译器对于标准C库的实现是否和C标准一致（是否定义、如何定义由编译器决定）
 __ST ...</div></div></div><div class="recent-post-item"><div class="post_cover right_radius"><a href="/Blog/posts/2/" title="无题">     <img class="post_bg" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="无题"></a></div><div class="recent-post-info"><a class="article-title" href="/Blog/posts/2/" title="无题">无题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2020-11-04T13:59:14.000Z" title="发表于 2020-11-04 21:59:14">2020-11-04</time></span></div><div class="content"> 《图解编译原理》读书笔记第一章 运行时结构及编译过程1.1 一个简单的C程序代码如下：
12345678910111213141516int fun(int a, int b);int m = 10;int main()&#123;  int i = 4;  int j = 5;  m = fun(i, j);  return 0;&#125;int fun(int a, int b)&#123;  int c = 0;  c = a + b;  return c;&#125;
程序运行之前执行程序之前，我们需要对程序进行编译。
编译分为以下几个步骤：



1. 预处理： 宏定义展开、头文件展开、条件编译、在这里并不会检查语法。



2. 编译： 检查语法，将预处理后的文件编译生成汇编文件


3. 汇编： 将汇编文件生成目标文件(二进制文件)


4. 链接： 将目标文件链接为可执行文件


编译完成生成可执行文件之后，我们通过在linux下size命令可以查看一个可执行二进制文件基本情况：


通过上图可以得知，在程序没有运行前，也就是说程序没有加载到内存前，可执行程序的内部 ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/Blog/page/3/#content-inner"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/Blog/">1</a><span class="space">&hellip;</span><a class="page-number" href="/Blog/page/3/#content-inner">3</a><span class="page-number current">4</span><a class="page-number" href="/Blog/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/Blog/page/5/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="/Blog/img/avatar.png" onerror="this.onerror=null;this.src='/Blog/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Phoenine</div><div class="author-info__description">Welcome to my new blog ：）</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/Blog/archives/"><div class="headline">文章</div><div class="length-num">42</div></a></div><div class="card-info-data-item is-center"><a href="/Blog/tags/"><div class="headline">标签</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/Blog/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/phoenine"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://wpa.qq.com/msgrd?v=3&amp;uin=19974979&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="/Blog/social/wechat/" target="_blank" title="WeChatChat"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://github.com/phoenine" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:sparkbye@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/Blog/posts/16108/" title="Python模块学习&lt;一&gt;"><img src="/Blog/img/python.png" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="Python模块学习&lt;一&gt;"/></a><div class="content"><a class="title" href="/Blog/posts/16108/" title="Python模块学习&lt;一&gt;">Python模块学习&lt;一&gt;</a><time datetime="2021-04-13T09:32:24.000Z" title="发表于 2021-04-13 17:32:24">2021-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Blog/posts/13020/" title="automake基础"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="automake基础"/></a><div class="content"><a class="title" href="/Blog/posts/13020/" title="automake基础">automake基础</a><time datetime="2021-04-13T08:59:00.000Z" title="发表于 2021-04-13 16:59:00">2021-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Blog/posts/11000/" title="23 种设计模式的通俗解释"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="23 种设计模式的通俗解释"/></a><div class="content"><a class="title" href="/Blog/posts/11000/" title="23 种设计模式的通俗解释">23 种设计模式的通俗解释</a><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Blog/posts/11000/" title="图解霍夫曼编码"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="图解霍夫曼编码"/></a><div class="content"><a class="title" href="/Blog/posts/11000/" title="图解霍夫曼编码">图解霍夫曼编码</a><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/Blog/posts/12007/" title="Jenkinsfile introduce"><img src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg" onerror="this.onerror=null;this.src='/Blog/img/404.jpg'" alt="Jenkinsfile introduce"/></a><div class="content"><a class="title" href="/Blog/posts/12007/" title="Jenkinsfile introduce">Jenkinsfile introduce</a><time datetime="2020-12-31T15:59:00.000Z" title="发表于 2020-12-31 23:59:00">2020-12-31</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/Blog/categories/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/"><span class="card-category-list-name">个人项目</span><span class="card-category-list-count">9</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/Blog/categories/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"><span class="card-category-list-name">使用教程</span><span class="card-category-list-count">8</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/Blog/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span class="card-category-list-name">博客搭建</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/Blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">学习笔记</span><span class="card-category-list-count">21</span></a></li>
            </ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">42</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-04-21T23:32:42.889Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 By Phoenine</div><div class="footer_custom_text"><p><a style="margin-inline:5px"target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为 Hexo" alt="HEXO"></a><a style="margin-inline:5px"target="_blank" href="https://butterfly.js.org/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用 Butterfly" alt="Butterfly"></a><a style="margin-inline:5px"target="_blank" href="https://www.jsdelivr.com/"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用 Jsdelivr 为静态资源提供CDN加速" alt="Jsdelivr"></a><a style="margin-inline:5px"target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由 GitHub 托管" alt="GitHub"></a><a style="margin-inline:5px"target="_blank"href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" alt="img" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/Blog/js/utils.js"></script><script src="/Blog/js/main.js"></script><script src="/Blog/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>